<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇博客</title>
    <url>/2022/07/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里是Nibil建立博客后的第一篇文章。</p>
<span id="more"></span>
<p>历时两个工作日，我采用了<a href="https://hexo.io/">Hexo博客框架</a>和Github Pages网页部署工具。在广大网友的帮助下，踩过一些坑，终于成功搭建并部署Nibil的博客。博客采用了<a href="https://github.com/next-theme/hexo-theme-next">Next</a>主题模板,在仿照<a href="https://carlyleliu.github.io/">CarlyleLiu</a>的博客模板的基础上，附带了我本人的一些个性化设置。于是，Nibil的私人博客诞生了，希望不要马上去世~~~<br>我建立博客的初衷是为了督促自己能抽出时间来学习，复习自己从事的嵌入式行业的专业知识，并分享在博客上，以此来达到温故而知新的目的，从而提高自己的行业竞争力。我暂时将博客大纲定性为四块，工作，学习，生活，杂项。工作包含自己在公司做项目过程中遇到的问题以及解决的问题，避免自己重复踩坑。学习包含自己主动去提升尚未掌握但是以后工作中会用到的领域的知识，避免一问三不知。生活属于是自己日常生活中的一些分享，毕竟这是一个博客。杂项就是我个人的一些感想，领悟啥的，属于是发牢骚。<br>暂时就写这么多，希望我的这第一篇文章不会成为我的最后一篇文章！</p>
]]></content>
      <categories>
        <category>杂</category>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Linux开发概述</title>
    <url>/2022/08/04/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第1章总结归纳</p>
<span id="more"></span>
<h1 id="嵌入式系统介绍"><a href="#嵌入式系统介绍" class="headerlink" title="嵌入式系统介绍"></a>嵌入式系统介绍</h1><h2 id="嵌入式系统的定义和特点"><a href="#嵌入式系统的定义和特点" class="headerlink" title="嵌入式系统的定义和特点"></a>嵌入式系统的定义和特点</h2><h3 id="嵌入式系统的定义"><a href="#嵌入式系统的定义" class="headerlink" title="嵌入式系统的定义"></a>嵌入式系统的定义</h3><p>嵌入式系统的定义为：以应用为中心，以计算机技术为基础、软硬件可裁剪、适用于应用系统，对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。它的主要特点是嵌入，专用。<br>含有嵌入式系统的设备成为嵌入式设备，这在生活中随处可见：电子表、手机、MP3播放器、遥控器等。涵盖了生产、工业控制、通信、网络、消费电子、汽车电子、军工等领域。从通俗，广义的角度来说，除电脑，超级计算机等具备比较强大计算能力及系统资源（比如内存，存储器等）的电子系统之外，凡具备计算能力的设备都可称为嵌入式设备。</p>
<h3 id="嵌入式设备的特点"><a href="#嵌入式设备的特点" class="headerlink" title="嵌入式设备的特点"></a>嵌入式设备的特点</h3><ol>
<li>软硬件可裁剪</li>
<li>对功能、可靠性、成本、体积、功耗严格要求</li>
</ol>
<h2 id="嵌入式技术的发展史"><a href="#嵌入式技术的发展史" class="headerlink" title="嵌入式技术的发展史"></a>嵌入式技术的发展史</h2><p>通用计算机和嵌入式计算机是两条不同的道路。通用计算机系统的技术要求是高速海量的数值计算；技术发展方向是总线速度的无限提升，存储容量的无限扩大。而嵌入式计算机系统的技术要求是对象的智能化控制能力；技术发展方向则是与对象系统密切相关的嵌入性能、控制能力与控制的可靠性。<br>嵌入式技术发展日新月异，经历了单片机（SCM）、微控制器（MCU）、系统级芯片（SOC）3个阶段。</p>
<h3 id="SCM（Single-Chip-Microcomputer）"><a href="#SCM（Single-Chip-Microcomputer）" class="headerlink" title="SCM（Single Chip Microcomputer）"></a>SCM（Single Chip Microcomputer）</h3><p>又称单片微型计算机，简称单片机，随着大规模集成电路的出现以及发展，计算机的CPU、RAM、ROM、定时计数器和多种I&#x2F;O接口集成在一片芯片上，形成芯片级计算机。<br>这个阶段主要寻求单片形态嵌入式系统的最佳体系结构。</p>
<h3 id="MCU（Micro-Controller-Unit）"><a href="#MCU（Micro-Controller-Unit）" class="headerlink" title="MCU（Micro Controller Unit）"></a>MCU（Micro Controller Unit）</h3><p>MCU即微型控制器的特征是：满足各类嵌入式应用，根据对象系统扩展各类外围电路和接口电路，突显其对象的智能化控制能力。它所涉及的领域都与对象系统有关。<br>实际上，SCM和MCU在日常工作中并不严格区分，很多时候一概以单片机称呼。随着能够运行更复杂软件（操作系统）的SOC的出现，单片机通常是指不允许操作系统，功能相对单一的嵌入式系统。但这也不是绝对的，比如8051上就可以运行RTX51实时操作系统，它的大小只有6KB，相比于嵌入式Linux，Windows CE等操作系统而言比较简单。</p>
<h3 id="SoC（System-on-a-Chip）"><a href="#SoC（System-on-a-Chip）" class="headerlink" title="SoC（System on a Chip）"></a>SoC（System on a Chip）</h3><p>随着设计与制造技术的发展，集成电路设计从晶体管的集成发展到逻辑门的集成，现在又发展到IP的集成，即SOC设计技术。Soc可以有效降低电子&#x2F;信息系统产品的开发成本，缩短开发周期，提高产品的竞争力，是未来工业界将采用的最主要的产品开发方式。<br>Soc的特征：</p>
<ol>
<li>实现复杂系统功能的VLSI；</li>
<li>采用超深亚微米工艺技术；</li>
<li>使用一个以上嵌入式CPU&#x2F;数字信号处理器DSP；</li>
<li>外部可以对芯片进行编程；</li>
<li>主要采用第三方IP进行设计。<br>从上述SoC特征来看，SoC中包含了微处理器、微控制器、存储器以及其他专用功能逻辑，但是并不包含微处理器、微控制器、存储器以及其他专用功能的芯片就是SoC。8051就集成了微处理器、存储器等部件，它不属于SoC。SoC的主要价值在于—缩短了产品的上市周期。<br>因此SoC更合理的定义：SoC是在一个芯片上由于广泛使用预定制模块IP（Intellectual Property）而得以快速开发的集成电路。<br>本书介绍的S3C2410&#x2F;S3C2440就属于SoC，它们集成了处理器、MMU、NAND Flash控制器等部件，而处理器的IP是基于ARM公司的。<br>以前写的单片机软件，通常是在main函数当中定义一个无限循环，然后在里面查询各类输入事件，并做相应处理，它直接操作硬件；而基于SoC的软件多是在操作系统上面运行，通过驱动程序操作硬件。</li>
</ol>
<h1 id="基于ARM处理器的嵌入式Linux系统"><a href="#基于ARM处理器的嵌入式Linux系统" class="headerlink" title="基于ARM处理器的嵌入式Linux系统"></a>基于ARM处理器的嵌入式Linux系统</h1><h2 id="ARM处理器介绍"><a href="#ARM处理器介绍" class="headerlink" title="ARM处理器介绍"></a>ARM处理器介绍</h2><h3 id="ARM处理器的概念"><a href="#ARM处理器的概念" class="headerlink" title="ARM处理器的概念"></a>ARM处理器的概念</h3><p>嵌入式处理器的种类繁多，又ARM、MIPS、PPC等多种架构。ARM的文档丰富，各类嵌入式软件大多选择ARM。在掌握ARM架构之后，上手其他处理器架构也会很快。<br>ARM(Advanced RISC Machine),既是一家公司的名字，也可以是一类处理器的统称，还可以认为是一种技术的名字。<br>ARM公司并不生产芯片，而是出售芯片授权。基于ARM的处理器以其高速度、低功耗、价格低等优点得到非常广泛的应用，它可以应用于以下领域：</p>
<ol>
<li>为无线通信、消费电子、成像设备等产品提供可运行复杂操作系统的开放应用平台；</li>
<li>在海量存储、汽车电子、工业控制和网络应用等领域提供实时嵌入式应用；</li>
<li>安全系统，比如SIM卡、信用卡等。</li>
</ol>
<h3 id="ARM体系架构的版本"><a href="#ARM体系架构的版本" class="headerlink" title="ARM体系架构的版本"></a>ARM体系架构的版本</h3><p>ARM体系架构的版本就是它所使用的指令集的版本。ARM公司支持32位的ARM指令集和16位的Thumb指令集，后者使得代码的存储空间大大减小。<br>还在使用的ARM指令集（ISA，Instruction Set Architecture）有以下版本：</p>
<ol>
<li>ARMv4<br>这是当前市场上最老的版本，ARMv4只支持32位的指令集，支持32位的地址空间。一些ARM7系列的处理器和Intel公司的StrongARM处理器采用ARMv4指令集。</li>
<li>ARMv4T<br>增加了16位的Thumb指令集，它可以产生更紧凑的代码，与相同功能的ARM代码相比，可以节省超过35%的存储空间，同时具备32位代码的所有优点。</li>
<li>ARMv5TE<br>1999年，ARMv5TE版本改进了Thumb指令集，增加了一些“增强型DSP指令”，简称E指令集。<br>这些指令用于增强处理器对于一些典型的DSP算法的处理性能，是的音频DSP应用可以提升70%的性能。许多系统在使用微控制器来进行各类控制的时候，还要具备数据处理能力，传统的做法要么是使用更高级的处理器，这会使得成本增加，要么是使用多个处理器，这会使得系统复杂度增高。通过E指令集可以在一个普通CPU中增加DSP的功能，这在成本、性能、简化设计等方面都有优势。</li>
<li>ARMv5TEJ<br>增加Jazelle技术用于提供Java加速功能。</li>
<li>ARMv6<br>2001年，ARMv6问世。它在很多方面都有改进：存储系统、异常处理，最重要的是增加了对多媒体功能的支持。ARMv6包含了一些媒体指令以支持SIMD媒体功能扩展。SIMD媒体功能扩展为音视频的处理提供了优化功能，可以使得音视频的处理性能提高4倍。<br>ARMv6中还引入了Thumb-2和TrustZone技术，这是两个可选的技术。之前的版本中，ARM指令和Thumb分别运行于不同的处理器状态下，执行不同的指令集的指令前需要进行切换。Thumb-2技术增加了混合模式的功能，定义了新的32位指令集，可以运行32位指令和16位指令的混合代码。这能够提供”ARM指令级别的性能“和”Thumb指令级别的代码密度“。TrustZone技术在硬件上提供了两个隔离的地址空间：安全域和非安全域，给系统提供了一个安全机制。</li>
<li>ARMv7<br>ARMv7架构使用Thumb-2技术，还使用了NEON技术，将DSP和媒体处理能力提高了近4倍，并支持改良的浮点运算，满足下一代3D图形、游戏物理应用以及传统嵌入式控制应用的需求。</li>
</ol>
<h3 id="ARM处理器系列"><a href="#ARM处理器系列" class="headerlink" title="ARM处理器系列"></a>ARM处理器系列</h3><p>在相同的指令集下，搭配不同的部件就可以组装出具有不同功能的处理器，比如有无内存管理单元，有无调试功能等。它们可以分为8个系列，系列名有7个后缀，这些后缀可以组合：<br>T：表示支持Thumb指令集。<br>D：表示支持片上调试（Debug）。<br>M：表示内嵌乘法器（Multiplier）。<br>I：支持片上断点和调试点。<br>E：表示支持增强型DSP功能。<br>J：表示支持Jazelle技术，即Java加速器。<br>S：表示全合成式（full synthesizable）。</p>
<ol>
<li>ARM7<br>ARM7系列处理器是低功耗32位RISC微处理器，它主要用于对成本、功耗特别敏感的产品。最高可达到130MIPS（Million Instructions Percent Second），支持Thumb16位指令集和ARM32位指令集。ARM7系列微处理器包括如下几种类型的核：ARM7TDMI、ARM7TDMI-S、ARM720T、ARM7EJ-S。其中。ARM7TMDI是目前使用最广泛的32位嵌入式RISC处理器，属于低端ARM处理器核。ARM7不带MMU。</li>
<li>ARM9<br>与ARM7相比，ARM9最大的差别在于：有MMU和Cach。它的指令执行效率较ARM7有较大提高，最高可达300MIPS。ARM9系列微处理器有ARM920T和ARM922T两种类型。</li>
<li>ARM9E<br>ARM9E系列微处理器在单一的处理器内核上提供了微控制器、DSP、Java应用系统的解决方案，极大的减少了芯片的面积和系统的复杂度。ARM9E系列微处理器提供了增强的DSP处理能力，适合于那些需要同时使用DSP和微控制器的应用场合。<br>ARM9E系列微处理器有ARM926EJ-S、ARM946E-S、ARM966E-S、ARM968E-S和ARM996HS共五种类型。</li>
<li>ARM10E<br>ARM10E微处理器具有更加杰出的高性能、低功耗特点，由于使用了新的体系结构，它拥有ARM系列中最高的主频。ARM10E系列微处理器采用了一种新的省电模式，支持”64 bit load-store micro-architecture“，含浮点运算协处理器。<br>ARM10E系列微处理器有ARM1020E、ARM1022E和ARM1026EJ-S三种类型。</li>
<li>ARM11<br>ARM11系列微处理器是ARM公司近年来推出的新一代RISC处理器，它是ARM新指令架构—ARMv6的第一代设计实现。ARM11的媒体处理能力和低功耗特点特别适用于无线和消费类电子产品，其高数据吞吐量和高性能的结合非常适合网络处理应用。另外在实时性能和浮点处理等方面ARM11可以满足汽车电子的应用需求。<br>ARM11系列微处理器有这4种类型：ARM11 MPCore、ARM1136J(F)-S、ARM1156T2(F)-S和ARM1176JZ(F)-S。</li>
<li>Cortex<br>Cortex基于ARMv7架构，分为Cortex-A、Cortex-R、Cortex-M三类。Cortex-A为传统的、基于虚拟内存的操作系统和应用程序而设计，支持ARM、Thumb、和Thumb-2指令集；Cortex-R针对实时系统设计，支持ARM、Thumb、和Thumb-2指令集；Cortex-M为对价格敏感的产品设计，只支持Thumb-2指令集。</li>
<li>SecureCore<br>SecureCore系列微处理器专为安全需要设计，提供了完善的32位RISC技术的安全解决方案，因此，SecureCore系列微处理器除了具有ARM体系结构的低功耗、高性能特点外，还具有其独特的优势，即提供了对安全解决方案的支持。<br>SecureCore系列微处理器有如下类型：SecureCoreSC100、SecureCoreSC200。</li>
<li>OptimoDE Data Engines<br>这是一个新的IP核，针对高性能的嵌入式信号处理应用而设计。<br>另外，Intel公司的StrongARM、Xscale系列处理器也属于ARM架构。Intel StrongARM处理器是便携式通信产品和消费电子产品的理想选择，已成功应用于多家公司的掌上电脑系列产品。Xscale处理器是基于ARMv5TE体系结构的解决方案，是一款全性能、高性价比、低功耗的处理器。它支持16位的Thumb指令和DSP指令集。</li>
</ol>
<h2 id="选择嵌入式Linux的理由"><a href="#选择嵌入式Linux的理由" class="headerlink" title="选择嵌入式Linux的理由"></a>选择嵌入式Linux的理由</h2><p>在嵌入式领域可以选择的操作系统有很多，比如：嵌入式Linux、VxWorks、Windows CE、μC&#x2F;OS-Ⅱ等。<br>VxWorks是美国WindRiver公司开发的嵌入式实时操作系统。但就性能而言，它是非常优秀的操作系统，具有可裁剪的微内核结构、高效的任务管理、灵活的任务间通信、微秒级的中断处理，支持POSIX 1003.1b实时扩展标准，支持多种物理介质及标准、完整的TCP&#x2F;IP网络协议等。缺点是它支持的硬件相对较少，源代码不开放，需要专门的技术人员进行维护，授权费用高。<br>Windows CE是微软公司针对嵌入式设备开发的32位、多任务、多线程的操作系统。它支持x86、ARM、MIPS、SH等架构的CPU，硬件驱动丰富，支持WiFi、USB2.0等新型设备，并且具有强大的多媒体功能；可以灵活裁剪以减少系统体积；与PC上的Windows操作系统相通，开发、调试工具使用方便。应用程序的开发流程与PC上的Windows程序开发流程类似。就开发的便利性而言，Windows CE是最好的。但是，它的源代码没有开放，开发人员难以进行更细致的定制，占用内存较多，整个相同相对庞大，版权许可费也比较高。<br>μC&#x2F;OS-Ⅱ是Micrium公司开发的操作系统，可用于8位、16位、32位处理器。可裁剪，对硬件要求低；可运行最多64个任务；任务调度方式位抢占式调度，总是运行最高优先级的就绪任务。用户可以获取μC&#x2F;OS-Ⅱ的全部代码，但是它不是完全免费的。用于商业目的，需要购买商业授权。μC&#x2F;OS-Ⅱ采用一次性收费的方式，价格低廉。μC&#x2F;OS-Ⅱ仅是一个实时内核，用户需要完成其他更多的工作，比如编写硬件驱动程序，实现文件操作等。<br>Linux是遵循GPL协议的开放源代码的操作系统，使用时无需缴纳许可费。内核可以任意裁剪，几乎支持所有的32位、62位CPU；内核中支持的硬件种类繁多，几乎可以从网络上找到所有的硬件驱动程序；支持几乎所有的网络协议；有大量的应用程序可以使用，从编译工具，调试工具到GUI程序，几乎都遵循GPL协议的相关版本；有庞大的开发人员群体，有数量众多的技术论坛，大多数问题可以得到快速而且免费的解答。<br>Linux的缺点在于实时性，虽然在2.6版本的Linux在实时性上有了较大的改进，但是仍然无法称作实时操作系统。不过正是因为Linux开放源代码、易于移植、资源丰富、免费等优点，使得它在嵌入式领域越来越流行。更重要的一点，由于嵌入式Linux与PC Linux基于同样的内核代码，只是裁剪的程度不一样，这使得很多为PC开发的软件再次编译后，可以直接在嵌入式设备上面运行，这使得软件资源极大丰富，比如各类使用的函数库等。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第1章 嵌入式Linux开发概述</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>何谓硬解码和软解码</title>
    <url>/2022/08/05/%E4%BD%95%E8%B0%93%E7%A1%AC%E8%A7%A3%E7%A0%81%E5%92%8C%E8%BD%AF%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于“硬解码”与“软解码”。</p>
<span id="more"></span>
<p>软解码和硬解码的区别：</p>
<ol>
<li>软解码使用CPU进行解码。</li>
<li>硬解码使用非CPU进行解码，如GPU、专用的DSP、FPGA、ASIC等芯片。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>何谓硬解码和软解码</category>
      </categories>
      <tags>
        <tag>多媒体编解码</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO接口</title>
    <url>/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第5章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>掌握嵌入式开发的步骤：编程、编译、烧写程序、运行</li>
<li>通过GPIO口的操作了解软件如何控制硬件</li>
</ol>
<h1 id="GPIO硬件介绍"><a href="#GPIO硬件介绍" class="headerlink" title="GPIO硬件介绍"></a>GPIO硬件介绍</h1><p>GPIO（Genaral Purpose I&#x2F;O Ports）意思是通过通用输入&#x2F;输出端口，通俗的说，就是一些引脚，可以通过它们输出高低电平或者通过它们读入引脚的状态—是高电平还是低电平。<br>S3C2410有117个I&#x2F;O端口，共分为A-H 8组，GPA、GPB、……、GPH。S3C2440有130个I&#x2F;O端口，共分为A-H 9组，GPA、GPB、……、GPJ。可以通过设置寄存器来确定某个引脚用于输入、输出还是其他特殊功能。比如可以设置GPH6作为一般的输入、输出引脚，或者用于串口。<br>GPIO的操作是所有硬件操作的基础，由此扩展开来可以了解所有硬件的操作，这是底层开发人员必须掌握的。</p>
<h2 id="通过寄存器来操作GPIO引脚"><a href="#通过寄存器来操作GPIO引脚" class="headerlink" title="通过寄存器来操作GPIO引脚"></a>通过寄存器来操作GPIO引脚</h2><p>既然一个引脚可以用于输入、输出或其他功能，那么一定有寄存器用来选择这些功能；对于输入，一定可以通过读取某个寄存器来确定引脚的电平是高还是低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电平还是低电平；对于其他特殊功能，则有另外的寄存器来控制它。<br>对于这几组GPIO引脚，它们的寄存器是相似的；GPxCON用于选择引脚功能。GPxDAT用于读写引脚数据。GPxUP用于确定是否使用内部上拉电阻。</p>
<h3 id="GPxCON寄存器"><a href="#GPxCON寄存器" class="headerlink" title="GPxCON寄存器"></a>GPxCON寄存器</h3><p>从寄存器的名字可以看出，它用于配置（Configure）—选择引脚的功能。<br>PORT A与PORT B-PORT H&#x2F;J在功能选择方面有所不同，GPACON中每一位对应一根引脚（共23根引脚）。当某位被设置为0时，相应引脚为输出引脚，此时我们可以在GPADAT中的相应位写入0或1让此引脚输出高电平或者低电平。当某位被设置为1时，相应的引脚为地址线，或用于地址控制。此时的GPADAT无用。通常而言GPACON全被设置为1，以便访问外部存储器件。<br>PORT B-PORT H&#x2F;J 在寄存器操作方面完全相同。GPxCON中每两位控制一根引脚，00表示输入、01表示输出、10表示特殊功能、11保留。</p>
<h3 id="GPxDAT寄存器"><a href="#GPxDAT寄存器" class="headerlink" title="GPxDAT寄存器"></a>GPxDAT寄存器</h3><p>GPxDAT用于读&#x2F;写引脚；当引脚被设置为输入时，读此寄存器可知相应引脚的电平状态是高还是低；当引脚被设置为输出时，写此寄存器相应位可令此引脚输出高电平或者低电平。</p>
<h3 id="GPxUP"><a href="#GPxUP" class="headerlink" title="GPxUP"></a>GPxUP</h3><p>某位为1时，相应引脚无内部上拉电阻；为0时，相应引脚使用内部上拉电阻。<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/1.jpeg" alt="img not found"><br>上拉、下拉电阻的作用在于，当GPIO引脚处于第三态（既不是输出高电平，也不是输出低电平，而是呈高阻态）时，它的电平状态由上拉、下拉电阻决定。</p>
<h2 id="怎样使用软件来访问硬件"><a href="#怎样使用软件来访问硬件" class="headerlink" title="怎样使用软件来访问硬件"></a>怎样使用软件来访问硬件</h2><h3 id="访问单个引脚"><a href="#访问单个引脚" class="headerlink" title="访问单个引脚"></a>访问单个引脚</h3><p>单个引脚的操作无外乎3种：输出高低电平、检测引脚状态、中断。对某个引脚的操作一般通过读写寄存器来完成。<br>比如对于图5.2所示的电路，可以设置GPBCON寄存器将GPB5、GPB6、GPB7和GPB8设为输出功能，然会写GPBDAT的寄存器使得这四个引脚输出高电平或低电平。输出高电平时，相应的LED灯熄灭，输出低电平时，相应的LED灯点亮。<br>还可以设置GPFCON寄存器将GPF0、GPF2、GPF3和GPF11设为输入功能，然后通过读出GPFDAT&#x2F;GPGDAT寄存器并判断相应位是0还是1来确定各个按键是否被按下。某个按键按下时，相应引脚电平为低，GPFDAT&#x2F;GPGDAT寄存器相应位为0，否则为1。<br>那么怎么访问这些寄存器呢，通过软件，读写它们的地址。比如，GPBCON和GPBDAT寄存器的地址都是0x56000010、0x56000014，可以通过如下的指令让GPB5输出低电平，点亮LED1。<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/2.jpeg" alt="img not found"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (*(volatile unsigned long *)0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (*(volatile unsigned long *)0x56000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line">GPBCON = GPB5_out;<span class="comment">//GPB5引脚设置为输出</span></span><br><span class="line">GPBDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//GPB5输出低电平</span></span><br></pre></td></tr></table></figure>
<h3 id="以总线方式访问硬件"><a href="#以总线方式访问硬件" class="headerlink" title="以总线方式访问硬件"></a>以总线方式访问硬件</h3><p>并非只能通过寄存器才能发出硬件信号，实际上，通过访问总线的方式控制硬件更常见。以NOR Flash的访问为例：<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/3.jpeg" alt="img not found"><br>图中，缓冲器的作用是为了提高驱动力、隔离前后级信号。NOR Flash AM29LV800BB的片选信号使用S3C2410&#x2F;S3C2440的nGCS0信号，当CPU发出的地址信号处于0x00000000-0x07FFFFFF之间时，nGCS0信号有效，于是NOR Flash被选中。这时，CPU发出的地址信号传到NOR Flash；进行写操作时，nWE信号为低，数据信号从CPU发出给NOR Flash；进行读操作时，nWE信号为高，数据信号从NOR Flash发给CPU。上图所示的硬件连线决定了读写操作都是以16位为单位的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址对齐的16位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> wVal;</span><br><span class="line">wVal = *pwAddr;</span><br></pre></td></tr></table></figure>
<p>上述代码就会向NOR Flash发起读操作：CPU发出的读地址为0x2，则地址总线ADDR1-ADDR20、A0-A19的信号都是1、0、…、0（CPU的ADDR0为0，不过ADDR0没有接到NOR Flash上）。NOR Flash接收到的地址就是0x1，NOR Flash在稍后的时间里将此址上的16位数据取出，并通过数据总线D0-D15发给CPU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址不对齐的16位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> wVal;</span><br><span class="line">wVal = *pwAddr;</span><br></pre></td></tr></table></figure>
<p>由于地址位0x1；不是2对齐的，但是BANK0的位宽被设为16，这将导致异常。我们可以设置异常处理函数来处理这种情况。在异常处理函数中，使用0x0、0x2发起两次读操作，然后将两个结果组合起来。使用地址0x0读到两字节数据D0、D1，再使用地址0x2读到D2、D3。最后D1、D2组合成一个16位的数返回给wVal。如果没有设置地址不对齐异常处理函数，那么上述代码将出错。如果某个BANK位宽被设置为n，访问此BANK时，在总线上永远只会看到地址对齐的n位操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*8位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *pucAddr = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">0x6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucVal;</span><br><span class="line">ucVal = *pucAddr;</span><br></pre></td></tr></table></figure>
<p>CPU首先使用地址0x6对NOR Flash发起16位的读操作，得到两字节的数据，假设位D1、D0，然后将D0取出赋值给uvVal。在读操作期间，地址总线ADDR1-ADDR20、A0-A19的信号都是1、1、1、…、0。CPU会自动丢弃D1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*32位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *pdwAddr = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwVal;</span><br><span class="line">dwVal = *pdwAddr;</span><br></pre></td></tr></table></figure>
<p>CPU首先使用地址0x6对NOR Flash发起16位的读操作，得到两字节的数据，假设为D0，D1；再使用地址0x8发起读操作，得到两字节的数据D2，D3，最后将这4个字节的数据组合后再赋值给变量dwVal。<br>由于NOR Flash的特性，使得对NOR Flash的写操作比较复杂—比如要先发出特定的地址信号通知NOR Flash准备接受数据，然后才发出数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*16位写操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x6</span>;</span><br><span class="line">*pwAddr = <span class="number">0x1234</span>;</span><br></pre></td></tr></table></figure>
<p>CPU发起一次对NOR Flash的写操作，地址总线ADDR1-ADDR20、A0-A19的信号都时1、1、…、0；数据线DATA0-DATA15、D0-D15的信号为0、0、1、0、1、1、0、0、0、1、0、0、1、0、0、0。<br>由此可见，CPU使用某个地址进行访问时，这个32位的地址值和ADDR0-ADDR31一一对应，外接的设备可以以8位、16位、32位进行操作—取决于硬件设计。如果以8位进行操作，那么数据出现在数据信号DATA0-DATA7上，如果以16位进行操作，则数值出现在数据线DATA0-DATA15上；如果以32位进行操作，则数值出现在DATA0-DATA31上。</p>
<h1 id="GPIO操作实例"><a href="#GPIO操作实例" class="headerlink" title="GPIO操作实例"></a>GPIO操作实例</h1><p>LED和按键与处理器的电路连接基于图5.2。程序基于裸机开发，不带操作系统。</p>
<h2 id="纯汇编实现点亮一个LED"><a href="#纯汇编实现点亮一个LED" class="headerlink" title="纯汇编实现点亮一个LED"></a>纯汇编实现点亮一个LED</h2><p>汇编程序实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    ldr r0,=0x56000010      @r0设置为GPBCON寄存器，用于配置GPIOB系列引脚。</span><br><span class="line">    mov r1,#0x00000400      @r1赋值立即数0x00000400</span><br><span class="line">    str r1,[r0]             @GPBCON写入0x00000400，设置GPB5为输出口，位[10:9]=0b01</span><br><span class="line">    ldr r0,=0x56000014      @r0设置为GPBDAT寄存器，用于读写GPIOB系列引脚的数据。</span><br><span class="line">    mov r1,#0x00000020      @r1赋值立即数0x00000020</span><br><span class="line">    str r1,[r0]             @点亮LED1</span><br><span class="line">main_loop:</span><br><span class="line">    b main_lopp             @死循环</span><br></pre></td></tr></table></figure>
<p>编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o led_on.o led_on.S                        @编译</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf        @链接</span><br><span class="line">arm-linux-objcopy -O binary -S led_on_elf led_on.bin            @将elf格式的可执行文件转换位二进制格式</span><br></pre></td></tr></table></figure>

<h2 id="C代码实现点亮一个LED"><a href="#C代码实现点亮一个LED" class="headerlink" title="C代码实现点亮一个LED"></a>C代码实现点亮一个LED</h2><p>C语言执行的第一条指令并不在main函数中。生成一个C程序的可执行文件时，编译器通常会在我们的代码中加上几个被称为启动文件的代码—crtl.o、crti.o、crtend.o、crtn.o等，它们是标准库文件。这些代码设置C程序的堆栈等，然后调用main函数。它们依赖于操作系统，在裸板上这些代码无法执行，所以需要自己写一个。<br>这段代码很简单，只有6条指令，自己编写的crt0.S文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:crt0.S</span></span><br><span class="line"><span class="comment">通过它转入C程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    ldr r0,=<span class="number">0x56000010</span>      @watchdog地址寄存器</span><br><span class="line">    mov r1,#<span class="number">0x0</span>             @</span><br><span class="line">    str r1,[r0]             @写入<span class="number">0</span>，禁止watchdog，否则CPU会不断重启</span><br><span class="line">    ldr sp,=<span class="number">1024</span>*<span class="number">4</span>          @设置堆栈，注意不能大于<span class="number">4</span>KB，因为当前可以内存只有<span class="number">4</span>KB</span><br><span class="line">                            @NAND Flash中的代码会在复位后移到内部RAM（只有<span class="number">4</span>KB）</span><br><span class="line">    bl main                 @调用C程序中的main函数</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">    b halt_loop</span><br></pre></td></tr></table></figure>
<p>设置好堆栈指针后，就可以调用C函数main了。C函数执行前，必须设置栈。<br>所以现在可以写出控制LED的C程序了。main函数在led_on_c.c中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (*(volatile unsigned long *)0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (*(volatile unsigned long *)0x56000014)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    GPBCON = <span class="number">0x00000040</span>;    <span class="comment">//设置GPB5为输出端口，位[10:9]=0b01</span></span><br><span class="line">    GPBDAT = <span class="number">0x00000000</span>;    <span class="comment">//GPB5输出0，LED1点亮</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o crt0.o crt0.S</span><br><span class="line">arm-linux-gcc -g -c -o led_on_c.0 led_on_c.c</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 -g crt0.o led_on_c.o -o led_on_c_elf</span><br><span class="line">arm-linux-objcopy -O binary -S led_on_c_elf led_on_c.bin</span><br><span class="line">arm-linux-objdump -D -m arm led_on_c_elf &gt; led_on_c.dis</span><br></pre></td></tr></table></figure>
<p>先分别编译crt0.S和led_on_c.c(不连接)。然后将编译的结果连接起来。然后把得到的ELF格式的文件led_on_c_elf转换成二进制的bin文件。最后将结果转换为汇编代码以供查看。</p>
<h2 id="按键来控制LED"><a href="#按键来控制LED" class="headerlink" title="按键来控制LED"></a>按键来控制LED</h2><p>当K1-K4某个按键按下时，点亮LED1-LED4中相应的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:key_led.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (* (unsigned long *) 0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (* (unsigned long *) 0x56000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFCON (* (unsigned long *) 0x56000050)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFDAT (* (unsigned long *) 0x56000054)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPGCON (* (unsigned long *) 0x56000060)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPGDAT (* (unsigned long *) 0x56000064)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LED1-LED4对应GPB5、GPB6、GPB7、GPB8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">K1-K4对应GPG11、GPG3、GPF2、GPF0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPG11_in ~(3&lt;&lt;(11*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPG3_in ~(3&lt;&lt;(3*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPF2_in ~(3&lt;&lt;(2*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPF0_in ~(3&lt;&lt;(0*2))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dwDat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LED1-LED4对应的4根引脚设置为输出</span></span><br><span class="line">    GPBCON = GPB5_out | GPB6_out | GPB7_out | GPB8_out ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//K1-K2对应的两根引脚设为输入</span></span><br><span class="line">    GPGCON = GPG11_in &amp; GPG3_in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwDat = GPGDAT;             <span class="comment">//读取GPG管脚电平状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>))       <span class="comment">//K1没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>);    <span class="comment">//LED1熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);   <span class="comment">//LED1点亮</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))        <span class="comment">//K2没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">6</span>);    <span class="comment">//LED2熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);   <span class="comment">//LED2点亮</span></span><br><span class="line"></span><br><span class="line">        dwDat = GPFDAT;             <span class="comment">//读取GPF管脚电平状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>))        <span class="comment">//K3没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);    <span class="comment">//LED3熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);   <span class="comment">//LED3点亮</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>))        <span class="comment">//K4没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">//LED4熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);   <span class="comment">//LED4点亮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码先将LED1-LED4对应的引脚GPB5-GPB8设为输出引脚。<br>然后将K1、K2对应的引脚GPG11、GPG3设为输入引脚，K3、K4对应的引脚GPF2、GPF0设为输入引脚。<br>然后就是一个无穷循环，读取GPGDAT、GPFDAT寄存器，从中判断K1、K2、K3、K4是否按下。若按下则点亮相应的LED，否则熄灭相应的LED。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第5章 GPIO接口</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之工厂模式</title>
    <url>/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之工厂模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在工厂模式中，我们创建对象时不会对客户暴露逻辑并且是通过一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；创建简单对象时，建议直接new完成一个实例对象的创建。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>主要特点是需要在工厂类中做判断，从而创建相应的产品，当增加新的产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。<br>缺点：工厂类中集中了所有产品的创建逻辑，如果产品量过大，会使工程类变得臃肿。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品种类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    Clothes_Min = <span class="number">-1</span>,</span><br><span class="line">    Clothes_pants,</span><br><span class="line">    Clothes_jeans,</span><br><span class="line">    Clothes_Max,</span><br><span class="line">&#125;Clothes_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Pants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Jeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Jeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Clothes *<span class="title">MakeClothes</span><span class="params">(Clothes_t clothes_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(clothes_type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Clothes_pants:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Pants</span>();</span><br><span class="line">            <span class="keyword">case</span> Clothes_jeans:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Jeans</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory fac;</span><br><span class="line"></span><br><span class="line">    Clothes *pants = fac.<span class="built_in">MakeClothes</span>(Clothes_pants);</span><br><span class="line">    pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    Clothes *jeans = fac.<span class="built_in">MakeClothes</span>(Clothes_jeans);</span><br><span class="line">    jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pants;</span><br><span class="line">    pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> jeans;</span><br><span class="line">    jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>定义一个创建对象的接口，其子类去具体实现这个接口已完成具体的创建工作。如果需要增加新的产品类，只需要扩展一个相应的工厂类即可。<br>缺点：产品类数据较多时，需要实现大量的工厂类，这无疑增加了代码量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Pants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Jeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Jeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Clothes* <span class="title">MakeClothes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PantsFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">Clothes* <span class="title">MakeClothes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Pants</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JeansFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">Clothes* <span class="title">MakeClothes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Jeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *pants_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Clothes *pants_clo = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    pants_fac = <span class="keyword">new</span> <span class="built_in">PantsFactory</span>();</span><br><span class="line">    pants_clo = pants_fac-&gt;<span class="built_in">MakeClothes</span>();</span><br><span class="line">    pants_clo-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pants_fac;</span><br><span class="line">    pants_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> pants_clo;</span><br><span class="line">    pants_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Factory *jeans_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Clothes *jeans_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    jeans_fac = <span class="keyword">new</span> <span class="built_in">JeansFactory</span>();</span><br><span class="line">    jeans_clo = jeans_fac-&gt;<span class="built_in">MakeClothes</span>();</span><br><span class="line">    jeans_clo-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> jeans_fac;</span><br><span class="line">    jeans_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> jeans_clo;</span><br><span class="line">    jeans_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/2.jpeg" alt="img not found"></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式提供创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。<br>当存在多个产品系列，而客户端只使用一格系列的产品时，可以考虑使用抽象工厂模式<br>缺点：当增加一个新系列的产品时，不仅需要实现具体的产品类，还需要增加一个新的创建接口，扩展相对困难。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhitePants</span> : <span class="keyword">public</span> Pants</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WhitePants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;WhitePants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackPants</span> : <span class="keyword">public</span> Pants</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlackPants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;BlackPants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhiteJeans</span> : <span class="keyword">public</span> Jeans</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WhiteJeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;WhiteJeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackJeans</span> : <span class="keyword">public</span> Jeans</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlackJeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;BlackJeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pants* <span class="title">MakePants</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Jeans* <span class="title">MakeJeans</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhiteFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pants* <span class="title">MakePants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WhitePants</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Jeans* <span class="title">MakeJeans</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WhiteJeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pants* <span class="title">MakePants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BlackPants</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Jeans* <span class="title">MakeJeans</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BlackJeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *white_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Pants* white_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    Jeans* white_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    white_fac = <span class="keyword">new</span> <span class="built_in">WhiteFactory</span>();</span><br><span class="line">    white_pants = white_fac-&gt;<span class="built_in">MakePants</span>();</span><br><span class="line">    white_pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    white_jeans = white_fac-&gt;<span class="built_in">MakeJeans</span>();</span><br><span class="line">    white_jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> white_fac;</span><br><span class="line">    white_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> white_pants;</span><br><span class="line">    white_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> white_jeans;</span><br><span class="line">    white_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Factory *black_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Pants* black_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    Jeans* black_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    black_fac = <span class="keyword">new</span> <span class="built_in">BlackFactory</span>();</span><br><span class="line">    black_pants = black_fac-&gt;<span class="built_in">MakePants</span>();</span><br><span class="line">    black_pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    black_jeans = black_fac-&gt;<span class="built_in">MakeJeans</span>();</span><br><span class="line">    black_jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> black_fac;</span><br><span class="line">    black_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> black_pants;</span><br><span class="line">    black_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> black_jeans;</span><br><span class="line">    black_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/3.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之单例模式</title>
    <url>/2022/08/17/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之单例模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>单例模式顾名思义，保证一个类在内存中仅有一个实例化对象，并提供一个可以访问它的全局化接口。实现单例模式必须注意以下几点：</p>
<ol>
<li>单例类只能有一个实例化对象。</li>
<li>单例类必须自己提供一个实例化对象。</li>
<li>单例类必须提供一个可以访问唯一实例化对象的接口。<br>单例模式分为懒汉式和饿汉式两种实现方式。</li>
</ol>
<h1 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h1><p>懒汉，顾名思义，不到万不得已就不会去实例化类，也就是说第一次用到类实例的时候才会去实例化一个对象。在访问量较小，甚至可能不会去访问的情况下，采用懒汉实现，以时间换空间。</p>
<h2 id="非线程安全的懒汉单例模式"><a href="#非线程安全的懒汉单例模式" class="headerlink" title="非线程安全的懒汉单例模式"></a>非线程安全的懒汉单例模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关键代码：构造函数私有，不能通过赋值运算，拷贝构造等方法实例化对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式一般实现：非线程安全，getInstance返回的实例指针需要delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">SingleMan</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line">&#125;;</span><br><span class="line">SingleMan *SingleMan::m_singleMan = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan *<span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_m_singleMan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="非线程安全的懒汉单例模式-1"><a href="#非线程安全的懒汉单例模式-1" class="headerlink" title="非线程安全的懒汉单例模式"></a>非线程安全的懒汉单例模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">SingleMan</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line"></span><br><span class="line">    std::mutex m_lock;</span><br><span class="line">&#125;;</span><br><span class="line">SingleMan *SingleMan::m_singleMan = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan *<span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_m_singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回一个reference指向local-static对象"><a href="#返回一个reference指向local-static对象" class="headerlink" title="返回一个reference指向local static对象"></a>返回一个reference指向local static对象</h2><p>这种单例模式实现方式多线程可能存在不确定性：任何一种non-const static 对象，不论它是local还是non-local，在多线程环境下”等待某事发生“都会有麻烦。<br>解决办法：在程序的单线程启动阶段手工调用所有reference-returing函数。<br>下面这种实现方式的好处就是你不需要去关心实例的释放，因为static修饰的变量生命周期和程序一样长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan&amp; <span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> SingleMan singleMan;</span><br><span class="line">    <span class="keyword">return</span> singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h1><p>饿汉模式，在访问量较大，或者访问线程较多时，采用饿汉实现，可以实现更好的性能。这是一种空间换时间的策略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式：线程安全，注意一定要在合适的地方去delete它</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line">​</span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">SingleMan* SingleMan::m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">​</span><br><span class="line"><span class="function">SingleMan* <span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/17/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之策略模式</title>
    <url>/2022/08/22/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之策略模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>策略模式是指定义一系列的算法，把它们一个个的封装起来，并且使它们可以互相替换。本模式可以使得算法独立于它的客户而变化。也就是说这些算法完成的功能一样，对外的接口一样，只是各自实现实现上存在差异。用策略模式来封装算法，效果比较好。<br>下面以高速缓存（Cache）的替换算法为例，实现策略模式。<br>所谓Cache的替换算法，就是当Cache发生缺失时，Cache控制器必须选择Cache中的一行并用欲获得的数据替换它。所采用的选择策略就是Cache的替换算法。相应的UML类图如下：<br><img src="/2022/08/22/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
<h1 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h1><p>这里首先给出算法的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">replace</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Least Recently Used replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFO_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;First in First out replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Random_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Random replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="实现方式1"><a href="#实现方式1" class="headerlink" title="实现方式1"></a>实现方式1</h1><p>接着给出Cache的定义，这里很关键，Cache的实现方式直接影响了客户的使用方式，其关键在于怎么指定替换算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cache</span>(ReplaceAlgorithm *ra)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ra = ra;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cache</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ra;</span><br><span class="line">        m_ra = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ra-&gt;<span class="built_in">replace</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ReplaceAlgorithm *m_ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cache <span class="title">cache</span><span class="params">(<span class="keyword">new</span> LRU_ReplaceAlgorithm())</span></span>; <span class="comment">//暴露了算法的定义  </span></span><br><span class="line">    cache.<span class="built_in">Replace</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式暴露给了客户具体的算法的定义。</p>
<h1 id="实现方式2"><a href="#实现方式2" class="headerlink" title="实现方式2"></a>实现方式2</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cache需要用到替换算法  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RA</span> &#123;LRU, FIFO, RANDOM&#125;; <span class="comment">//标签  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    ReplaceAlgorithm *m_ra;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Cache</span>(<span class="keyword">enum</span> RA ra)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(ra == LRU)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">LRU_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ra == FIFO)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">FIFO_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ra == RANDOM)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">Random_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">            m_ra = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~<span class="built_in">Cache</span>() &#123; <span class="keyword">delete</span> m_ra; &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span> </span>&#123; m_ra-&gt;<span class="built_in">Replace</span>(); &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">Cache <span class="title">cache</span><span class="params">(LRU)</span></span>; <span class="comment">//指定标签即可  </span></span><br><span class="line">    cache.<span class="built_in">Replace</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这种方式也是通过参数指定，不过不是传入指针，而是传入算法的枚举。这样客户就不需要知道算法的具体定义，只需要知道算法的标签即可。</p>
<h1 id="实现方式3"><a href="#实现方式3" class="headerlink" title="实现方式3"></a>实现方式3</h1><p>以上两种实现方式都需要构造函数传参才能实现，是否可以不需要构造函数传参的方式来实现？<br>利用模板来实现。算法通过模板的实参指定，虽然还是使用了参数，但是不是构造函数的参数。在策略模式中，参数的传递难以避免，客户必须指定某种算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cache需要用到的替换算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RA</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RA m_ra;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cache</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Cache</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ra.<span class="built_in">repalce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cache &lt;Random_ReplaceAlgorithm&gt; cache;<span class="comment">//模板实参</span></span><br><span class="line">    cache.<span class="built_in">replace</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>策略模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title>通用异步收发器UART</title>
    <url>/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第11章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解UART的原理</li>
<li>掌握S3C2410&#x2F;S3C2440中UART的使用</li>
</ol>
<h1 id="UART原理以及UART部件使用方法"><a href="#UART原理以及UART部件使用方法" class="headerlink" title="UART原理以及UART部件使用方法"></a>UART原理以及UART部件使用方法</h1><h2 id="UART原理说明"><a href="#UART原理说明" class="headerlink" title="UART原理说明"></a>UART原理说明</h2><p>通用异步收发器简称UART（Universal Asynchronous Reciver Transmitter），它用来传输串行数据。发送数据时，CPU将并行数据写入UART，UART按照一定的格式在一根电线上发出；接收数据时，UART检测另一根电线上的信号，将串行收集放在缓冲区中，CPU即可读取UART获得这些数据。UART之间以全双工方式传输数据，最精简的连线方法只有三根电线，TxD用于发送数据，RxD用于接收数据，GnD用于给双方提供参考电平。<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/1.jpeg" alt="img not found"><br>UART使用标准的TTL&#x2F;CMOS逻辑电平（0-5V、0-3.3V、0-2.5V、0-1.8V）来表示数据，高电平表示1，低电平表示0。为了增强数据的抗干扰能力、提高传输长度，通常将TTL&#x2F;CMOS逻辑电平转换为RS-232逻辑电平，3<del>12V表示0，-3</del>-12V表示1。<br>TxD、RxD数据线以“位”为最小单位传输数据。帧（Frame）由具有完整意义、不可分割的若干位组成，它包含开始位、数据位、校验位（需要的话）和停止位。发送数据之前，UART之间要约定好数据的传输速率（即每位所占据的时间，其倒数称为波特率）、数据的传输格式（即有多少个数据位、是否使用校验位、奇校验还是偶校验、有多少个停止位）。<br>数据传输流程如下：</p>
<ol>
<li>平时数据线处于空闭状态（1状态）。</li>
<li>当要发送数据时，UART改变TxD数据线的状态（变为0状态），并维持1位的时间，这样接收方检测到开始位之后，再等待1.5位的时间就开始一位一位检测数据线的状态得到所传输的数据。</li>
<li>UART一帧中可以有5、6、7或8位得数据，发送方一位一位地改变数据线的状态将它们发送出去，首先发送最低位。</li>
<li>如果使用校验功能，UART在发送完数据位之后，还要发送一个校验位。有两种校验方法：奇校验、偶校验—数据位连同校验位中“1”的数目等于奇数还是偶数。</li>
<li>最后，发送停止位，数据线恢复到空闭状态（1状态）。停止位的长度有3种：1位、1.5位、2位。</li>
</ol>
<p>下图演示了UART使用7个数据位、偶校验、2个停止位的格式传输字符’A‘（二进制格式为0b1000001）时，TTL&#x2F;CMOS逻辑电平、RS232逻辑电平对应的波形。<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/2.jpeg" alt="img not found"></p>
<h2 id="S3C2410-x2F-S3C2440-UART的特性"><a href="#S3C2410-x2F-S3C2440-UART的特性" class="headerlink" title="S3C2410&#x2F;S3C2440 UART的特性"></a>S3C2410&#x2F;S3C2440 UART的特性</h2><p>S3C2410&#x2F;S3C2440 中UART的特性相似，有3个独立的通道，每个通道都可以工作于中断模式或DMA模式，即UART可以发出中断或DMA请求以便在CPU、UART之间传输数据。S3C2410&#x2F;S3C2440 UART由波特率发生器、发送器、接收器和控制逻辑组成。<br>使用系统时钟时，S3C2410的UART波特率可以达到230.4Kbit&#x2F;s，S3C2440则可以达到115.2Kbit&#x2F;s；如果使用UEXTCLK引脚提供的外部时钟，则可以达到更高的波特率。波特率可以通过编程控制。<br>S3C2410 UART的每个控制通道都有16字节的发送FIFO和16字节的接收FIFO，S3C2440 UART的FIFO深度为64。发送数据时，CPU先将数据写入发送FIFO中，然后UART控制器会自动将FIFO中的数据复制到“发送移位器（Transmit Shifter）”中，发送移位器将数据一位一位的发送到TxD数据线上。接收数据时，“接收移位器（Receive Shifter）”，将RxD数据线上的数据一位一位的接收进来，然后复制到接收FIFO中，CPU即可从中读取数据。<br>S3C2410&#x2F;S3C2440 UART的每个通道支持的停止位有1位、2位，数据位有5、6、7或8位，支持校验功能，另外还有红外发送&#x2F;接收功能。<br>S3C2410&#x2F;S3C2440 UART结构如下图所示：<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/3.jpeg" alt="img not found"></p>
<h2 id="S3C2410-x2F-S3C2440-UART的使用"><a href="#S3C2410-x2F-S3C2440-UART的使用" class="headerlink" title="S3C2410&#x2F;S3C2440 UART的使用"></a>S3C2410&#x2F;S3C2440 UART的使用</h2><p>在使用UART之前需要设置波特率、传输格式；对于S3C2410&#x2F;S3C2440，还要选择所涉及管脚为UART功能，选择UART通道的工作模式为中断模式还是DMA模式。设置好之后，往某个寄存器写入数据即可发送。可以通过查询状态寄存器或设置中断来获知数据是否已经发送完毕、是否已经接收到数据。</p>
<h3 id="将所涉及的UART通道管脚设为UART功能"><a href="#将所涉及的UART通道管脚设为UART功能" class="headerlink" title="将所涉及的UART通道管脚设为UART功能"></a>将所涉及的UART通道管脚设为UART功能</h3><p>比如UART通道0中，GPH2、GPH3分别用作TXD0、RXD0，要使用UART通道0时，先设置GPHCON寄存器将GPH2、GPH3引脚的功能设为TXD0、RXD0。</p>
<h3 id="UBRDIVn寄存器（UART-BAUD-RATE-DIVISOR）：设置波特率"><a href="#UBRDIVn寄存器（UART-BAUD-RATE-DIVISOR）：设置波特率" class="headerlink" title="UBRDIVn寄存器（UART BAUD RATE DIVISOR）：设置波特率"></a>UBRDIVn寄存器（UART BAUD RATE DIVISOR）：设置波特率</h3><p>S3C2410 UART的时钟源有两种选择：PCLK、UEXTCLK；S3C2440的时钟源有三种选择：PCLK、UEXTCLK、FCLK&#x2F;n，其中n通过UCON0<del>UCON2联合设置。<br>根据给定的波特率、所选择的时钟源的频率，可以通过以下公式计算UBRDIVn寄存器（n为0</del>2，对应3个UART通道）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBRDIVn = (<span class="type">int</span>)(UART clock/(baud rate x <span class="number">16</span>)) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上述公式计算出来的UBRDIVn寄存器值不一定是整数，只要误差在1.87%之内即可。误差计算公式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tUPCLK = (UBRDIVn + <span class="number">1</span>) x <span class="number">16</span> x <span class="number">1F</span>rame / (UART clock)     <span class="comment">//tUPCLK 实际的UART时钟</span></span><br><span class="line">tUEXACT = <span class="number">1F</span>rame / baud rate                            <span class="comment">//tUEXACT 理论的UART时钟</span></span><br><span class="line">UART error = (tUPCLK - tUEXACT) / tUEXACT x <span class="number">100</span>%        <span class="comment">//误差</span></span><br></pre></td></tr></table></figure>

<h3 id="ULCONn寄存器（UART-LINE-CONTROL）：设置传输格式"><a href="#ULCONn寄存器（UART-LINE-CONTROL）：设置传输格式" class="headerlink" title="ULCONn寄存器（UART LINE CONTROL）：设置传输格式"></a>ULCONn寄存器（UART LINE CONTROL）：设置传输格式</h3><p>ULCONn寄存器（n为0~2）格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数据位宽度</td>
<td>[1:0]</td>
<td>0b00：5位<br> 0b01：6位<br> 0b10：7位<br> 0b11：8位</td>
</tr>
<tr>
<td>停止位宽度</td>
<td>[2]</td>
<td>0：一帧中有一个停止位 <br>1：一帧中有两个停止位</td>
</tr>
<tr>
<td>校验模式</td>
<td>[5:3]</td>
<td>设置校验位的产生方法、检验方法: <br> 0b0xx：无校验 <br>0b100：奇校验<br>0b101：偶校验<br>0b110：发送数据时强制设为1，接收数据时检查是否为1<br>0b111：发送数据时强制设为0，接收数据时检查是否为0</td>
</tr>
<tr>
<td>红外模式</td>
<td>[6]</td>
<td>0：正常模式<br>1：红外模式</td>
</tr>
</tbody></table>
<p>UART通道被设为红外模式时，其串行数据的波形与正常模式稍有不同。</p>
<h3 id="ULCONn寄存器（UART-CONTROL）"><a href="#ULCONn寄存器（UART-CONTROL）" class="headerlink" title="ULCONn寄存器（UART CONTROL）"></a>ULCONn寄存器（UART CONTROL）</h3><p>ULCONn寄存器用于选择UART时钟源、设置UART中断方式等。S3C2410 UART的时钟源有两种选择：PCLK、UEXTCLK；S3C2440的时钟源有三种选择：PCLK、UEXTCLK、FCLK&#x2F;n。所以在时钟源的选择与设置方面稍有不同。<br>S3C2410的ULCONn寄存器格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>接收模式</td>
<td>[1:0]</td>
<td>选择如何从UART接收缓冲区中读取数据。<br>0b00：禁止接收数据 <br>0b01：中断方式或者查询方式 <br>0b10：DMA0请求（UART0） DMA3请求（UART2）<br>0b11：DMA1请求（UART1）</td>
</tr>
<tr>
<td>发送模式</td>
<td>[3:2]</td>
<td>选择如何将数据发送到UART发送缓存区。<br>0b00：禁止发送数据 <br>0b01：中断方式或者查询方式 <br>0b10：DMA0请求（UART0） DMA3请求（UART2）<br>0b11：DMA1请求（UART1）</td>
</tr>
<tr>
<td>自环模式</td>
<td>[5]</td>
<td>自环模式就是将TxDn和RxDn在内部相连，用于自发自收。<br>0：正常模式 1：自环模式</td>
</tr>
<tr>
<td>接收错误状态中断使能</td>
<td>[6]</td>
<td>用于使能当发生错误时（帧错误、溢出）时，产生中断。<br> 0：出错时不产生中断 <br>1：出错时产生中断</td>
</tr>
<tr>
<td>接收超时使能</td>
<td>[7]</td>
<td>当使用UART FIFO时，用于使能&#x2F;禁止接收超时的中断。 <br>0&#x3D;禁止 1&#x3D;使能</td>
</tr>
<tr>
<td>接收中断方式</td>
<td>[8]</td>
<td>如下情况发生时，将产生接收中断。<br> 不使用FIFO时，接收到一个数据；<br>使用FIFO时，FIFO中的数据达到RxFIFO的触发阈值。<br>中断方式如下设置。<br>0：脉冲 <br>1：电平</td>
</tr>
<tr>
<td>发送中断方式</td>
<td>[9]</td>
<td>如下情况发生时，将产生发送中断。<br> 不使用FIFO时，发送缓冲区变空；<br>使用FIFO时，FIFO中的数据达到TxFIFO的触发阈值。<br>中断方式如下设置。<br>0：脉冲 <br>1：电平</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[10]</td>
<td>选择UART时钟源。<br>0：PCLK <br>UEXTCLK</td>
</tr>
</tbody></table>
<p>S3C2440的UCONn寄存器在UART时钟的选择方面与S3C2410有所不同，从位[10]往上的位含义不一样，并且原来的位[4]用于选择是否发出“break”信号，这些位的含义如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“break”信号</td>
<td>[4]</td>
<td>设置此位时，UART会在一帧的时间内发出一个“break”信号。<br>0：正常发送  1：发出“break”信号</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[11:10]</td>
<td>选择UART时钟源。<br>0b00&#x2F;0b10：PCLK <br> 0b01：UEXTVLK <br> 0b11：FCLK&#x2F;n</td>
</tr>
<tr>
<td>FCLK分频率系数</td>
<td>[15:12]</td>
<td>用来设置“FCLK&#x2F;n”中的n值</td>
</tr>
</tbody></table>
<p>ULCON0、ULCON1、ULCON2这3个寄存器的位[15:12]一起用来确定n值，它们的意义如下。</p>
<ol>
<li>ULCON2[15]：“FCLK&#x2F;n”使能位。<br>它等于0时，禁止使用“FCLK&#x2F;n”作为UART时钟源；等于1时，可以用作UART时钟源。</li>
<li>n值的设置。<br>ULCON0[15:12]、ULCON1[15:12]、ULCON2[14:12]三者用于设置n值，当其中一个被设置为非0值时，其他两个必须为0。<ol>
<li>n值处于7~12时，UART时钟&#x3D;FCLK&#x2F;（divider + 6），divider为ULCON0[15:12]的值，大于0。</li>
<li>n值处于22~36时，UART时钟&#x3D;FCLK&#x2F;（divider + 21），divider为ULCON1[15:12]的值，大于0。</li>
<li>n值处于37~43时，UART时钟&#x3D;FCLK&#x2F;（divider + 36），divider为ULCON2[14:12]的值，大于0。</li>
<li>ULCON0[15:12]、ULCON1[15:12]、ULCON2[14:12]都等于0时，UART时钟：FCLK&#x2F;44。</li>
</ol>
</li>
</ol>
<h3 id="UFCONn寄存器（UART-FIFO-CONTROL）、UFSTATn寄存器（UART-FIFO-STATUS）"><a href="#UFCONn寄存器（UART-FIFO-CONTROL）、UFSTATn寄存器（UART-FIFO-STATUS）" class="headerlink" title="UFCONn寄存器（UART FIFO CONTROL）、UFSTATn寄存器（UART FIFO STATUS）"></a>UFCONn寄存器（UART FIFO CONTROL）、UFSTATn寄存器（UART FIFO STATUS）</h3><p>UFCONn寄存器用于设置是否使用FIFO，设置各FIFO的触发阈值，即发送FIFO中有多少个数据产生中断、接收FIFO中有多少个数据产生中断。并可以通过设置UFCONn寄存器来复位各个FIFO。<br>读取UFSTATn寄存器可以知道各个FIFO是否已经满、其中有多少个数据。<br>不适用FIFO时，可以认为FIFO的深度是1，使用FIFO时，S3C2410的FIFO深度是16，S3C2440的深度是64。</p>
<h3 id="UMCONn寄存器（UART-MODEM-CONTROL）、UMSTATn寄存器（UART-MODEM-STATUS）"><a href="#UMCONn寄存器（UART-MODEM-CONTROL）、UMSTATn寄存器（UART-MODEM-STATUS）" class="headerlink" title="UMCONn寄存器（UART MODEM CONTROL）、UMSTATn寄存器（UART MODEM STATUS）"></a>UMCONn寄存器（UART MODEM CONTROL）、UMSTATn寄存器（UART MODEM STATUS）</h3><p>这两类寄存器用于流量控制。</p>
<h3 id="UTRSTATn寄存器（UART-TX-x2F-RX-STATUS）"><a href="#UTRSTATn寄存器（UART-TX-x2F-RX-STATUS）" class="headerlink" title="UTRSTATn寄存器（UART TX&#x2F;RX STATUS）"></a>UTRSTATn寄存器（UART TX&#x2F;RX STATUS）</h3><p>UTRSTATn寄存器用来表明数据是否已经发送完毕、是否已经接收到数据。格式如下表所示。缓冲区其实就是FIFO，只不过不适用FIFO时，FIFO的深度为1。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>接收缓冲区数据就绪</td>
<td>[0]</td>
<td>当接收到数据时，此位被自动设为1</td>
</tr>
<tr>
<td>发送缓冲区空</td>
<td>[1]</td>
<td>当发送缓冲区没有数据时，此位被自动设为1</td>
</tr>
<tr>
<td>发送器空</td>
<td>[2]</td>
<td>当发送缓冲区中没有数据，并且最后一个数据也已经发送出去，此位被自动设为1</td>
</tr>
</tbody></table>
<h3 id="UERSTATn寄存器（UART-ERROR-STATUS）"><a href="#UERSTATn寄存器（UART-ERROR-STATUS）" class="headerlink" title="UERSTATn寄存器（UART ERROR STATUS）"></a>UERSTATn寄存器（UART ERROR STATUS）</h3><p>用来表示各种错误是否发生，位[0]~位[3]为1时分别表示溢出错误、校验错误、帧错误、检测到“break”信号。读取这个寄存器时，它会自动清0。<br>需要注意的是，接收数据时如果使用FIFO，则UART内部会使用一个“错误FIFO”来表明接收FIFO中哪个数据在接收过程中发生了错误。CPU只有在读出这个错误的数据时，才会察觉到发生了错误。要想清除“错误FIFO”，则必须读出错误的数据，并读出UERSTATn寄存器。</p>
<h3 id="UTXHn寄存器（UART-TRANSMIT-BUFFER-REGISTER）"><a href="#UTXHn寄存器（UART-TRANSMIT-BUFFER-REGISTER）" class="headerlink" title="UTXHn寄存器（UART TRANSMIT BUFFER REGISTER）"></a>UTXHn寄存器（UART TRANSMIT BUFFER REGISTER）</h3><p>CPU将数据写入这个寄存器，UART即会将它保存到缓冲区，并自动发送出去。</p>
<h3 id="URXHn寄存器（UART-RECEIVER-BUFFER-REGISTER）"><a href="#URXHn寄存器（UART-RECEIVER-BUFFER-REGISTER）" class="headerlink" title="URXHn寄存器（UART RECEIVER BUFFER REGISTER）"></a>URXHn寄存器（UART RECEIVER BUFFER REGISTER）</h3><p>当UART接收到数据，CPU读取这个寄存器，即可获得数据。</p>
<h1 id="UART操作实例"><a href="#UART操作实例" class="headerlink" title="UART操作实例"></a>UART操作实例</h1><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>本示例代码的目的是在串口上输出一串字符，单板接收到后将它的ASCII码加1后从串口输出。<br>首先设置MPLL提高系统时钟，令PCLK为50MHz，UART将选择PCLK为时钟源。将代码复制到SDRAM中之后，调用main函数。重点在于UART0的初始化、收发数据，这由3个函数来实现：uart0_init、getc和putc。</p>
<h3 id="UART初始化"><a href="#UART初始化" class="headerlink" title="UART初始化"></a>UART初始化</h3><p>uart0_init函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCLK                        50000000            <span class="comment">//init.c中的clock_init函数设置PCLK为50MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_CLK                    PCLK                <span class="comment">//UART0的时钟源设置为PCLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BAUD_RATE              115200              <span class="comment">//波特率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BRD                    ((UART_CLK / (UART_BAUD_RATE * 16 )) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化UART0</span></span><br><span class="line"><span class="comment">115200 8N1 无流控</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPHCON |= <span class="number">0xa0</span>;                     <span class="comment">//GPH2、GPH3用作TXD0、RXD0</span></span><br><span class="line">    GPHUP   = <span class="number">0x0c</span>;                     <span class="comment">//GPH2、GPH3内部上拉</span></span><br><span class="line"></span><br><span class="line">    ULCON0  = <span class="number">0x03</span>;                     <span class="comment">//波特率为115200，数据格式为：8个数据位、没有流控、1个停止位</span></span><br><span class="line">    UCON0   = <span class="number">0x05</span>;                     <span class="comment">//查询方式，UART时钟源位PLCK</span></span><br><span class="line">    UFCON0  = <span class="number">0x00</span>;                     <span class="comment">//不使用FIFO</span></span><br><span class="line">    UMCON0  = <span class="number">0x00</span>;                     <span class="comment">//不使用流控</span></span><br><span class="line">    UBRDIV0 = UART_BRD;                 <span class="comment">//波特率位115200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送字符的函数"><a href="#发送字符的函数" class="headerlink" title="发送字符的函数"></a>发送字符的函数</h3><p>本实例不使用FIFO，发送字符前，首先判断上一个字符是否已经被发送出去。如果没有，则不断查询UTRSTAT0寄存器的位[2]，当它为1时表示已经发送完毕。于是，即可向UTXH0寄存器中写入当前要发送的字符。代码如下（宏TXD0READY被定义为（1 &lt;&lt; 2））:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送一个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待，直到发送缓区中的数据已经全部发送出去</span></span><br><span class="line">    <span class="keyword">while</span>(!(UTRSTAT0 &amp; TXD0READY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向UTXH0寄存器中写入数据，UART即自动将它发送出去</span></span><br><span class="line">    UTXH0 = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收字符的函数"><a href="#接收字符的函数" class="headerlink" title="接收字符的函数"></a>接收字符的函数</h3><p>试图读取数据前，先查询UTRSTAT0寄存器的位[1]，当它为1时表示接收缓冲区有数据，于是，即可读取URXH0得到数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接收一个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">getc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待，直到接收缓存区有数据</span></span><br><span class="line">    <span class="keyword">while</span>(!(UTRSTAT0 &amp; RXD0READY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接读取URXH0寄存器，即可获得接收到的数据</span></span><br><span class="line">    <span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>在main函数中，初始化UART0之后，即不断读取串口数据，并判断它是否为数字或字母。如果是的话，就将它加1后从串口输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    uart0_init();               <span class="comment">//波特率115200，8N1（8个数据位，无校验位，1个停止位）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从串口接收到数据之后，判断其是否为数字或字母，若是则加1后输出</span></span><br><span class="line">        c = getc();</span><br><span class="line">        <span class="keyword">if</span>(isDigital(c) || isLetter(c))</span><br><span class="line">            putc(c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h2><p>首先使用串口将开发板的COM0和PC的串口相连，打开PC上的串口工具（推荐使用SecureCRT），设置其波特率为115200、8N1（8个数据位，无校验位，1个停止位）。然后将编译生成的uart.bin文件烧入NAND Flash后上电运行。最后在PC上的串口工具中输入数字或者字母，可以看到输出另一个字符（加1）；如果输入其他字符，则无输出。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第11章 通用异步收发器UART</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>设备与模块</title>
    <url>/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Linux内核设计与实现》第17章总结归纳</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><ol>
<li>设备类型：在所有Unix系统中为了统一普通设备的操作所采用的分类</li>
<li>模块：Linux内核中用于按需加载和卸载目标码的机制</li>
<li>内核对象：内核数据结构支持面向对象的简单操作，还支持维护父子对象之间的关系</li>
<li>sysfs：表示系统中设备树的一个文件系统</li>
</ol>
<h1 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h1><p>在Linux以及所有的Unix中，设备被分为三种类型；</p>
<ol>
<li>块设备<br> 通常缩写为blkdev，块设备是可寻址的，寻址以块为单位。块设备通常支持重定位操作，即对数据的随机访问。常见的块设备有硬盘，光碟，Flash。块设备通常会被挂载为文件系统。</li>
<li>字符设备<br> 通常缩写为cdev，字符设备是不可寻址的，仅提供数据的流式访问（即一个一个字符或者一个一个字节）。常见的字符设备有键盘，鼠标，打印机等，还有大部分伪设备。应用程序可以直接访问字符设备节点与字符设备交互。</li>
<li>网络设备<br> 一般以Ethernet Device来称呼，它提供了对网络的访问，通过一种物理适配器（如网卡）和一种特定的协议（如IP）进行的。它不是通过文件节点来访问的，而是通过套接字来这样的特殊接口来访问。</li>
<li>伪设备<br> 并不是所有设备驱动都表示物理设备。有些设备驱动时虚拟的，仅仅提供访问访问内核功能而已，称之为伪设备。例如内核随机数发生器（&#x2F;dev&#x2F;null）,空设备（&#x2F;dev&#x2F;zero）,零设备（&#x2F;dev&#x2F;urandom），满设备（&#x2F;dev&#x2F;full），内存设备（&#x2F;dev&#x2F;mem）。</li>
</ol>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>Linux是单块内核的操作系统，即整个系统都运行与一个单独的保护域中，但是Linux内核却是模块化的。它允许内核在运行期间动态的向其中插入或删除代码。这些代码（相关的子例程，数据，函数出口，函数入口）被存放在一个单独的二进制镜像中，称之为模块。支持模块的好处就是基本的内核镜像能尽可能的小，因为可选的功能和驱动程序都可以以模块的形式再提供。当热插拔新设备时，可以重新载入新的驱动程序。</p>
<h2 id="一个最简单模块"><a href="#一个最简单模块" class="headerlink" title="一个最简单模块"></a>一个最简单模块</h2><p>虽然编写“Hello World”程序属于陈词滥调，但是它就是那么合适，下面就是属于内核模块的“Hello World”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello.c Hello World 我们的第一个内核模块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello_init--初始化函数，模块装载时被调用，如果成功装载，返回0，否则返回非零值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;hello init.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello_exit--退出函数，模块卸载时被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;hello exit.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LISENCE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Nibil&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A Hello World Module&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>hello_init()</code>函数是模块的入口点，它通过<code>module_init()</code>例程注册到系统中，在内核装载时被调用。<code>module_init()</code>是一个宏。<br>模块的所有初始化函数必须符合下面的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>因为它不会被外部调用，所以可以加上static修饰。在实际的模块初始化函数中，往往会注册资源，初始化硬件，分配数据结构等。如果这个文件被静态编译进入内核镜像，那么这个模块将会在内核启动时运行。<br><code>hello_exit()</code>函数是模块的出口函数，他由<code>module_exit()</code>例程注册到系统。在模块从内核中卸载时，便会调用<code>hello_exit()</code>。简单来说，该函数负责对模块生命周期内所做的一切事情的撤销工作，在<code>hello_exit()</code>返回后，模块就被卸载了。<br>退出函数必须符合下面的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>与init函数一样，你也可以用static修饰它。<br><code>MODULE_LISENCE()</code>用于指定模块的版权；<code>MODULE_AUTHOR()</code>和<code>MODULE_DESCRIPTION()</code>用于指定作者和模块的简要描述，他们完全是用作信息记录目的。</p>
<h2 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h2><p>在2.6的内核中采用了“KBuild”构建系统，现在构建模块相比从前更加容易。构建过程的第一步是决定在哪里管理模块代码。你可以把模块源码加入到内核源代码树上，或者是作为一个补丁，最终把你的代码合并到正式的内核代码树上；另一种可行的方法就是在内核源代码树之外维护和构建你的模块代码。</p>
<h3 id="放在内核源代码树上"><a href="#放在内核源代码树上" class="headerlink" title="放在内核源代码树上"></a>放在内核源代码树上</h3><p>当你决定了把你的模块放在内核源代码树上，下一步就要清楚放在内核源代码树的何处。设备驱动程序位于&#x2F;drivers的子目录下，在其内部，设备驱动程序被进一步按照类别，类型或者特殊驱动程序等更有序的组织起来。如字符设备存放于&#x2F;drivers&#x2F;char目录下，块设备存放于&#x2F;drivers&#x2F;block目录下，USB设备存放于&#x2F;drivers&#x2F;usb目录下。文件的具体组织规则并不是墨守成规，不容打破，很多USB设备也属于字符设备。不管怎样，这些组织关系对我们来说相当容易理解，而且也很准确。<br>假定你有一个字符设备，而且你希望将它存放于&#x2F;drivers&#x2F;char目录下，建议建立你自己代码的子目录。你的驱动程序是一个钓鱼竿和计算机的接口，那么你需要在&#x2F;drivers&#x2F;char下面建立一个fishing的子目录。接下来需要向&#x2F;drivers&#x2F;char下的Makefile文件添加一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-m += fishing/</span><br></pre></td></tr></table></figure>
<p>这行代码告诉模块构建系统，在模块编译时需要进入fishing&#x2F;子目录中。更有可能发生的是，你的驱动程序的编译取决于一个特殊配置选项；比如，可能的CONFIG_FISHING_POLE。那么，你可能需要用下面的指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing/</span><br></pre></td></tr></table></figure>
<p>最后，在&#x2F;drivers&#x2F;char&#x2F;fishing&#x2F;下，添加一个新的Makefile文件，其中需要有下面这行指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing.o</span><br></pre></td></tr></table></figure>
<p>以后，假如你的钓鱼竿程序需要更加智能化–它需要可以增加自动检测钓鱼线的功能。那么你的源程序就不止一个C文件了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing.o</span><br><span class="line">fishing-objs := fish-main.o fish-line.o</span><br></pre></td></tr></table></figure>
<p>每当设置了CONFIG_FISHING_POLE，fishing-main.c和fishing-line.c就会被一起编译链接到fishin.ko中去。最后需要注意的是，构建文件时你可能需要额外的编译标记，你只需要在Makefile中添加如下命令，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS += -DTITANIUM_POLE</span><br></pre></td></tr></table></figure>
<p>然后就开始编译吧！</p>
<h3 id="放在内核代码外"><a href="#放在内核代码外" class="headerlink" title="放在内核代码外"></a>放在内核代码外</h3><p>模块在内核内和在内核外的构建的区别在于构建过程。当模块在内核源码树外时，你必须告诉make如何找到内核源代码文件和Makefile文件，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make -C /kernel/source/location SUBDIRS=$PWD modules</span><br></pre></td></tr></table></figure>
<p>在这个例子中，&#x2F;kernel&#x2F;source&#x2F;location是你自己配置的内核源码树。</p>
<h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>编译后的模块将被装入到目录&#x2F;lib&#x2F;modules&#x2F;version&#x2F;kernel下，在将kernel&#x2F;目录下的每一个目录都对应着内核源码树中的模块位置。如果使用的是2.6.34的内核，而且将你的模块源代码直接放在&#x2F;drivers&#x2F;char下，那么编译后的钓鱼杆驱动程序的存放路径将是:&#x2F;lib&#x2F;modules&#x2F;2.6.34&#x2F;kernel&#x2F;drivers&#x2F;char&#x2F;fishing.ko。<br>下面的构建命令用来安装编译的模块到合适的目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<h2 id="产生模块依赖性"><a href="#产生模块依赖性" class="headerlink" title="产生模块依赖性"></a>产生模块依赖性</h2><p>Linux模块之间存在依赖性，也就是说钓鱼模块依赖于鱼饵模块，那么当你载入钓鱼模块时，鱼饵模块会自动被载入。你可以使用如下命令获取内核模块之间的依赖信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depmod</span><br><span class="line">depmod -A #模块依赖关系存放于/lib/modules/version/modules.dep中。</span><br></pre></td></tr></table></figure>

<h2 id="载入模块"><a href="#载入模块" class="headerlink" title="载入模块"></a>载入模块</h2><p>载入模块最简单的方法就是通过insmod命令，它的功能就是请求内核载入指定的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insmod module.ko</span><br><span class="line">rmmod module #卸载一个模块</span><br></pre></td></tr></table></figure>
<h2 id="管理配置选项"><a href="#管理配置选项" class="headerlink" title="管理配置选项"></a>管理配置选项</h2><p>这里我们继续以钓鱼竿驱动程序为例，看看一个新的配置选项如何加入。<br>由于2.6内核新引入了“Kbuild”系统，你所需要做的就是想Kconfig文件中添加一项，用以对应内核源码树。对驱动程序而言，kconfig通常和源代码处于同一目录。如果钓鱼杆驱动程序位于&#x2F;drivers&#x2F;char下，那么&#x2F;drivers&#x2F;char&#x2F;kconfig也会存在。<br>如果你新引入了一个子目录fishing&#x2F;，那么你必须在一个已经存在的kconfig文件中将它引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;drivers/char/fishing/kconfig&quot;</span><br></pre></td></tr></table></figure>
<p>请看kconfig中钓鱼竿模块的选项，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config FISHING_POLE</span><br><span class="line">    tristate &quot;Fish Mater 3000 support&quot;</span><br><span class="line">    default n</span><br><span class="line">    help </span><br><span class="line">        you can say N(no),M(Module),Y(yes) here,if unsure say N</span><br></pre></td></tr></table></figure>
<p>第一行定义了该选项所代表的配置目标，注意CONFIG_前缀并不需要带上。<br>第二行声明类型为tristate，也就是说可以编译进内核（Y），也可以作为模块编译（M），或者干脆不编译它（N）。如果配置选项代表的是一个系统功能，而不是一个模块，那么编译选项将用bool代替tristate，说明它不允许被编译成模块。<br>第三行指定默认编译选项，驱动程序一般默认不编译进入内核（N）。<br>help指令为该选项提供帮助文档。<br>除了上述选项外，还存在其他选项。比如depends指令指定了在该选项设置前，首先需要设置的选项。假设你加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depends on FISH_TANK</span><br></pre></td></tr></table></figure>
<p>到配置选项中，那么就意味着在CONFIG_FISH_TANK被选择前，我们的钓鱼竿模块是不能被使用的（Y或者M）。<br>select指令和depends类似，它们只有一点不同之处—那就是select指定了谁，它就会将被指定的选项强制打开，所以要慎重使用select</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select BAIT</span><br></pre></td></tr></table></figure>
<p>意味着当CONFIG_FISHING_POLE被激活时，配置选项CONFIG_BAIT必然被一起激活。<br>如果select和depends同时指定多个选项，那就需要通过&amp;&amp;指令来进行多选。使用的depends时，你还可以利用叹号前缀来指明禁止某个选项。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depends on EXAMPLE_DIRVERS &amp;&amp; !NO_FISHING_ALLOWED</span><br></pre></td></tr></table></figure>
<p>这行指令就指定驱动程序安装要求打开CONFIG_EXAMPLE_DIRVERS选项，同时禁止CONFIG_NO_FISHING_ALLOWED选项。<br>tristate和bool选项往往会结合if指令一起使用，这表示某个选项取决于另一个配置选项。如果条件不满足，配置选项不但会被禁止，甚至不会显示在配置工具中。比如，要求配置系统只有在CONFIG_x86配置选项时才显示某选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool &quot;x86 only&quot; if x86</span><br></pre></td></tr></table></figure>
<h2 id="导出符号表"><a href="#导出符号表" class="headerlink" title="导出符号表"></a>导出符号表</h2><p>模块被载入后，就会被动态的连接到内核。注意，它与用户空间的动态链接库类似，只有被显式导出后的外部函数，才可以被动态库调用。在内核中，导出内核函数需要使用特殊的指令<code>EXPORT_SYMBOL()</code>和<code>EXPORT_SYMBOL_GPL()</code>。<br>导出的内核函数可以被模块调用，而未导出的函数模块则无法被调用。函数代码的链接和调用规则相比核心内核镜像的的代码而言，要更加严格。核心代码在内核中可以调用任意非静态接口，因为所有的核心源代码文件被链接成了同一个镜像。当然，被导出的符号表所含的函数必然也要是非静态的。<br>导出的内核符号被看作导出的内核接口，甚至被称为内核API。导出符号相当简单，在声明函数后，紧跟上<code>EXPORT_SYMBOL()</code>指令就搞定了。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    返回当前priate胡须的颜色</span><br><span class="line">*/</span><br><span class="line">int get_priate_beard_color(struct priate *p)</span><br><span class="line">&#123;</span><br><span class="line">    return p-&gt;beard.color;</span><br><span class="line">&#125;</span><br><span class="line">EXPROT_SYMBOL(get_priate_beard_color)</span><br></pre></td></tr></table></figure>
<p>如果你希望先前的函数仅对标记为GPL协议的模块可见，那么你就需要用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPROT_SYMBOL_GPL(get_priate_beard_color)</span><br></pre></td></tr></table></figure>
<p>如果你的代码被配置为模块，那么你就必须确保它被编译为模块时，它所用的全部接口都已经被导出，否则就会出现连接错误（而且模块不能编译成功）。</p>
<h1 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h1><p>2.6的内核增加了一个引人注目的新特性—-统一设备模型（device model）。设备模型提供了一个独立的机制专门来表示设备，并描述其在系统中的拓扑结构，从而使得系统具有以下优点：</p>
<ol>
<li>代码重复最小化；</li>
<li>提供诸如引用计数这样的统一机制；</li>
<li>可以列举系统中的所有设备，观察他们的形态，并且查看他们连接的总线；</li>
<li>可以将系统中的全部设备结构以树的形式完整，有效的展示出来—-包括总线和所有的内部连接；</li>
<li>可以将设备和其对应的驱动联系起来，反之亦然；</li>
<li>可以将设备按照类型分类，比如分为输入设备，而无需理解物理设备的拓扑结构；</li>
<li>可以沿这设备树的叶子向其根节点的方向遍历，以保证能以正确的顺序关闭各个设备的电源。<br>内核无疑需要一棵设备树。</li>
</ol>
<h2 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h2><p>设备模型的核心部分就是kobject（kernel object），它由struct kobject结构体表示，定义域头文件<code>&lt;linux/kobject.h&gt;</code>中。它提供了诸如引用计数，名称，父指针等字段，可以创建对象的层次结构。具体结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject&#123;</span><br><span class="line">    const char          *name;</span><br><span class="line">    struct list_head    entry;</span><br><span class="line">    struct kobject      *parent;</span><br><span class="line">    struct kset         *kset;</span><br><span class="line">    struct kobi_type    *ktype;</span><br><span class="line">    struct sysfs_dirent *sd;</span><br><span class="line">    struct kref         kref;</span><br><span class="line">    unsigned int        state_initialized:1;</span><br><span class="line">    unsigned int        state_in_sysfs:1;</span><br><span class="line">    unsigned int        state_add_uevent_sent:1;</span><br><span class="line">    unsigned int        state_remove_uevent_sent:1;</span><br><span class="line">    unsigned int        uevent_suppress:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>name 指针指向该kobject的名称。<br>parent 指针指向kobject的父对象，这样一来，kobject就会在内核中构造一个对象层次结构，并且可以将多个对象间的关系表现出来。这便是sysfs的真面目：一个用户空间的文件系统，用来表示内核中kobject对象的层次结构。<br>sd 指针指向sysfs_dirent结构体，它在sysfs中表示的就是这个kobject。<br>kref 提供引用计数。ktype和kset对kobject进行描述和分类。<br>kobject通常是嵌入到其他结构中，其单独存在的意义不大。比如定义在<code>&lt;linux/cdev.h&gt;</code>下的struct cdev中才真正用到了kobj结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    该对象代表一个字符设备</span><br><span class="line">*/</span><br><span class="line">struct cdev&#123;</span><br><span class="line">    struct kobject          kobj;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当konject被嵌入到其他结构中时，该结构便拥有了kobject提供的标准功能。更重要的一点是，嵌入kobject的结构体可以成为对象层次架构中的一部分。比如cdev就可以通过其父指针cdev-&gt;kobj.parent 和链表 cdev-&gt;kobj.entry 插入到对象层次结构中。</p>
<h2 id="ktype"><a href="#ktype" class="headerlink" title="ktype"></a>ktype</h2><p>kobject对象被关联到一种特殊的类型，即ktype（kernel object type）。ktype由kobj_type结构体表示，定义于头文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strcut kobj_type&#123;</span><br><span class="line">    void (*release)(struct kobject *);</span><br><span class="line">    const struct sysfs_ops *sysfs_ops;</span><br><span class="line">    struct attribute       **defalut_attrs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ktype的存在就是为了描述一族kobject的普遍特性。如此一来，不需要每一个kobject都分别定义自己的特性，而是将这些普遍的特性在ktype中一次定义，然后所有的同类“kobject”都能共享一样的特性。<br>release函数指针指向kobject引用计数为零时要被调用的析构函数。该函数负责释放所有kobject使用的内存和其他相关清理工作。<br>sysyfs_ops变量指向sysfs_ops结构体。该结构体描述了sysfs文件读写时的特性。<br>default_attrs指向了一个attribute结构体数组。这些结构体定义了该kobject相关的默认属性。属性描述了给定对象的特征，如果该kobject导出到sysyfs，那么这些属性都将相应的作为文件而导出，数组的最后一项必须为NULL。</p>
<h2 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h2><p>kset是kobject对象的集合体。可以把它看作是一个容器，可将所有相关的kobject对象，比如”全部的块设备“置于同一位置。kset和ktype最大的区别就是：具有相同ktype的kobject可以被分组到不同的kset。也就是说，在Linux内核中，只有少数一些的ktype，却有多个kset。<br>kobject的kset指针指向相应的kset集合。kset集合由kset结构体表示，定义于头文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kset&#123;</span><br><span class="line">    struct list_head        list;</span><br><span class="line">    spinlock_t              list_lock;</span><br><span class="line">    struct kobject          kobj;</span><br><span class="line">    struct kset_uevent_ops  *uevenet_ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个结构中，其中list连接该集合中所有的kobject对象，list_lock是保护这个链表对象的自旋锁，kobj指向的konject对象代表了该集合的基类。uevent_ops指向了一个结构体—用于处理集合中kobject对象的热插拔操作。<code>uevent就是用户事件（user event）的缩写</code>，提供了与用户空间热插拔信息进行通信的机制。</p>
<h2 id="kobject、ktype、kset的相互关系"><a href="#kobject、ktype、kset的相互关系" class="headerlink" title="kobject、ktype、kset的相互关系"></a>kobject、ktype、kset的相互关系</h2><p><img src="/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/1.jpeg" alt="img not found"></p>
<h2 id="管理和操作kobject"><a href="#管理和操作kobject" class="headerlink" title="管理和操作kobject"></a>管理和操作kobject</h2><p>当了解了kobject的内部基本细节后，我们来看管理和操作他的外部接口了。<br>使用kobject的第一步需要先进行声明和初始化。kobject通过函数<code>kobject_init()</code>进行初始化，该函数定义在文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_init(struct kobject *kobj,struct kobj_type *ktype);</span><br></pre></td></tr></table></figure>
<p>该函数第一个参数就是需要初始化kobject对象，在调用初始化之前，kobject必须清空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memset(kobj,0,sizeof(*kobj));</span><br></pre></td></tr></table></figure>
<p>只有在初始化之后就可以安全的初始化parent和kset字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">kobj = kmalloc(sizeof(*kobj),GFP_KERNEL);</span><br><span class="line">if(!kobj)</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">memset(kobj,0,sizeof(*kobj));</span><br><span class="line">kobj-&gt;kset = my_kset;</span><br><span class="line">kobject_init(kobj,my_ktype);</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">kobj = kobject_create();</span><br><span class="line">if(!kobj)</span><br><span class="line">    return -ENOMEM;</span><br></pre></td></tr></table></figure>
<p>大多数情况下，应该调用<code>kobject_create()</code>而不是直接操作这个结构体。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>kobject的主要功能之一就是为我们提供了一个统一的引用计数系统。初始化后，koject的引用计数设置为1。只要引用计数不为零，那么该对象就会继续保留在内存中。任何包含对象引用的代码首先要增加该对象的引用计数，当代码结束后就减少它的引用计数。当引用计数跌为零时，对象便可以撤销，相关内存也都被释放。</p>
<h3 id="增加和递减引用计数"><a href="#增加和递减引用计数" class="headerlink" title="增加和递减引用计数"></a>增加和递减引用计数</h3><p>增加一个引用计数可通过<code>kobject_get()</code>函数完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_get(struct kobject *kobj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数正常情况下将返回一个指向kobject的指针，如果失败则返回NULL。<br>减少引用计数通过<code>kobject_put()</code>完成，这个函数也声明在<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_put(struct kobject *kobj);</span><br></pre></td></tr></table></figure>
<p>如果对应的kobject的引用计数减少到零，那么与该kobject关联的ktype中的析构函数将会被调用。</p>
<h3 id="kref"><a href="#kref" class="headerlink" title="kref"></a>kref</h3><p>kobject的引用计数是通过kref结构体实现的。该结构体定义在<code>&lt;linux/kref.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kref&#123;</span><br><span class="line">    atomic_t refcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中唯一的字段是用来存放引用计数的原子变量。那么为什么采用结构体，这是为了便于进行类型检测。在使用kref前，你必须通过<code>kref_init()</code>来初始化它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_init(strcut kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">    atomic_set(&amp;kref-&gt;refcount,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数简单的将原子变量置1，所以fref一旦被初始化，它所表示的引用计数便固定为1。<br>要获得对kref的引用，需要调用<code>kref_get()</code>函数，该函数增加引用计数值，没有返回值，这个函数在<code>&lt;linux/kref.h&gt;</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_get(strcut kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(!atomic_read(&amp;kref-&gt;refcount));</span><br><span class="line">    atomic_inc(&amp;kref-&gt;refcount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少对kref的引用，这个函数在<code>&lt;linux/kref.h&gt;</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_put(strcut kref *kref,void (*release) (strcut kref *kref))</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(release == NULL);</span><br><span class="line">    WARN_ON(release == (void (*release) (strcut kref *)) kfree);</span><br><span class="line"></span><br><span class="line">    if(atomic_dec_and_test(&amp;kref-&gt;refcount))&#123;</span><br><span class="line">        release(kref);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述所有函数定义和声明分别在<code>lib/kref.c</code>和<code>&lt;linux/kref.h&gt;</code>中。</p>
<h1 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h1><p>sysfs文件系统是一个处于内存中的虚拟文件系统，它为我们提供了kobject对象层次结构的视图。帮助用户能以一个简单文件系统的方式来视察系统中各种设备的拓扑结构。借助属性对象，kobject可以用导出文件的方式，将内核变量提供给用户读取或者写入。<br>虽然设备模型的初衷是为了方便电源管理而提出的一种设备拓扑结构，但是sysfs是颇为意外的收获。为了方便调试，设备模型的开发者决定将设备结构树导出为一个文件系统。今天所有的2.6内核的系统都拥有sysfs文件系统，而且几乎都将其挂载在<code>sys/</code>下。<br>sysfs的诀窍就是吧kobject对象和目录项（directory entries）紧密联系在一起，这点是通过kobject对象中的dentry字段实现的。dentry结构体表示目录项，通过连接kobject到指定的目录项上，无疑方便的将kobject映射到该目录上。从此，把kobject导出形成文件系统就变得跟在内存中构建目录项一样简单。kobject其实已经形成了一棵树—就是我们心爱的对象体系模型。由于kobject映射到目录项，同时对象层次结构也已经在内存中形成了一棵树，因此sysfs的生成便水到渠成般的简单了。<br><img src="/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/2.jpeg" alt="img not found"><br>sysfs的根目录下至少包含了十个目录：block、bus、class、dev、devices、firmware、fs、kernel、module和power。</p>
<ol>
<li>block下每个子目录都对应着系统中已注册的块设备。反过来，每个目录下又都包含了该块设备的所有分区。</li>
<li>bus目录提供了一个系统总线试图。</li>
<li>class目录包含了以高层功能逻辑组织起来的系统设备视图。</li>
<li>dev目录是已注册的设备节点的视图。</li>
<li>devices目录是系统中的设备拓扑结构视图，它直接映射了内核中设备结构体的组织层次。</li>
<li>firmware目录包含了一些诸如ACPI、EDD、EFI等低层子系统的特殊树。</li>
<li>fs目录是已注册的文件系统的视图。</li>
<li>kernel目录包含内核配置项和状态信息。</li>
<li>module目录则包含系统已加载模块的信息。</li>
<li>power目录包含系统范围的电源去管理数据。<br>其中最重要的目录是devices，该目录将设备模型导出到用户空间。目录结构就是系统中的实际的设备拓扑。其他目录中的很多数据都是将devices目录下的数据加以转换加工得来的。比如，<code>/sys/class/net/</code>目录是以注册网络接口这一高层概念来组织设备关系的，在这个目录中可能会有目录<code>eth0</code>，它里面包含的devices文件其实就是一个指回到devices下实际设备目录的符号链接。<br>随便看看你可以访问到的任何Linux系统的sys目录，这种系统设备视图相当准确和漂亮，而且可以看到class中高层概念与devices中的低层物理设备，以及bus中的实际驱动程序之间互相联络是非常广泛的。当你认识到这种数据是开放的，换句话说，这种内核中维持系统的很好表示方式时，整个经历都是弥足珍贵的。</li>
</ol>
<h2 id="sysfs中添加和删除kobject"><a href="#sysfs中添加和删除kobject" class="headerlink" title="sysfs中添加和删除kobject"></a>sysfs中添加和删除kobject</h2><p>仅仅初始化kobject是不能将其导入到sysfs中去的，想要将kobject导入sysfs，你需要用到<code>kobject_add()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kobject_add(struct kobject *kobj,struct kobject *parent,const char *fmt,...);</span><br></pre></td></tr></table></figure>
<p>kobject在sysfs的位置取决于kobject在对象层次结构中的位置。如果kobject的父指针被设置，那么在sysfs中kobject将被映射为其父目录下的子目录；如果parent没有被设置，那么kobject将被映射为kset-&gt;kobj中的子目录。如果给定的kobject中parent或kset字段都没有被设置，那么就认为kobject没有父对象，所以就会被映射成sysfs下的根级目录。这往往不是你所需要的，所以在调用<code>kobject_add()</code>之前，parent或者kset应该被适当的设置。sysfs中代表kobject的目录名字是由fmt指定的，它也接受<code>printf()</code>样式的格式化字符串。<br>辅助函数<code>kobject_create_and_add()</code>把<code>koject_create()</code>和<code>kobject_add()</code>所做的工作放在一个函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_create_and_add(const char *name,struct kobject *parent);</span><br></pre></td></tr></table></figure>
<p>从sysfs中删除一个kobject对应文件目录，需要使用函数<code>kobject_del()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_del(struct kobject *kobj);</span><br></pre></td></tr></table></figure>
<p>上述函数都定义于文件<code>lib/kobject.c</code>中，声明位于头文件<code>&lt;linux/kobject.h&gt;</code>中。</p>
<h2 id="向sysfs中添加文件"><a href="#向sysfs中添加文件" class="headerlink" title="向sysfs中添加文件"></a>向sysfs中添加文件</h2><p>我们已经看到kobject被映射为文件目录了，而且所有的对象层次结构都优雅的，一个不少的映射成sys下的目录结构。但是里面的文件是什么，sysfs仅仅是一个漂亮的树，但是没有提供实际数据的文件。</p>
<h3 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h3><p>默认的文件集合是通过kobject和kset中的ktype提供的。因此所有具有相同类型的kobject在它们对应的sysfs目录下都拥有相同默认文件集合。kobject_type字段含有一个字段—default_attrs，它是一个attribute结构体数组。这些属性负责将内核数据映射成sysfs中的文件。<br>attribute结构体定义在文件<code>&lt;linux/sysfs.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">attribute 结构体 - 内核数据映射成sysfs中的文件</span><br><span class="line">*/</span><br><span class="line">struct attribute&#123;</span><br><span class="line">    const char      *name;      /*属性名称*/</span><br><span class="line">    struct module   *owner;     /*所属模块，如果存在*/</span><br><span class="line">    mode_t          mode;       /*权限*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中名称字段提供了该属性的名称，最终出现在sysfs中的文件名就是它。owner字段在存在所属模块的情况下指向其所属的module结构体。如果一个模块没有该属性，那么该字段为NULL。mode 字段类型为mode_t，它表示了sysfs中该文件的权限。对于只读属性而言，如果是所有人都可以读它，则该字段设置为S_IRUGO;如果只限于所有者可读，则该字段被设置为S_IRUSR。同样对于可写属性，可能会设置该字段为S_IRUGO | S_IWUSR。sysfs中的所有文件和目录的uid与gid标志均为0。<br>虽然default_attr列出了默认的属性，sysfs_ops字段则描述了如何使用他们。sysfs_ops字段指向了一个定义于文件<code>&lt;linux/sysfs.h&gt;</code>的同名的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sysfs_ops&#123;</span><br><span class="line">    /*在读sysfs时被调用*/</span><br><span class="line">    ssize_t (*show) (struct kobject *kobj,struct attribute *attr,char *buffer);</span><br><span class="line">    /*在写sysfs时被调用*/</span><br><span class="line">    ssize_t (*store) (struct kobject *kobj,struct attribute *attr,char *buffer,size_t size);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当从用户空间读取sysfs的项时调用<code>show()</code>方法。它会拷贝由attr提供的属性值到buffer指定的缓冲区中，缓冲区大小为PAGE_SIZE字节；<br><code>store()</code>方法在写操作时调用，它会从buffer中读取size大小的字节，并将其存放入attr表示的属性结构体变量中。</p>
<h3 id="创建新属性"><a href="#创建新属性" class="headerlink" title="创建新属性"></a>创建新属性</h3><p>内核为能在默认集合上，再添加新属性而提供了<code>sysfs_create_file()</code>接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sysfs_create_file(struct kobject *kobj,const struct attribute *attr);</span><br></pre></td></tr></table></figure>
<p>注意，kobject中的ktype所对应的sysfs_ops操作将负责处理新属性。现有的<code>show()</code>和<code>store()</code>方法必须能够处理新属性。<br>除了添加文件外，还有可能需要创建符号链接。再sysf中创建一个符号链接很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sysyfs_create_link(struct kobject *kobj,struct kobject *target,char *name);</span><br></pre></td></tr></table></figure>
<p>该函数创建的符号链接名由name决定，连接则由kobj对应的目录映射到target指定的目录。如果成功该函数返回零，如果失败返回负的错误码。</p>
<h3 id="删除新属性"><a href="#删除新属性" class="headerlink" title="删除新属性"></a>删除新属性</h3><p>删除一个属性需要通过函数<code>sysfs_remove_file()</code>完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sysfs_remove_file(struct kobject *kobj,const struct attribute *attr);</span><br></pre></td></tr></table></figure>
<p>一但调用返回，给定的属性将不再存在于给定的kobject目录中。另外由<code>sysfs_create_link()</code>创建的符号链接可通过函数<code>sysfs_remove_link()</code>删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sysfs_remove_link(struct kobject *kobj,char *name);</span><br></pre></td></tr></table></figure>
<p>调用一旦返回，在kobj对应目录中的名为name的符号链接将不复存在。<br>上述四个函数在文件<code>&lt;linux/kobject.h&gt;</code>中声明；<code>sysfs_create_file()</code>和<code>sysfs_remove_file()</code>定义于文件<code>fs/sysfs/file.c</code>。<code>sysyfs_create_link()</code>和<code>sysfs_remove_link()</code>定义于文件<code>fs/sysfs/symlink.c</code>中。</p>
<h2 id="内核事件层"><a href="#内核事件层" class="headerlink" title="内核事件层"></a>内核事件层</h2><p>内核事件层实现了内核到用户的消息通知系统，就是建立在上文一直讨论的kobject基础之上。在2.6.0版本之后，显而易见，系统确实需要一种机制来帮助事件传出内核输入到用户空间，特别是对于桌面系统来说吗，因为他需要更完整和异步的系统。为此就要让内核将其事件压倒堆栈：硬盘满了，CPU过热了，分区挂载了。<br>早期的事件层没有采用kobject和sysfs，他们如过眼云烟，没有存在多久。现在的事件层借助kobject和sysfs实现以证明相当理想。内核事件层把事件模拟册成信号—从明确的kobject对象发出，所以每个事件源都是一个sysfs路径。如果请求的事件与你的第一个硬盘相关，那么<code>sys/block/had</code>便是源树。实质上，在内核中我们认为事件都是从幕后的kobject对象产生的。<br>每个事件都被赋予了一个动词或者动作字符串表示信号。该字符串会以“被修改过”或者“未挂载”等词语来描述事件。<br>最后。每个事件都有一个可选的负载（payload）。相比传递任意一个标识负载的字符串到用户空间而言，内核事件层使用sysfs属性代表负载。<br>从内部实现来讲，内核事件由内核空间传递到用户空间需要经过netlink。netlink是一个用于传送网络信息的多点传送套接字。使用netlink就意味着从用户空间获取内核事件就如同在套接字上堵塞一样易如反掌。方法就是用户空间实现一个系统后台服务用于监听套接字，处理任何读到的信息，并将事件传送到系统栈里面。对于这种用户后台服务来说，一个潜在的目的就是将事件融入D-BUS系统。D-BUS系统已经实现了一套系统范围的消息总线，这种总线可帮助内核如同系统中其他组件一样地发出信号。<br>在内核代码中向用户空间发送信号使用函数<code>kobject_uevent()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kobject_uevent(struct kobject* kobj,enum kobject_action action);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定发送该信号的对象。实际的内核事件将包含该kobject映射到sysfs的路径。<br>第二个参数指定了该信号的“动作”或者“动词”。实际的内核事件将包含一个映射成枚举类型kobject_action的字符串。该函数不是直接提供一个字符串，而是利用一个枚举变量来提高可重用性和保证类型安全，而且也消除了打字错误或者其他错误。该枚举变量定义于文件<code>&lt;linux/kobject_uevent.c&gt;</code>中，其形式为kOBJ_foo。当前值包含kOBJ_MOUNT、kOBJ_UNMOUNT、kOBJ_ADD、kOBJ_REOMOVE、kOBJ_CHNAGE等。这些值分别映射为字符串“mount”、“unmount”、“add”、“remove”、“change”等。当现有的这些值不够用时，允许添加新动作。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中涉及到的内核功能有设备驱动的实现、设备树的管理、包括模块、kobject、kset、ktype和sysfs。这些功能对于设备驱动程序的开发者来说是至关重要的。因为它能让我们写出更加模块化、更为高级的驱动程序。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第17章 设备与模块</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>存储控制器</title>
    <url>/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第6章总结归纳<br>总线的使用是嵌入式底层开发的基础，了解它之后，再根据外设的具体特性，就可以驱动该外设了。</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440地址空间的布局</li>
<li>掌握如何通过总线形式访问扩展的外设，比如内存、NOR Flash、网卡等。</li>
</ol>
<h1 id="使用存储控制器访问外设的原理"><a href="#使用存储控制器访问外设的原理" class="headerlink" title="使用存储控制器访问外设的原理"></a>使用存储控制器访问外设的原理</h1><h2 id="S3C2410-x2F-S3C2440的地址空间"><a href="#S3C2410-x2F-S3C2440的地址空间" class="headerlink" title="S3C2410&#x2F;S3C2440的地址空间"></a>S3C2410&#x2F;S3C2440的地址空间</h2><p>S3C2410&#x2F;S3C2440的”存储控制器“提供了访问外部设备所需的信号，它有如下特性：</p>
<ol>
<li>支持小字节序、大字节序（通过软件选择）；</li>
<li>每个BANK的地址空间为128MB，共1GB（8BANKs）；</li>
<li>可编程控制的范围总线位宽（8&#x2F;16&#x2F;32bit），不过BANK0只能选择两种位宽（16&#x2F;32bit）；</li>
<li>总共8个BANK，BANK0-BANK5可以支持外接ROM、SRAM等。BANK6-BANK7除了可以支持ROM、SRAM外，还支持SDRAM等；</li>
<li>BANK0-BANK7共7个BANK的起始地址是固定的；</li>
<li>BANK7的起始地址可编程选择；</li>
<li>BANK6、BANK7的地址空间大小是可编程控制的；</li>
<li>每个BANK的访问周期均可编程控制；</li>
<li>可以通过外部的”wait“信号延长总线的访问周期；</li>
<li>在外接SDRAM时，支持自刷新（self-refresh）和省电模式（power down mode）<br>S3C2410&#x2F;S3C2440对外引出的27根地址线ADDR0-ADDR26的访问范围只有128MB，那么如何达到上面所说的1GB的访问空间呢？CPU对外引出了8根片选信号nGCS0-nGCS7，对应于BANK0-BANK7，当访问BANKx的地址空间时，nGCSx的引脚输出低电平，用来选中外接的设备。这样，每个nGCSx对应的128MB空间，8个nGCSx信号总共就对应了1GB的地址空间。这8个BANK的地址空间如图所示：<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"><br>如图所示，左边对应不使用NAND Flash作为启动设备（单板上不接NAND BOOT跳线）时的地址空间布局，右边对应使用NAND Flash作为启动设备（单板上接NAND BOOT跳线）时的地址空间布局。<br>S3C2410&#x2F;S3C2440作为32位的CPU，可以使用的地址范围理论上达到4GB。除去上述用于连接外设的1GB地址空间外，还有一部分是CPU内部寄存器的地址，剩下的地址空间没有使用。<br>S3C2410&#x2F;S3C2440的寄存器地址范围都处于0x4800000-0x5fffffff，各功能部件的寄存器大体相同。（”-表示相同。”无“表示不含该功能部件。）<table>
<thead>
<tr>
<th>功能部件</th>
<th>S3C2410起始地址</th>
<th>S3C2410结束地址</th>
<th>S3C2440起始地址</th>
<th>S3C2440结束地址</th>
</tr>
</thead>
<tbody><tr>
<td>存储控制器</td>
<td>0x48000000</td>
<td>0x48000030</td>
<td>0x48000000</td>
<td>0x48000030</td>
</tr>
<tr>
<td>USB Host控制器</td>
<td>0x49000000</td>
<td>0x49000058</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>中断控制器</td>
<td>0x4A000000</td>
<td>0x4A00001C</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>DMA</td>
<td>0x4B000000</td>
<td>0x4B0000E0</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>时钟和电源管理</td>
<td>0x4C000000</td>
<td>0x4C000014</td>
<td>-</td>
<td>0x4C000018</td>
</tr>
<tr>
<td>LCD控制器</td>
<td>0x4D000000</td>
<td>0x4D000060</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>NAND Flash控制器</td>
<td>0x4E000000</td>
<td>0x4E000014</td>
<td>-</td>
<td>0x4E00003C</td>
</tr>
<tr>
<td>摄像头接口</td>
<td>无</td>
<td>无</td>
<td>0x4F000000</td>
<td>0x4F0000A0</td>
</tr>
<tr>
<td>UART</td>
<td>0x50000000</td>
<td>0x50008028</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>脉宽调制计时器</td>
<td>0x51000000</td>
<td>0x51000040</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>USB设备</td>
<td>0x52000140</td>
<td>0x5200026F</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>看门狗计时器</td>
<td>0x53000000</td>
<td>0x53000008</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>IIC控制器</td>
<td>0x54000000</td>
<td>0x5400000C</td>
<td>-</td>
<td>0x54000010</td>
</tr>
<tr>
<td>IIS控制器</td>
<td>0x55000000</td>
<td>0x55000012</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>I&#x2F;O端口</td>
<td>0x56000000</td>
<td>0x560000B0</td>
<td>-</td>
<td>0x560000CC</td>
</tr>
<tr>
<td>RTC</td>
<td>0x57000000</td>
<td>0x5700008B</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>A&#x2F;D转换器</td>
<td>0x58000000</td>
<td>0x58000010</td>
<td>-</td>
<td>0x58000014</td>
</tr>
<tr>
<td>SPI</td>
<td>0x59000000</td>
<td>0x59000034</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>SD接口</td>
<td>0x5A000000</td>
<td>0x5A000040</td>
<td>-</td>
<td>0x5A000043</td>
</tr>
<tr>
<td>AC97音频编码接口</td>
<td>无</td>
<td>无</td>
<td>0x5B000000</td>
<td>0x5B00001C</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="存储控制器与外设的关系"><a href="#存储控制器与外设的关系" class="headerlink" title="存储控制器与外设的关系"></a>存储控制器与外设的关系</h2><p>本书所用的开发板使用了存储控制器的BANK0-BANK6，分别接如下设备：NOR Flash、IDE接口、10M网卡 CS8900A、100M网卡DM9000、扩展串口芯片16C2550、SDRAM。连线方式如下图所示：<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>根据图6.1可以知道各个BANK的起始地址，但是还需要结合图6.2中用到的地址线才能确定相关外设的访问地址。这些地址线所确定的地址值，再加上这个BANK的起始地址，就是这个外设的访问地址。<br>选择一个复杂的BANK—扩展串口作为例子。</p>
<ol>
<li>它使用nGCS5，起始地址作为0x28000000；</li>
<li>nCSA&#x3D;ADDR24 || nGCS5，nCSB&#x3D;!ADDR24 || nGCS5。当ADDR24和nGCS5均为低电平时选中扩展串口A；当ADDR24为高电平、nGCS5为低电平时选中扩展串口B。</li>
<li>CPU的ADDR0-ADDR2连接到扩展串口的A0-A2。所以访问空间有8字节。<br>综上所述，扩展串口A的访问空间为：0x28000000-0x28000007；扩展串口B的访问空间为：0x29000000-0x29000007。</li>
</ol>
<p>BANK0-BANK5的连接方式都是相似的，BANK6连接SDRAM时复杂一点，CPU提供了一组用于SDRAM的信号。</p>
<ol>
<li>SDRAM时钟有效信号SCKE；</li>
<li>SDRAM时钟信号SCLK0&#x2F;SCLK1；</li>
<li>数据掩码信号DQM0、DQM1、DQM2、DQM3；</li>
<li>SDRAM片选信号nSCS0（它与nGCS6是同一个引脚的两个功能）；</li>
<li>SDRAM行地址选通脉冲信号nSRAS；</li>
<li>SDRAM列地址选通脉冲信号nSCAS；</li>
<li>写允许信号mWE（它不是专用于SDRAM的）。<br>SDRAM的内部是一个存储阵列，阵列就如同表格一样，把数据填进去，和表格的检索原理一样，先指定一个行（Row），再指定一个列（Column），就可以找到所需的单元格，这就是SDRAM的寻址的基本原理。这个单元格称为存储单元，这个表格就是逻辑BANK（L-BANK），SDRAM一般含有4个L-BANK。<br>对SDRAM的访问可以分为如下4个步骤：</li>
<li>CPU发出片选信号，nSCS0有效，它选中SDRAM芯片。</li>
<li>SDRAM中有4个L-BANK,需要两个地址线来选择其中一个，从图6.2可知使用ADDR24、ADDR25作为L-BANK的选择信号。</li>
<li>对被选中的芯片进行统一的行&#x2F;列（存储单元）寻址。<br>根据SDRAM芯片的列地址线数目选择CPU的相关寄存器后，CPU就会从32位的地址中自动分出L-BANK选择信号，行地址信号，列地址信号，然后发出行地址信号、列地址信号。L-BANK选择信号在发出行地址信号的同时发出，并维持到列地址信号结束。<br>在图6.2中，行地址、列地址公用地址线ADDR2-ADDR14（BANK6位宽位32，ADDR0&#x2F;1没有使用），使用nSRAS、nSCAS两个信号来区分它们。比如本开发板中，使用两根地址线ADDR24、ADDR25作为L-BANK的选择信号；SDRAM芯片K4S561632的行地址数位13，列地址数为9，所以当nSRAS信号有效时，ADDR2-ADDR14上发出的是行地址信号，它对应32位地址空间的bit[23::11]；当nSCAs信号有效时，ADDR2-ADDR10上发出的是列地址信号，它对应32位地址空间的bit[10:2]；由于图6.2中BANK6以32位的宽度外接SDRAM，ADDR0、ADDR1恒为0，不参与译码。</li>
<li>找到存储单元后，被选中的芯片就要进行统一的数据传输了。<br>开发板中使用两片16位的SDRAM芯片并联组成32位的位宽，与CPU的32根数据线（DATA0-DATA31）相连。<br>BANK6的起始地址为0x30000000，所以SDRAM的访问地址为0x30000000-0x33ffffff，共64M。<br>对6.2图中连接的外设，它们的访问地址（物理地址）如下表所示：<table>
<thead>
<tr>
<th>BANKx</th>
<th>外设名称</th>
<th>起始地址</th>
<th>结束地址</th>
<th>大小（字节）</th>
<th>位宽</th>
</tr>
</thead>
<tbody><tr>
<td>BANK0</td>
<td>NOR Flash</td>
<td>0x00000000</td>
<td>0x001FFFFF</td>
<td>2M</td>
<td>16</td>
</tr>
<tr>
<td>BANK1</td>
<td>IDE 接口命令块寄存器</td>
<td>0x08000000</td>
<td>0x0800000F</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>BANK2</td>
<td>IDE 接口控制块寄存器</td>
<td>0x10000000</td>
<td>0x1000000F</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>BANK3</td>
<td>10M网卡CS8900A</td>
<td>0x19000000</td>
<td>0x190FFFFF</td>
<td>1M</td>
<td>16</td>
</tr>
<tr>
<td>BANK4</td>
<td>10&#x2F;100M网卡DM9000</td>
<td>只有两个地址 0x20000000 和 0x20000004</td>
<td></td>
<td>2M</td>
<td>16</td>
</tr>
<tr>
<td>BANK5</td>
<td>扩展串口A</td>
<td>0x28000000</td>
<td>0x28000007</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>BANK6</td>
<td>扩展串口B</td>
<td>0x29000000</td>
<td>0x29000007</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>BANK7</td>
<td>SDRAM</td>
<td>0x30000000</td>
<td>0x33FFFFFF</td>
<td>64M</td>
<td>32</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：10M网卡CS8900A使用nIOR、nIOW作为读&#x2F;写使能信号时，ADDR24必须为1。</p>
<h2 id="存储控制器的寄存器使用方法"><a href="#存储控制器的寄存器使用方法" class="headerlink" title="存储控制器的寄存器使用方法"></a>存储控制器的寄存器使用方法</h2><p>存储控制器共有13个寄存器，BANK0-BANK5只需要设置BWSCON和BANKCONx（x为0-5）两个寄存器，BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</p>
<ol>
<li>位宽和等待控制寄存器BWSCON（BUS WIDTH &amp; WAIT CONTROL REGISTER）<br>BWSCON中每4位控制一个BANK。最高4位对应BANK7、接下来4位对应BANK6、依此类推。<br>STx：启动&#x2F;禁止SDRAM的数据掩码引脚，对于SDRAM，此位为0；对于SRAM此位为1。<br>DWx：使用两位来设置相应BANK的位宽。0b00对应8位，0b01对应16位，0b10对应32位，0b11保留。<br>WSx：是否使用存储器的WAIT信号，通常设为0。<br>比较特殊的是BANK0，他没有ST0和WS0，DW0（[2:1]）只读，0b01表示16位，0b10表示32位，BANK0只支持16、32两种位宽。</li>
<li>BANK控制寄存器BANKCONx（BANK CONTROL REGISTER x为0-5）<br>这几个寄存器控制BANK0-BANK5外接设备的访问时序。</li>
<li>BANK控制寄存器BANKCONx（BANK CONTROL REGISTER x为6-7）<br>在8个BANK中，只有BANK6和BANK7可以外接SRAM或者SDRAM，所以BANKCON6-BANKCON7与BANKCON0-BANKCON5有点不同。<br>MT[16:15]：用于设置本BANK外接的是ROM&#x2F;SRAM还是SDRAM。SRAM-0b00，SDRAM-0b11。当MT&#x3D;0b00时，此寄存器与BANKCON0-BANKCON5类似，当MT&#x3D;0b11时，此寄存器其他值如下设置：<br>Trcd[3:2]：RAS to CAS delay，设为推荐值，0b01。<br>SCAN[1:0]：SDRAM的列地址位数，对于本开发板使用的SDRAM K4S561632，列地址位数为9，所以SCAN&#x3D;0b01。如果使用其他型号的SDRAM，需要查看其数据手册来决定SCAN的取值。0b00表示8位，0b01表示9位，0b10表示10位。</li>
<li>刷新控制寄存器REFRESH（REFRESH CONTROL RFEGISTER）：设为0x008C0000 + R_CNT<br>REFEN[23]：0&#x3D;禁止SDRAM的刷新功能，1&#x3D;开启SDRAM的刷新功能。<br>TREFMD[22]：SDRAM的刷新模式，0&#x3D;CBR&#x2F;ATUO Refresh，1&#x3D;Self Refresh（一般在系统休眠时使用）。<br>Trp[21:20]设为0即可。<br>Tsrc[19:18]：设为默认值0b11即可。<br>Refresh Counter[10:0]：即上述的R_CNT。可如下计算（SDRFAM的时钟频率就是HCLK）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R_CNT = 2^11 + 1 - SDRAM时钟频率(MHZ) + SDRAM刷新周期（uS）</span><br></pre></td></tr></table></figure>
SDRAM的刷新周期在SDRAM的数据手册上有标明，在本开发板上使用的SDRAM K4S561632的数据手册上，可以看见这么一行”64ms refresh period （8K Cycle）“。所以，刷新周期&#x3D;64ms&#x2F;8192 &#x3D; 7.8125 us。<br>在未使用PLL时，SDRAM的时钟频率等于晶振频率，12MHz。现在可以计算：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R_CNT = 2^11 + 1 - 12 * 7.8125 = 1955</span><br></pre></td></tr></table></figure>
所以在未使用PLL时，REFRESH &#x3D; 0x008C0000 + 1955 &#x3D; 0x008C07A3。</li>
<li>BANKSIZE寄存器REFRESH （BANKSIZE REGISTER）<br>BURST_EN[7]：0&#x3D; ARM核禁止突发传输，1&#x3D;ARM核支持突发传输。<br>SCKE_EN[5]：0&#x3D;不使用SCKE信号令SDRAM进入省电模式，1&#x3D;使用SCKE信号令SDRAM进入省电模式。<br>SCLK_EN[4]：0&#x3D;时刻发出SCLK信号，1&#x3D;仅在访问SDRAM期间发出SCLK信号（推荐）。<br>BK76MAP[2:0]：设置BANK6&#x2F;7的大小。<br>BANK6&#x2F;7对应的地址空间与BANK0-5不同，BANK0-5的地址空间大小都是固定的128MB，地址范围是（x * 128M）到（x + 1）* 128M-1，x表示0到5。BANK6&#x2F;7的大小是可变的，以保持这两个空间的地址连续，即BANK7的起始地址会随他们的大小而变化。  BK76MAP的取值意义如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0b010 = 128MB/128MB,0b001 = 64MB/64MB,0b000 = 32MB/32MB,</span><br><span class="line">0b111 = 16MB/16MB,0b110 = 8MB/8MB,0b101 = 4M/4M,0b100 = 2M/2M</span><br></pre></td></tr></table></figure>
本开发板BANK6外接64MB的SDRAM，令[2:0]&#x3D;0b001，表示BANK6&#x2F;7的容量都是64MB，虽然BANK7未使用。</li>
<li>SDRAM模式设置寄存器MRSRBx（SDRAM MODE REGISTER SET REGISTER，x为6-7）<br>能修改的只有为CL[6:4]，这是SDRAM时序的一个时间参数：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[work]0b000 = 1 clock,0b010  = 2 clocks,0b011 = 3 clocks</span><br></pre></td></tr></table></figure>
SDRAM K4S561632不支持CL&#x3D;1的情况，所以位[6:4]取值为0b010(CL &#x3D; 2)或0b011(CL &#x3D; 3)。</li>
</ol>
<h1 id="存储控制器操作实例：使用SDRAM"><a href="#存储控制器操作实例：使用SDRAM" class="headerlink" title="存储控制器操作实例：使用SDRAM"></a>存储控制器操作实例：使用SDRAM</h1><h2 id="代码详解及程序的复制、跳转过程"><a href="#代码详解及程序的复制、跳转过程" class="headerlink" title="代码详解及程序的复制、跳转过程"></a>代码详解及程序的复制、跳转过程</h2><p>从NAND Flash启动CPU时，CPU会通过内部的硬件将NAND Flash开始的4KB数据复制到称为”Steppingstone“的4KB的内部RAM中（起始地址为0），然后跳到地址0开始执行。<br>本实例先使用汇编语言设置好存储控制器，使外接的SDRAM可用：然后把程序本身从Steppingstone复制到SDRAM处，最后跳到SDRAM中执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:head.S</span></span><br><span class="line"><span class="comment">功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDARM执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">.equ    MEM_CTL_BASE,       <span class="number">0x48000000</span></span><br><span class="line">.equ    SDRAM_BASE,         <span class="number">0x30000000</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    bl  disable_watch_dog                       @关闭看门狗，否则CPU会一直重启</span><br><span class="line">    bl  memsetup                                @设置存储控制器</span><br><span class="line">    bl  copy_steppingstone_to_sdram             @复制代码到SDRAM中</span><br><span class="line">    ldr pc,=on_sdram                            @跳到SDRAM中执行</span><br><span class="line">on_sdram:</span><br><span class="line">    ldr sp,=<span class="number">0x34000000</span>                          @设置栈</span><br><span class="line">    bl  main</span><br><span class="line">    </span><br><span class="line">halt_loop:</span><br><span class="line">    b   halt_loop</span><br><span class="line"></span><br><span class="line">disable_watch_dog:</span><br><span class="line">    mov r1,#<span class="number">0x53000000</span>                          @看门狗寄存器</span><br><span class="line">    mov r2,#<span class="number">0x0</span>                                 @往里写<span class="number">0</span></span><br><span class="line">    str r2,[r1]</span><br><span class="line">    mov pc,lr                                   @返回</span><br><span class="line"></span><br><span class="line">copy_steppingstone_to_sdram:</span><br><span class="line">                                                @将Steppingstone的<span class="number">4</span>KB数据全部复制到SDRAM中去。</span><br><span class="line">                                                @Steppingstone起始地址为<span class="number">0x00000000</span>，SDRAM中起始地址为<span class="number">0x30000000</span></span><br><span class="line">    mov r1,#<span class="number">0</span>                                   </span><br><span class="line">    ldr r2,=SDARM_BASE</span><br><span class="line">    mov r3,#<span class="number">4</span>*<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    ldr r4,[r1],#<span class="number">4</span>                              @从Steppingstone读取<span class="number">4</span>字节的数据，并让源地址加<span class="number">4</span></span><br><span class="line">    str r4,[r2],#<span class="number">4</span>                              @将此<span class="number">4</span>字节的数据复制到SDRAM中，并让目的地址加<span class="number">4</span></span><br><span class="line">    cmp r1,r3                                   @判断是否完成：源地址等于Steppingstone的末地址</span><br><span class="line">    bne lb                                      @若没有复制完，继续</span><br><span class="line">    mov pc, lr                                  @返回</span><br><span class="line"></span><br><span class="line">memsetup:</span><br><span class="line">                                                @设置存储控制器以便使用SDRAM外设</span><br><span class="line">    mov r1,#MEM_CTL_BASE                        @存储控制器的<span class="number">13</span>个寄存器的开始地址</span><br><span class="line">    adrl    r2,mem_cfg_val                      @这<span class="number">13</span>个值的起始存储地址</span><br><span class="line">    add r3,r1,#<span class="number">52</span>                               @<span class="number">13</span>*<span class="number">4</span> = <span class="number">52</span></span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    ldr r4,[r2],#<span class="number">4</span>                              @读取设置值，并让r2加<span class="number">4</span></span><br><span class="line">    str r4,[r1],#<span class="number">4</span>                              @将此值写入寄存器，并让r1加<span class="number">4</span></span><br><span class="line">    cmp r1,r3                                   @判断是否设置完所有<span class="number">13</span>个寄存器</span><br><span class="line">    bne lb                                      @若没有完成，继续</span><br><span class="line">    mov pc,lr                                   @返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">mem_cfg_val:</span><br><span class="line">                                                @存储控制器<span class="number">13</span>个寄存器的设置值</span><br><span class="line">    .<span class="type">long</span> <span class="number">0x22011110</span>    </span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00018005</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00018005</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x008C07A3</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x000000B1</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000030</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000030</span></span><br></pre></td></tr></table></figure>
<p>12-18行是程序的主题，为了使得程序结构明了，主要使用了函数调用的方式。<br>第12行禁止看门狗，否则看门狗会不断重启系统，往看门狗寄存器（0x53000000）里写0即可禁止看门狗。<br>第13行设置存储控制器的13个寄存器，以便使用SDRAM。<br>第14行将Steppingstone中的代码复制到SDRAM中（起始地址为0x30000000）。<br>第15行向pc寄存器直接赋值跳到SDRAM中执行下一条指令”ldr sp，&#x3D;0x34000000“。、<br>第17行设置栈，调用c函数之前必须设置好栈。<br>第18行调用C函数main。<br>程序是如何从Steppingstone跳到SDRAM中去执行的呢？<br>这是通过第15行的”ldr pc,&#x3D;on_sdram“指令完成的。程序标号”on_stream“这个地址值在连接程序时被确定为0x30000010（这是SDRAM的地址），执行”ldr pc,&#x3D;on_sdram“后，程序一下子就跳到SDRAM中去了。<br>”on_sdram“这个地址值为什么等于0x30000010？<br>Makefile中连接程序的命令为”arm-linux-ld -Ttext 0x30000000 head.o sdram.o -o sdram_elf“，意思就是代码段的起始地址为0x30000000，即程序的第一条指令（第12行）的连接地址为0x30000000，第二条指令（第13行）的连接地址是0x30000004，…,第五条指令（第17行）的连接地址为0x300000010，其程序标号”on_sdram“的值即为0x300000010。<br>虽然第12-14行指令的连接地址都在SDRAM中，但是由于它们都是位置无关的相对跳转指令，所以可以在Steppingstone里执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o head.o head.S</span><br><span class="line">arm-linux-gcc -g -c -o leds.o leds.c</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 -g head.o leds.o -o sdram_elf</span><br><span class="line">arm-linux-objcopy -O binary -S sdram_elf sdram_elf.bin</span><br><span class="line">arm-linux-objdump -D -m arm sdram_elf &gt; sdram_elf.dis</span><br></pre></td></tr></table></figure>
<p>下图所示程序从Steppingstone 到SDRAM 的执行过程。<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/4.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/5.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/6.png" alt="img not found"></p>
<h2 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h2><p>生成的sdram.bin下载到板子上运行之后，可以发现与leds程序相比，LED灯闪烁的更慢，原因是外部的SDRAM的性能比内部SRAM差一些。<br>把程序从性能更好的内部SRAM移到外部SDRAM中去，是否多此一举？内部的SRAM只有4KB大小，如果程序大于4KB，那么就不指望完全利用内部SRAM来运行了，就得想办法把存储在NAND Flash中的代码复制到SDRAM中去。对于NAND Flash的前4KB，芯片自动把它复制到内部SRAM中，可以很轻松的再把它复制到SDRAM中（实验代码中的函数copy_steppingstone_to_sdram就有此功能），要复制4KB后面的代码需要使用NAND Flash控制器来读取NAND Flash。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第6章 存储控制器</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>NAND_Flash控制器</title>
    <url>/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第8章总结归纳</p>
<span id="more"></span>
<h1 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h1><ol>
<li>了解NAND Flash芯片的接口</li>
<li>掌握通过NAND Flash控制器访问NAND Flash的方法</li>
</ol>
<h1 id="NAND-Flash介绍和NAND-Flash控制器使用"><a href="#NAND-Flash介绍和NAND-Flash控制器使用" class="headerlink" title="NAND Flash介绍和NAND Flash控制器使用"></a>NAND Flash介绍和NAND Flash控制器使用</h1><p>NAND Flash在嵌入式系统中地位与PC中的硬盘类似，用于保存系统运行所必须的操作系统、应用程序、用户数据、运行过程中产生的各类数据。与内存掉电后数据丢失不同，NAND Flash中的数据在掉电后仍可永久保存。</p>
<h2 id="Flash介绍"><a href="#Flash介绍" class="headerlink" title="Flash介绍"></a>Flash介绍</h2><p>常用的Flash类型有NOR Flash和NAND Flash两种。NOR Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和EEPROM。NAND Flash由Toshiba公司在1989年发明。两者主要差别如下表所示：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>NOR</th>
<th>NAND</th>
</tr>
</thead>
<tbody><tr>
<td>容量</td>
<td>1MB-32MB</td>
<td>16MB-512MB</td>
</tr>
<tr>
<td>XIP</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>擦除性能</td>
<td>非常慢（5S）</td>
<td>（快）3ms</td>
</tr>
<tr>
<td>写性能</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>读性能</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>可靠性</td>
<td>比较高，位反转的比例小于NAND Flash的10%</td>
<td>比较低，位反转比较常见，必须有校验措施。比如TNR必须有坏块管理措施</td>
</tr>
<tr>
<td>可擦除次数</td>
<td>10000-100000</td>
<td>100000-1000000</td>
</tr>
<tr>
<td>生命周期</td>
<td>低于NAND Flash的10%</td>
<td>是NOR Flash的10倍以上</td>
</tr>
<tr>
<td>接口</td>
<td>与RAM接口相同</td>
<td>I&#x2F;O接口</td>
</tr>
<tr>
<td>访问方法</td>
<td>随机访问</td>
<td>顺序访问</td>
</tr>
<tr>
<td>易用性</td>
<td>容易</td>
<td>复杂</td>
</tr>
<tr>
<td>主要用途</td>
<td>用于保存代码和关键数据</td>
<td>用于保存数据</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<p>NOR Flash支持XIP，即代码可以直接在NOR上运行，无须复制到内存中。这是由于NOR的接口与RAM完全相同，可以随机访问任意地址的数据。在NOR上进行读数据的效率非常高，但是擦除和写的效率很低。而且NOR的容量一般比较小。NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，NOR Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配NOR以存储程序。<br>Flash存储器件由擦除单元（块）组成，当要写某个块时，需要确保这个块已经被擦除。NOR Flash的块大小范围为64KB-128KB；NAND Flash的块大小为8KB-64KB。擦&#x2F;写一个NOR Flash块需要4S，而擦&#x2F;写一个NAND Flash块仅需2ms。NOR Flash的块太大，不仅增加了擦写时间，对于给定的操作，NOR Flash也需要更多的擦除操作–特别是小文件。比如一个文件只有1KB，但是为了保存它却需要擦除大小为64KB-128KB的NOR Flash块。<br>NOR Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的接口仅仅包含几个I&#x2F;O引脚，需要串行访问。NAND Flash一般以512字节为单位进行读写。这使得NOR Flash更适合运行程序，NAND Flash更适合存储数据。<br>容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上NOR Flash的容量通常为1MB-4MB(也有32MB的NOR Flash)。NAND Flash的容量为8MB-512MB。容量的差别也使得NOR Flash多用于存储程序，NAND Flash多用于存储数据。<br>基于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转问题：由于Flash固有的电气特性，在读写数据的过程中，偶尔会产生一位或几位数据错误，而NAND Flash出现的概率远大于NOR Flash。当位反转发生在关键的代码、数据时，有可能导致系统崩溃。当仅仅是报告位反转，重新读取即可；如果确实发生了位反转，则必须有相应的错误检测&#x2F;恢复措施。在NAND Flash上发生位反转的概率更高，推荐使用EDC&#x2F;ECC进行错误检测和恢复。NAND Flash上面会有坏块随机分布，在使用前需要将坏块扫描出来，确保不在使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右。是NOR Flash的10倍。另外，因为NAND Flash的块大小通常是NOR Flash的1&#x2F;8，所以NAND Flash的寿命远远超过NOR Flash。<br>嵌入式Linux对NOR、NAND Flash的软件支持都很成熟。在NOR Flash上常用jffs2文件系统，而在NAND Flash常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操作，它也实现了EDC&#x2F;ECC校验。</p>
<h2 id="NAND-Flash的物理结构"><a href="#NAND-Flash的物理结构" class="headerlink" title="NAND Flash的物理结构"></a>NAND Flash的物理结构</h2><p>以NAND Flash K9F1208U0M为例，K9F1208U0M是Samsung公司生产的容量为64MB的NAND Flash，常用于手持设备等消费电子产品。它的封装下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"></p>
<p>外部引脚如下表所示：</p>
<table>
<thead>
<tr>
<th>引脚名称</th>
<th>引脚功能</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O0-I&#x2F;O7</td>
<td>数据输入&#x2F;输出</td>
</tr>
<tr>
<td>CLE</td>
<td>命令锁存使能</td>
</tr>
<tr>
<td>ALE</td>
<td>地址锁存使能</td>
</tr>
<tr>
<td>CE</td>
<td>芯片使能</td>
</tr>
<tr>
<td>RE</td>
<td>读使能</td>
</tr>
<tr>
<td>WE</td>
<td>写使能</td>
</tr>
<tr>
<td>WP</td>
<td>写保护</td>
</tr>
<tr>
<td>R&#x2F;B</td>
<td>就绪&#x2F;忙输出信号</td>
</tr>
<tr>
<td>Vcc</td>
<td>电源</td>
</tr>
<tr>
<td>Vss</td>
<td>地</td>
</tr>
<tr>
<td>N.C</td>
<td>不接</td>
</tr>
</tbody></table>
<p>K9F1208U0M的功能结构图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>K9F1208U0M的内部结构包含10个功能部件：</p>
<ol>
<li>X-Buffers Latche &amp; Decoders：用于行地址。</li>
<li>Y-Buffers Latche &amp; Decoders：用于列地址。</li>
<li>Command Register：用于命令字。</li>
<li>Control Logic &amp; High Voltage Generator：控制逻辑及产生Flash所需高压。</li>
<li>Nand Flash Array：存储部件。</li>
<li>Page Register &amp; S&#x2F;A：页寄存器，当读、写某页时，会将数据先读入&#x2F;写入此寄存器，大小为528字节。</li>
<li>Y-Gating。</li>
<li>I&#x2F;O Buffers &amp; Latches。</li>
<li>Global Buffers。</li>
<li>Output Drivers。</li>
</ol>
<p>Nand Flash 存储单元组织结构如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/3.jpeg" alt="img not found"><br>K9F1208U0M容量为528Mbit，分为131072行（页）、528列。每一页大小为512字节，外加16字节的额外空间，这16字节额外空间的列地址为512-527。<br>命令、地址、数据都通过8个I&#x2F;O口输入&#x2F;输出，这种形式减少了芯片的引脚个数，并使得系统很容易升级到更大的容量。写入命令、地址或数据时，都需要将WE、CE信号同时拉低。<br>数据在WE信号的上升沿被NAND Flash锁存。命令锁存信号CLE、地址锁存信号ALE用来分辨、锁存命令或地址。K9F1208U0M的64MB存储空间需要26位地址，因此以字节为单位访问Flash时需要4个地址序列：列地址、行地址的低位部分，行地址的高位部分。读&#x2F;写页发出命令之后，需要4个地址序列，而擦除块在发出擦除命令后仅需要3个地址序列。</p>
<h2 id="Nand-Flash的访问方法"><a href="#Nand-Flash的访问方法" class="headerlink" title="Nand Flash的访问方法"></a>Nand Flash的访问方法</h2><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p>NAND Flash和S3C2410&#x2F;S3C2440的硬件连接图如下所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/4.jpeg" alt="img not found"><br>NAND Flash和S3C2410&#x2F;S3C2440的连线较少：8个I&#x2F;O引脚（I&#x2F;O0-I&#x2F;O7），5个使能信号（nWE、ALE、CLE、nCE、nRE）、1个状态引脚（RDY&#x2F;B）、1个写保护引脚（nWP）。地址、数据、命令都是在这些使能信号的配合下，通过8个I&#x2F;O引脚的传输。写地址、数据、命令时，nCE、nWE信号必须为低电平，它们在nWE信号的上升沿被锁存。命令锁存使能信号CLE和地址锁存信号ALE用来区分I&#x2F;O引脚上传输的是命令还是地址。</p>
<h3 id="命令字及操作方法"><a href="#命令字及操作方法" class="headerlink" title="命令字及操作方法"></a>命令字及操作方法</h3><p>操作NAND Flash时，先传输命令，然后传输地址，最后读写数据。期间要检查Flash的状态。对于K9F1208U0M，它的容量是64MB，需要一个26位的地址。发出命令后，后面要紧跟着4个地址序列。比如读Flash时，发出读命令和4个地址序列后，后续的读操作就可以得到这个地址及器后续地址的数据。相应的命令字和地址序列如下表所示：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>第1个访问周期</th>
<th>第2个访问周期</th>
<th>第3个访问周期</th>
</tr>
</thead>
<tbody><tr>
<td>Read1（读）</td>
<td>00h&#x2F;01h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read2（读）</td>
<td>50h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read ID（读芯片ID）</td>
<td>90h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Page Program（写页）</td>
<td>80h</td>
<td>10h</td>
<td>-</td>
</tr>
<tr>
<td>Block Erase（擦除块）</td>
<td>60h</td>
<td>D0h</td>
<td>-</td>
</tr>
<tr>
<td>Read Status（读状态）</td>
<td>70h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read Multi-Plane Status（读多层的状态）</td>
<td>71h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Reset（复位）</td>
<td>FFh</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Page Program（Dummy）</td>
<td>80h</td>
<td>11h</td>
<td>-</td>
</tr>
<tr>
<td>Copy-Back Program（True）</td>
<td>00h</td>
<td>8Ah</td>
<td>10H</td>
</tr>
<tr>
<td>Copy-Back Program（Dummy）</td>
<td>03h</td>
<td>8Ah</td>
<td>11H</td>
</tr>
<tr>
<td>Multi-Plane Block Erase</td>
<td>60h-60h</td>
<td>D0h</td>
<td>-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>&#x2F;</th>
<th>I&#x2F;O0</th>
<th>I&#x2F;O1</th>
<th>I&#x2F;O2</th>
<th>I&#x2F;O3</th>
<th>I&#x2F;O4</th>
<th>I&#x2F;O5</th>
<th>I&#x2F;O6</th>
<th>I&#x2F;O7</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>第1个地址序列</td>
<td>A0</td>
<td>A1</td>
<td>A2</td>
<td>A3</td>
<td>A4</td>
<td>A5</td>
<td>A6</td>
<td>A7</td>
<td>列地址</td>
</tr>
<tr>
<td>第2个地址序列</td>
<td>A9</td>
<td>A10</td>
<td>A11</td>
<td>A12</td>
<td>A13</td>
<td>A14</td>
<td>A15</td>
<td>A16</td>
<td>行地址（页地址）</td>
</tr>
<tr>
<td>第3个地址序列</td>
<td>A17</td>
<td>A18</td>
<td>A19</td>
<td>A20</td>
<td>A21</td>
<td>A22</td>
<td>A23</td>
<td>A24</td>
<td>行地址（页地址）</td>
</tr>
<tr>
<td>第4个地址序列</td>
<td>A25</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>行地址（页地址）</td>
</tr>
</tbody></table>
<p>注：<br>①K9F1208U0M一页大小为512字节，分两部分：上半部、下半部。<br>②列地址用来在半页（256字节）中寻址。<br>③当发出读命令00h时，表示列地址将在上半部寻址。当发出写命令01h时，表示列地址将在下半部寻址。<br>④A8被读命令00h设为低电平，被01h设为高电平。<br>⑤L表示低电平。</p>
<p>K9F1208U0M一页大小为508字节，而列地址A0-A7可以寻址的范围是256字节，所以必须辅以其他手段才能完全寻址着528字节。将一页分为A、B、C三个区：A区为0-255字节，B区为256-511字节，C区为512-527字节。访问某页时，需要选定特定的区，这称为“使地址指针指向特定的区”。这通过3个命令来实现：命令00h让地址指针指向A区、命令01h让地址指针指向B区、命令50h让地址指针指向C区。命令00h和命令50h会使得访问Flash的地址指针一直从A区或C区开始，除非发出了其他的修改地址指针的命令。命令01h的效果只能维持一次，当前的读、写、擦除、复位或者上电操作完成后，地址指针重新指向A区。写A区或C区的数据时，必须在发出命令80h之前发出命令00h或50h；写B区的数据时，发出命令01h后必须紧接着发出命令80h。下图形象的描述了这个过程：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/5.jpeg" alt="img not found"></p>
<ol>
<li>Read 1：命令字为00h或01h<br>在发出命令00h或者01h后，就选定了读操作是从A区还是B区开始。列地址A0-A7可以寻址的范围是256字节，命令00h和01h使得可以在512字节大小的页内任意寻址–这相当于A8被命令00h设为0，而命令01h设为1。<br>发出命令字后，随后发出4个地址序列，然后就可以检测R&#x2F;nB引脚以确定Flash是否准备好。如果准备好了，就可以发起读操作一次读出数据。</li>
<li>Read 2：命令字为50h<br>与Read 1类似，不过读取的是C区数据，操作序列为：发出命令字50h、发出4个地址序列、等待R&#x2F;nB引脚为高，最后读取数据。不同的是，地址序列中A0-A3用于设定C区（16字节）要读取的起始地址，A4-A7被忽略。</li>
<li>Read ID：命令字90h。<br>发出命令字90h，发出4个地址序列（都设为0），然后就可以连续读入5个数据，分别表示：厂商代码（Samsung格式为Ech）、设备代码（K9F1208U0M为76h）、保留的字节（K9F1208U0M为A5h）、多层操作代码（C0h表示支持多层操作）。</li>
<li>Reset：命令字为FFh<br>发出命令字FFh即可复位NAND Flash芯片。如果芯片正处于读、写、擦除状态，复位命令会终止这些命令。</li>
<li>Page Program（True）：命令字分两阶段，80h和10h<br>它的操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/6.jpeg" alt="img not found"><br>NAND Flash的写操作一般是以页为单位的，但是可以只写一页中的一部分。发出命令字80h后，紧接着的是4个地址序列，然后向Flash发送数据（最大可达528字节），然后发送命令字10h启动写操作，此时Flash内部会自动完成写、校验操作。一旦发出命令字10h后，就可以通过读状态命令70h获知当前写操作是否完成、是否成功。</li>
<li>Page Program（Dummy）：命令字分为两阶段，80h和11h。<br>NAND Flash K9F1208U0M分为4个128Mbit的存储层（plane），每个存储层包含1024个block和528字节的寄存器。这使得可以同时写多个页（page）或者同时擦除多个块（block）。块的地址经过精心安排，可以在4个连续的块内同时进行写或者擦除操作。下图为K9F1208U0M的块组织图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/7.jpeg" alt="img not found"><br>命令Page Program（Dummy）正是在这种结构下对命令Page Program（True）的扩展，后者仅能对一页进行写操作，前者可以同时写4页。操作序列如下图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/8.jpeg" alt="img not found"><br>发出命令字80h、4个地址序列及最多528字节的数据之后，发出命令字11h（11h称为“Dummy Page Program command”，相对的，10h称为“True Page Program Command”）；接着对相邻层（plane）上的页进行同样的操作。仅在第4页的最后使用10h替代11h，这样即可启动Flash内部的写操作。此时可以通过命令71h获知这些写操作是否完成、是否成功。</li>
<li>Copy-Back Program（True）：命令字分3阶段，00h、08h、10h。<br>此命令用于将一页复制到同一层（plane）内的另一页，它省略了读出源数据、将数据重新载入Flash，这使得效率大卫提高。此命令有两个限制：源页、目的页必须在同一层（plane）中，并且将源地址、目的地址的A14、A15必须相同。<br>操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/9.jpeg" alt="img not found"><br>首先发出命令Read 1（00h）、4个源地址序列，此时源页的528字节数据很快就被全部读入内部寄存器中；接着发出命令字8Ah（Page-Copy Data-input command）,随之发出4个目的地址序列；最后发出命令字10h启动对目的页的写操作。此后可以使用命令70h来查看此操作是否完成、是否成功。</li>
<li>Copy-Back Program（Dummy）：命令字分3个阶段，03h、8Ah、11h。<br>与命令Page Program（Dummy）类似，Copy-Back Program（Dummy）可以同时启动对多达4个连续plane内的Copy-Back Program操作。操作序列如下所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpeg" alt="img not found"><br>从图中可得知，首先发出命令字00h、源页地址，这使得源页的528字节数据被读入所在plane的寄存器；对于随后的其他plane的源页，发出命令字03h和相应的源页地址将数据读入该plane的寄存器；按照前述说明读出最多4页的数据到寄存器后，发出命令字8Ah、目的地址、命令字11h，在发出最后一页地址后，用10h代替11h启动写操作。</li>
<li>Block Erase：命令字分3阶段，60h、D0h。<br>此命令用于擦除NAND Flash块（block，大小为16KB）。发出命令字后，发出block地址—仅需要3个地址序列，并且A9-A13被忽略，操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/11.jpeg" alt="img not found"></li>
<li>Multi-Plane Block Erase：60h—-60h D0h。<br>此命令用于擦除不同的plane中的块，发出命令字60h后，紧接着发出block地址序列，如此最多可以发出4个block地址，最后发出命令字D0h启动擦除操作。操作序列如图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/12.jpeg" alt="img not found"></li>
<li>读状态命令字有如下两种：<br>①Read Status：命令字为70h。<br>②Read Multi-Plane Status：命令字为71h。<br>Falsh中有状态寄存器，发出命令字70h或71h后，启动读操作即可读入此寄存器。状态寄存器中各位的含义如下表所示：<table>
<thead>
<tr>
<th>I&#x2F;O引脚</th>
<th>所标识的状态</th>
<th>命令70h对应的定义</th>
<th>命令71h对应的定义</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O0</td>
<td>总标记：成功&#x2F;失败</td>
<td>成功：0 失败：1</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O1</td>
<td>Plane0的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O2</td>
<td>Plane1的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O3</td>
<td>Plane2的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O4</td>
<td>Plane3的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O5</td>
<td>保留</td>
<td>忽略</td>
<td>忽略</td>
</tr>
<tr>
<td>I&#x2F;O6</td>
<td>设备状态</td>
<td>忙：0 就绪：1</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O7</td>
<td>写保护状态</td>
<td>保护：0 没有保护：1</td>
<td>保护：0 没有保护：1</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：<br>①I&#x2F;O0是所有Plane的“总标记”，只要有一个Plane的操作是失败的，I&#x2F;O0就会被设为“失败”。<br>②I&#x2F;O0-I&#x2F;O4引脚只部件它对应的Plane。</p>
<h2 id="S3C2410-x2F-S3C2440-NAND-Flash控制器介绍"><a href="#S3C2410-x2F-S3C2440-NAND-Flash控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 NAND Flash控制器介绍"></a>S3C2410&#x2F;S3C2440 NAND Flash控制器介绍</h2><p>NAND Flash控制器提供几个寄存器来简化对NAND Flash的操作。比如要发出读命令时，只需要往NFCMD寄存器中写入0即可，NAND Flash控制器会自动发出各种控制信号。</p>
<h3 id="操作方法概述"><a href="#操作方法概述" class="headerlink" title="操作方法概述"></a>操作方法概述</h3><p>访问NAND Flash时需要先发出命令，然后发出地址序列，最后读写数据。需要使用各个使能信号来分辨是命令、地址还是数据。S3C2410的NAND Flash控制器提供了NFCONF、NFCMD、NFADDR、NFDATA、NFSTAT和NFECC等6个寄存器来简化这些操作。S3C2440的NAND Flash控制器则提供了NFCONF、NFCONT、NFCMMD、NFADDR、NFDATA、NFSTAT和其他与ECC有关的寄存器。对NAND Flash控制器的操作，S3C2410与S3C2440有一点小差别，有的寄存器地址不一样，有的寄存器内容不一样。<br>NAND Flash的读写操作次序如下：</p>
<ol>
<li>设置NFCONF（对于S3C2440，还要设置NFCONT）寄存器，配置NAND Flash。</li>
<li>向NFCMD寄存器写入命令。</li>
<li>向NFADDR写入地址。</li>
<li>读&#x2F;写数据，通过寄存器NFSTAT检测NAND Flash的状态，在启动某个操作之后，应该检测R&#x2F;nB信号以确定该操作是否完成、是否成功。</li>
</ol>
<h3 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h3><ol>
<li>NFCONF：NAND Flash配置寄存器<br>这个寄存器在S3C2410、S3C2440上功能有所不同。<br>S3C2410上的NFCONF寄存器，被用来使能&#x2F;禁止NAND Flash控制器，使能&#x2F;禁止控制引脚信号nFCE、初始化ECC、设置NAND Flash的时序参数等。TACLS、TWRPH0和TWRPH1这3个参数控制的是NAND Flash信号线CLE&#x2F;ALE与写控制信号nWE的时序关系。<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/13.jpeg" alt="img not found"><br>S3C2440的NFCONF寄存器，被用来设置NAND Flash的时序参数TACLS、TWRPH0、TWRPH1，设置数据位宽；还有一些只读位，用来指示是否支持其他大小的页（256&#x2F;512&#x2F;1024&#x2F;2048字节）。<br>它没有实现S3C2410的NFCONF寄存器的控制功能，这些功能在S3C2440的NFCONT寄存器里实现。</li>
<li>NFCONT：NAND Flash控制寄存器，S3C2410没有这个寄存器。<br>被用来使能&#x2F;禁止NAND Flash控制器、使能&#x2F;禁止控制引脚信号nFCE、初始化ECC。它还有其他功能，在一般的应用中用不到，比如锁定NAND Flash。</li>
<li>NFCMD：NAND Flash命令寄存器<br>对于不同型号的Flash，操作命令一般不一样。</li>
<li>NFADDR：NAND Flash地址寄存器。<br>当写这个寄存器时，它将对Flash发出地址信号。</li>
<li>NFDATA：NAND Flash数据寄存器。<br>只用到低8位，读写此寄存器将启动对NAND Flash的读数据、写数据操作。</li>
<li>NFSTAT：NAND Flash状态寄存器<br>只用到位0。0：busy，1：ready。</li>
</ol>
<h1 id="NAND-Flash控制器操作实例：读Flash"><a href="#NAND-Flash控制器操作实例：读Flash" class="headerlink" title="NAND Flash控制器操作实例：读Flash"></a>NAND Flash控制器操作实例：读Flash</h1><p>本实例讲述如何读取NAND Flash，擦除、写Flash的操作与读Flash类似，读者可以自行编写程序程序。</p>
<h2 id="读NAND-Flash的步骤"><a href="#读NAND-Flash的步骤" class="headerlink" title="读NAND Flash的步骤"></a>读NAND Flash的步骤</h2><p>下面讲述如何从NAND Flash中读出数据，假设读地址为addr。</p>
<h3 id="1-设置NFCONF（对于S3C2440，还要设置NFCONT）"><a href="#1-设置NFCONF（对于S3C2440，还要设置NFCONT）" class="headerlink" title="1.设置NFCONF（对于S3C2440，还要设置NFCONT）"></a>1.设置NFCONF（对于S3C2440，还要设置NFCONT）</h3><ol>
<li><p>对于S3C2410<br>实例中此寄存器设为0x9830—使能NAND Flash控制器、初始化ECC、NAND Flash片选信号nFCE&#x3D;1（inactive，真正使用时再让它等于0），设置TACLS&#x3D;0，TWRPH0&#x3D;3，TWRPH1&#x3D;0。这些时序参数的含义为：TACLS&#x3D;1个HCLK时钟，TWRPH0&#x3D;4个HCLK时钟，TWRPH1&#x3D;1个HCLK时钟。<br>K9F1208U0M的时间特性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLE setup Time = 0 ns,CLE Hold Time = 10 ns,</span><br><span class="line">ALE setup Time = 0 ns,ALE Hold Time = 10 ns,</span><br><span class="line">WE Pulse Width 25 ns</span><br></pre></td></tr></table></figure>
<p>参考上图：即使在HCLK&#x3D;100MHZ的情况下，TACLS+TWRPH0+TWRPH1&#x3D;6&#x2F;100μs&#x3D;60ns，也是可以满足NAND Flash K9F1208U0M的时序要求的。</p>
</li>
<li><p>对于S3C2440<br>时间参数也设为：TACLS&#x3D;0，TWRPH0&#x3D;3，TWRPH1&#x3D;0。NFCONF寄存器的值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF = 0x300</span><br></pre></td></tr></table></figure>
<p>NFCONT寄存器的取指如下，表示使能NAND Flash控制器、禁止控制引脚信号nFCE、初始化ECC。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT = (1&lt;&lt;4) | (1&lt;&lt;1) | (1&lt;&lt;0)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-在第一次操作NAND-Flash前，通常复位一下NAND-Flash"><a href="#2-在第一次操作NAND-Flash前，通常复位一下NAND-Flash" class="headerlink" title="2.在第一次操作NAND Flash前，通常复位一下NAND Flash"></a>2.在第一次操作NAND Flash前，通常复位一下NAND Flash</h3><ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF &amp;= ~(1&lt;&lt;11)  (发出片选信号)</span><br><span class="line">NFCMD   = 0xff      (reset命令)</span><br></pre></td></tr></table></figure>
然后循环查询NFSTAT位0，直到它等于1。<br>最后禁止片选信号，在实际使用NAND Flash时再使能。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF  |=  (1&lt;&lt;11) (禁止NAND Flash)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  &amp;=  ~(1&lt;&lt;11)    (发出片选信号)</span><br><span class="line">NFCMD    =  0xff        (reset命令)</span><br></pre></td></tr></table></figure>
然后循环查询NFSTAT位0，知道它等于1。<br>最后禁止片选信号，在实际使用NAND Flash时再使能。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  |=  0x2         (禁止NAND Flash)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-发出读命令"><a href="#3-发出读命令" class="headerlink" title="3.发出读命令"></a>3.发出读命令</h3><p>先使能NAND Flash，然后发出读命令。</p>
<ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF &amp;=   ~(1&lt;&lt;11)        (发出片选信号)</span><br><span class="line">NFCMD   =   0               (读命令)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  &amp;=  ~(1&lt;&lt;11)        (发出片选信号)</span><br><span class="line">NFCND    =  0               (读命令)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-发出地址信号"><a href="#4-发出地址信号" class="headerlink" title="4.发出地址信号"></a>4.发出地址信号</h3><p>这步请注意，表8.3列出了在地址操作的4个步骤对应的地址线，没用到A8（它由读命令设置，当读命令为0时，A8&#x3D;0；当读命令为1时，A8&#x3D;1），如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFADDR  = addr &amp; 0xff</span><br><span class="line">NFADDR  = (addr &gt;&gt; 9)   &amp;   0xff    (左移9位，不是8位)</span><br><span class="line">NFADDR  = (addr &gt;&gt; 17)  &amp;   0xff    (左移17位，不是16位)</span><br><span class="line">NFADDR  = (addr &gt;&gt; 25)  &amp;   0xff    (左移25位，不是24位)</span><br></pre></td></tr></table></figure>
<h3 id="5-循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了"><a href="#5-循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了" class="headerlink" title="5.循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了"></a>5.循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了</h3><h3 id="6-连续读取NFDATA寄存器512次，得到一页数据（512字节）"><a href="#6-连续读取NFDATA寄存器512次，得到一页数据（512字节）" class="headerlink" title="6.连续读取NFDATA寄存器512次，得到一页数据（512字节）"></a>6.连续读取NFDATA寄存器512次，得到一页数据（512字节）</h3><p>循环执行第3、4、5、6这四个步骤，直到读出所要求的所有数据。</p>
<h3 id="7-最后禁止NAND-Flash的片选信号"><a href="#7-最后禁止NAND-Flash的片选信号" class="headerlink" title="7.最后禁止NAND Flash的片选信号"></a>7.最后禁止NAND Flash的片选信号</h3><ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF |= (1&lt;&lt;11)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  |=  (1&lt;&lt;1)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>源文件为head.S、init.c和main.c。本实例的目的是把一部分代码存放在NAND Flash地址4096后，当程序启动NAND Flash控制器将它们读出来、执行。以前的代码都小于4096字节，开发板启动后它们被自动复制进“Steppingstone”中。<br>连接脚本nand.lds把它们分为两部分，nand.lds代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    first   0x00000000  ：&#123;head.o init.o nand.o&#125;</span><br><span class="line">    second  0x30000000  :   AT(4096)    &#123;main.o&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2行表示head.o、init.o、nand.o这3个文件的运行地址为0，它们在生成的映像文件中的偏移地址也为0（从0开始存放）。<br>第3行表示main.o的运行地址为0x30000000，它在生成的映像文件中的偏移地址为4096。<br>head.S调用init.c中的函数来关WATCH DOG、初始化SDRAM；调用nand.c中的函数来初始化NAND Flash，然后将main.c中的代码从NAND Flash地址4096开始处复制到SDRAM中；最后跳到main.c中的main函数继续执行。<br>由于S3C2410、S3C2440的NAND Flash控制器并非完全一样，这个程序要既能处理S3C2410，也能处理S3C2440，首先需要分辨是S3C2410还是S3C2440，然后使用不同的函数进行处理。读取GSTATUS1寄存器，如果它的值为0x32410000或0x32410002，就表示处理器是S3C2410，否则就是S3C2440。<br>nand.c向外引出两个函数：用来初始化NAND Flash的nand_init函数，用来将数据从NAND Flash读到SDRAM的nand_read函数。</p>
<h3 id="nand-init-函数分析"><a href="#nand-init-函数分析" class="headerlink" title="nand_init 函数分析"></a>nand_init 函数分析</h3><p>代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化NAND Flash</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH0  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH1  0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*判断是S3C2410还是S3C2440*/</span></span><br><span class="line">    <span class="keyword">if</span>((GSTATUS1 == <span class="number">0x32410000</span>) || (GSTATAUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        nand_chip.nand_reset            =   s3c2410_nand_reset;</span><br><span class="line">        nand_chip.wait_idle             =   s3c2410_wait_idle;</span><br><span class="line">        nand_chip.nand_select_chip      =   s3c2410_nand_select_chip;</span><br><span class="line">        nand_chip.nand_deselect_chip    =   s3c2410_nand_deselect_chip;</span><br><span class="line">        nand_chip.write_cmd             =   s3c2410_write_cmd;</span><br><span class="line">        nand_chip.write_addr            =   s3c2410_write_addr;</span><br><span class="line">        nand_chip.read_data             =   s3c2410_read_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*使能NAND Flash控制器，初始化ECC，禁止片选，设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (<span class="number">1</span>&lt;&lt;<span class="number">15</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">12</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (TACLS&lt;&lt;<span class="number">8</span>) | (TWRPH0&lt;&lt;<span class="number">4</span>) | (TWRPH1&lt;&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nand_chip.nand_reset            =   s3c2440_nand_reset;</span><br><span class="line">        nand_chip.wait_idle             =   s3c2440_wait_idle;</span><br><span class="line">        nand_chip.nand_select_chip      =   s3c2440_nand_select_chip;</span><br><span class="line">        nand_chip.nand_deselect_chip    =   s3c2440_nand_deselect_chip;</span><br><span class="line">        nand_chip.write_cmd             =   s3c2440_write_cmd;</span><br><span class="line">        nand_chip.write_addr            =   s3c2440_write_addr;</span><br><span class="line">        nand_chip.read_data             =   s3c2440_read_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line">        <span class="comment">/*使能NAND Flash控制器，初始化ECC，禁止片选，设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*复位NAND Flash*/</span></span><br><span class="line">    nand_reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第12行读取GSTATUS1寄存器来判断为S3C2410还是S3C2440，然后分别处理：S3C2410、S3C2440的NAND Flash控制器中，有一些寄存器的功能是相同的，但是它们的地址是不一样的；有一些寄存器的功能已经发生变化。所以使用两套函数来进行处理。<br>第14-20行设置S3C2410的NAND Flash处理函数，第27-33行设置S3C2440的NAND Flash处理函数，把这些函数赋值给nand_chip结构，以后通过这个结构来调用。<br>如果处理器是S3C2410，则调用第23行的代码设置NFCONF寄存器；使能NAND Flash控制器，初始化ECC，禁止片选，设置时序。如果处理器是S3C2440，则使用第36、38两行代码来进行相同的设置。<br>最后第41行调用nand_reset函数复位NAND Flash。在第一次使用前通常复位一下。其中涉及的各个函数都只有几行，主要是读写寄存器。</p>
<h3 id="nand-read-函数分析"><a href="#nand-read-函数分析" class="headerlink" title="nand_read 函数分析"></a>nand_read 函数分析</h3><p>它的原型如下，表示从NAND Flash位置satrt_addr开始，将数据复制到SDRAM地址buf处，共复制size字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">unsigned</span> <span class="type">long</span> start_addr,<span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">unsigned</span> <span class="type">long</span> start_addr,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((start_addr &amp; NAND_BLOCK_MASK) || (size &amp; NAND_BLOCK_MASK))&#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">/*地址或长度不对齐*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*选中芯片*/</span></span><br><span class="line">    nand_select_chip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = start_addr;i &lt; start_addr + size;)&#123;</span><br><span class="line">        <span class="comment">/*发出READ0命令*/</span></span><br><span class="line">        write_cmd(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Write Address*/</span></span><br><span class="line">        write_addr(i);</span><br><span class="line">        wait_idle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;i &lt; NAND_SECTOR_SIZE;j++,i++)&#123;</span><br><span class="line">            *buf = read_data();</span><br><span class="line">            buf++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*取消片选信号*/</span></span><br><span class="line">    nand_deselect_chip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，读NAND Flash的操作分为6步。</p>
<ol>
<li>选择芯片——nand_select_chip()；</li>
<li>发出读命令——write_cmd()；</li>
<li>发出地址——write_addr()；</li>
<li>等待数据就绪——wait_idle()；</li>
<li>读取数据——read_data()；</li>
<li>结束后，取消片选信号；</li>
</ol>
<p>流程图如下：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpeg" alt="img not found"><br>从NAND Flash复制代码到SDRAM并运行的过程：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/15.jpeg" alt="img not found"><br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/16.jpeg" alt="img not found"><br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/17.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第8章 NAND Flash控制器</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>中断体系结构</title>
    <url>/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第9章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解ARM系统CPU的7中工作模式</li>
<li>了解S3C2410&#x2F;S3C2440中断体系结构</li>
<li>掌握S3C2410&#x2F;S3C2440的中断服务程序的编写方法</li>
</ol>
<h1 id="S3C2410-x2F-S3C2440中断体系结构"><a href="#S3C2410-x2F-S3C2440中断体系结构" class="headerlink" title="S3C2410&#x2F;S3C2440中断体系结构"></a>S3C2410&#x2F;S3C2440中断体系结构</h1><h2 id="ARM体系CPU的7种工作模式"><a href="#ARM体系CPU的7种工作模式" class="headerlink" title="ARM体系CPU的7种工作模式"></a>ARM体系CPU的7种工作模式</h2><ol>
<li>用户模式（usr）：ARM处理器正常的程序执行状态。</li>
<li>快速中断模式（fiq）：用于高速数据传输或通道处理。</li>
<li>中断模式（irq）：用于通用的中断处理。</li>
<li>管理模式（svc）：操作系统使用的保护模式。</li>
<li>数据访问终止模式（abt）：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。</li>
<li>系统模式（sys）：运行具有特权的操作系统任务。</li>
<li>未定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</li>
</ol>
<p>可以通过软件来进行模式切换，或者发生各类中断、异常时CPU自动进入相应的模式。除用户模式外，其他6种模式都属于特权模式。大多数程序运行于用户模式，进入特权模式是为了处理中断、异常，或者访问被保护的系统资源。<br>另外，ARM体系的CPU有以下两种工作状态。<br>ARM状态：此时处理器执行32位的字对齐的ARM指令。<br>Thumb状态：此时处理器执行16位的、半字对齐的Thumb指令。<br>实际上，本书所有的程序都是在ARM状态下运行的，而CPU一上电就处于ARM状态，所以无需关心CPU的工作状态。<br>ARM920T有31个通用的32位寄存器和6个程序状态寄存器。这37个寄存器分为7组，进入某个工作模式是就使用它的那组寄存器。有些寄存器，不同的工作模式有自己的副本，当切换到另一个工作模式时，那个工作模式的寄存器副本将被使用：这些寄存器被称为备份寄存器。<br>在ARM状态下，每种工作模式都有16个通用寄存器和1个（或2个，取决于工作模式）程序状态寄存器。下图列出了ARM状态下不同工作模式所使用的寄存器：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1.jpeg" alt="img not found"><br>图中R0-R15可以直接访问，这些寄存器除R15之外都是通用寄存器。即它们既可以保存数据也可以保存地址。另外，R13-R15稍有特殊。R13又被称为栈指针寄存器，通常用于保存栈指针。R14  又被称为程序连接寄存器或连接寄存器，当执行BL子程序调用指令时，R14中得到R15（程序计数器PC）的备份。而当发生中断或者异常时，对应的R14_svc、R14_irq、R14_fiq、R14_abt或R14_und中保存R15的返回值。R15是程序计数器。<br>快速中断模式有7个备份寄存器R8-R14（即R8_fiq-R14_fiq），这使得进入快速中断模式执行很大部分程序时（只要它们不改变R0-R7），甚至不需要保存任何寄存器。用户模式、管理模式、数据访问终止模式和未定义指令中止模式都含有两个独占的寄存器副本R13、R14，这样可以令每个模式拥有自己的栈指针寄存器和连接寄存器。<br>每种工作模式除R0-R15共有16个寄存器外，还有第17个寄存器CPSR，即“当前程序状态寄存器（Current Program Status Register）”。CPSR中一些位被用于表示各种状态，一些位被用于标识当前处于说明工作模式。<br>CPSR中各位意义如下：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2.jpeg" alt="img not found"></p>
<ol>
<li>T位：置位时，CPU处于Thumb状态，否则处于ARM状态。</li>
<li>中断禁止位：I位和F位属于中断禁止位。它们置位时，IRQ中断、FIQ中断分别被禁止。</li>
<li>工作模式位：表明CPU当前处于什么工作模式。可以编写这些位，使CPU进入指定的工作模式。</li>
</ol>
<p>除CPSR外，还有快速中断模式、中断模式、管理模式、数据访问终止模式和未定义指令中止模式等5种工作模式和一个寄存器–SPSR，即“程序状态保存寄存器（Saved Process Status Registers）”。当切换进入这些工作模式时，在SPSR中保存前一个工作模式的CPSR值，这样，当返回前一个工作模式时，可以将SPSR的值恢复到CPSR中。<br>综上所述，当一个异常发生时，将切换进入相应的工作模式（下文中将称为异常模式），这是CPU核将自动完成以下事情：</p>
<ol>
<li>在异常工作模式的连接寄存器R14中保存前一个工作模式的下一条，即将执行的指令的地址。对于ARM状态，这个值是当前PC值加4或加8。</li>
<li>将CPSR的值复制到异常模式的SPSR。</li>
<li>将CPSR的工作模式位设为这个异常对应的工作模式。</li>
<li>令PC值等于这个异常模式在异常向量表中的地址，即跳转去执行异常向量表中的相应指令。</li>
</ol>
<p>相反的，从异常工作模式推出到之前的工作模式时，需要通过软件完成如下事情。</p>
<ol>
<li>前面进入异常工作模式时，连接寄存器保存了前一工作模式的一个指令地址，将它减去一个适当的值后赋值给PC寄存器。</li>
<li>将SPSR的值复制回CPSR。</li>
</ol>
<table>
<thead>
<tr>
<th>异常模式</th>
<th>退出异常模式时PC的计算方法</th>
<th>进入异常模式时R14中保存的值（ARM状态）</th>
</tr>
</thead>
<tbody><tr>
<td>管理模式（通过SWI指令进入）</td>
<td>MOVS PC，R14</td>
<td>PC + 4 ①</td>
</tr>
<tr>
<td>未定义指令中止模式</td>
<td>MOVS PC，R14</td>
<td>PC + 4  ①</td>
</tr>
<tr>
<td>快速中断模式</td>
<td>SUBS PC，R14，#4</td>
<td>PC + 4 ②</td>
</tr>
<tr>
<td>中断模式</td>
<td>SUBS PC，R14，#4</td>
<td>PC + 4 ②</td>
</tr>
<tr>
<td>数据访问终止模式</td>
<td>异常原因：指令预取终止 SUBS PC，R14，#4</td>
<td>PC + 4 ①</td>
</tr>
<tr>
<td>数据访问终止模式</td>
<td>异常原因：指令访问终止 SUBS PC，R14，#8</td>
<td>PC + 8 ③</td>
</tr>
</tbody></table>
<p>注：<br>①PC值是这些指令的地址：SWI、未定义的指令、在预取时就失败的指令。<br>②PC值是这些指令的地址：进入快速中断模式、中断模式前、被打断而未执行的指令。<br>③PC值是这些指令的地址：导致数据访问终止的加载&#x2F;存储指令（LDR、STR、LDM、STM）。</p>
<h2 id="S3C2410-x2F-S3C2440中断控制器"><a href="#S3C2410-x2F-S3C2440中断控制器" class="headerlink" title="S3C2410&#x2F;S3C2440中断控制器"></a>S3C2410&#x2F;S3C2440中断控制器</h2><p>CPU运行过程中，如何知道各类外设发生了某些不预期的事件，比如串口收到了新数据，USB接口中插入了设备，按下了某个按键等。主要有以下两种方法：</p>
<ol>
<li>轮询方式：程序循环的查询各个设备的状态并作出相应反应。它实现简单，常用在功能相对单一的系统中。比如在一个温控系统中可以使用查询方式不断检测温度的变化。缺点是占用CPU资源过高，不适用于多任务系统。</li>
<li>中断方式：当某件事情发生时，硬件会设置某个寄存器；CPU在每执行完一条指令时，通过硬件查看这个寄存器，如果发现所关注的事情发生了，则中断当前程序流程，跳转到一个固定的地址处理这件事情，最后返回继续执行被中断的程序。它的实现相对复杂，但是效率很高，是常用的方法。</li>
</ol>
<p>参考下图，不论何种CPU，中断的处理过程是相似的：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/3.jpeg" alt="img not found"></p>
<ol>
<li>中断控制器汇集各类外设发出的中断信号，然后告诉CPU。</li>
<li>CPU保存当前程序的运行环境（各个寄存器等），调用中断服务程序（ISR，Interrupt Service Routine）来处理这些中断。</li>
<li>在ISR中通过读取中断控制器、外设的相关寄存器来识别这是哪个中断，并进行相应的处理。</li>
<li>清除中断：通过读写中断控制器和外设的相关寄存器来实现。</li>
<li>最后恢复被中断程序的运行环境（即上面保存的各个寄存器等），继续执行。</li>
</ol>
<p>对于不同的CPU而言，中断的处理只是细节的不同，S3C2410&#x2F;S3C2440的中断控制器结构如下图所示：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4.jpeg" alt="img not found"><br>SUBSRCPND和SRCPND寄存器表明有哪个中断被触发了，正在等待处理（pending）；SUBMASK（INTSUBMSK）和MASK（INTMSK）用于屏蔽某些中断。<br>图中的“Request sources （with sub -register）”表示INT_RXD0、INT_TXD0等中断源（S3C2410中这类中断有11个，而S3C2440中有15个）。它们不同于“Request sources （without sub -register）”。</p>
<ol>
<li>Request sources （without sub -register）中的中断源被触发之后，SRCPND寄存器中相应位被置1，如果此中断没有被INTMSK寄存器屏蔽或者快中断（FIQ）的话，它将被进一步处理。</li>
<li>对于Request sources （with sub -register）中的中断源被触发之后，SUBSRCPND寄存器中的相应位被置1，如果此中断没有被INTSUBMSK寄存器屏蔽的话，它在SRCPND寄存器中的相应位也被置1，之后的处理过程就和“Request sources （without sub -register）”一样了。</li>
</ol>
<p>在SRCPND寄存器中，被触发的中断的相应位被置1，等待处理：</p>
<ol>
<li>如果被触发的中断中有快速中断（FIQ）—MODE（INTMOD寄存器）中为1的位对应的中断是FIQ，则CPU进入快速中断模式（FIQ Mode）进行处理。</li>
<li>对于一般中断IRQ，可能同时有几个中断被触发，未被INTMSK寄存器屏蔽的中断经过比较后，选出优先级最高的中断，此中断在INTPND寄存器中的相应位被置1，然后CPU进入中断模式（IRQ Mode）进行处理。中断服务程序可以通过读取INTPND寄存器或者INTOFFSET寄存器来确定中断源。</li>
</ol>
<p>“Priority”表示中断的优先级判选，通过PRIORITY寄存器进行设置。</p>
<p>综上所述，使用中断的步骤如下：</p>
<ol>
<li>设置好中断模式和快速中断模式下的栈：当发生中断IRQ时，CPU进入中断模式，这是使用中断模式下的栈；当发生快速中断模式FIQ时，CPU进入快速中断模式，这时使用快速中断模式下的栈。</li>
<li>准备好中断处理函数。<br>  ①异常向量：<br>  在异常向量表中设置好当进入中断模式或快速中断模式时的跳转函数，它们的异常向量地址分别为0x00000018、0x0000001C。<br>  ②中断服务程序（ISR）：<br>  IRQ、FIQ的跳转函数，最终将调用具体中断的服务函数。对于IRQ，读取INTPND寄存器或者INTOFFSET寄存器的值来确定中断源，然后分别处理。<code>对于FIQ，因为只有一个中断可以设为FIQ</code>，因此无需判断。<br>  ③清除中断：<br>  如果不清除中断，则CPU会误以为这个中断又一次发生了。<br>  可以在调用ISR之前清除中断，也可以在调用ISR之后清除中断，这取决于在ISR执行过程中，这个中断是否可能继续发生、是否能够丢弃。如果在ISR执行过程中，这个中断可能发生并不能丢弃，则在调用ISR之前就清除中断，这样在ISR过程中发生的中断能够被各寄存器再次记录并通知CPU；如果在ISR过程中，这个中断并不能发生或者可以丢弃，则在调用ISR后清除中断。<br>  清除中断时，从源头开始：首先，需要的话，操作具体外设清除中断信号；其次，清除SUBSRCPND、SRCPND寄存器的相应位（往相应位写1即可）；最后，清除INTPND寄存器的相应位（往相应位写1即可），最简单的方法就是“INTPND&#x3D;INTPND”。</li>
<li>进入、退出中断模式或快速中断模式时，需要保存、恢复被中断程序的运行环境。<br>  ①对于IRQ：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub lr,lr,#4              @计算返回地址</span><br><span class="line">stmdb   sp!,&#123;r0-r12,lr&#125;   @保存使用到的寄存器</span><br><span class="line">... ...                   @处理中断</span><br><span class="line">ldmia   sp!,&#123;r0-r12,pc&#125;   @中断返回</span><br><span class="line">                          @^表示将spsr的值赋值给cpsr</span><br></pre></td></tr></table></figure>
  ②对于FIQ<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub lr,lr,#4              @计算返回地址</span><br><span class="line">stmdb   sp!,&#123;r0-r7,lr&#125;   @保存使用到的寄存器</span><br><span class="line">... ...                   @处理中断</span><br><span class="line">ldmia   sp!,&#123;r0-r7,pc&#125;   @中断返回</span><br><span class="line">                          @^表示将spsr的值赋值给cpsr</span><br></pre></td></tr></table></figure></li>
<li>根据具体中断，设置相关外设。不比如对于GPIO中断，需要将相应引脚的功能设置为“外部引脚”、设置中断触发条件（低电平出发、高电平触发、下降沿触发还是上升沿触发）等。一些中断拥有自己的屏蔽寄存器，还要开启它。</li>
<li>对于“Request sources （without sub -register）”中的中断，将INTSUBMSK寄存器中相应位设为0。</li>
<li>确定使用此中断的方式：FIQ或IRQ。<br>  ①如果是FIQ，则在INTMOD寄存器中设置相应位为1。<br>  ②如果是IRQ，则在PRIORITY寄存器中设置优先级。</li>
<li>如果是IRQ，将IMTMSK寄存器中相应位设为0（FIQ不受INTMSK寄存器控制）。</li>
<li>设置CPSR寄存器中的I-bit位（IRQ）或者F-bit（对于FIQ）为0，使能IRQ或者FIQ。</li>
</ol>
<h2 id="中断控制器寄存器"><a href="#中断控制器寄存器" class="headerlink" title="中断控制器寄存器"></a>中断控制器寄存器</h2><p>SUBSRCPND、INTSUBMSK这两个寄存器中相同的位对应相同的中断；SRCPND、INTMSK、INTMOD、INTPND这四个寄存器中相同的位对应相同的中断。</p>
<h3 id="SUBSRCPND寄存器（SUB-SOURCE-PENDING）"><a href="#SUBSRCPND寄存器（SUB-SOURCE-PENDING）" class="headerlink" title="SUBSRCPND寄存器（SUB SOURCE PENDING）"></a>SUBSRCPND寄存器（SUB SOURCE PENDING）</h3><p>SUBSRCPND寄存器被用来标识INT_RXD0、INT_TXD0等中断（S3C2410中这类中断有11个，而S3C2440中有15个）受否已经发生，每位对应一个中断。当这些中断发生并且没有被INTSUBSMSK寄存器屏蔽，则它们中的若干位将“汇集”出现在SRCPND寄存器的一位下。比如SUBSRCPND寄存器中的3个中断，INT_RXD0、INT_TXD0、INT_ERR0，只要有一个发生了并且它没有被屏蔽，则SRCPND寄存器中的INT_UART0位被置1。<br>要清除中断时，往SUBSRCPND寄存器中某位写入1即可令此位为0；写入0无效果，数据保持不变。</p>
<h3 id="INTSUBMSK寄存器（INTERRUPT-SUB-MSK）"><a href="#INTSUBMSK寄存器（INTERRUPT-SUB-MSK）" class="headerlink" title="INTSUBMSK寄存器（INTERRUPT SUB MSK）"></a>INTSUBMSK寄存器（INTERRUPT SUB MSK）</h3><p>INTSUBMSK寄存器被用来屏蔽SUBSRCPND寄存器标识的中断。INTSUBMSK寄存器中某位被设为1时，对应的中断被屏蔽。</p>
<h3 id="SRCPND寄存器（SOURCE-PENDING）"><a href="#SRCPND寄存器（SOURCE-PENDING）" class="headerlink" title="SRCPND寄存器（SOURCE PENDING）"></a>SRCPND寄存器（SOURCE PENDING）</h3><p>SRCPND中每一位被用来表示一个（或者一类）中断是否已经发生。例如：</p>
<ol>
<li>使用SUBSRCPND&#x2F;INTSUBMSK控制的中断。</li>
<li>不使用SUBSRCPND&#x2F;INTSUBMSK控制的中断。<br>SRPND寄存器的操作与SUBSRCPND类似，若想清除某一位，往此位写入1。</li>
</ol>
<h3 id="INTMSK-寄存器（INTERRUPT-MASK）"><a href="#INTMSK-寄存器（INTERRUPT-MASK）" class="headerlink" title="INTMSK 寄存器（INTERRUPT MASK）"></a>INTMSK 寄存器（INTERRUPT MASK）</h3><p>INTMSK寄存器被用来屏蔽SRCPND寄存器所标识的中断。INTMSK寄存器中某位被设为1时，对应的中断被屏蔽。<br>INTMSK寄存器只能屏蔽被设为IRQ的中断，不能屏蔽被设为FIQ的中断。</p>
<h3 id="INTMOD-寄存器（INTERRUPT-MODE）"><a href="#INTMOD-寄存器（INTERRUPT-MODE）" class="headerlink" title="INTMOD 寄存器（INTERRUPT MODE）"></a>INTMOD 寄存器（INTERRUPT MODE）</h3><p>当INTMOD寄存器中某位被设为1时，它对应的中断被设为FIQ，即此中断发生时，CPU将进入快速中断模式，这通常用来处理特别紧急的中断。</p>
<h3 id="PRIORITY-寄存器"><a href="#PRIORITY-寄存器" class="headerlink" title="PRIORITY 寄存器"></a>PRIORITY 寄存器</h3><p>上面INTMOD寄存器中，将设为1的中断称为快速中断（FIQ），将其余设为0的中断称为普通中断（IRQ）。<br>当有多个普通中断发生时，中断处理器将选出优先级最高的中断，首先处理它。中断优先级的判选通过7个仲裁器来完成，包括6个以及仲裁器和1个二级仲裁器：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/5.jpeg" alt="img not found"><br>每个仲裁器含6个输入引脚REQ0-REQ5。对于每个仲裁器，PRIORITY寄存器使用三位来控制其行为：一位被用于选择仲裁器工作模式，称为ARB_MODE；两位被用于控制各输入信号的优先级，称为ARB_SEL。<br>ARB_SEL的取值和REQ0-REQ5的优先级如下表所示：</p>
<table>
<thead>
<tr>
<th>ARB_SEL</th>
<th>优先级（从高到低）</th>
</tr>
</thead>
<tbody><tr>
<td>00b</td>
<td>REQ0、REQ1、REQ2、REQ3、REQ4、REQ5</td>
</tr>
<tr>
<td>01b</td>
<td>REQ0、REQ2、REQ3、REQ4、REQ1、REQ5</td>
</tr>
<tr>
<td>10b</td>
<td>REQ0、REQ3、REQ1、REQ1、REQ2、REQ5</td>
</tr>
<tr>
<td>11b</td>
<td>REQ0、REQ4、REQ4、REQ2、REQ3、REQ5</td>
</tr>
</tbody></table>
<p>注：REQ0的优先级永远是最高的、REQ5的优先级永远是最低的。</p>
<p>当某个仲裁器的ARB_MODE位被设为0时，它的ARB_SEL位是不会自动变化的，此时这个仲裁器的6个输入引脚的优先级固定不变（当然，可以通过软件修改ARB_SEL来改变它们的优先级）。当ARB_MODE位被设为1时，ARB_SEL会随着“已经被服务的REQx”（x&#x3D;1~4）自动变化：</p>
<table>
<thead>
<tr>
<th>已经被服务的REQx</th>
<th>ARB_SEL的新值</th>
</tr>
</thead>
<tbody><tr>
<td>REQ0&#x2F;REQ5</td>
<td>维持不变</td>
</tr>
<tr>
<td>REQ1</td>
<td>01b</td>
</tr>
<tr>
<td>REQ2</td>
<td>10b</td>
</tr>
<tr>
<td>REQ3</td>
<td>11b</td>
</tr>
<tr>
<td>REQ4</td>
<td>00b</td>
</tr>
<tr>
<td>结合上表可知：当ARB_MODE为1时，某个REQx（x&#x3D;1~4）被服务之后，它的优先级变为REQ0-REQ4中的最低。</td>
<td></td>
</tr>
<tr>
<td>PRIORITY寄存器中位[0:6]对应这7个仲裁器的ARB_MODE位（位[0]是ARB_MODE0，依此类推），位[7:20]位对应这7个仲裁器的ARB_SEL位（[7:8]是ARB_SEL0，依此类推）。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="INTPND寄存器（INTERRUPT-PENDING）"><a href="#INTPND寄存器（INTERRUPT-PENDING）" class="headerlink" title="INTPND寄存器（INTERRUPT PENDING）"></a>INTPND寄存器（INTERRUPT PENDING）</h3><p>经过中断优先级仲裁器选出的优先级最高的中断后，这个中断在INTPND寄存器中的相应位被置1，随后，CPU将进入中断模式处理它。<br>同一时间内，此寄存器只有一位被置1；在ISR中，可以根据这个位确定是哪个中断。清除中断时，往这个位写1。</p>
<h3 id="INTOFFSET-寄存器（INTERRUPYT-OFFSET）"><a href="#INTOFFSET-寄存器（INTERRUPYT-OFFSET）" class="headerlink" title="INTOFFSET 寄存器（INTERRUPYT OFFSET）"></a>INTOFFSET 寄存器（INTERRUPYT OFFSET）</h3><p>这个寄存器被用来表示INTPND寄存器中哪位被置1了，即INTPND寄存器中位[X]为1时，INTOFFSET寄存器中的值为x（x为0~31）。<br>在清除SRCPND、INTPND寄存器时，INTOFFSET寄存器被自动清除。</p>
<h1 id="中断控制器操作实例：外部中断"><a href="#中断控制器操作实例：外部中断" class="headerlink" title="中断控制器操作实例：外部中断"></a>中断控制器操作实例：外部中断</h1><h2 id="按键中断代码实详解"><a href="#按键中断代码实详解" class="headerlink" title="按键中断代码实详解"></a>按键中断代码实详解</h2><p>开发板上，K1-K4四个按键所接的CPU引脚可以设成外部中断功能。本程序的main函数是一个不做任何事的无限循环，程序的功能完全靠中断来驱动：当按下某个按键时，CPU调用其中断服务程序来点亮对应的LED。</p>
<h3 id="head-S代码详解"><a href="#head-S代码详解" class="headerlink" title="head.S代码详解"></a>head.S代码详解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@******************************************************</span><br><span class="line">@File:head.S</span><br><span class="line">@功能：初始化，设置中断模式、系统模式的栈，设置好中断处理函数</span><br><span class="line">@******************************************************</span><br><span class="line"></span><br><span class="line">.<span class="keyword">extern</span> main</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">@******************************************************</span><br><span class="line">@中断向量，本程序中，除Reset和HandleIRQ外，其他异常都没有使用</span><br><span class="line">@******************************************************</span><br><span class="line">  b Reset</span><br><span class="line"></span><br><span class="line">@<span class="number">0x04</span>：未定义指令终止模式的向量地址</span><br><span class="line">HandleUndef：</span><br><span class="line">  b HandleUndef</span><br><span class="line"></span><br><span class="line">@<span class="number">0x08</span>：管理模式的向量地址，通过SWI指令进入此模式</span><br><span class="line">HandleSWI：</span><br><span class="line">  b HandleSWI</span><br><span class="line"></span><br><span class="line">@<span class="number">0x0c</span>：指令预取终止导致的异常的向量地址</span><br><span class="line">HandlePrefetchAbort：</span><br><span class="line">  b HandlePrefetchAbort</span><br><span class="line"></span><br><span class="line">@<span class="number">0x10</span>：数据访问终止导致的异常的向量地址</span><br><span class="line">HandleDataAbort：</span><br><span class="line">  b HandleDataAbort</span><br><span class="line"></span><br><span class="line">@<span class="number">0x14</span>：保留</span><br><span class="line">HandleNotUsed:</span><br><span class="line">  b HandleNotUsed</span><br><span class="line"></span><br><span class="line">@<span class="number">0x18</span>：中断模式的向量地址</span><br><span class="line">  b HandleIRQ</span><br><span class="line"></span><br><span class="line">@<span class="number">0x1c</span>：快中断模式的向量地址</span><br><span class="line">HandleFIQ：</span><br><span class="line">  b HandleFIQ</span><br></pre></td></tr></table></figure>
<p>上面7行指令所对应的地址为0x00、0x04、…、0x1C，这些地址上的指令称为“异常向量”。当发生各类异常时，CPU进入相应的工作模式，并跳转去执行它的异常向量。比如当复位时，CPU进入系统模式，并跳到0x00地址开始执行；发生中断时，CPU进入中断模式，并跳到地址0x18开始执行。<br>本程序中，只能使用“复位”和“中断”对应的异常向量，其他异常向量没有实际作用。<br>0x00地址处的指令为“b Reset”，在系统复位后，这条指令将跳去执行“Reset”开始的代码，它们完成一些初始化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reset:</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置栈指针，以下都是C函数，调用前需要设置好栈</span><br><span class="line">  bl disable_watch_dog    @关闭看门狗，否则CPU会不断重启</span><br><span class="line">  </span><br><span class="line">  msr cpsr_c,#<span class="number">0xd2</span>        @进入中断模式</span><br><span class="line">  ldr sp,=<span class="number">3072</span>            @设置中断模式栈指针</span><br><span class="line"></span><br><span class="line">  msr cpsr_c,#<span class="number">0xdf</span>        @进入系统模式</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置系统模式栈指针</span><br><span class="line">                          @其实复位之后，CPU就处于系统模式</span><br><span class="line">                          @前面的“ldr sp,=<span class="number">4096</span>”完成同样的功能，此句可省略</span><br></pre></td></tr></table></figure>
<p>第5-6行、第8-9行代码的功能相似，前者用于设置中断模式的栈指针，后者用于设置系统模式的栈指针。注意，这是尚未设完成所有初始化，所以还不能开开中断—第5、第8行代码中，CPSR中寄存器的I、F位都被设为1。第6、第9行代码中sp寄存器并不是同一个寄存器，前者为sp_irq、后者为sp_sys。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bl  init_led                  @初始化LED的GPIO管脚</span><br><span class="line">bl  init_irq                  @调用中断初始化函数，在init.c中</span><br><span class="line">msr cpsr_c, #<span class="number">0x5f</span>             @设置I-bit=<span class="number">0</span>, 开IRQ中断</span><br><span class="line"></span><br><span class="line">ldr lr, =halt_loop            @设置返回地址</span><br><span class="line">ldr pc, =main                 @调用main函数</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">  b halt_loop</span><br></pre></td></tr></table></figure>
<p>第1行调用init_led函数设置LED1-LED4这四个LED的GPIO为输出功能，第2行进行中断管脚的初始化。<br>当完成所有初始化后，第3行将CPSR寄存器中的I位设置为0，开IRQ中断。<br>标号“HandleIRQ”开始的代码用于处理中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HandleIRQ:</span><br><span class="line">  sub lr, lr,#<span class="number">4</span>                         @计算返回地址</span><br><span class="line">  stmdb sp!,  &#123;r0-r12,lr&#125;               @保存使用到的寄存器</span><br><span class="line">                                        @注意，此时的sp是中断模式的sp</span><br><span class="line">                                        @初始值是上面设置的<span class="number">3072</span></span><br><span class="line">  ldr lr, =int_return                   @设置调用ISR即EINT_Handle函数后的返回地址</span><br><span class="line">  ldr pc, =EINT_Handle                  @调用中断服务函数，在interrupt.c中。</span><br><span class="line"></span><br><span class="line">int_return:</span><br><span class="line">  ldmia sp!,  &#123;r0-r12,lr&#125;^              @中断返回,^表示将spsr的值复制到cpsr</span><br></pre></td></tr></table></figure>
<p>第2行计算处理中断处理完毕后的返回地址，lr寄存器的值等于被中断指令的地址加4，所以返回地址为lr的值减去4。<br>第3行用于保存被中断程序的运行环境，即各个寄存器。其中的sp为中断模式的栈，在上面的“ldr sp,&#x3D;3072”中初始化。这样，r0-r12,lr这14个寄存器被保存在中断模式的栈中。<br>第6行用于设置EINT_Handle函数执行完后的返回地址，这个地址为第10行指令的地址。<br>第7行调用中断服务函数EINT_Handle（代码在interrput.c中）。<br>当EINT_Handle函数处理完所发生的中断后，返回第10行的指令。它恢复前面第3行保存的各个寄存器，即恢复被中断程序的运行环境：从栈中恢复r0-r12、pc这14个寄存器的值，同时，将SPSR寄存器的值复制到CPSR（在进入中断模式时，CPU自动将原来的CPSR值保存到SPSR中），这导致CPU切换到原来的工作模式。</p>
<h3 id="init-c中与中断相关的代码详解"><a href="#init-c中与中断相关的代码详解" class="headerlink" title="init.c中与中断相关的代码详解"></a>init.c中与中断相关的代码详解</h3><p>下面详述init_irq函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化GPIO引脚作为外部中断</span></span><br><span class="line"><span class="comment">GPIO引脚用作外部中断时，默认为低电平触发、IRQ方式（不用设置INTMOD）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPFCON = GPF0_eint | GPF2_eint;</span><br><span class="line">  GPGCON = GPG3_eint | GPG11_eint;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于EINT11、EINT19，需要在EINTMASK寄存器中使能它们。</span></span><br><span class="line">  EINTMASK &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">11</span>)) &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  设定优先级：</span></span><br><span class="line"><span class="comment">  ARB_SEL0 = 00b，ARB_MODE0 = 0：REQ1 &gt; REQ3,即EINT0 &gt; EINT2</span></span><br><span class="line"><span class="comment">  仲裁器1、6无需设置</span></span><br><span class="line"><span class="comment">  最终：</span></span><br><span class="line"><span class="comment">  EINT0 &gt; EINT2 &gt; ETIN11、EINT9。即K4 &gt; K3 &gt; K1、K2</span></span><br><span class="line"><span class="comment">  EINT11 和 EINT9优先级相同</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  PRIORITY = (PRIORITY &amp; ((~<span class="number">0x01</span>) | (<span class="number">0x3</span> &lt;&lt; <span class="number">7</span>))) &amp; (<span class="number">0x0</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//EINT0、EINT2、EINT8_23使能</span></span><br><span class="line">  INTMSK  &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) &amp; (~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7、8行用于设置K1-K4对应的GPIO管脚为中断功能。使用GPIO的中断功能时，还需要确定它们的中断触发模式（低电平触发、高电平触发、下降沿触发、上升沿触发）。我们默认使用低电平触发，无需额外设置。<br>第11行在EINTMASK寄存器中开启EINT19、EINT11中断，它们对应的K1、K2。K3、K4对应的EINT2、EINT10不受EINTMASK寄存器控制。EINTMASK可以屏蔽的中断可以参考数据手册。<br>第21行用于设置中断优先级。本开发板中，外部中断EINT9、EINT11、EINT2和EINT0分别对应K1、K2、K3和K4四个按键。EINT0、EINT2被接到仲裁器0的REQ1、REQ3，程序中设置ARB_SEL0为0（即0b00），所以REQ1的优先级高于REQ3，即K4的优先级高于K3。程序中设置ARB_MODE0为0，所以仲裁器0中各优先级保持不变。EINT8-EINT23共用仲裁器1的REQ1，所以EINT11和EINT9的中断优先级相同。仲裁器0、1的输出接到仲裁器6的REQ0、REQ1，而仲裁器中REQ0的优先级总是高于REQ1，所以这4个按键的优先级：K4 &gt; K3 &gt; K1、K2。<br>本程序使用的GPIO的默认中断方式—IRQ，不是FIQ，所以不用设置INTMOD寄存器。<br>最后，第24行将INTMSK寄存器中EINT0、EINT2、EINT8_23这3个中断对应的位设为0，使能中断。但是仍未完全开启中断，head.S中的“msr cpsr_c, #0x5f”才打开了最后一个开关。</p>
<h3 id="interrupt-c中的中断处理函数"><a href="#interrupt-c中的中断处理函数" class="headerlink" title="interrupt.c中的中断处理函数"></a>interrupt.c中的中断处理函数</h3><p>上面说明了中断的初始化、中断的进入与退出。真正的处理函数为EINT_Handle，它被称为中断服务程序（ISR），代码在interrupt.c中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EINT_Handle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> oft = INTOFFSET;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(oft)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//K4被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |= (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//所有LED灯熄灭</span></span><br><span class="line">      GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);         <span class="comment">//LED4点亮</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//K3被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |= (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//所有LED灯熄灭</span></span><br><span class="line">      GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);         <span class="comment">//LED3点亮</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//K1或K2被被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |=  (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);      <span class="comment">//所有LED熄灭</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//需要进一步判断是K1还是K2被按下，或者K1、K2被同时按下</span></span><br><span class="line">      val = EINTPEND;</span><br><span class="line">      <span class="keyword">if</span>(val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>))</span><br><span class="line">        GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);       <span class="comment">//K2被按下，LED2点亮</span></span><br><span class="line">      <span class="keyword">if</span>(val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">19</span>))</span><br><span class="line">        GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//K1被按下，LED1点亮</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清除中断</span></span><br><span class="line">  <span class="keyword">if</span>(oft == <span class="number">5</span>)</span><br><span class="line">    EINTPEND = (<span class="number">1</span> &lt;&lt; <span class="number">11</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">19</span>);   <span class="comment">//EINT8-EINT23合用IRQ5</span></span><br><span class="line">  SRCPND = <span class="number">1</span> &lt;&lt; oft;</span><br><span class="line">  INTPND = <span class="number">1</span> &lt;&lt; oft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要关注中断的识别与清除，其余代码根据所识别出来的中断（按键）点亮对应的LED。第5行用来读取INTOFFSET寄存器，它的值被用来标识INTPND寄存器中哪位被设为1。此值为0是表示INTPND寄存器的位[0]为1，即EINT0中断发生了，说明K4被按下；此值为2时表示INTPND寄存器的位[2]为1，即EINT2中断发生了，说明按键K3被按下；此值为5时表示INTPND寄存器的位[5]为1，即EINT8-EINT23中至少一个中断发生了，在本程序中这表明K1、K2中至少按下了一个，至于是哪一个，需要进一步判断。<br>第27行用来读取EINTPEND寄存器，它的位x为1时，表示EINTx已经发生了（x为4-23）。本程序就是通过读取EINTPEND寄存器的值来进一步判断EINT11还是EINT19发生了，即是K1还是K2按下了。<br>第45行用于清除EINTPEND寄存器，往某位写入1即可清除此位。<br>第46、47行用于清除SRCPND、INTPND寄存器。</p>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>程序的主函数很简单，在main.c中，只是个不做任何事情的无限循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图演示了代码的运行过程，注意PC和SP寄存器的变化：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第9章 中断体系结构</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>系统时钟和定时器</title>
    <url>/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第10章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440的时钟体系结构</li>
<li>掌握通过设置MPLL改变系统时钟的方法</li>
<li>掌握在不同频率下设置存储控制器的方法</li>
<li>掌握PWM定时器的用法</li>
<li>了解WATCHDOG定时器的用法</li>
</ol>
<h1 id="时钟体系以及各类时钟部件"><a href="#时钟体系以及各类时钟部件" class="headerlink" title="时钟体系以及各类时钟部件"></a>时钟体系以及各类时钟部件</h1><h2 id="S3C2410-x2F-S3C2440时钟体系"><a href="#S3C2410-x2F-S3C2440时钟体系" class="headerlink" title="S3C2410&#x2F;S3C2440时钟体系"></a>S3C2410&#x2F;S3C2440时钟体系</h2><p>S3C2410&#x2F;S3C2440的时钟控制逻辑既可以外接晶振，然后通过内部电路产生时钟源；也可以直接使用外部提供的时钟源，它们通过引脚的设置来选择。时钟控制逻辑给整个芯片提供了3种时钟。FCLK用于CPU核，HCLK用于AHB总线上的设备，比如CPU核、存储控制器、中断控制器、LCD控制器、DMA和USB主机模块等，PCLK用于APB总线上的设备，比如WATCHDOG、IIS、IIC、PWM定时器、MMC接口、ADC、UART、GPIO、RTC、SPI。<br>AHB（Advanced High performance Bus）总线主要用于高性能模块（CPU、DMA和DSP等）之间的连接；APB（Advanced Peripheral Bus）总线主要用于低带宽的周边外设之间的连接，例如UART，IIC等。<br>S3C2410核的工作电压为1.8V时，主频可达200MHz；工作电压为2.0V，主频可达266MHz。S3C2440核的工作电压为1.2V时，主频可达300MHz；工作电压为1.3V时，主频可达300MHz。为了降低电磁干扰，降低板间布线的要求，S3C2410&#x2F;S3C2440外接晶振的频率一般很低，本开发板上的为12MHz，需要通过时钟控制逻辑的PLL提高系统时钟。<br>S3C2410&#x2F;S3C2440有两个PLL，MPLL和UPLL。UPLL专用于USB设备，MPLL用于设置FCLK、HCLK、PCLK。它们的设置方式类似。以MPLL为例。<br>上电时，PLL没启动，FCLK即等于外部输入的时钟，称为Fin。若要提高系统时钟，需要软件来启动PLL。结合下图来介绍PLL的设置过程。<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/1.jpeg" alt="img not found"></p>
<ol>
<li>上电几毫秒后，晶振（图中的OSC）输出稳定，FCLK&#x3D;Fin（晶振频率），nRESET信号恢复高电平之后，CPU开始执行指令。</li>
<li>可以在程序开头启动MPLL，设置MPLL的几个寄存器之后，需要等待一段时间（Lock Time），MPLL的输出才稳定。这段时间（Lock Time）内，FCLK停振，CPU停止工作。Lock Time的长短由寄存器LOCKTIME设定。</li>
<li>Lock Time之后，MPLL的输出才稳定，CPU工作在新的FCLK下。</li>
</ol>
<p>FCLK、HCLK、PCLK的比例是可以改变的，设置它们三者的比例，启动MPLL只需要设置3个寄存器。</p>
<ol>
<li>LOCKTIME寄存器（LOCK TIME COUNT），用于设置“Lock Time”的长度。<br>MPLL启动后需要等待一段时间（Lock Time），使得其输出稳定。S3C2410中，位[23:12]用于UPLL，位[11:0]用于MPLL。S3C2440中，位[31:16]用于UPLL，位[15:0]用于MPLL。一般而言。使用它的默认值即可，S3C2410中默认值为0x00FFFFFF，S3C2440中的默认值为0xFFFFFFFF。</li>
<li>MPLLCON寄存器（Main PLL Control），用于设置FCLK与Fin的倍数，<br>位[19:12]的值称为MDIV，位[9:4]的值称为PDIV，位[1:0]的值称为SDIV。FCLK与Fin的关系有如下计算公式：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于S3C2410</span></span><br><span class="line">MPLL（FCLK） = （m*Fin）/(p*<span class="number">2</span>^s)</span><br><span class="line">其中：m = MDIV + <span class="number">8</span>，p = PDIV + <span class="number">2</span>,s = SDIV。</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于S3C2440</span></span><br><span class="line">MPLL（FCLK） = （<span class="number">2</span>*m*Fin）/(p*<span class="number">2</span>^s)</span><br><span class="line">其中：m = MDIV + <span class="number">8</span>，p = PDIV + <span class="number">2</span>,s = SDIV。</span><br></pre></td></tr></table></figure>
设置MPLLCON就相当于之前图中说的“首先使用软件来设置PLL”，Lock Time就被自动插入。Lock Time之后，MPLL输出稳定，CPU工作在新的FCLK下。</li>
<li>CLKDIVN寄存器（CLOCK DIVIDER CONTROL），用于设置FCLK、HCLK、PCLK三者的比例。<br>对于S3C2410、S3C2440这个寄存器表现稍有不同<table>
<thead>
<tr>
<th>CLKDIVN</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HDIVN1</td>
<td>2</td>
<td>0表示保留，1表示FCLK：HCLK：PCLK&#x3D;1：4：4，此时HDIVN、PDIVN必须设为0b00</td>
</tr>
<tr>
<td>HDIVN</td>
<td>1</td>
<td>HCLK的分频系数，0-HCLK&#x3D;FCLK，1-HCLK&#x3D;FCLK&#x2F;2</td>
</tr>
<tr>
<td>PDIVN</td>
<td>0</td>
<td>PCLK的分频系数，0-PCLK&#x3D;HCLK，1-PCLK&#x3D;HCLK&#x2F;2</td>
</tr>
</tbody></table>
</li>
</ol>
<p>对于S3C2440的一些时钟比例，还需要额外设置一个寄存器CAMDIVN。下图中，HDIVN为CLKDIVN寄存器的位[2:1]，PDIVN为位[0]；HCLK4_HALF、HCLK3_HALF分别为CAMDIVN寄存器的位[9]、[8]。各种时钟比例对应的寄存器设置如下图所示：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/2.jpeg" alt="img not found"><br>对于S3C2410，HDIVN是CLKCIVN寄存器的位[1]，对于S3C2440，HDIVN是CLKDIVN寄存器的位[2:1]。如果HDIVN非0，CPU的总线模式应该从“fast bus mode”变为“asynchronous bus mode”，这可以通过如下指令来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#MMU_SetAsyncBusMode</span><br><span class="line">mrc p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line">orr r0,r0,#R1_nF:OR:R1_iA</span><br><span class="line">mcr p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>其中的“#R1_nF:OR:R1_iA”等于0xC0000000。如果HDIVN非0时，而CPU的总线模式仍是“fast bus mode”，则CPU的工作频率将自动变为HCLK，而不再是FCLK。</p>
<h2 id="PWM定时器"><a href="#PWM定时器" class="headerlink" title="PWM定时器"></a>PWM定时器</h2><p>S3C2410&#x2F;S3C2440的定时器部件完全一样，共有5个16位的定时器。其中定时器0、1、2、3有PWM（Pulse Width Modulation）功能，即它们都只有一个输出引脚，可以通过定时器来控制引脚周期性的高低电平变化；定时器4没有输出引脚。<br>定时器部件的时钟源为PCLK，首先通过两个8位的预分频器降低频率：定时器0、1共用第一个预分频器，定时器2、3、4共用第一个预分频器。预分频器的输出将进入第二级分频器。它们输出5种频率的时钟，2、4、8、16分频或者外部时钟TCLK0&#x2F;TCLK1。每个定时器的工作时钟可以从这5种频率中选择。<br>两个预分频都可以通过TCFG0寄存器来设置，每个定时器工作在哪个频率下也可以通过TCFG1寄存器来选择。下图形象的说明了定时器的结构：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/3.jpeg" alt="img not found"><br>上面只是确定了定时器的工作频率，至于定时器如何工作还得了解其内部结构。定时器内部控制逻辑的工作流程如下：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/4.jpeg" alt="img not found"></p>
<ol>
<li>程序初始化，设定TCMPBn、TCNTBn这两个寄存器，它们表示定时器n的比较值，初始计数值。</li>
<li>随之设置TCON寄存器启动定时器n，这时，TCMPBn、TCNTBn的值将被装入其内部寄存器TCMPn、TCNTn中。在定时器n的工作频率下，TCNTn开始减1计数，其值可以通过读取TCNTOn寄存器得知。</li>
<li>当TCNTn的值等于TCMPn的值时，定时器n的输出管脚TOUTn反转；TCNTn继续减1计数。</li>
<li>当TCNTn的值到达0时，其输出管脚TOUTn再次反转，并触发定时器n的中断（如果使能了中断的话）。</li>
<li>当TCNTn的值到达0时，如果在TCON寄存器中将定时器n设为自动加载，则TCMPB0和TCNTB0寄存器的值被自动装入TCMP0和TCNT0寄存器中，下一个计数流程开始。<br>定时器n的输出管脚TOUTn初始状态为高电平，以后在TCNTn的值等于TCMPn的值、TCNTn的值时反转。也可以通过TCON寄存器设置其初始电平，这样TOUTn的输出就完全反相了。通过设置TCMPBn、TCNTBn的值可以设置管脚TOUTn输出信号的占空比，这就是所谓的可调制脉冲（PWM），所以这些定时器就可以称为PWM定时器。</li>
</ol>
<p>定时器的寄存器：</p>
<ol>
<li>TCFG0寄存器（TIMER CONTFIGURATION）<br>位[7:0]、位[15:8]分别用来控制预分频器0、1。它们的值为0-255。经过预分频器出来的时钟频率为PCLK&#x2F;{prescaler value + 1}。</li>
<li>TCFG1寄存器（TIMER CONTFIGURATION）<br>经过预分频器的得到的时钟将被2分频、4分频、8分频和16分频，除这4种频率外，额外的，定时器0、1还可以工作在外接的TCLK0时钟下，定时器2、3、4还可以工作在外接的TCLK1时钟下。<br>通过TCFG1寄存器来设置这5个定时器，分别工作于这5个频率的哪一个之下，如下表所示：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/4.jpeg" alt="img not found"><br>这样，定时器n的工作频率或者是外接的TCLK0或TCLK1可通过这个公式进行计算：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定时器工作频率 = PCLK / &#123;presacaler value + 1&#125; / &#123;divider value&#125;</span><br><span class="line">&#123;prescaler value&#125; = 0-255</span><br><span class="line">&#123;divider value&#125; = 2,4,8,16</span><br></pre></td></tr></table></figure></li>
<li>TCNTBn&#x2F;TCMPBn寄存器（COUNT BUFFER REGISTER &amp; COMPARE BUFFER REGISTER）<br>n为0-4，这四个寄存器都只用到位[15:0],TCNTBn中保存定时器的初始计数值，TCMPBn中保存比较值。它们的值在启动定时器时，被传到定时器内部寄存器TCNTn、TCMPn中。<br>没有TCMPB4因为定时器4没有输出引脚。</li>
<li>TCNTOn寄存器（COUNT OBSERVATION）。<br>n为0-4，定时器n被启动后，内部寄存器TCNTn在其工作时钟下不断减1计数，可以通过读取TCNTOn寄存器得知其值。</li>
<li>TCON寄存器（TIMER CONTROL）。<br>它有以下4个作用:<ol>
<li>第一次启动定时器时“手动”将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中。</li>
<li>启动、停止定时器。</li>
<li>决定在定时器计数到达0时是否自动将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中。</li>
<li>决定定时器的管脚TOUTn的输出电平是否反转。<br>TCON寄存器位[3:0]、位[11:8]、位[15:12]、位[19:16]、位[22:20]分别用于定时器0-4。除定时器因为没有输出引脚在没有“输出反转”位外，其他位的功能相似，下表以定时器0为例说明这些寄存器：<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>开启&#x2F;停止</td>
<td>0</td>
<td>0：停止定时器  1：开启定时器</td>
</tr>
<tr>
<td>手动更新</td>
<td>1</td>
<td>0：无用  1：将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中</td>
</tr>
<tr>
<td>输出反转</td>
<td>2</td>
<td>0：TOUT0不反转  1：TOUT0反转</td>
</tr>
<tr>
<td>自动加载</td>
<td>3</td>
<td>0：不自动加载   1：在定时器计数达到0时，TCNTBn&#x2F;TCMPBn寄存器的值自动装入内部寄存器TCNTn、TCMPn中</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<p>第一次使用定时器时，需要设置“手动更新”位为1以使TCNTBn&#x2F;TCMPBn寄存器的值装入TCNTn、TCMPn中。下一次如果还要设置这一位，需要先将它清0。</p>
<h2 id="WATCHDOG-定时器"><a href="#WATCHDOG-定时器" class="headerlink" title="WATCHDOG 定时器"></a>WATCHDOG 定时器</h2><p>WATCHDOG定时器可以像一般16位定时器一样用于产生周期性的中断，也可以用于发出复位信号以重启失常的系统。它与PWM定时器结构类似。<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/6.jpeg" alt="img not found"><br>同样的，WATCHDOG定时器的8位预分频器将PCLK分频后，将再次分频得到4种频率。16、32、64、128分频。WATCHDOG 定时器可以选择工作于哪种频率之下。WTCNT寄存器按照其工作频率减1计数，当达到0时，可以产生中断信号，可以输出复位信号。在第一次使用WATCHDOG 定时器时，需要往WTCNT寄存器中写入初始计数值，以后在计数值达到0时自动从WATDAT寄存器中装入，重新开始下一个计数周期。<br>使用WATCHDOG 定时器的“WATCHDOG 功能”时，在正常的程序中，必须不断重新设置WTCNT寄存器使得它不为0，这样可以保证系统不被重启，称为“喂狗”。当程序崩溃时不能正常喂狗，计数值达到0后系统将被重启，这样程序将程序运行。为了克服各种干扰、避免各类系统错误时系统彻底死机，经常使用WATCHDOG 功能。<br>WATCHDOG 定时器涉及到的寄存器如下：</p>
<ol>
<li>WTCON寄存器（WATCHDOG TIMER CONTROL）<br>用于设置预分频系数，选择各种频率，决定是否使能中断，是否启用WATCHDOG 功能（即是否输出复位信号）。<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WATCHDOG功能</td>
<td>0</td>
<td>当定时器达到0时，0：不输出复位信号  1：输出复位信号</td>
</tr>
<tr>
<td>中断使能</td>
<td>1</td>
<td>0：禁止中断  1：使能中断</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[4:3]</td>
<td>选择分频系数  0b00：16  0b01：32 0b10：64 0b11：128</td>
</tr>
<tr>
<td>定时器启动</td>
<td>5</td>
<td>0：停止  1：启动</td>
</tr>
<tr>
<td>预分频系数</td>
<td>[15:8]</td>
<td>预分频系数：0-255</td>
</tr>
</tbody></table>
</li>
</ol>
<p>与PWM定时器相似，WATDOG定时器的工作频率可以通过这公式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WATDOG定时器工作频率=PCLK/&#123;presacler value + 1&#125;/&#123;divider value&#125;</span><br><span class="line">&#123;prescaler value&#125; = 0-255</span><br><span class="line">&#123;divider value&#125; = 16,32,64,128</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>WTDAT寄存器（WATCHDOG TIMER DATA）<br>WTDAT寄存器被用来决定WATCHDOG定时器的超时周期，在定时器启动后，当计数达到0时，WTDAT寄存器的值会自动传入WTCNT寄存器。不过，第一次启动WATCHDOG定时器时，WTDAT寄存器的值会自动传入WTCNT寄存器。</li>
<li>WTCNT寄存器（WATCHDOG TIMER COUNT）<br>在启动WATCHDOG前，必须往这个寄存器写入初始计数值。启动定时器后，它减1计数，当计数值达到0时：如果中断被使能的话发出中断，如果WATCHDOG功能被使能的话就发出复位信号，装载WTDAT寄存器的值并重新计数。</li>
</ol>
<h1 id="MPLL和定时器操作实例"><a href="#MPLL和定时器操作实例" class="headerlink" title="MPLL和定时器操作实例"></a>MPLL和定时器操作实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例讲解MPLL、定时器的使用。首先启动MPLL提高系统时钟，初始化存储控制器使SDRAM工作在新的HCLK下，然后将定时器0设为0.5s产生一次中断，在中断程序里改变LED的状态。</p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>4个关键点：设置&#x2F;启动MPLL、根据HCLK设置存储控制器、初始化定时器0、定时器中断。</p>
<h3 id="设置-x2F-启动MPLL"><a href="#设置-x2F-启动MPLL" class="headerlink" title="设置&#x2F;启动MPLL"></a>设置&#x2F;启动MPLL</h3><p>clock_init函数用于设置MPLL，本开发板的输入时钟频率Fin为12MHz，将FCLK、HCLK、PCLK分别设为200MHz、100MHz和50MHz。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_MPLL_200MHZ ((0x5C &lt;&lt; 12) | (0x04 &lt;&lt; 4) | (0x00))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_MPLL_200MHZ ((0x5C &lt;&lt; 12) | (0x01 &lt;&lt; 4) | (0x02))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于MPLLCON寄存器，[19:12]为MDIV，[9:4]为PDIV，[1:0]为SDIV</span></span><br><span class="line"><span class="comment">有如下计算公式：</span></span><br><span class="line"><span class="comment">S3C2410：MPLL（FCLK） = （m*Fin）/ (p*2^s)</span></span><br><span class="line"><span class="comment">S3C2440：MPLL（FCLK） = （2*m*Fin）/ (p*2^s)</span></span><br><span class="line"><span class="comment">其中 m = MDIV + 8，p = PDIV + 2,s = SDIV。</span></span><br><span class="line"><span class="comment">本开发板Fin = 12MHz</span></span><br><span class="line"><span class="comment">设置CLKDIVN，令分频比为FCLK：HCLK：PCLK=1：2：4</span></span><br><span class="line"><span class="comment">FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LOCKTIME = 0x00ffffff;                   //使用默认值即可</span></span><br><span class="line">    CLKDIVN = <span class="number">0x03</span>;                             <span class="comment">//FCLK：HCLK：PCLK=1：2：4  HDIVN = 1,PDIVN = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果HDIVN非0，CPU的总线模式应该从“fast bus mode”变为“asynchronous bus mode”</span></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mrc p15,0,r1,c1,c0,0\n&quot;</span>                <span class="comment">//读出控制寄存器</span></span><br><span class="line">        <span class="string">&quot;orr r1,r1,#0xc0000000\n&quot;</span>               <span class="comment">//设置为“asynchronous bus mode”</span></span><br><span class="line">        <span class="string">&quot;mcr p15,0,r1,c1,c0,0\n&quot;</span>                <span class="comment">//写入控制寄存器</span></span><br><span class="line">    ); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是S3C2410还是S3C2440</span></span><br><span class="line">    <span class="keyword">if</span>((GSTATUS1 == <span class="number">0x3241000</span>) || (GSTATUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        MPLLCON = S3C2410_MPLL_200MHZ;          <span class="comment">//FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        MPLLCON = S3C2440_MPLL_200MHZ;          <span class="comment">//FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第17行设置FCLK、HCLK、PCLK三者分频比为1：2：4。<br>当HDIVN非0时，需要将CPU总线模式从“fast bus mode”设为“asynchronous bus mode”，第21-23行的汇编代码即完成此事。<br>第27-34行代码判断芯片是S3C2410还是S3C2440，它们的MPLL计算公式稍有不同，需要区分开来。如果处理器为S3C2410，使用第29行设置MPLL寄存器，令MDIV&#x3D;0x5C，PDIV&#x3D;0x04，SDIV&#x3D;0，所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MPLL(FCLK)=(m * Fin)/(p * 2 ^ s) = (0x5c + 8)*12MHz / ((0x04+2)*2^0) = 200MHz</span><br><span class="line">HCLK = FCLK / 2 = 100MHz</span><br><span class="line">PCLK = FCLK / 4 = 50MHz</span><br></pre></td></tr></table></figure>
<p>类似的，S3C2440的FCLK &#x3D; 200MHz，HCLK &#x3D; 100MHz，PCLK &#x3D; 50MHz。</p>
<h3 id="设置存储控制器"><a href="#设置存储控制器" class="headerlink" title="设置存储控制器"></a>设置存储控制器</h3><p>memsetup函数被用来设置存储控制器，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用存储控制器以使用SDRAM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memsetup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)MEM_CTL_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个函数之所以这样赋值，而不是像前面的实验（MMU）那样将配置值写在数组中，是因为要生成位置无关的代码，使得这个函数可以被复制到SDRAM之前就可以在Steppingstone中运行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*存储控制器13个寄存器的值*/</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0x22011110</span>;                  <span class="comment">//BWSCON</span></span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON0</span></span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON1</span></span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON2</span></span><br><span class="line">    p[<span class="number">4</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON3</span></span><br><span class="line">    p[<span class="number">5</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON4</span></span><br><span class="line">    p[<span class="number">6</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON5</span></span><br><span class="line">    p[<span class="number">7</span>] = <span class="number">0x00018005</span>;                  <span class="comment">//BANKCON6</span></span><br><span class="line">    p[<span class="number">8</span>] = <span class="number">0x00018005</span>;                  <span class="comment">//BANKCON7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    REFRESH,</span></span><br><span class="line"><span class="comment">    HCLK = 12MHz:0x008C07A3</span></span><br><span class="line"><span class="comment">    HCLK = 100MHz:0x008C04F4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    p[<span class="number">9</span>] = <span class="number">0x008C04F4</span>;                  </span><br><span class="line">    p[<span class="number">10</span>] = <span class="number">0x000000B1</span>;                  <span class="comment">//BANKSIZE</span></span><br><span class="line">    p[<span class="number">11</span>] = <span class="number">0x00018030</span>;                  <span class="comment">//MRSRB6</span></span><br><span class="line">    p[<span class="number">12</span>] = <span class="number">0x00018030</span>;                  <span class="comment">//MRSRB7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在HCLK的值等于100MHz，REFRESH寄存器的值需要重新计算。<br>R_CNT &#x3D; 2^11 + 1 - 100MHz * 7.8125μS &#x3D; 0x04F4，所以REFRESH &#x3D; 0x008C0000 + R_CNT &#x3D; 0x008C0000 + 0x04F4 &#x3D; 0x008C04F4。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REFRESH = 0x008c0000 + R_CNT</span><br><span class="line">R_CNT = 2 ^ 11 + 1 - SDRAM时钟频率（MHz） * SDRAM刷新周期（μS）</span><br></pre></td></tr></table></figure>
<p>对于第12到第20行为何用这么笨拙的方式设置存储控制器的13个寄存器，在连接脚本timer.lds中，全部代码的起始运行地址都被设为0x30000000，但是在执行memsetup函数时，代码仍在SRAM（Steppingstone）中，为了能够在Steppingstone中运行这个函数，它应该是位置无关的代码，而第12到第20行得手工赋值可以达到这个要求。</p>
<h3 id="初始化定时器0"><a href="#初始化定时器0" class="headerlink" title="初始化定时器0"></a>初始化定时器0</h3><p>tiemr0_init函数用于初始化定时器0，根据相关寄存器的格式并参考代码中的注释就可以理解这个函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Timer input clock Frequence = PCLK / &#123;prescaler value + 1&#125;/&#123;divider value&#125;</span></span><br><span class="line"><span class="comment">&#123;prescaler value&#125; = 0-255</span></span><br><span class="line"><span class="comment">&#123;divider value&#125; = 2,4,8,16</span></span><br><span class="line"><span class="comment">本实验的Timer0的时钟频率=100MHz/(99 + 1)/(16) = 62500Hz</span></span><br><span class="line"><span class="comment">设置Timer0 0.5s触发一次中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCFG0 = <span class="number">99</span>;                 <span class="comment">//预分频器0 = 99</span></span><br><span class="line">    TCFG1 = <span class="number">0x03</span>;               <span class="comment">//选择16分频</span></span><br><span class="line">    TCNB0 = <span class="number">31250</span>;              <span class="comment">//0.5s触发一次中断</span></span><br><span class="line">    TCON |= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);           <span class="comment">//手动更新</span></span><br><span class="line">    TCON = <span class="number">0x09</span>;                <span class="comment">//自动加载，清除“手动更新位”，启动定时器0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h3><p>head.S中调用timer0_init函数之后，定时器0即开始工作；调用init_irq函数使能定时器0中断，设置CPSR寄存器开启IRQ中断之后，每当定时器0达到0就会触发中断。init_irq函数很简单，在init.c中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定时器0中断使能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定时器0中断使能</span></span><br><span class="line">    INTMSK &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生定时器中断时，CPU将调用其中断服务程序Timer0_Handle,它在interrupt.c中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Handle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每次中断令4个LED改变状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(INTOFFSET == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPBDAT = ~(GPBDAT &amp; (<span class="number">0xf</span> &lt;&lt; <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清除中断</span></span><br><span class="line">    SRCPND = <span class="number">1</span> &lt;&lt; INTOFFSET;</span><br><span class="line">    INTPND = INTPND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器0的中断使用SRCPND、INTPND寄存器中的位10来表示。中断服务程序Timer0_Handle先判断是否定时器0的中断，若是则反转4个LED的状态。</p>
<h3 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h3><p>编译生成的bin文件烧入NAND Flash后，上电运行，即可看到4个LED每1S闪烁一次。<br>将head.S中对clock_init函数的调用去掉，不启用MPLL，并随之将init.c中的memesetup函数的REFRESH寄存器改为12MHz对应的0x008C07A3。重新编译、烧写。可以看到差不多8S这4个LED才闪烁一次。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第10章 系统时钟和定时器</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC</title>
    <url>/2022/08/25/IIC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第12章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解IIC总线协议</li>
<li>掌握S3C2410&#x2F;S3C2440中IIC的使用方法</li>
</ol>
<h1 id="IIC总线协议及硬件介绍"><a href="#IIC总线协议及硬件介绍" class="headerlink" title="IIC总线协议及硬件介绍"></a>IIC总线协议及硬件介绍</h1><h2 id="IIC总线协议"><a href="#IIC总线协议" class="headerlink" title="IIC总线协议"></a>IIC总线协议</h2><h3 id="IIC总线的概念"><a href="#IIC总线的概念" class="headerlink" title="IIC总线的概念"></a>IIC总线的概念</h3><p>IIC（Inter-Integrated Circuit）总线是一种由PHILIPS公司开发的串行总线，用于连接微控制器及其外围设备。</p>
<ol>
<li>只有两条总线线路：一条串行数据线（SDA），一条串行时钟线（SCL）。</li>
<li>每个连接到总线的器件都可以使用软件根据它的唯一地址来识别。</li>
<li>传输数据的设备间是简单的主从关系。</li>
<li>主机可以用作主机发送器或主机接收器。</li>
<li>它是一个真正的多主机总线，两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏。</li>
<li>串行的8位双向数据传输，位速率在标准模式下可达100kbit&#x2F;s，在快速模式下可达400kbit&#x2F;s，在高速模式下可达3.4Mbit&#x2F;s。</li>
<li>片上的滤波器可以增加抗干扰功能，保证数据的完整。</li>
<li>连接到同一总线上的IC数量只受到总线最大电容400pF的限制。</li>
</ol>
<p>下图是一条IIC总线多个设备相连的例子：<br><img src="/2022/08/25/IIC/1.jpeg" alt="img not found"></p>
<p>一些术语如下表：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>发送器</td>
<td>发送数据到总线的器件</td>
</tr>
<tr>
<td>接收器</td>
<td>从总线接收数据的器件</td>
</tr>
<tr>
<td>主机</td>
<td>发起&#x2F;停止数据传输、提供时钟信号的器件</td>
</tr>
<tr>
<td>从机</td>
<td>被主机寻址的器件</td>
</tr>
<tr>
<td>多主机</td>
<td>可以有多个主机试图去控制总线，但是不会破坏数据</td>
</tr>
<tr>
<td>仲裁</td>
<td>当多个主机试图去控制总线时，通过仲裁可以使得只有一个主机获得总线控制权，并且它传输的信息不会被破坏</td>
</tr>
<tr>
<td>同步</td>
<td>多个器件同步时钟信号的过程</td>
</tr>
</tbody></table>
<h3 id="IIC总线的信号类型"><a href="#IIC总线的信号类型" class="headerlink" title="IIC总线的信号类型"></a>IIC总线的信号类型</h3><p>IIC总线在传送数据的过程中共有3种类型信号：开始信号、结束信号和响应信号。</p>
<ol>
<li>开始信号（S）：SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据。</li>
<li>结束信号（P）：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。</li>
<li>响应信号（ACk）：接收器在接收到8位数据之后，在第9个时钟周期，拉低SDA电平。</li>
</ol>
<p>它们的波形如下图：<br><img src="/2022/08/25/IIC/2.jpeg" alt="img not found"></p>
<p>SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化，如下图所示：<br><img src="/2022/08/25/IIC/3.jpeg" alt="img not found"></p>
<h3 id="IIC总线的数据传输格式"><a href="#IIC总线的数据传输格式" class="headerlink" title="IIC总线的数据传输格式"></a>IIC总线的数据传输格式</h3><p>发送到SDA线上的每个字节必须是8位的，每次传输可以发送的字节数量不受限制。每个字节后必须跟一个响应位。首先传输的是数据的最高位。如果从机要完成一些其他功能后（例如一个内部中断程序）才能继续接收或发送下一个字节，从机可以拉低SCL迫使主机进入等待状态。当从机准备好接收下一个数据并释放SCL后，数据继续传输。如果主机在传输数据期间也需要完成一些其他功能（例如一个内部中断程序）也可以拉低SCL以占住总线。<br>启动一个传输时，主机发出S信号，然后发出8位数据。这8位数据中前7位为从机的地址，第8位表示传输的方向（0表示写操作，1表示读操作）。被选中的从机发出响应信号。紧接着传输一系列字节及其响应位。最后，主机发出P信号结束本次传输。<br>下图是IIC数据传输的3种类型读、写、读写转换：<br><img src="/2022/08/25/IIC/4.jpeg" alt="img not found"></p>
<p>并非每传输8位之后就会由ACK信号，以下3种例外：</p>
<ol>
<li>当主机不能响应从机地址时（例如它正忙着其他事情而无法响应IIC总线的操作，或者这个地址没有对应的主机），在第9个SCL周期内SDA线没有被拉低，即没有ACK信号。这时，主机发出一个P信号终止传输或者重新发出一个S信号开始新的传输。</li>
<li>如果从机接收器在传输过程中不能接收更多数据时，它也不会发出ACK信号。这样，主机就可以意识到这点，从而发出一个P信号终止传输或者重新发出一个S信号开始新的传输。</li>
<li>主机接收器在接收到最后一个字节后，也不会发出ACK信号，于是，从机发送器释放SDA线，以允许主机发出P信号结束传输。</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-IIC-总线控制器"><a href="#S3C2410-x2F-S3C2440-IIC-总线控制器" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线控制器"></a>S3C2410&#x2F;S3C2440 IIC 总线控制器</h2><h3 id="S3C2410-x2F-S3C2440-IIC-总线控制器介绍"><a href="#S3C2410-x2F-S3C2440-IIC-总线控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线控制器介绍"></a>S3C2410&#x2F;S3C2440 IIC 总线控制器介绍</h3><p>S3C2410&#x2F;S3C2440 IIC 接口有4种工作模式：主机发送器、主机接收器、从机发送器、从机接收器。其内部结构如下图所示：<br><img src="/2022/08/25/IIC/5.jpeg" alt="img not found"><br>S3C2410&#x2F;S3C2440提供4个寄存器来完成所有的IIC操作，SDA线上的数据从IICDS寄存器发出，或传入IICDS寄存器中；IICADD寄存器中保存S3C2410&#x2F;S3C2440当作从机的地址：IICCON、IICSTAT两个寄存器用来控制或标识各种各种状态，比如选择工作模式，发出S信号，P信号，决定是否发出ACK信号，检测是否收到ACK信号。寄存器的用法如下：</p>
<ol>
<li>IICCON寄存器（Multi-master IIC-bus control）<br>IICCON寄存器用于控制是否发出ACK信号、设置发送器的时钟、开启IIC中断，并标识中断是否发生。<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACK信号使能</td>
<td>[7]</td>
<td>0 &#x3D; 禁止 1 &#x3D; 使能 <br> 在发送模式，此位无意义 <br> 在接收模式，此位使能时，SDA线在响应周期内将被拉低，即发出ACK信号</td>
</tr>
<tr>
<td>发送模式时钟源选择</td>
<td>[6]</td>
<td>0 &#x3D; IICCLK 为PCLK&#x2F;6，1 &#x3D; IICCLK为PCLK&#x2F;512</td>
</tr>
<tr>
<td>发送&#x2F;接收中断使能</td>
<td>[5]</td>
<td>0 &#x3D; IIC总线 Tx&#x2F;Rx中断使能 <br> 1 &#x3D; IIC总线 Tx&#x2F;Rx中断使能</td>
</tr>
<tr>
<td>中断标记</td>
<td>[4]</td>
<td>此位用来标识是否有IIC中断发生，读出为0时表示没有中断发生，读出为1时表示有中断发生。当此位为1时，SCL线被拉低，此时所有IIC传输停止：如果需要继续传输，需写入0清除它</td>
</tr>
<tr>
<td>发生模式时钟分频系数</td>
<td>[3:0]</td>
<td>发送器时钟&#x3D;IICCLK&#x2F;(IICCON[3:0] + 1)</td>
</tr>
</tbody></table>
</li>
</ol>
<p>使用IICCON寄存器时，有如下注意事项：<br>①发送模式的时钟频率由位[6]、位[3:0]联合决定。另外，当IICCON[6]&#x3D;0时，IICCON[3:0]不能取0或1。<br>②IIC中断在以下3种情况下发生：当发出地址信息或者接收到一个从机地址并且吻合时，当总线仲裁失败时，当发送&#x2F;接收完一个字节的数据（包括ACK）时。<br>③基于SDA、SCL线上时间特性的考虑，要发送数据时，先将数据写入IICDS寄存器，然后再清除中断。<br>④如果IICCON[5] &#x3D; 0，IICCON[4]将不能正常工作。所以，即使不使用IIC中断，也要将IICCON[5]设为1。</p>
<ol start="2">
<li><p>IICSTAT（Multi-master IIC-bus control&#x2F;status）<br>IICSTAT寄存器用于选择IIC接口的工作模式，发出S信号、P信号，使能接收&#x2F;发送功能，并标识各种状态，比如总线仲裁是否成功、作为从机是否被寻址、是否接受到0地址、是否接收到ACK信号等。<br>IICSTAT寄存器的各位表示如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>工作模式</td>
<td>[7:6]</td>
<td>0b00：从机接收器 <br> 0b01：从机发送器 <br> 0b10：从机接收器 <br> 0b11：从机发送器</td>
</tr>
<tr>
<td>忙状态位&#x2F;S信号、P信号</td>
<td>[5]</td>
<td>读此位时0：总线空闲，1：总线忙 <br> 写此位时0：发出P信号，1：发出S信号。当发出S信号后，IICDS寄存器中的数据将被自动发送。</td>
</tr>
<tr>
<td>串行输出使能位</td>
<td>[4]</td>
<td>0：禁止接收&#x2F;发送功能，1：使能接收&#x2F;发送功能</td>
</tr>
<tr>
<td>仲裁状态</td>
<td>[3]</td>
<td>0：总线仲裁成功 1：总线仲裁失败</td>
</tr>
<tr>
<td>从机地址状态</td>
<td>[2]</td>
<td>作为从机时，在检测到S&#x2F;P信号时此位被自动清0 <br> 接收到的地址与IICADD寄存器中的值相等时，此位被置1</td>
</tr>
<tr>
<td>0地址状态</td>
<td>[1]</td>
<td>在检测到S&#x2F;P信号时此位被自动清0 <br> 接收到的地址为0b0000000时，此位被置1</td>
</tr>
<tr>
<td>最后一位的状态</td>
<td>[0]</td>
<td>0：接收到的最后一位为0（接收到ACK信号） <br> 1：接收到的最后一位为1 （没有接受到ACK信号）</td>
</tr>
</tbody></table>
</li>
<li><p>IICADD寄存器（Multi-master IIC-bus address）<br>用到IICADD寄存器的位[7:1]，表示从机地址。IICADD寄存器在串行输出使能位IICSTAT[4]为0时，才可以写入；在任何时间都可以读出。</p>
</li>
<li><p>IICDS寄存器（Multi-master IIC-bus Tx&#x2F;Rx data shift）<br>用到IICDS寄存器的位[7:0]，其中保存的是要发送或已经接受的数据。IICDS寄存器在串行输出使能位IICSTAT[4]为1时，才可以写入；在任何时候都可以读出。</p>
</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440-IIC-总线操作方法"><a href="#S3C2410-x2F-S3C2440-IIC-总线操作方法" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线操作方法"></a>S3C2410&#x2F;S3C2440 IIC 总线操作方法</h3><p>启动或恢复S3C2410&#x2F;S3C2440 的IIC传输有以下两种方法：</p>
<ol>
<li>当IICCON[4]即中断状态位为0时，通过写IICSTAT寄存器启动IIC操作，有以下两种情况：<br>①在主机模式，令IICSTAT[5:4]等于0b11，将发出S信号和IICDS寄存器的数据（寻址），令IICSTAT[5:4]等于0b01，将发出P信号。<br>②在从机模式，令IICSTAT[4]等于1将等待其他主机发出S信号及地址信息。</li>
<li>当IICCON[4]即中断位为1时，表示IIC操作被暂停。在这期间设置好其他寄存器之后，向IICCON[4]中写入0即可恢复IIC操作。所谓“设置其他寄存器”，有以下3种情况。<br>①对于主机模式，可以按照上面①的方法写IICSTAT寄存器，恢复IIC操作后即可发出S信号和IICDS寄存器的值（寻址），或者发出P信号。<br>②对于发送器，可以将下一个要发送的数据写入IICDS寄存器中，恢复IIC操作后即可发出这个数据。<br>③对于接收器，可以从IICDS寄存器中读出接收到的数据。最后向IICCON[4]写入0的同时，设置IICCON[7]以决定在接收到下一个数据后是否发出ACK信号。</li>
</ol>
<p>通过中断服务程序来驱动IIC传输。</p>
<ol>
<li>当仲裁失败时发生中断—本次传输没有抢到总线，可以稍后继续。</li>
<li>对于主机模式，当发出S信号、地址信息并经过一个SCL周期（对于ACK信号）后，发生中断—主机可在此时判断是否成功寻址到从机。</li>
<li>对于从机模式，当接收到的地址与IICADD寄存器吻合时，先发出ACK信号，然后发生中断—从机可在此时准备后续的传输。</li>
<li>对于发送器，当发送完一个数据并经过一个SCL周期（对于ACK信号）后，发生中断。这是可以准备下一个要发送的数据，或者发送P信号以停止传输。</li>
<li>对于接收器，当接收到一个数据时，先根据IICCON[7]决定是否发出ACK信号后，然后发生中断。这时可以读取IICDS寄存器得到数据，并设置IICCON[7]以决定接收到下一个数据后是否发出ACK信号。</li>
</ol>
<p>对于4种工作模式，S3C2410&#x2F;S3C2440数据手册中都有它们的操作流程图。现在以主机发送器作为例子说明，它的工作流程如图所示：<br><img src="/2022/08/25/IIC/6.jpeg" alt="img not found"></p>
<ol>
<li>配置主机发送器的各类参数。<br>设置GPE15、GPE14引脚用于SDA、SCL，设置IICCON寄存器选择IIC发送时钟，最后设置IICSTAT[4]为1。这样，后面才能写IICDS寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips：初始时IICCON[4]为0，不能将IICSTAT设为主机模式，否则就会立刻发出S信号，发送IICDS寄存器的值。</span><br></pre></td></tr></table></figure></li>
<li>将要寻址的从机地址写入IICDS寄存器。</li>
<li>将0xF0写入IICSTAT寄存器，即设为主机发送器、使能串行输出功能、发出S信号。</li>
<li>发出S信号后，步骤2中设置的IICDS寄存器值也将被发出，它用来寻址从机。</li>
<li>在响应周期之后，发生中断，此时IICCON[4]为1，IIC传输暂停。</li>
<li>如果没有数据要发送，则跳到步骤10，否则跳到步骤7。</li>
<li>将下一个要发送的数据写入IICDS寄存器中。</li>
<li>往IICCON[4]中写入0，恢复IIC传输。</li>
<li>这时IICDS寄存器中的值将被一位一位地发送出去。当8位数据发送完毕，在经过另一个SCL周期（对应ACK信号）后，中断再次发生，跳到步骤5。</li>
<li>将0xF0写入IICSTAT寄存器，即：设为主机发送器、使能串行输出功能、发出P信号。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips：这时的P信号并没有实际发出，只有清除了IICCON[4]后才会发出P信号。</span><br></pre></td></tr></table></figure></li>
<li>清除IICCON[4]，P信号得以发出。</li>
<li>等待一段时间，使得P信号完全发出。</li>
</ol>
<h1 id="IIC总线操作实例"><a href="#IIC总线操作实例" class="headerlink" title="IIC总线操作实例"></a>IIC总线操作实例</h1><h2 id="IIC接口RTC芯片M41t11的操作方法"><a href="#IIC接口RTC芯片M41t11的操作方法" class="headerlink" title="IIC接口RTC芯片M41t11的操作方法"></a>IIC接口RTC芯片M41t11的操作方法</h2><p>本书所用的开发板中，通过IIC总线连接RTC（实时时钟）芯片的M41t11，它使用电池供电，系统断电时也可以维持日期和时间。S3C2410&#x2F;S3C2440作为IIC主机向M41t11发送数据以设置日期和时间、读取M41t11以获得日期和时间。连接图如下图所示：<br><img src="/2022/08/25/IIC/7.jpeg" alt="img not found"><br>M41t11中有8个寄存器，分别对应秒、分、时、天、日、月、年、控制寄存器，其中的数据都是以BCD格式保存（0x15表示数值15），如下表所示：<br><img src="/2022/08/25/IIC/8.jpeg" alt="img not found"><br>除上表的8个寄存器（地址为0-7）之外，M41t11内部还有56字节的RAM（地址为8-63）。访问M41t11前，先设置寄存器地址，以后每次读写操作完成后，M41t11内部会自动将寄存器地址加1。<br>所以读写M41t11分为以下两个步骤：</p>
<ol>
<li>主机向M41t11发出要操作的寄存器地址（0-7）。</li>
<li>要设置M41t11时，主机连续发出数据；要读取M41t11时，主机连续读取数据。M41t11的IIC从机地址为0xD0。</li>
</ol>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例将在串口上输出一个菜单，可以选择设置时间和日期，或者将它们读出来。将通过本实例验证IIC主机的发送、接收操作。</p>
<h2 id="设置-x2F-读取M41t11的源码详解"><a href="#设置-x2F-读取M41t11的源码详解" class="headerlink" title="设置&#x2F;读取M41t11的源码详解"></a>设置&#x2F;读取M41t11的源码详解</h2><p>文件i2c.c封装了S3C2410&#x2F;S3C2440作为主机发送器、主机接收器的4个操作函数：i2c_init用于初始化，i2c_write用于发起发送数据，i2c_read用于发起读取数据，I2CHandle是IIC中断服务程序，它用于完成后续的数据传输。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC控制器初始化"><a href="#S3C2410-x2F-S3C2440-IIC控制器初始化" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC控制器初始化"></a>S3C2410&#x2F;S3C2440 IIC控制器初始化</h3><p>i2c_init函数对应于图12.7的步骤1，它用来初始化IIC，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IIC初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPEUP |= <span class="number">0xc000</span>;                <span class="comment">//禁止内部上拉</span></span><br><span class="line">    GPECON  |=  <span class="number">0xa0000000</span>;         <span class="comment">//选择引脚功能，GPE15：IICSDA  GPE14：IICSCL</span></span><br><span class="line"></span><br><span class="line">    INTMSK  &amp;=  ~(BIT_IIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    bit[7]=1，使能ACK</span></span><br><span class="line"><span class="comment">    bit[6]=0，IICCLK=PCLK/16</span></span><br><span class="line"><span class="comment">    bit[5]=1，使能中断</span></span><br><span class="line"><span class="comment">    bit[3:0] = 0xf，Tx clock = IICCLK/16</span></span><br><span class="line"><span class="comment">    PCLK = 50MHz，IICCLK = 3.125MHz，Tx Clock = 0.195MHz</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    IICCON = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">6</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) | (<span class="number">0xf</span>);        <span class="comment">//0xaf</span></span><br><span class="line"></span><br><span class="line">    ICCADD = <span class="number">0x10</span>;                                          <span class="comment">// S3C24xx slave address = [7:1]</span></span><br><span class="line">    IICSTAT = <span class="number">0x10</span>;                                         <span class="comment">// IIC串行输出使能（Rx/Tx）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6、7行代码将GPE15、GPE14的功能选择用于IIC：IICSDA、IICSCL。<br>第9行在INTMSK寄存器中开启IIC中断，这样，以后调用i2c_read、i2c_write启动传输时，即可以触发中断，进而可以在中断服务程序中进一步完成后续传输。<br>第19行用于选择发送时钟，并进行一些设置：使能ACK、使能中断。<br>第21行用于设置S3C2410&#x2F;S3C2440作为IIC从机时的地址。<br>第22行使能IIC串行输出（设置IICSTAT[4]为1），这样，在i2c_write、i2c_read函数中就可以写IICDS寄存器了。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-主机发送函数"><a href="#S3C2410-x2F-S3C2440-IIC-主机发送函数" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 主机发送函数"></a>S3C2410&#x2F;S3C2440 IIC 主机发送函数</h3><p>初始化完成后，就可以调用i2c_read、i2c_write函数读写IIC从机了。它们的使用方法从参数名称中可以看出。这两个函数仅仅是启动IIC传输，然后等待，直到数据在中断服务程序中传输完毕后再返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主机发送</span></span><br><span class="line"><span class="comment">slvAddr：从机地址，buf：数据存放的缓冲区，len：数据长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slvaddr,<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tS3C24xx_IIC.Mode         = WRDATA;           <span class="comment">//写操作</span></span><br><span class="line">    g_tS3C24xx_IIC.Pt           = <span class="number">0</span>;                <span class="comment">//索引初始值为0</span></span><br><span class="line">    g_tS3C24xx_IIC.pData        = buf;              <span class="comment">//保存缓冲区地址</span></span><br><span class="line">    g_tS3C24xx_IIC.DataCount    = len;              <span class="comment">//传输长度</span></span><br><span class="line"></span><br><span class="line">    IICDS   = slvAddr;</span><br><span class="line">    IICSTAT = <span class="number">0xf0</span>;                                 <span class="comment">//主机发送，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*等待直至数据发送完毕*/</span></span><br><span class="line">    <span class="keyword">while</span>(g_tS3C24xx_IIC.DataCount != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7-10行用于设置全局变量g_tS3C24xx_IIC，它表明当前是写操作，并保存缓冲区地址、要传送数据的长度，将缓冲区索引值初始化为0。<br>第12行将从机地址写入IICDS寄存器，这样，再第13行启动传输并发出S信号后，紧接着就自动发出从机地址。<br>第13行设置IICSTAT寄存器，将S3C2410&#x2F;S3C2440设为主机发送器，并发出S信号。后续的传输工作将在中断服务程序中完成。<br>第16行等待g_tS3C24xx_IIC.DataCount在中断服务程序中被设为-1，这表明传输完成，于是返回。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-主机接收函数"><a href="#S3C2410-x2F-S3C2440-IIC-主机接收函数" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 主机接收函数"></a>S3C2410&#x2F;S3C2440 IIC 主机接收函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主机接收</span></span><br><span class="line"><span class="comment">slvAddr：从机地址，buf：数据存放的缓冲区，len：数据长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slvAddr,<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tS3C24xx_IIC.Mode         = RDDATA;                   <span class="comment">//读操作</span></span><br><span class="line">    g_tS3C24xx_IIC.Pt           = <span class="number">-1</span>;                       <span class="comment">//索引值初始化为-1，表示第一个中断时不接受数据（地址中断）</span></span><br><span class="line">    g_tS3C24xx_IIC.pData        = buf;                      <span class="comment">//保存缓冲区地址</span></span><br><span class="line">    g_tS3C24xx_IIC.DataCount    = len;                      <span class="comment">//传输长度</span></span><br><span class="line"></span><br><span class="line">    IICDS = slvAddr;</span><br><span class="line">    IICSTAT = <span class="number">0xb0</span>;                                         <span class="comment">//主机接收，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*等待直至数据传输完毕*/</span></span><br><span class="line">    <span class="keyword">while</span>(g_tS3C24xx_IIC.DataCount != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是第8行将索引值设为-1，在中断处理函数中根据这个值决定是否从IICDS寄存器中读取数据。读操作时，第一次中断发生时表示发出了地址，这时候还不能读取数据。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-中断服务程序"><a href="#S3C2410-x2F-S3C2440-IIC-中断服务程序" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 中断服务程序"></a>S3C2410&#x2F;S3C2440 IIC 中断服务程序</h3><p>IIC操作的主体在中断服务程序，它分为3部分：首先是在SRCPND、INTPND中清除中断，后面两部分分别对应于写操作、读操作。先看清除中断的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IIC中断服务程序</span></span><br><span class="line"><span class="comment">根据剩余的数据长度选择继续传输或者结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2CIntHandle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> iicSt,i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清中断</span></span><br><span class="line">    SRCPND = BIT_IIC;</span><br><span class="line">    INTPND = BIT_IIC;</span><br><span class="line"></span><br><span class="line">    iicSt = IICSTAT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iicSt &amp; <span class="number">0x8</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Bus arbitration failed\n\r&quot;</span>);&#125;         <span class="comment">//仲裁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第10、11行用来清除IIC中断的代码。需要注意的是，即使清除中断之后，IICCON寄存器中的位[4]（中断标志位）仍为1，这导致IIC传输暂停。<br>第13行读取状态寄存器IICSTAT,发生中断时有可能因为仲裁失败，在第15行对它进行处理。<br>接下来一个swicth语句，分别处理读、写操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(g_tS3C24xx_IIC.Mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> WRDATA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((g_tS3C24xx_IIC.DataCount--) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//下面两行用来恢复IIC操作，发出P信号</span></span><br><span class="line">            IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">            IICCON = <span class="number">0xaf</span>;</span><br><span class="line">            Delay(<span class="number">10000</span>);   <span class="comment">//等待一段时间以便P信号发出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        IICDS = g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据写入IICDS后，需要一段时间才能出现在SDA线上</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line"></span><br><span class="line">        IICCON = <span class="number">0xaf</span>;          <span class="comment">//恢复IIC传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>g_tS3C24xx_IIC.DataCount表示剩余等待传输的数据个数，第4行判断数据是否已经全部发送完毕：若是，则通过第7、8行发出P信号，停止传输。<br>第7行设置IICSTAT寄存器以便发出P信号，但是由于这时IICCON[4]仍为1，P信号还没有实际发出。当8行清除IICCON[4]后，P信号才真正发出。第9行等待一段时间，确保P信号已经发送完毕。<br>如果数据还没有发送完毕，第12行从缓冲区得到下一个要发送的数据，将它写入IICDS寄存器中。稍加等待之后，即可在第17行清除IICCON[4]以恢复IIC传输，这时，IICDS寄存器中的数据就会发送出去，这将触发下一个中断。<br>IIC的读操作代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(g_tS3C24xx_IIC.Mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> RDDATA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g_tS3C24xx_IIC.Pt == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这次中断是在发送IIC设备地址后发生的，没有数据</span></span><br><span class="line">            <span class="comment">//只接收一个数据时，不要发出ACK信号</span></span><br><span class="line">            g_tS3C24xx_IIC.Pt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(g_tS3C24xx_IIC.DataCount == <span class="number">1</span>)</span><br><span class="line">                IICCON = <span class="number">0x2f</span>;      <span class="comment">//恢复IIC传输，开始接收数据，接收数据时不发出ACK</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                IICCON = <span class="number">0xaf</span>;      <span class="comment">//恢复IIC传输，开始接收数据</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((g_tS3C24xx_IIC.DataCount--) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++] = IICDS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面两行用来恢复IIC操作，发出P信号</span></span><br><span class="line">            IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">            IICCON = <span class="number">0xaf</span>;</span><br><span class="line">            Delay(<span class="number">10000</span>);   <span class="comment">//等待一段时间以便P信号发出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++] = IICDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收最后一个数据时，不要发出ACK信号</span></span><br><span class="line">        <span class="keyword">if</span>(g_tS3C24xx_IIC.DataCount == <span class="number">0</span>)</span><br><span class="line">            IICCON = <span class="number">0x2f</span>;          <span class="comment">//恢复IIC传输，接收到下一数据时无ACK</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            IICCON = <span class="number">0xaf</span>;          <span class="comment">//恢复IIC传输，接收到下一数据时发出ACK</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读操作比写操作多了一个步骤：第一次中断发生时表示发出了地址，这时候还不能读取数据，在代码中要分辨这点。对应第5-15行：如果g_tS3C24xx_IIC.P等于-1，表示这是第一次中断，然后修改g_tS3C24xx_IIC.Pt为0，并设置IICCON寄存器恢复IIC传输（第10-14行）。<br>当数据传输开始后，每接收到一个数据就会触发一次中断。后面的代码读取数据，判断所有的数据是否已经完成：如果完成就发出P信号，否则就继续下一次传输。<br>第17行判断数据是否已经全部接收完毕：若是，先通过第19行将当前数据从IICDS寄存器中取出存入缓冲区，然后通过22、23行发出P信号停止传输。<br>第22行设置IICSTAT寄存器以便发出P信号，但是由于这时IICCON[4]仍为1，P信号没有实际发出。第23行清除IICCON[4]后，P信号才真正发出。第24行等待一段时间，确保P信号已经发送完毕。<br>第28-25用来启动下一个数据的接收。<br>第28行将当前数据从IICDS寄存器中取出存入缓存区中。<br>第31-35行判断是否只剩下最后一个数据了：若是，就通过第32行中清除IICCON[4]、IICCON[7]，这样即可恢复IIC传输，并使得接收到数据后，S3C2410&#x2F;S3C2440不发出ACK信号（这样从机即可知道数据传输完毕）；否则，在第34行中只要清除IICCON[4]以恢复IIC传输。<br>中断服务程序中，当数据传输完毕时，g_tS3C24xx_IIC.DataCount将自减为-1，这样，i2c_read或i2c_write函数即可跳出等待，直接返回。</p>
<h3 id="RTC芯片M41t11特性相关的操作"><a href="#RTC芯片M41t11特性相关的操作" class="headerlink" title="RTC芯片M41t11特性相关的操作"></a>RTC芯片M41t11特性相关的操作</h3><p>M41t11.c文件中提供两个函数M41t11_set_datetime、M41t11_get_datetime，前者用来设置日期和时间，后者用来读取日期与时间。它们都通过调用i2c_read或i2c_write函数来完成与M41t11的交互。<br>前面说过，操作M41t11只需要两个步骤：发出寄存器地址，发出数据或读出数据。M41t11_set_datetime函数把这两个步骤合为一个IIC写操作。M41t11_get_datetime函数先发起一个IIC写传输，再发起一个IIC读传输。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写M41t11、设置日期与时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">M41t11_set_datetime</span><span class="params">(<span class="keyword">struct</span> rtc_time *dt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> leap_yr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtc_registers</span> <span class="title">rtc</span>;</span></span><br><span class="line">    &#125;__attribute__((packed)) addr_and_regs;</span><br><span class="line">    ... ... <span class="comment">/*设置rtc结构，即根据传入的参数构造各寄存器的值*/</span></span><br><span class="line">    i2c_write(<span class="number">0xD0</span>,(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;addr_and_regs,<span class="keyword">sizeof</span>(addr_and_regs));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略号表示的代码用来设置addr_and_regs结构。这个结构分为两部分：addr_and_regs.addr表示M41t11寄存器地址（它被设为0），addr_and_regs.rtc表示M41t11的8个寄存器。<br>根据传入的参数填充好addr_and_regs结构之后，就可以启动IIC写操作了。“<strong>attribute</strong>((packed))”设置这个结构体为紧凑格式，使得它的大小为9Byte（否则按照内存对齐的规则为12Byte）：1个字节用来保存寄存器地址，8个字节用来保存8个寄存器的值。<br>第12行发起一次IIC写操作，将addr_and_regs结构中的数据发送给M41t11：M41t11会把接收到的第一个数据当作寄存器的起始地址，随后是要写入寄存器的数据。<br>M41t11_get_datetime函数的代码与M41t11_set_datetime函数类似，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">读取M41t11，获取日期与时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">M41t11_get_datetime</span><span class="params">(<span class="keyword">struct</span> rtc_time *dt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> addr[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_registers</span> <span class="title">rtc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;rtc,<span class="number">0</span>,<span class="keyword">sizeof</span>(rtc));</span><br><span class="line"></span><br><span class="line">    i2c_write(<span class="number">0xD0</span>,addr,<span class="number">1</span>);</span><br><span class="line">    i2c_read(<span class="number">0xD0</span>,(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;rtc,<span class="keyword">sizeof</span>(rtc));</span><br><span class="line"></span><br><span class="line">    ... ...<span class="comment">/*根据读出的各寄存器的值，设置dr结构*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第12行发起一次IIC写传输，设置要操作的M41t11寄存器地址为0。<br>第13行发起一次IIC读传输，读出M41t11各寄存器的值。<br>省略号对应的代码根据读出的各寄存器的值，设置dr结构。M41t11下中以BCD码表示日期与时间，需要转换为程序使用的一般二进制格式。</p>
<h2 id="IIC实例的连接脚本"><a href="#IIC实例的连接脚本" class="headerlink" title="IIC实例的连接脚本"></a>IIC实例的连接脚本</h2><p>本实例要用到第8章NAND Flash控制器的函数将代码从NAND Flash复制到SDRAM中。由于nand代码中用到了全局变量，而全局变量要运行于可读写的内存中，为了方便，使用连接脚本将这些初始化代码放在Steppingstone中。<br>连接脚本为i2c.lds,内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    . = <span class="number">0x00000000</span>;</span><br><span class="line">    .init : AT(<span class="number">0</span>) &#123;head.o init.o nand.o&#125;</span><br><span class="line">    . = <span class="number">0x30000000</span>;</span><br><span class="line">    .text : AT(<span class="number">4096</span>) &#123; *(.text) &#125;</span><br><span class="line">    .rodata <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span> : <span class="title function_">AT</span><span class="params">((LOADADDR(.text) + SIZEOF(.text) + <span class="number">3</span>) &amp;~ (<span class="number">0x03</span>))</span> &#123; *(.rodata*) &#125; </span><br><span class="line">    .data <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>  : <span class="title function_">AT</span><span class="params">((LOADADDR(.rodata) + SIZEOF(.rodata) + <span class="number">3</span>) &amp;~ (<span class="number">0x03</span>))</span> &#123; *(.data) &#125;</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>   : &#123;*(.bss) *(COMMON) &#125;</span><br><span class="line">    __bss_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2-3行将head.S、init.c和nand.c对应的代码的运行地址设为0，加载地址（存在NAND Flash上的地址）设为0。从NAND Flash启动时，这些代码被复制到Steppingstone后就可以直接运行。<br>第4行设置其余代码的运行地址为0x3000000；第5行将代码段的加载地址设为4096，表示代码段将存在NAND Flash地址4096处。<br>第6-7行的“AT(…)”设置rodata段，data段的加载地址依次位于代码段之后。“LOADADDR(…)”表示某段的加载地址，“SIZEOF(…)”表示它的大小。这两行的前面使用“ALIGN(4)”使得它们的运行地址为4字节对齐，为了使各段之间加载地址的相对偏移值等于运行地址的相对偏移值，需要将“AT(…)”中的值也设为4字节对齐：先加上3，然后与~(0x03)进行与操作（将低2位设为0）。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第12章 IIC</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式编程基础知识</title>
    <url>/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第3章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解交叉编译工具链的各种选项</li>
<li>掌握连接脚本的编译方法</li>
<li>了解Makefile文件中常用的函数</li>
<li>了解几个常用的ARM汇编指令</li>
<li>了解汇编程序调用C函数所遵循的ATPCS规则</li>
</ol>
<h1 id="交叉编译工具选项说明"><a href="#交叉编译工具选项说明" class="headerlink" title="交叉编译工具选项说明"></a>交叉编译工具选项说明</h1><p>源文件需要经过编译才能生成可执行文件。在Windows上进行开发时，只需要单击几个按钮即可编译，集成开发环境已经将各种编译工具的使用封装好了。Linux下也有很多优秀的集成开发工具，但是更多的是时候是直接使用编译工具；即使使用集成开发工具，也需要掌握一些编译选项。<br>PC上的编译工具链为gcc、ld、objcopy、objdump等，它们编译出来的程序在x86平台上运行。要编译出在ARM平台上运行的程序，必须要使用交叉编译工具arm-linux-gcc、arm-linux-ld。</p>
<h2 id="arm-linux-gcc选项"><a href="#arm-linux-gcc选项" class="headerlink" title="arm-linux-gcc选项"></a>arm-linux-gcc选项</h2><p>一个c&#x2F;c++文件需要经过预处理，编译，汇编，链接等4步才能变成可执行文件。</p>
<ol>
<li>预处理<br>c&#x2F;c++源文件中，以”#“开头的命令被称为预处理命令。如包含命令”#include“，宏定义命令”#define“，条件编译命令”#if“，”#ifdef“等。预处理就是将要包含的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些代码输入到一个”.i“文件中等待进一步处理。预处理将要用到arm-linux-cpp工具。</li>
<li>编译<br>编译就是把c&#x2F;c++代码”翻译“汇编代码，所用到的工具为ccl（它的名字就是ccl，而不是arm-linux-ccl）。</li>
<li>汇编<br>汇编就是将第二步输出的汇编代码翻译成一定格式的机器代码，在Linux系统上一般表现为ELF（OBJ文件），用到的工具为arm-linux-as。”反汇编“是指将机器代码转换为汇编代码，这在调试程序时常常用到。</li>
<li>连接<br>连接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件连接起来，最终生成可以在特定平台运行的可执行文件，用到的工具是arm-linux-ld。<br>编译器利用这4个步骤中的一个或者多个来处理输入文件，源文件的后缀名表示源文件所用的语言，后缀名控制着编译器的默认动作。</li>
</ol>
<table>
<thead>
<tr>
<th>后缀名</th>
<th>语言种类</th>
<th>后期操作</th>
</tr>
</thead>
<tbody><tr>
<td>.c</td>
<td>c源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.C</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cc</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cxx</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.m</td>
<td>Object-C 源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.i</td>
<td>预处理后的c文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.ii</td>
<td>预处理后的c++文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.s</td>
<td>汇编语言源程序</td>
<td>汇编</td>
</tr>
<tr>
<td>.S</td>
<td>汇编语言源程序</td>
<td>预处理、汇编</td>
</tr>
<tr>
<td>.h</td>
<td>预处理器文件</td>
<td>通常不出现在命令行上</td>
</tr>
</tbody></table>
<p>其他后缀名的文件被传递给连接器（linker），通常包括一下两种：<br>.o：目标文件（Object file，OBJ文件）。<br>.a：归档库文件（Archive file）。<br>在编译过程中，除非使用了”-c“，”-S“,或者”-E“选项，或者编译错误组织了完整的编译过程，否则最后的步骤总是连接。在连接阶段中，所有对应于源程序的.o文件、”-l“选项指定的库文件、无法识别的文件名（包括指定的”.o“目标文件和”.a“库文件）按命令行中的顺序传递给连接器。<br>以一个简单的”Hello World“C程序为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*File : hello.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用arm-linux-gcc，只需要一个命令就可以生成可执行文件hello，它包含了4个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>加上”-v“选项，可以查看编译的细节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ccl hello.c -o /tmp/cctETob7.s</span><br><span class="line">as -o /tmp/ccvv2KbL.o /tmp/cctETob7.s</span><br><span class="line">collect2 -o hello   crtl.o  crti.o  crtbegin.o /tmp/ccvv2KbL.o crtend.o crtn.o</span><br></pre></td></tr></table></figure>
<p>以上三个命令分别对应于编译步骤中的预处理+编译、汇编和连接，ld被collect2调用来连接程序。预处理和编译被放在了一个命令中（ccl）进行，可以把它再次拆分为一下两步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp -o hello.i hello.c</span><br><span class="line">ccl hello.i -o /tmp/cctETob7.s</span><br></pre></td></tr></table></figure>
<p>可以通过各种选项来控制arm-linux-gcc的动作，下面介绍一些常用的选项。</p>
<h3 id="总体选项"><a href="#总体选项" class="headerlink" title="总体选项"></a>总体选项</h3><ol>
<li>-c<br>预处理、编译和汇编源文件，但是不作连接，编译器根据源文件生成OBJ文件。默认情况下，GCC通过用”.o“替换文件名的后缀”.c“，”.i“，”.s“等，产生OBJ文件名。可以使用”-o“选项选择其他名字。GCC忽略”-c“选项后面任何无法识别的输入文件。</li>
<li>-S<br>编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。默认情况下，GCC通过用”.s“替换源文件名后缀”.c“，”.i“等，产生汇编文件名。可以使用”-o“选项选择其他名字。GCC忽略任何不需要汇编的输入文件。</li>
<li>-E<br>预处理后即停止，不进行编译。预处理后的代码送往标准输出。GCC忽略任何不需要预处理的输入文件。</li>
<li>-o file<br>指定输出文件为file。无论下是预处理、编译、汇编还是连接，这个选项都可以使用，</li>
<li>-v<br>显示制作GCC工具自身时的配置命令；同时显示编译器驱动程序、预处理器、编译器的版本号。<br>以一个程序为例，它包含三个文件：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">File:main.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main fun\n&quot;</span>);</span><br><span class="line">    sub_fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File:sub.h</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">File:sub.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pintf(<span class="string">&quot;Sub fun\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用上述命令进行编译：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
其中，main.o、sub.o是经过了预处理、编译、汇编后生成的OBJ文件，它们还没有被连接成可执行文件；最后一步将它们连接成可执行文件test，可以直接运行以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Main fun</span><br><span class="line">Sub fun</span><br></pre></td></tr></table></figure>
现在试试其他选项，以下命令生成的main.s是main.c的汇编语言文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -S -o main.s  main.c</span><br></pre></td></tr></table></figure>
以下命令对main.c进行预处理，并将得到的结果打印出来，里面包含了所有包含的文件、所有定义的宏。在编写程序时，有时候查找某个宏定义是非常繁琐的事情，可以使用”-dM-E“选项来查看。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -E main.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="警告选项"><a href="#警告选项" class="headerlink" title="警告选项"></a>警告选项</h3><p>”-Wall“选项基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明前就使用的函数、局部变量除了声明就没有再使用等。<br>编译上面的main.c文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -Wall -c main.c</span><br></pre></td></tr></table></figure>
<p>得到的警告信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.c:In function &quot;main&quot;</span><br><span class="line">main.c:6 warning: unused variable &quot;i&quot;</span><br></pre></td></tr></table></figure>
<p>这个警告虽然对程序没有坏的影响，但是有些警告需要加以关注，比如匹配类型的警告等。</p>
<h3 id="调试选项"><a href="#调试选项" class="headerlink" title="调试选项"></a>调试选项</h3><p>-g: 加入只有GDB才使用的额外调试信息。</p>
<h3 id="优化选项"><a href="#优化选项" class="headerlink" title="优化选项"></a>优化选项</h3><ol>
<li>-O或者-O1<br>优化：对于大多数函数，优化编译的过程将占用较长的时间和相当大的内存。不使用”-O“选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的。如果在两条语句之间用断点中止程序，可以对任何变量进行赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确获取所期待的结果。<br>不使用”-O“或者”-O1“选项时，只有声明了register的变量才分配使用寄存器。<br>使用了”-O“或者”-O1“选项时，编译器会试图减少目标码的大小和执行时间。如果指定了”-O“或者”-O1“选项，”-fthread-jumps“和”-fdefer-pop“选项被打开。在有delay slot的机器上，”-fdelayed-branch“选项将被打开。在既没有帧指针又支持调试的机器上，”-fomit-frame-pointer“选项将被打开。某些机器上还可能打开其他选项。</li>
<li>-O2<br>多优化一些。除了涉及空间和速度的优化选项，执行几乎所有的优化工作。例如不进行循环展开和函数内嵌。和”-O“选项相比，这个选项既增加了编译时间，也提高了生成代码的运行效果。</li>
<li>-O3<br>优化的更多，除了打开”-O2“所做的一切，它还打开了”-finline-functions“选项。</li>
<li>-O0<br>不优化。<br>如果指定了多个”-O0“选项，不管带不带数字，生效的是最后一个选项。</li>
</ol>
<h3 id="链接器选项"><a href="#链接器选项" class="headerlink" title="链接器选项"></a>链接器选项</h3><p>下面的选项用于连接OBJ文件，输出可执行文件或者库文件。</p>
<ol>
<li>object-file-name<br>如果某些文件没有特别明确的后缀。GCC就认为它是OBJ文件或者库文件。如果GCC执行连接操作，这些OBJ文件就会成为连接器的输入文件。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
main.o和sub.o就是输入的文件。</li>
<li>-llibrary<br>连接名为library的库文件。<br>连接器在搜索标准目录中寻找这个库文件，库文件的真正名字”liblibrary.a“。搜索目录除了一些系统标准目录外，还包括用户以”-L“选项指定的路径。一般来说用这个方法找到的文件就是<code>库文件---即由OBJ文件组成的归档文件</code>。连接器处理归档文件的方法是：扫面归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义。但是，如果连接器普通的OBJ文件，而不是库文件，就把这个OBJ文件按照平常方式连接进来。指定”-l“选项和指定文件名的唯一区别是，”-l“选项用”lib“和”.a“把library包裹起来，而且搜索一些目录。<br>即使不明显的使用”-llibrary“选项，一些默认的库也被连接进去，可以使用”-v“选项看到这点。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker /lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtl.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../ctri.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtbegin.o</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o</span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtend.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtn.o</span><br></pre></td></tr></table></figure>
可以看见，除了main.o、sub.o两个文件外，还连接了启动文件crtl.o、crti.o、crtend.o、crtn.o，还有一些库文件（-lgcc、-lgcc_eh、-lc、-lgcc、-lgcc_eh）。</li>
<li>-nostartfiles<br>不连接系统标准启动文件，而标准库文件依然正常使用：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -nostartfiles -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/ld:warning:cannot find entry symbol _start;defaulting to 08048184</span><br></pre></td></tr></table></figure>
可以看见启动文件ctll.o、ctri.o、crtend.o、crtn.o没有被连接进去。需要说明的是，对于一般应用程序，这些启动文件是必须的，这里仅是作为例子（这样编译出来的test文件无法执行）。在编译bootloader、内核时，将用到这个选项。</li>
<li>-nostdlib<br>不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器，这个选项常用于编译内核，bootloader等程序，它们不需要启动文件，标准库文件。仍以options程序作为例子：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">/usr/bin/ld:warning:cannot find entry symbol _start;defaulting to 08048074</span><br><span class="line">main.o(.text + 0x19):In function &quot;main&quot;:</span><br><span class="line">:undefined referendce to &quot;printf&quot;</span><br><span class="line">sub.o(.text + 0xf):In function &quot;sub_fun&quot;:</span><br><span class="line">:undefined reference to &quot;printf&quot;</span><br><span class="line">collect2:ld returned 1 exit status</span><br></pre></td></tr></table></figure>
出现了一大堆错误，因为printf等函数是在库文件中实现的。在编译bootloader、内核时，用到这个选项，它们用的很多函数都是自包含的。</li>
<li>-static<br>在支持动态连接的的系统上阻止连接共享库。<br>仍以options程序作为例子,使用和不使用”-static“选项编译出来的可执行程序大小相差巨大：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.c</span><br><span class="line">$ gcc -c -o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br><span class="line">$ gcc -o test_static mian.o sub.o -static </span><br><span class="line">$ ls -l test test_static</span><br><span class="line">6591 test</span><br><span class="line">546479 test_static</span><br></pre></td></tr></table></figure>
其中test文件为6591字节，test_static为546479字节。当不使用”-static“编译文件时，程序执行前要连接共享库文件，所以还需要将共享库文件放入文件系统中。</li>
<li>-shared<br>生成一个共享OBJ文件，它可以和其他OBJ文件连接产生可执行文件。只有部分系统支持该选项。<br>当不想以源代码发布程序时，可以使用”-shared“选项生成库文件，比如对于options程序，可以如下制作库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure>
以后要使用sub.c中的sub_fun时，在连接程序时，将sub.a加入即可。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure>
可以将多个文件制作为一个库文件，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub.o sub2.o sub3.o</span><br></pre></td></tr></table></figure></li>
<li>-Xlinker option<br>把选项option传递给连接器。可以用来传递系统特定的连接选项，GCC无法识别这些选项。如果需要传递携带参数的选项，必须使用两次”-Xlinker“，一次传递选项，另一次传递其参数。例如，如果传递”-arsset-definitions“，要写成”-Xlinker -assert -Xlinker definitions“，而不能写成”-Xlinker -assert definitions“。因为这样会把整个字符串当作一个参数传递，显然不是连接器期待的。</li>
<li>-Wl，option<br>把选项option传递给连接器 。如果option中含有逗号，就在逗号处分割成多个选项。连接器通常都是通过gcc，arm-linux-gcc等命令间接启动的，要向他传入参数时，参数前面加上”-Wl,“。</li>
<li>-u symbol<br>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义。可以使用多个”-u“选项，各自跟上不同的符号，使得连接器调入附加的模块。</li>
</ol>
<h3 id="目录选项"><a href="#目录选项" class="headerlink" title="目录选项"></a>目录选项</h3><p>下列选项指定搜索路径，用于查找头文件，库文件或者编译器的某些成员。</p>
<ol>
<li>-Idir<br>在头文件的搜索路径列表添加dir目录。头文件的搜索方法为：如果以”#include &lt;&gt;“包含文件，则只会在标准库目录开始搜索（包括使用-Idir选项定义的目录）；如果以”#include “包含文件，则先从用户的工作目录开始搜索，再搜索标准库目录。</li>
<li>-I-<br>任何在”-I-“前面用”-I“选项指定的搜索路径只适用于”#include ’file‘“这种情况；它们不能用来搜索”#include&lt;&gt;“包含的头文件。如果用”-I“选项指定的搜索路径位于”-I-“选项后面，就可以在这些路径中搜索所有的”#include“指令。”-I-“选项能够阻止当前目录成为搜索”#include ’file‘“的第一选择。</li>
<li>-Ldir<br>在”-L“选项的搜索路径中添加dir目录，仍然使用options程序进行说明，先制作库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o libsub.a sub.o</span><br></pre></td></tr></table></figure>
编译main.c：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br></pre></td></tr></table></figure>
连接程序，下面的指令将会出错，提示找不到库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o -lsub</span><br><span class="line">/usr/bin/ld: cannot find lsub</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
可以使用”-Ldir“选项将当前目录加入搜索路径，如下则连接成功：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -L. -o test main.o -lsub</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-ld选项"><a href="#arm-linux-ld选项" class="headerlink" title="arm-linux-ld选项"></a>arm-linux-ld选项</h2><p>arm-linux-ld将用于多个目标文件、库文件连接成可执行文件。</p>
<h3 id="直接指定代码段、数据段、bss段的起始地址"><a href="#直接指定代码段、数据段、bss段的起始地址" class="headerlink" title="直接指定代码段、数据段、bss段的起始地址"></a>直接指定代码段、数据段、bss段的起始地址</h3><p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure>
<p>其中的”startaddr“分别代表代码段、数据段和bss段的起始地址，它是一个十六进制数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure>
<p>它代表的代码段的运行地址为0x00000000，<code>由于没有定义数据段、bss段的起始地址，它们被依次放在代码段的后面</code>。<br>以一个例子来说明”-Ttext“选项的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text </span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">  b step1</span><br><span class="line">step1:</span><br><span class="line">  ldr pc, =step2</span><br><span class="line">step2:</span><br><span class="line">  b step2 </span><br></pre></td></tr></table></figure>
<p>使用下面的命令编译、连接、反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -c -o link.o link.s</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 link.o -o  link_elf_0x00000000</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 link.o -o  link_elf_0x30000000</span><br><span class="line">arm-lihux-objdump -D link_elf_0x00000000 &gt; link_0x00000000.dis</span><br><span class="line">arm-lihux-objdump -D link_elf_0x30000000 &gt; link_0x30000000.dis</span><br></pre></td></tr></table></figure>
<p>例子中用到了两种跳转方法：b跳转指令、直接向pc寄存器赋值。先列出不同“-Ttext”选项下生成的反汇编文件，在详细分析由于不同运行地址带来的差异及影响。两个反汇编文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_0x00000000.dis                       link_0x30000000.dis</span><br><span class="line">0: eaffffff b 0x4                         0: eaffffff b 0x4</span><br><span class="line">4: e59ff000 ldr pc, [pc, #0]              4: e59ff000 ldr pc, [pc, #0]</span><br><span class="line">8: eafffffe b 0x8                         8: eafffffe b 0x8</span><br><span class="line">c: 00000008 andeq r0, r0, r8              c: 30000008 tsteq r0, #8 ; 0x8</span><br></pre></td></tr></table></figure>
<p>“b step1”是个相对跳转指令，其机器码的格式如下：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpeg" alt="img not found"></p>
<ol>
<li>[31:28]位是条件码。</li>
<li>[27:24]位为“1010”时，表示b跳转指令；为“1011”时，表示b1跳转指令。</li>
<li>[23::0]表示偏移地址。<br>使用“b”或者“b1”跳转时，下一条指令的地址是这样计算的：将指令中24位带符号的补码扩展为32位（扩展其符号位），将此32位数左移两位，将得到的值加到pc寄存器中，将得到跳转的目标地址。</li>
</ol>
<p>“b step1”的机器码为eaffffff。</p>
<ol>
<li>24位带符号的补码为0xffffff，将它扩展为32位得到0xffffffff。</li>
<li>将此32位数左移两位得到0xfffffffc，其值就是-4.</li>
<li>pc的值是当前指令下的下两条指令的地址，加上步骤2得到的-4，这恰好是第二条指令step1的地址。<br>请不要被反汇编代码的“b 0x4”迷惑。它不是指跳转到0x4处执行，绝对地址需要按照上述3个步骤计算。可以发现，b跳转指令依赖于当前PC寄存器的值，这个特性使得使用b指令的程序不依赖于代码存储的位置—即不管这条代码放在什么位置，b指令都可以跳到正确的位置。这类指令称为位置无关码。使用不同的“-Ttext”选项，生成的代码仍旧是一样的。<br>“ldr pc, &#x3D;step2”，从汇编码“ldr pc, [pc, #0]”可以看出，这条指令从内存中的某个位置读出数据，并赋值给PC寄存器。这个位置的地址是当前pc寄存器的值加上偏移量0。其中存放的值依赖于连接命令的“-Ttext”选项。执行这条指令之后，对于link_0x00000000.dis，pc &#x3D; 0x0000000；对于link_0x30000000.dis，pc &#x3D; 0x30000008。执行第三条指令“b step2”后，程序的运行地址就不同了：分别是0x00000008、0x30000008。<br>Bootloader、内核程序刚开始执行时，它们所处的地址通常不等于运行地址。在程序的开头，先使用b、bl、mov等“位置无关”的指令将代码从Flash等设备复制到内存的“运行地址”处，然后再跳转到“运行地址”去执行。</li>
</ol>
<h3 id="使用连接脚本设置地址"><a href="#使用连接脚本设置地址" class="headerlink" title="使用连接脚本设置地址"></a>使用连接脚本设置地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-ld -Ttimer.lds -o timer_elf head.o init.o interrupt.o main.o</span><br></pre></td></tr></table></figure>
<p>它使用连接脚本timer.lds来设置可执行文件timer_elf的地址信息，timer.lds文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  . = 0x30000000;</span><br><span class="line">  .text             : &#123;   *(.text)    &#125;</span><br><span class="line">  .rodata ALIGN(4)  : &#123;   *(rodata)   &#125;</span><br><span class="line">  .data   ALIGN(4)  : &#123;   *(data)     &#125;</span><br><span class="line">  .bss    ALIGN(4)  : &#123;   *(bss)  *(COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析timer.lds文件之前，先讲解连接脚本的格式。连接脚本的基本命令是SECTIONS命令，它描述了输出文件的映射图：输出文件中各段、各文件怎么怎么放置。一个SECTIONS命令内部包含一个或者多个段。段（Section）是连接脚本的基本单元，它表示输入文件中的某部分怎么放置。<br>完整的连接脚本格式如下，它的核心部分是段（Section）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">secname start ALIGN(align)  (NOLOAD)  : AT(ldadr)</span><br><span class="line">  &#123; contents  &#125; &gt; region :phdr =fill</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>secname 和 contents是必需的，前者用来命名这个段。后者用来确定代码中的什么部分放在这个段中。<br>start是这个段重定位地址，也称为运行地址。如果代码中有位置无关的指令，程序在运行时，这个段必须放在这个地址上。<br>ALIGN(align)：虽然start指定了运行地址，但是仍然可以使用BLOCK（align）来指定对齐的要求—这个对齐的地址才是真正的运行地址。<br>（NOLOAD）：用来告诉加载器，在运行时不用加载这个段。显然，这个选项只有在操作系统的情况下才有意义。<br>AT（ldadr）：指定这个段在编译出来的映像文件中的地址—加载地址。如果不使用这个选项，则加载地址等于运行地址。通过这个选项，可以控制各段分别保存输出文件中不同的位置，便于把文件保存到单板上：A段放在A处，B段放在B处，运行前再把A、B段分别读出来组装成一个完整的执行程序。<br>现在开始分析下timer.lds文件：</p>
<ol>
<li>第2行表示设置“当前运行地址”为0x30000000。</li>
<li>第3行定义了一个名为“.text”的段，它的内容为“* （.text）”，表示所有输入文件的代码段。这些代码段被集合在一起，起始运行地址为0x30000000。</li>
<li>第4行定义了一个名为“.rodata”的段，在输出文件timer_elf中，它紧挨着“.text”段存放。其中“ALIGN（4）”表示起始运行地址为4字节对齐。假设前面“.text”段的地址范围是0x30000000-0x300003f1，则“.rodata”段的地址为4字节对齐后的0x300003f4。</li>
<li>第5、6行的含义与第4行类似。</li>
</ol>
<h2 id="arm-linux-objcopy选项"><a href="#arm-linux-objcopy选项" class="headerlink" title="arm-linux-objcopy选项"></a>arm-linux-objcopy选项</h2><p>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可以使用不同于源文件的格式来输出目的文件，即可以进行格式转换。<br>这本书中，常用arm-linux-objcopy来将ELF格式的可执行文件转换为二进制文件。下面讲解常用的选项：</p>
<ol>
<li>input-file、outfile<br>参数input-file和outfile分别表示输入目标文件和输出目标文件。</li>
<li>-I bfdname 或 –input-target&#x3D;bfdname<br>用来指明源文件的格式，bfdname是BFD库中描述的标准格式名。如果不指明源文件格式，arm-linux-objcopy会自己去分析源文件的格式，然后去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</li>
<li>-O bfdname 或 –output-target&#x3D;bfdname<br>使用指定的格式来输出文件，bfdname是BFD库中描述的的标准格式名。</li>
<li>-F bfdname 或 –target&#x3D;bfdname<br>同时指明源文件和目的文件的格式。将源文件的内容复制到目的文件的过程中，只进行复制而不做格式转换，源文件是什么格式，目的目标文件就是什么格式。</li>
<li>-R sectionname 或 –remove-section&#x3D;sectionname<br>从输出文件中删除掉所有名为sectionname的段。这个选项可以多次使用。</li>
<li>-S 或 –strip-all<br>不从源文件复制重定位信息和符号信息到目标文件中去。</li>
<li>-g 或 –strip-debug<br>不从源文件中复制调试符号到目标文件中去。<br>在编译bootloader、内核时，常用arm-linux-objcopy命令将ELF格式的生成结果转换为二进制文件，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-objcopy -O binary -S elf_file bin_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-objdump选项"><a href="#arm-linux-objdump选项" class="headerlink" title="arm-linux-objdump选项"></a>arm-linux-objdump选项</h2><p>arm-linux-objdump用于显示二进制文件信息，本书中常用来查看反汇编代码。下面讲解常用的选项：</p>
<ol>
<li>-b bfdname 或 –target&#x3D;bfdname<br>指定目标码格式。这不是必须的，arm-linux-objdump能自动识别许多格式。可以使用“arm-linux-objdump -i”命令查看支持的目标码格式。</li>
<li>–disassemble 或 -d<br>反汇编可执行段。</li>
<li>–disassemble 或 -D<br>反汇编所有段。</li>
<li>-EB或-EL或–endian&#x3D;{big|little}<br>指定字节序。</li>
<li>–file-headers或-f<br>显示文件的整体头部摘要信息。</li>
<li>–section-headers、–header或-h<br>显示目标文件各个段的头部摘要信息。</li>
<li>–info或-i<br>显示支持的目标文件格式和CPU架构，它们在“-b”、“-m”选项中用到。</li>
<li>–section&#x3D;name或-j name<br>仅显示指定section的信息。</li>
<li>–architecture&#x3D;machine或-m machine<br>指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候，这个选项很有用。可以用“-i”选项列出这里能够指定的架构。<br>在调试程序时，常用arm-linux-objdump命令来得到汇编代码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将ELF格式的文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D elf_file &gt; dis_file</span><br><span class="line">/*将二进制文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D -b binary -m arm bin_file &gt; dis_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="汇编代码、机器码和存储器的关系以及数据的表示"><a href="#汇编代码、机器码和存储器的关系以及数据的表示" class="headerlink" title="汇编代码、机器码和存储器的关系以及数据的表示"></a>汇编代码、机器码和存储器的关系以及数据的表示</h2><p>即使使用C&#x2F;C++或者其他高级语言编程，最后也会被编译工具转换为汇编代码，并最终作为机器码存储在内存、硬盘或者其他存储器上。在调试程序时，经常需要阅读它的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4bc:        e3a0244e: mov r2, #1308622848;</span><br><span class="line">4c0:        e3a0344e: mov r3, #1308622848;</span><br><span class="line">4c4:        e5933000: ldr r3, [r3];</span><br></pre></td></tr></table></figure>
<p>4bc、4c0、4c4是这些代码的运行地址，就是说运行前，这些指令必须位于内存中的这些地址上；e3a0244e、e3a0344e、e5933000是机器码。运行地址、机器码都是十六进制表示。CPU用到的、内存中保存的都是机器码示意如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*内存中的示意图*/</span><br><span class="line">/*地址:机器码*/</span><br><span class="line">···</span><br><span class="line">0x4bc:0xe3a0244e</span><br><span class="line">0x4c0:0xe3a0344e</span><br><span class="line">0x4c4:0xe5933000</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>“mov r2, #1308622848”、“mov r3, #1308622848”、“ldr r3, [r3]”是上述几个机器码的汇编代码。所谓汇编代码仅仅是为了方便读写而引入的，机器码和汇编代码之间也仅仅是简单的转换关系。参考CPU的数据手册，ARM的数据处指令格式为：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.jpeg" alt="img not found"><br>以机器码0xe3a0244e为例：</p>
<ol>
<li>[31:28] &#x3D; 0b1110，表示这条指令无条件执行。</li>
<li>[25] &#x3D; 0b1，表示Operand2是一个立即数。</li>
<li>[24:21] &#x3D; 0b1101，表示这是MOV指令。</li>
<li>[20] &#x3D; 0b0，表示这条指令执行时不影响状态位。</li>
<li>[15:12] &#x3D; 0b0010，表示Rd就是r2寄存器。</li>
<li>[11:0] &#x3D; 0x44e，这是一个立即数。<br>立即数占据机器码的低12位表示：最低8位的值称为immed_8，高4位称为rotate_imm。立即数的数值计算方法为：<value> &#x3D; immed_8 循环右移 （2 * rotate_imm）。对于”[11:0] &#x3D; 0x44e“，其中immed_8 &#x3D; 0x4e、rotate_imm&#x3D;0x4，所以此立即数为0x4e000000。</value></li>
</ol>
<h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>在Linux中使用Make命令来编译程序，特别是大程序；而make命令所执行的动作依赖与Makefile文件。最简单的Makefile文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello：hello.c</span><br><span class="line">  gcc -o hello hello.c</span><br><span class="line">clean:</span><br><span class="line">  rm -rf hello</span><br></pre></td></tr></table></figure>
<p>将上述4行存为Makefile文件（注意必须以Tab键来进行缩进第2、4行，不能以空格来进行缩进），执行make即可编译程序，执行make clean即可清除编译出来的结果。<br>make命令根据文件更新的时间戳来决定哪些文件需要重新编译，这使得可以避免编译已经编译过的、没有变化的程序，大大提高编译效率。</p>
<h2 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h2><p>一个简单的Makefile文件包含一系列”规则“，其样式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标（target）...：依赖（prerequiries）...</span><br><span class="line">&lt;Tab&gt;命令（command）</span><br></pre></td></tr></table></figure>
<p>目标（target）通常是要生成的文件的名称，可以是可执行文件或者OBJ文件，也可以是一个执行的动作名称，诸如”clean“。<br>依赖是用来产生目标的材料（比如源文件），一个目标通常有几个依赖。<br>命令是生成目标时的动作，一个规则可以含有几个命令，每个命令占一行。<br>通常，如果一个依赖发生了变化，就需要规则调整命令以更新或者创建目标。但是并非所有的目标都有依赖，例如，目标”clean“的作用就是清除文件，它没有依赖。<br>规则一般是用于解释怎样和何时重建目标。make首先调用命令处理依赖，进而才能创建或者更新目标。当然，一个规则也可以是用于解释怎样和何时执行一个动作，即打印提示信息。<br>一个Makefile文件可以包含规则以外的其他文本，但一个简单的Makefile文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但是格式是完全一样的。<br>对于上述Makefile，执行”make“命令时，仅当hello.c文件比hello文件新，才会执行命令”arm-linux-gcc -o hello hello.c“生成可执行文件hello；如果还没有hello文件，这个命令也会执行。<br>运行”make clean“，由于目标没有依赖项，它的命令“rm -f hello”将被强制执行。</p>
<h2 id="Makefile文件里的赋值方法"><a href="#Makefile文件里的赋值方法" class="headerlink" title="Makefile文件里的赋值方法"></a>Makefile文件里的赋值方法</h2><p>变量的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">immediate = deferred</span><br><span class="line">immediate ?= deferred</span><br><span class="line">immediate := immediate</span><br><span class="line">immediate += deferred or immediate</span><br><span class="line">define immediate</span><br><span class="line">deferred</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>在GNU make中对变量的赋值有两种方式：延时变量、立即变量。区别在于它们的定义方式和扩展时的方式不同，前者在这个变量使用时才会扩展开，意思就是当真正使用这个变量时才会确定；后者在定义时它的值就已经确定了。使用“&#x3D;”、“?&#x3D;”定义或者使用define指定定义的变量是延时变量；使用“：&#x3D;”定义的变量是立即变量。需要注意一点的的是“?&#x3D;”仅仅在变量没有定义的情况下有效，即“?&#x3D;”用来定义第一次出现的延时变量。对于附加操作符“+&#x3D;”，右边变量如果在前面使用（：&#x3D;）定义为立即变量则它也是立即变量，否则均为延时变量。</p>
<h2 id="Makefile常用函数"><a href="#Makefile常用函数" class="headerlink" title="Makefile常用函数"></a>Makefile常用函数</h2><p>函数调用的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(function arguments)</span><br></pre></td></tr></table></figure>
<p>这里“function”是函数名，“arguments”是该函数的参数。参数与函数名之间用空格或者Tab隔开，如果有多个参数，它们之间用逗号隔开。这些空格和逗号不是参数值的一部分。下面介绍一些常用的Makefile函数。</p>
<h3 id="字符串替换和分析函数"><a href="#字符串替换和分析函数" class="headerlink" title="字符串替换和分析函数"></a>字符串替换和分析函数</h3><ol>
<li>$ (subst from,to,text)<br>在文本“text”中使用“to”替换每一处“from”。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (subst ee,EE,feet on the street)</span><br><span class="line">==&gt;fEEt on the strEEt</span><br></pre></td></tr></table></figure></li>
<li>$ (patsubst pattern,replacement,text)<br>寻找“text”中符合格式“pattern”的字，用“replacement”替换它们。“pattern”和“replacement”中可以使用通配符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (patsubst %.c,%.o,x.c.c bar.c)</span><br><span class="line">==&gt;x.c.o bar.o</span><br></pre></td></tr></table></figure></li>
<li>$ (strip string)<br>去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (strip a   b c )</span><br><span class="line">==&gt;a b c</span><br></pre></td></tr></table></figure></li>
<li>$ (findstring find,in)<br>在字符串“in”中查找“find”，如果找到，则返回值是“find“，否则返回值为空。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(findstring a,a b c)</span><br><span class="line">==&gt;a</span><br><span class="line">$(findstring a,b c)</span><br><span class="line">==&gt;</span><br></pre></td></tr></table></figure></li>
<li>$(filter pattern…,text)<br>返回在”text“中由空格隔开且匹配格式”pattern…“的字，去除不符合格式”pattern…“的字。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;foo.c bar.c baz.s</span><br></pre></td></tr></table></figure></li>
<li>$(filter-out pattern…,text)<br>返回在”text“中由空格隔开并且不匹配格式”pattern…“的字，去除符合格式”pattern…“的字。它是函数filter的反函数。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;ugh.h</span><br></pre></td></tr></table></figure></li>
<li>$(sort list)<br>将”list“中的字按照字母顺序排列，并去掉重复的字。输出由单个空格隔开的字的列表。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(sort foo bar lose)</span><br><span class="line">==&gt;bar foo lose</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文件名函数"><a href="#文件名函数" class="headerlink" title="文件名函数"></a>文件名函数</h3><ol>
<li>$(dir names…)<br>抽取”names…“中每一个文件名的路径部分，文件名的路径部分包括从文件名的首字符到最后一个斜杠之前的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/ ./</span><br></pre></td></tr></table></figure></li>
<li>$(notdir names…)<br>抽取”names…“中每一个文件名的除路径之外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;foo.c hacks</span><br></pre></td></tr></table></figure></li>
<li>$(suffix names…)<br>抽取”names…“中每一个文件名的后缀。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;.c</span><br></pre></td></tr></table></figure></li>
<li>$(basename names…)<br>抽取”names…“中每一个文件名除后缀以外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/foo hacks</span><br></pre></td></tr></table></figure></li>
<li>$(addsuffix suffix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；suffix是一个后缀名。将suffix（后缀）的值附加在每一个独立文件的后面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(addsuffix .c,foo bar)</span><br><span class="line">==&gt;foo.c bar.c</span><br></pre></td></tr></table></figure></li>
<li>$(addprefix prefix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；prefix是一个前缀名。将prefix（前缀）的值附加在每一个独立文件的前面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line">==&gt;src/foo  src/bar</span><br></pre></td></tr></table></figure></li>
<li>$(wildcard pattern)<br>参数”pattern“是一个文件名格式，包含有通配符（通配符和shell的用法一样）。函数wildcard的结果是一列和格式匹配且真实存在的文件的名称，文件名之间用一个空格隔开。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_src := $(wildcard *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ol>
<li>$(foreach var,list,text)<br>前两个参数，”var“和”list“将首先扩展，最后一个参数”text“此时不扩展；接着，”list“扩展得到的每个字都赋值给”var“变量；然后，”text“引用该变量进行扩展，因此”text“每次扩展都不相同。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirs := a b c d</span><br><span class="line">files := $(foreach dir,$(dir),$(wildcard $(dir)/*))</span><br><span class="line">==&gt;</span><br><span class="line">$(wildcard a/*)</span><br><span class="line">$(wildcard b/*)</span><br><span class="line">$(wildcard c/*)</span><br><span class="line">$(wildcard d/*)</span><br></pre></td></tr></table></figure></li>
<li>$(if condition,then-part[,else-part])<br>首先把第一个参数”condition“的前导空格、结尾空格去掉，然后扩展。如果扩展为非空字符产，则条件”condition“为真，那么计算第二个参数”then-part“的值，并将之作为函数的返回值。如果condition为假，并且第三个参数存在，则计算第三个参数”else-part“的值，并将该值作为函数得返回值。如果第三个参数不存在，则返回空。</li>
<li>$(origin variable)<br>变量”variable“是一个查询变量的名称，不是对改变量的引用。所以不能采用”$“和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。函数的返回值如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined                     :变量”variable“从未被定义；</span><br><span class="line">default                       :变量”variable“是默认定义；</span><br><span class="line">environment                   :变量”variable“作为环境变量定义，选项”-e“没有打开；</span><br><span class="line">environment override          :变量”variable“作为环境变量定义，选项”-e“已打开；</span><br><span class="line">file                          :变量”variable“在Makefile中定义；</span><br><span class="line">command line                  :变量”variable“在命令行中定义；</span><br><span class="line">override                      :变量”variable“在Makefile中用override指令定义；</span><br><span class="line">automatic                     :变量”variable“是自动变量。</span><br></pre></td></tr></table></figure></li>
<li>$(shell command arguments)<br>函数shell是Makefile与外部环境通信的工具。函数shell的执行结果和在控制台上执行”command arguments“的结果相似。不过如果”command arguments“的结果含有换行符，则在函数shell的返回结果中将它们处理为单个空格，若返回结果最后是换行符或者回车符则被去掉。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_src := $(shell ls *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure>
下面以一个Makefile为例进行演示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File:Makefiel</span><br><span class="line">src :=  $(shell ls *.c)</span><br><span class="line">objs := $(patsubst  %.c,%.o,$(src))</span><br><span class="line"></span><br><span class="line">test: $(objs)</span><br><span class="line">  gcc -o  $@  $^</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">  gcc -c -o $@  $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -rf test *.o</span><br></pre></td></tr></table></figure>
上述Makefile中”$@“、”$^“、”$&lt;“称为自动变量。”$@“表示规则的目标文件名；”$^“表示所有依赖的名字，名字中间用空格隔开；”$&lt;“表示第一个依赖的文件名。<br>已知当前目录下的所有文件为Makefile、main.c、sub.c、sub.h。<br>第一行src变量的值为”main.c sub.c“。<br>第二行objs变量的值为”main.o sub.o“。<br>第四行实际上就是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test  : main.o sub.o</span><br></pre></td></tr></table></figure>
目标test的依赖项是main.o sub.o。开始时这两个文件还没有生成，在执行文件生成test的命令前先将main.o、sub.o作为目标查找合适的规则，以生成main.o、sub.o。<br>第七八行就是用来生成main.o、sub.o的规则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.o : main.c</span><br><span class="line">  gcc -c -o main.o main.c</span><br><span class="line"></span><br><span class="line">sub.o : sub.c</span><br><span class="line">  gcc -c -o sub.o sub.c</span><br></pre></td></tr></table></figure>
这样，test的依赖main.o和sub.o就生成了。</li>
</ol>
<h1 id="常用ARM汇编指令及ATPCS规则"><a href="#常用ARM汇编指令及ATPCS规则" class="headerlink" title="常用ARM汇编指令及ATPCS规则"></a>常用ARM汇编指令及ATPCS规则</h1><p>在嵌入式开发中，汇编程序常常用于非常关键的地方，比如系统启动时的初始化，进出中断时的环境保存、恢复，对性能要求非常苛刻的函数等。</p>
<ol>
<li>相对跳转指令b、bl<br>这两条指令的不同之处在于bl指令除了跳转之外，还将返回地址（bl的下一条指令的地址）保存在lr寄存器中。<br>这两条指令的可跳转范围是当前指令的前后32M。<br>它们是位置无关的指令。<br>使用示例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  b fun1</span><br><span class="line">  ...</span><br><span class="line">fun1:</span><br><span class="line">  bl fun2</span><br><span class="line">  ...</span><br><span class="line">fun2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>数据传送指令mov，地址读取伪指令ldr<br>mov指令可以把一个寄存器的值赋值给另一个寄存器赋给另一个寄存器，或者把一个常数赋值给寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*r1 = r2*/</span><br><span class="line">mov r1,r2</span><br><span class="line"></span><br><span class="line">/*r1 = 4096*/</span><br><span class="line">mov r1,#4096</span><br></pre></td></tr></table></figure>
mov传送的常数必须能用立即数来表示。<br>当不知道一个数能否用”立即数“来表示时，可以使用ldr命令来赋值。ldr是伪指令，它不是真实存在的指令，编译器会把它扩展成真正的指令：如果该常数能用”立即数“来表示，则使用mov指令；否则编译时将该常数保存在某个位置，使用内存读取指令把它读出来。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*r1 = 4097*/</span><br><span class="line">ldr r1, =4097</span><br><span class="line"></span><br><span class="line">/*r1 = label的绝对地址*/</span><br><span class="line">ldr r1, =label</span><br><span class="line">label:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>内存访问指令:ldr,str,ldm,stm<br>ldr指令从内存中读取数据到寄存器，str指令把寄存器的值存储到内存，它们操作的数据都是32位的。示例如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将地址为r2+4的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2,#4]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1,然后r2 = r2 + 4*/</span><br><span class="line">ldr r1,[r2],#4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*将r1的数据保存到地址为r2 + 4的内存单元*/</span><br><span class="line">str r1,[r2,#4]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元*/</span><br><span class="line">str r1,[r2]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元，然后r2 = r2 + 4*/</span><br><span class="line">str r1,[r2],#4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ldm和stm属于批量内存访问指令，只用一条指令就可以读写多个数据。它们的格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br><span class="line">stm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br></pre></td></tr></table></figure>
其中{cond}表示地址变化模式，有以下4种模式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ia (Increment After):事后递增模式</span><br><span class="line">ib (Increment Before):事先递增模式</span><br><span class="line">da (Decrement After):事后递减模式</span><br><span class="line">db (Decrement Before):事先递减模式</span><br></pre></td></tr></table></figure>
<rn>中保存内存的地址，如果在后面加上了感叹号，指令执行后，rn的值会更新，等于下一个内存单元的地址。<br><register list>表示寄存器列表，对于ldm指令，从<rn>所对应的内存块取出数据。写入这些寄存器；对于stm指令，把这些寄存器的值写入<rn>所对应的内存块中。<br>{^}有两种含义：如果<register list>中有PC寄存器，它表示指令执行后，spsr寄存器的值将自动复制到cpsr寄存器中—这常用于从中断处理函数返回；如果<register list>中没有pc寄存器，它表示操作的是用户模式下的寄存器，而不是当前特权模式的寄存器。<br>指令中寄存器列表和内存单元的对应关系为：编号低的寄存器对应内存中的低地址单元，编号高的寄存器对应内存中的高地址单元。</register></register></rn></rn></register></rn></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HandleIRQ:                @中断入口函数</span><br><span class="line">  sub lr,lr,#4            @计算返回地址</span><br><span class="line">  stmdb sp!,&#123;r0-r12,lr&#125;   @保存使用到的寄存器，r0-r12,lr被保存在sp表示的内存中，”!“使得指令执行后sp=sp-14*4</span><br><span class="line">  ldr lr, =int_return     @设置调用Handle_IRQ函数后的返回地址</span><br><span class="line">  ldr pc, =IRQ_Handle     @调用中断返回函数</span><br><span class="line"></span><br><span class="line">int_return:</span><br><span class="line">  ldmia sp!,&#123;r0-r12,pc&#125;^  @中断返回，”^“表示将spsr的值复制到cpsr，于是从irq模式返回被中断的工作模式。”!“使得指令执行后sp = sp + 14*4</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加减指令：add、sub<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add r1,r2,#1 /*表示r1 = r2 + 1,即寄存器r1的值等于r2的值加上1*/</span><br><span class="line">sub r1,r2,#1 /*表示r1 = r2 - 1*/</span><br></pre></td></tr></table></figure></li>
<li>程序状态字寄存器的访问指令：msr、mrs<br>ARM处理器有一个程序状态字寄存器cpsr，它用来控制处理器的工作模式、设置中断的总开关。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msr cpsr,r0 /*复制r0到cpsr中*/</span><br><span class="line">mrs r0,cpsr /*复制cpsr到r0中*/</span><br></pre></td></tr></table></figure></li>
<li>其他伪指令<br>在本书的汇编程序中，常常见到如下语句：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.extern main</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure>
”.extern“定义一个外部符号（可以是变量也可以是函数），上面的代码表示本文件中引用的main是一个外部函数。<br>”.text“表示下面的语句都属于代码段。<br>”.global“将本文件的某个程序标号定义为全局的，比如下面的代码表示_start是个全局函数。</li>
<li>汇编指令的执行条件<br>大多数ARM指令都可以条件执行，即根据cpsr寄存器中的条件标志决定执行该指令：如果条件不满足，该指令相当于一条nop指令。<br>每条ARM指令包含4位的条件域码，这表明可以定义16个执行条件。可以将这些执行条件的助记符附加在汇编指令后，如moveq，movgt等。</li>
</ol>
<table>
<thead>
<tr>
<th>条件码</th>
<th>助记符</th>
<th>含义</th>
<th>cpsr中条件标志位</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>eq</td>
<td>相等</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>0001</td>
<td>ne</td>
<td>不相等</td>
<td>Z&#x3D;0</td>
</tr>
<tr>
<td>0010</td>
<td>cs&#x2F;hs</td>
<td>无符号数大于&#x2F;等于</td>
<td>C&#x3D;1</td>
</tr>
<tr>
<td>0100</td>
<td>mi</td>
<td>负数</td>
<td>N&#x3D;1</td>
</tr>
<tr>
<td>0101</td>
<td>pl</td>
<td>非负数</td>
<td>N&#x3D;0</td>
</tr>
<tr>
<td>0110</td>
<td>vs</td>
<td>上溢出</td>
<td>V&#x3D;1</td>
</tr>
<tr>
<td>0111</td>
<td>vc</td>
<td>没有上溢出</td>
<td>V&#x3D;0</td>
</tr>
<tr>
<td>1000</td>
<td>hi</td>
<td>无符号数大于</td>
<td>C&#x3D;1 &amp;&amp; Z&#x3D;0</td>
</tr>
<tr>
<td>1001</td>
<td>ls</td>
<td>无符号数小于等于</td>
<td>C&#x3D;0</td>
</tr>
<tr>
<td>1010</td>
<td>ge</td>
<td>带符号数大于等于</td>
<td>N&#x3D;1,V&#x3D;1</td>
</tr>
<tr>
<td>1011</td>
<td>lt</td>
<td>带符号数小于</td>
<td>N&#x3D;1,V&#x3D;0</td>
</tr>
<tr>
<td>1100</td>
<td>gt</td>
<td>带符号数大于</td>
<td>Z&#x3D;0 &amp;&amp; N&#x3D;V</td>
</tr>
<tr>
<td>1101</td>
<td>le</td>
<td>带符号数小于&#x2F;等于</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>1110</td>
<td>al</td>
<td>无条件执行</td>
<td>-</td>
</tr>
<tr>
<td>1111</td>
<td>nv</td>
<td>从不执行</td>
<td>-</td>
</tr>
</tbody></table>
<p>表中的cpsr条件标志位N、Z、C、V分别表示Negative、Zero、Cary、Overflow。影响条件标志位的因素比较多，比如比较指令cmp、cnm、teq及tst等。</p>
<h2 id="ARM-THUMB子程序调用规则ATPCS"><a href="#ARM-THUMB子程序调用规则ATPCS" class="headerlink" title="ARM-THUMB子程序调用规则ATPCS"></a>ARM-THUMB子程序调用规则ATPCS</h2><p>为了使C语言程序和汇编程序之间能够相互调用，必须为子程序之间的调用制定规则，在ARM处理器中，这个规则被称为ATPCS：ARM程序和Thumb程序中子程序的调用的规则。<br>基本的ATPCS规则包括寄存器使用规则、数据栈使用规则、参数传递规则等。</p>
<h3 id="寄存器使用规则"><a href="#寄存器使用规则" class="headerlink" title="寄存器使用规则"></a>寄存器使用规则</h3><p>ARM处理器中有r0-r15共16个寄存器，它们的用途有一些约定的习惯，并依据这些这些用途定义了别名。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>别名</th>
<th>使用规则</th>
</tr>
</thead>
<tbody><tr>
<td>r15</td>
<td>pc</td>
<td>程序计数器</td>
</tr>
<tr>
<td>r14</td>
<td>lr</td>
<td>连接寄存器</td>
</tr>
<tr>
<td>r13</td>
<td>sp</td>
<td>数据栈指针</td>
</tr>
<tr>
<td>r12</td>
<td>ip</td>
<td>子程序内部调用的scratch寄存器</td>
</tr>
<tr>
<td>r11</td>
<td>v8</td>
<td>ARM状态局部变量寄存器8</td>
</tr>
<tr>
<td>r10</td>
<td>v7、sl</td>
<td>ARM状态局部变量寄存器7、在支持数据栈检查的ATPCS中为数据栈限定指针</td>
</tr>
<tr>
<td>r9</td>
<td>v6、sb</td>
<td>ARM状态局部变量寄存器6、在支持RWPI的ATPCS中为静态基址寄存器</td>
</tr>
<tr>
<td>r8</td>
<td>v5</td>
<td>ARM状态局部变量寄存器5</td>
</tr>
<tr>
<td>r7</td>
<td>v4、wr</td>
<td>ARM状态局部变量寄存器4、Thumb状态工作寄存器</td>
</tr>
<tr>
<td>r6</td>
<td>v3</td>
<td>ARM状态局部变量寄存器3</td>
</tr>
<tr>
<td>r5</td>
<td>v2</td>
<td>ARM状态局部变量寄存器2</td>
</tr>
<tr>
<td>r4</td>
<td>v1</td>
<td>ARM状态局部变量寄存器1</td>
</tr>
<tr>
<td>r3</td>
<td>a4</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器4</td>
</tr>
<tr>
<td>r2</td>
<td>a3</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器3</td>
</tr>
<tr>
<td>r1</td>
<td>a2</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器2</td>
</tr>
<tr>
<td>r0</td>
<td>a1</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器1</td>
</tr>
</tbody></table>
<p>寄存器的使用规则总结如下：</p>
<ol>
<li>子程序间通过寄存器r0-r3来传递参数，这时可以使用它们的别名a0-a3。被调用的子程序返回前无须恢复r0-r3的内容。</li>
<li>在子程序中，使用r4-r11来保存局部变量，这时可以使用它们的别名v1-v8。如果在子程序中使用了它们的某些寄存器，子程序进入时需要保存这些寄存器的值，在返回时需要恢复它们；对于子程序没有使用到的寄存器，则不必进行这些操作。在Thumb程序中，通常只能使用寄存器r4-r7来保存局部变量。</li>
<li>寄存器r12用作子程序间scratch寄存器，别名ip。</li>
<li>寄存器r13用作数据栈指针，别名sp。在子程序中寄存器r13不能用作其他用途。它的值在进入、退出子程序时必须相等。</li>
<li>寄存器r14称为连接寄存器，别名lr。它用于保存子程序的返回地址。如果在子程序中保存了返回地址（比如将lr的值保存到数据栈中），r14可以用作其他用途。</li>
<li>寄存器r15是程序计数器，别名pc。它不能用作其他用途。</li>
</ol>
<h3 id="数据栈使用规则"><a href="#数据栈使用规则" class="headerlink" title="数据栈使用规则"></a>数据栈使用规则</h3><p>数据栈有两个增长方向：向内存地址减小的方向增长时，称为DESCENDING栈；向内存增加的方向增长时，称为ASCENDING栈。<br>所谓数据栈的增长就是移动栈指针。当栈指针指向栈顶元素时，称为FULL栈；当栈指针指向栈顶元素相邻的一个空的数据单元时，称为EMPTY栈。<br>使用stmdb命令往数据栈保存内容时，先递减sp指针，再保存数据，使用ldmia命令从数据栈恢复数据时，先获得数据，再递增sp指针，sp指针总是指向栈顶元素。</p>
<h3 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h3><p>一般来说，当参数个数不超过4个时，使用r0-r3这4个寄存器来传递参数；如果参数超过4个，剩余的参数通过数据栈来传递。<br>对于一般的返回结果，通常使用a0-a3来传递。示例：<br>假设CopyCode2SDRAM函数是用C语言实现的，它的数据原型如下：<br>int CopyCode2SDRAM(unsigned char *buf,unsigned long start_addr,int size);<br>在汇编代码中，使用下面的代码调用它，并判断返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldr r0,=0x30000000</span><br><span class="line">mov r1,#0</span><br><span class="line">mov r2,#16*1024</span><br><span class="line">bl CopyCode2SDRAM</span><br><span class="line">cmp a0,#0</span><br></pre></td></tr></table></figure>
<p>第一行将r0设为0x30000000，则CopyCode2SDRAM函数执行时，它的第一个参数buf的指向的内存地址是0x30000000。<br>第二行将r1设为0，CopyCode2SDRAM函数的第二个参数start_addr等于0。<br>第三行将r2设为16x1024，CopyCode2SDRAM函数的第三个参数size等于16x1024。<br>第五行判断返回值。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第3章 嵌入式编程基础知识</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>MMU</title>
    <url>/2022/08/15/MMU/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第7章总结归纳</p>
<span id="more"></span>
<h1 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h1><ol>
<li>了解虚拟地址和物理地址的关系</li>
<li>掌握如何通过设置MMU来控制虚拟地址到物理地址的转化</li>
<li>了解MMU的内存访问权限机制</li>
<li>了解TLB、Cache、Write Buffer的原理，使用时的注意事项</li>
<li>实例</li>
</ol>
<h1 id="内存管理单元MMU介绍"><a href="#内存管理单元MMU介绍" class="headerlink" title="内存管理单元MMU介绍"></a>内存管理单元MMU介绍</h1><h2 id="S3C2410-x2F-S3C2440-MMU特性"><a href="#S3C2410-x2F-S3C2440-MMU特性" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU特性"></a>S3C2410&#x2F;S3C2440 MMU特性</h2><p>内存管理单元（Memory Management Unit）简称MMU，它负责虚拟地址收到物理地址的映射，并提供硬件机制的内存访问权限检查。现代的多用户多进程操作系统通过MMU使得各个用户进程都拥有自己独立的地址空间：地址映射功能使得各进程拥有看起来一样的地址空间，而内存访问权限的检查可以保护每个进程所用的内存不会被其他破坏。</p>
<ol>
<li>与ARM V4兼容的映射长度、域、访问权限检查机制。</li>
<li>4种映射长度：段（1MB）、大页（64KB）、小页（4KB）、极小页（1KB）。</li>
<li>对每段都可以设置访问权限。</li>
<li>大页、小页的每个子页（sub-page，被映射页的1&#x2F;4）都可以设置单独的访问权限。</li>
<li>硬件实现的16个域。</li>
<li>指令TLB（含64个条目）、数据TLB（含64个条目）。</li>
<li>硬件访问页表（地址映射、权限检查有硬件自动进行）。</li>
<li>TLB条目中替换采用round-robin算法（也称cyclic算法）。</li>
<li>可以使无效整个TLB。</li>
<li>可以单独使无效某个TLB。</li>
<li>可以在TLB中锁定某个条目，指令TLB、数据TLB相互独立。<br>重点在于页表的结构与建立、映射的过程。</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-MMU地址变换过程"><a href="#S3C2410-x2F-S3C2440-MMU地址变换过程" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU地址变换过程"></a>S3C2410&#x2F;S3C2440 MMU地址变换过程</h2><h3 id="地址的分类"><a href="#地址的分类" class="headerlink" title="地址的分类"></a>地址的分类</h3><p>以前的程序是非常小的，可以全部装入内存。随着技术的发展，出现了以下两种情况：</p>
<ol>
<li>有的程序很大，它所要求的内存，超过了内存总容量，不能一次性装入内存。</li>
<li>多道系统中有很多程序需要同时执行，它们要求的内存超过了内存总容量，不能把所有程序都装入内存。<br>实际上，一个程序在运行前，没有必要全部装入内存，而仅需要将那些当前需要运行的部分先装入内存，其余部分在用到时再从磁盘调入，而当内存耗光时再将暂时不用的部分调出到磁盘。这使得一个大程序可以在较小的内存空间中运行，这也使得内存中可以同时装入更多的程序并发执行，从用户的角度看，该系统所具有的内存容量将比实际内存容量大得多，人们把这样的存储器称为虚拟存储器。<br>虚拟存储器从逻辑上对内存容量进行了扩充，用户看到的大容量只是一种感觉，是虚的，在32位的CPU系统中，这个虚拟内存地址范围为0-0xFFFFFFFF，我们把这个地址范围称为虚拟地址空间，其中某个地址称为虚拟地址。与虚拟地址空间、虚拟地址对应的是物理地址空间、物理地址，它们对应实际的内存。<br>虚拟地址空间最终需要转化为物理地址才能读写实际的数据，这通过将虚拟地址空间、物理地址空间划分为同样大小的一块块小空间（段或页），然后为这两类小空间建立映射关系。由于虚拟地址空间远大于物理空间，有可能多块虚拟地址空间映射到同一块物理地址空间，或者有些虚拟地址空间没有映射到具体的物理地址空间上去（可以使用到时再映射）。<br><img src="/2022/08/15/MMU/1.jpeg" alt="img not found"></li>
</ol>
<p>ARM CPU上的地址转换涉及3个概念：虚拟地址（Virtual Address）、变换后的虚拟地址（Modified Virtual Address）、物理地址（Physical Address）。<br>没启动MMU时，CPU核、cache、MMU、外设等所有部件使用的都是物理地址。<br>启动MMU后，CPU核对外发出虚拟地址VA；VA被转换为MVA供cache、MMU使用，再这里MVA被转换为PA；最后使用PA读写实际设备（S3C2410&#x2F;S3C2440内部寄存器或外界的设备）：</p>
<ol>
<li>CPU看到的、用到的只是虚拟地址VA，至于VA如何最终落实到物理地址PA上，CPU核是不理会的。</li>
<li>而caches和MMU也是看不到VA的，它们利用有MVA转换得到PA。</li>
<li>而实际设备看不到VA，MVA，它们读写时使用的是物理地址PA。<br>MVA是除CPU核外的其他部分看见的虚拟地址，VA与MVA之间的变化关系如图所示：<br><img src="/2022/08/15/MMU/2.jpeg" alt="img not found"><br>如果VA&lt;32M，需要使用进程标识号（PID）通过读CP15的c13获得来转换MVA。VA与MVA的转换方式如下（这是硬件自动完成的）：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (VA &lt; <span class="number">32</span>M) then</span><br><span class="line">    MVA = VA | (PID &lt;&lt; <span class="number">25</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    MVA = VA</span><br></pre></td></tr></table></figure>
利用PID生成MVA的目的是为了减少切换进程时的代价；不使用MVA而直接使用VA的话，当两个进程使用的虚拟地址空间VA有重叠时，在切换进程时为了把重叠的VA映射到不同的PA上去，需要重建页表、使无效caches和TLBS等，代价很大。使用MVA后，进程切换就省事多了：假设两个进程1、2运行时的VA都是0-32M，但是它们的MVA并不重叠，分别是0x02000000-0x03FFFFFF、0x04000000-0x05FFFFFF，这样就不必进行重建页表工作了。</li>
</ol>
<h3 id="虚拟地址到物理地址的转换过程"><a href="#虚拟地址到物理地址的转换过程" class="headerlink" title="虚拟地址到物理地址的转换过程"></a>虚拟地址到物理地址的转换过程</h3><p>将一个虚拟地址转换为物理地址，一般有两个办法：用一个确定的数学公式进行转换或用表格存储虚拟地址对应的物理地址。这类表格称为页表（Page Table），页表由一个个条目（Entry）组成；每个条目存储了一段虚拟地址对应的物理地址及其访问权限，或者下一级页表地址。<br>在AMR CPU中使用的第二种方法。S3C2410&#x2F;S3C2440最多会用到两级页表：以段（1MB）的方式进行转换时只用到一级页表，以页（Page）的方式进行转换时用到两级页表。页的大小由3种：大页（64KB）、小页（4KB）、极小页（1KB）。条目也称为”描述符“（Descriptor），有段描述符、大页描述符、小页描述符、极小页描述符–它们保存段、大页、小页或极小页的起始物理地址：粗页表描述符、细页表描述符–它们保存二级页表的物理地址。<br>大概的转换过程如下：</p>
<ol>
<li>根据给定的虚拟地址找到一级页表中的条目。</li>
<li>如果此条目是段描述符，则返回物理地址，转换结束。</li>
<li>否则如果此条目是二级页表描述符，继续利用虚拟地址在此二级页表找到下一个条目。</li>
<li>如果第二个条目是页描述符，则返回物理地址，转换结束。</li>
<li>其他情况出错。</li>
</ol>
<p><img src="/2022/08/15/MMU/3.jpeg" alt="img not found"><br>图中的“TTB base”代表一级页表的地址，将它写入协处理器CP15的寄存器C2（页表基址寄存器）即可。一级页表的地址必须是16K对应的（[14:0]为0）。<br><img src="/2022/08/15/MMU/4.jpeg" alt="img not found"><br>先介绍一级页表，32位的CPU的虚拟地址空间达到4GB，一级页表使用4096个描述符来表示这4GB空间—每个描述符对应1MB的虚拟地址，要么存储了它对应的1MB物理空间的起始地址，要么存储了下一级页表的地址。使用MVA[31:20]来索引一级页表，得到一个描述符，每个描述符占用4字节，如下图所示：<br><img src="/2022/08/15/MMU/5.jpeg" alt="img not found"><br>根据一级页表描述符的最低两位，可分为以下4种：</p>
<ol>
<li>0b00：无效。</li>
<li>0b01：粗页表（Coarse page table）<br>位[31:10]称为粗页表基址（Coarse page table base address），此描述符的低10位填充0后就是一个二级页表的物理地址。此二级页表含256个条目（所以大小为1KB），称为粗页表。其中每个条目表示大小为4KB的物理地址空间，所以一个粗页表表示1MB的物理地址空间。</li>
<li>0b10：段（Section）<br>位[31:20]称为段基址（Section Base），此描述符的低20位填充0后就是一块1MB的物理地址空间的起始地址。MVA[19:0]用来在这1MB的空间中寻址。所以，描述符的位[31:20]和MVA[19:0]就构成了这个虚拟地址MVA对应的物理地址。<br>以段的方式进行映射时，虚拟地址MVA到物理地址PA的转换过程如下：<br><img src="/2022/08/15/MMU/6.jpeg" alt="img not found"><br>①页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到段描述符。<br>②取出段描述符的位[31:20]—段基址，它和MVA[19:0]组成一个32位的物理地址–这就是MVA对应的PA。</li>
<li>0b11：细页表（Fine page table）<br>位[32：12]称为细页表基址（Fine page table base address），此描述符的低12位填充0后就是一个二级页表的物理地址。此二级页表含1024个条目（所以大小为4KB），称为细页表。其中每个条目表示大小为1KB的物理地址空间，所以一个细页表表示1MB的物理地址空间。<br>以大页（64KB）、小页（4KB）或极小页（1KB）进行地址映射时，需要用到两级页表。二级页表有粗页表、细页表两种，二级页表中描述符的格式如下：<br><img src="/2022/08/15/MMU/7.jpeg" alt="img not found"><br>根据二级描述符的最低两位，可分为以下4种情况：<br>①0b00：无效。<br>②0b01：大页描述符。<br>位[31:16]称为大页基址（Large page base address），此描述符的低16位填充0后就是一块64KB物理地址空间的起始地址。粗页表每个条目只能表示4KB的物理空间，如果大页描述符保存在粗页表中，则连续16个条目都保存同一个大页描述符。类似的，细页表中每个条目只能表示1KB的物理空间，如果大页描述符保存在细页表中，则连续64个条目都保存同一个大页描述符。<br>下面以保存在粗页表中的大页描述符为例，说明地址转换的过程：<br><img src="/2022/08/15/MMU/8.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到粗页表描述符。</span><br><span class="line">2. 取出粗页表描述符的位[31:10]--即粗页表基址，它和MVA[19:12]组成一个低两位为0的32位物理地址---据此即可找到大页描述符。</span><br><span class="line">3. 取出大页描述符的位[31:16]--即大页基址，它和MVA[15:0]组成一个32位的物理地址---这就是MVA对应的PA。</span><br><span class="line"></span><br><span class="line">上面的步骤2和3中，用于在粗页表中索引的MVA[19:12]、用于在大页内寻址的MVA[15:0]有重合的位：位[15:12]。当位[15:12]从0b0000变化到0b1111时，步骤2返回的大页描述符相同，所以粗页表中连续16个条目都保存同一个大页描述符。</span><br></pre></td></tr></table></figure>
③0b10：小页描述符<br>位[31:12]称为小页基址，此描述符的低12位填充0后就是一块4KB物理地址空间的起始地址。粗页表中每个条目表示4KB的物理空间，如果小页描述符保存在粗页表中，则只需要用一个条目来保存一个小页描述符。类似的，细页表中每个条目只能表示1KB的物理空间，如果小页表描述符保存在细页表中，则连续4个条目都保存同一个小页描述符。<br><img src="/2022/08/15/MMU/9.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到粗页表描述符。</span><br><span class="line">2. 取出粗页表描述符的位[31:10]--即粗页表基址，它和MVA[19:12]组成一个低两位为0的32位物理地址---据此即可找到小页描述符。</span><br><span class="line">3. 取出小页描述符的位[31:12]--即小页基址，它和MVA[11:0]组成一个32位的物理地址---这就是MVA对应的PA。</span><br><span class="line"></span><br><span class="line">小页描述符保存在细页表中，地址转换过程与上面类似，不在赘述。</span><br></pre></td></tr></table></figure>
④0b11：极小页描述符<br>位[31:10]被称为极小页基址，此描述符的低10位填充0后就是一块1KB的物理地址空间的起始地址。极小页描述符只能保存在细页表中，用一个条目来保存一个极小页描述符。<br><img src="/2022/08/15/MMU/10.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到细页表描述符。</span><br><span class="line">2. 取出细页表描述符的位[31:12]---即细页表基址。它和MVA[19:10]组成一个低两位为0的32位物理地址--据此即可找到极小页描述符。</span><br><span class="line">3. 取出极小页描述符的位[31:10]---即极小页基址，它和MVA[9:0]组成一个32位的物理地址---这是MVA对应的PA。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从段、大页、小页、极小页的地址转换过程可知。</p>
<ol>
<li>以段进行映射时，通过MVA[31:20]结合页表得到一段（1MB）的起始物理地址，MVA[19:0]用来在段中寻址。</li>
<li>以大页进行映射时，通过MVA[31:16]结合页表得到一个大页（64KB）的起始物理地址，MVA[15:0]用来在大页中寻址。</li>
<li>以小页进行映射时，通过MVA[31:12]结合页表得到一个小页（4KB）的起始物理地址，MVA[11:0]用来在大页中寻址。</li>
<li>以极小页进行映射时，通过MVA[31:10]结合页表得到一个极小页（1KB）的起始物理地址，MVA[9:0]用来在极小页中寻址。</li>
</ol>
<h2 id="内存的访问权限检查"><a href="#内存的访问权限检查" class="headerlink" title="内存的访问权限检查"></a>内存的访问权限检查</h2><p>内存的访问权限检查是MMU的主要功能之一，简单的说，它就是决定一块内存是否允许读、是否允许写。这由CP15寄存器C3（域访问控制）、描述符的域（Domain）、CP15寄存器C1的R&#x2F;S&#x2F;A位。描述符的AP位等联合作用。<br>CP15寄存器C1中的A位表示是否对地址进行对齐检查。所谓对齐检查就是，访问字（4字节的数据）时地址是否为4字节对齐。访问半字（2字节的数据）时地址是否2字节对齐，如果地址不对齐则产生”Alignment Fault“异常。无论MMU是否被开启，都可以进行对齐检查。CPU读取指令时不进行对齐检查，以字节为单位访问时也不进行对其检查。对其检查在MMU的权限检查，地址映射前进行。<br>内存的访问权限检查可以概括为一下两点：</p>
<ol>
<li>”域“决定是否对某块内存进行权限检查。</li>
<li>”AP“决定如何对某块内存进行权限检查。</li>
</ol>
<p>如图所示，S3C2410&#x2F;S3C2440有16个域，CP15寄存器C3中每两位对应一个域，用来表示这个域是否进行权限检查。图中表示CP15寄存器C3中哪两位对应哪个域，表中给出了CP15寄存器C3中这些”两位数据“的含义。<br><img src="/2022/08/15/MMU/11.jpeg" alt="img not found"></p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>无访问权限</td>
<td>任何访问都将导致”Domain Fault“ 异常</td>
</tr>
<tr>
<td>01</td>
<td>客户模式</td>
<td>使用段描述符、页描述符进行权限检查</td>
</tr>
<tr>
<td>10</td>
<td>保留</td>
<td>保留，目前相当于”无访问权限“</td>
</tr>
<tr>
<td>11</td>
<td>管理模式</td>
<td>运行任何访问</td>
</tr>
</tbody></table>
<p>下图中的”Domain“占4个字节，用来表示这块内存属于上面定义的16个域中哪一个。<br><img src="/2022/08/15/MMU/12.jpeg" alt="img not found"></p>
<ol>
<li>段描述符中的”Domain“为0b0000时，表示这1MB内存属于域0，如果域访问控制寄存器的位[1:0]等于0b00，则访问这1MB空间时都会产生”Domain fault“的异常，如果域访问控制器寄存器的位[1:0]等于0b11，则使用描述符中的”AP“位进行权限检查。</li>
<li>粗页表中的”Domain“为0b1111时，表示这1MB内存属于域15，如果域访问控制寄存器的位[31:30]等于0b00，则访问这1MB空间时都会产生”Domain fault“的异常，如果域访问控制寄存器的位[31:30]等于0b11时，则使用二级页表中的大页&#x2F;小页描述符中的”ap3“、”ap2“、”ap1“、”ap0“进行位权限检查。</li>
</ol>
<p>图中的”AP“、”ap3“、”ap2“、”ap1“、”ap0”结合CP15寄存器C1的R&#x2F;S位，决定如何进行访问权限检查。首先说明，段描述符中的“AP”控制整个段（1MB）的访问权限；大页描述符中的每个“apx”（x为0-3）控制一个大页（64KB）中1&#x2F;4内存的访问权限，即“ap3”对应大页高端的16KB，“ap0”对应大页低端的16KB；小页描述符与大页描述符相似，每个“apx”控制一个小页（4KB）的1&#x2F;4内存的访问权限；极小页中的“ap”就控制着整个极小页（1KB）的访问权限。<br>如下表所示，AP位、S位和R位的组合，可以产生多种访问权限。需要指出的是，ARM CPU有7种工作模式，其中6种属于特权模式，一种属于用户模式。在特权模式的用户模式下，相同的AP位、S位和R位的组合，其访问权限也不相同。</p>
<table>
<thead>
<tr>
<th>AP</th>
<th>S</th>
<th>R</th>
<th>特权模式</th>
<th>用户模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>0</td>
<td>0</td>
<td>无访问权限</td>
<td>无访问权限</td>
<td>任何访问都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>00</td>
<td>1</td>
<td>0</td>
<td>只读</td>
<td>无访问权限</td>
<td>在超级权限下进行读操作</td>
</tr>
<tr>
<td>00</td>
<td>0</td>
<td>1</td>
<td>只读</td>
<td>只读</td>
<td>任何写操作都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>00</td>
<td>1</td>
<td>1</td>
<td>保留</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>01</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>无访问权限</td>
<td>只允许在超级模式下访问</td>
</tr>
<tr>
<td>10</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>只读</td>
<td>在用户模式下进行写操作都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>11</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>读&#x2F;写</td>
<td>在任何模式下都允许访问</td>
</tr>
<tr>
<td>xx</td>
<td>1</td>
<td>1</td>
<td>保留</td>
<td>–</td>
<td>–</td>
</tr>
</tbody></table>
<h2 id="TLB的作用"><a href="#TLB的作用" class="headerlink" title="TLB的作用"></a>TLB的作用</h2><p>从虚拟地址到物理地址的转换过程可得知：使用一级页表进行地址转换时，每次读写数据时需要访问两次内存。第一次访问一级页表获取物理地址，第二次才是真正的读写数据。使用两级页表时，每次读写数据需要访问三次内存，访问两次页表（一级页表和二级页表）获得物理地址，第三次才是真正的读写数据。<br>上述地址的转换过程大大降低了CPU的性能，有没有说明办法改进呢？程序执行过程中，所用到的指令、数据的地址往往集中在一个很小的范围内，其中的地址数据经常多次使用，这称为程序访问的局部性。由此，通过使用一个高速、容量相对较小的存储器来存储近期用过的页表条目（段、大页、小页、极小页描述符），以避免每次地址转换都需要到主存去查找，这样可以大幅度的提高性能。这个存储器用来帮助快速的进行地址转换，称为“转译查找缓存（Translation Lookaside Buffers，TLB）”。<br>当CPU发出一个虚拟地址时，MMU首先访问TLB。如果TLB中含有能转换这个虚拟地址的描述符，则直接利用此描述符进行地址转换和权限检查；否则MMU访问页表找到描述符后再进行地址转化和权限检查，并将这个描述符填入TLB中（如果TLB已满，则利用round-robin算法找到一个条目，然后覆盖他），下次再使用这个虚拟地址时就可以直接使用TLB中的描述符了。<br>使用TLB需要保证TLB的内容与页表一致，在启动MMU之前，在页表中的内容发生变化后，尤其要注意这点。S3C2410&#x2F;S3C2440可以使无效（Invalidate）整个TLB，或者通过某个虚拟地址使无效TLB中某个条目。一般的做法是：在启动MMU之前使无效整个TLB，改变页表时，使无效所涉及的虚拟地址对应的TLB中的条目。</p>
<h2 id="Cache的作用"><a href="#Cache的作用" class="headerlink" title="Cache的作用"></a>Cache的作用</h2><p>同样基于程序访问的局部性，在主存和CPU通用寄存器之间设置一个高速的、容量相对较小的存储器，把正在执行的指令地址附近的一部分指令或数据从主存调入这个存储器，供CPU在一段时间内使用，这对提高程序的运行速度有很大的作用。这个介于主存和CPU之间的高速小容量存储器称作高速缓存存储器（Cache）。<br>启用Cache后，CPU读取数据时，如果Cache中有这个数据的复本则直接返回，否则从主存中读入数据，并存入Cache中，下次再使用（读&#x2F;写）这个数据时，可以直接使用Cache中的复本。<br>启用Cache后，CPU写数据时有写穿式和写回式两种方式：</p>
<ol>
<li>写穿式（Write Through）<br>任一从CPU发出的写信号送到Cache的同时，也写入主存，以保证主存的数据能同步更新。它的优点是操作简单，但是由于主存的慢速，降低了系统的写速度并占用总线时间。</li>
<li>回写式<br>为了克服写穿式每次写数据时都要访问主存，从而导致系统写速度降低并占用总线时间，尽量减少对主存的访问次数，又有了回写式。<br>它的工作方式：数据一般只写到Cache，这样有可能出现Cache中的数据得到更新而主存数据不变（数据陈旧）的情况。但此时可在Cache中设一标志及数据陈旧的信息，只有当Cache中的数据被换出或强制进行“清空”操作时，才将原更新的数据写入主存相应的单元中。这样保证了Cache和主存的数据一致性。</li>
</ol>
<p>下面介绍Cache的两个操作：</p>
<ol>
<li>“清空”（clean）：把Cache或Write Buffer中已经脏的（修改过，但是还未写入主存）数据写入主存。</li>
<li>“使无效”（Invalidate）：使之不能再使用，并不将脏的数据写入主存。</li>
</ol>
<p>S3C2410&#x2F;S3C2440内置了指令Cache（ICache）、数据Cache（DCache）、写缓存（Write Buffer）。下面的内容需要用到页表中描述符的C、B位，为了方便读者，先把这些描述符用下图表示出来。下文中，描述符的C位称为Ctt，B位称为Btt。<br><img src="/2022/08/15/MMU/13.jpeg" alt="img not found"></p>
<h3 id="指令Cache（ICache）"><a href="#指令Cache（ICache）" class="headerlink" title="指令Cache（ICache）"></a>指令Cache（ICache）</h3><p>ICache的使用比较简单。系统刚上电或复位时，ICache中的内容是无效的，并且ICache功能是关闭着的。往Icr位（即CP15写处理器中寄存器1的第12位）写1可以启动ICache，写0可以停止ICache。<br>ICache一般在MMU开启之后被使用，此时页表中描述符的C位用来表示一段内存是否可以被Cache。若C&#x3D;1，则允许Cache，否则不允许被Cache。但是，即使MMU没有开启，ICache也是可以被使用的，这时CPU读取指令（取指）时所涉及的内存都被当作是允许Cache的。<br>ICache被关闭时，CPU每次取指都是需要读取主存，性能非常低，所以需要尽早启动ICache。<br>ICache被开启后，CPU每次取指都会在ICache中查看是否能找到所要的指令，而不管C&#x3D;0还是C&#x3D;1。如果找到了，称为Cache命中，如果找不到，称为Cache缺失。ICache被开启后，CPU的取指分为如下三种情况：</p>
<ol>
<li>Cache命中且C&#x3D;1时，从ICache取出指令，返回CPU。</li>
<li>Cache缺失且C&#x3D;1时，CPU从主存读出指令。同时，一个称为“8-word linefill”的动作将发生，这个动作把该指令所处区域的8个word写进ICache的某个条目中。这有可能会覆盖某个条目。</li>
<li>C&#x3D;0时，CPU从主存读取指令。</li>
</ol>
<h3 id="数据Cache（DCache）"><a href="#数据Cache（DCache）" class="headerlink" title="数据Cache（DCache）"></a>数据Cache（DCache）</h3><p>与ICache相似，系统刚复位或者上电时，DCache中的内容也是无效的，并且DCache功能也是关闭的，而Write Buffer中的内容也是被废弃不用的。往Ccr（Cp15协处理器中寄存器1的第2位）写1可以启动DCache，写0可以停止DCache。Write Buffer与DCache紧密结合，没有专门的控制位来开启、停止它。<br>与ICache不同的是，DCache功能必须在MMU开启之后才能被使用，因为开启MMU之后，才能使用页表的描述符来定义一块内存如何使用DCache和Write Buffer。<br>DCache被关闭时，CPU每次读写数据时都会先在DCache中查看是否能找到所要的数据，而不管C&#x3D;0还是C&#x3D;1。找到了，称为Cache命中，没找到，称为Cache缺失。<br>下表描述了DCache和Write Buffer在CCr、Ctt、Btt的各种取值下如何工作。表中“Ctt and Ccr”一项的值是Ctt与Ccr进行逻辑与之后的值（Ctt &amp;&amp; Ccr）。</p>
<table>
<thead>
<tr>
<th>Ctt and Ccr</th>
<th>Btt</th>
<th>DCache、Write Buffer和主存的访问方式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>Non-Cached、Non-buffered（NCNB）；读写数据都是直接操作内存，并且可以被外设中止；写数据时不使用Write Buffer，CPU会等待操作完成；不会出现Cache命中</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Non-Cached、buffered（NCB）；读写数据都是直接操作主存，不会出现Cache命中；写数据时，数据先存入Write Buffer，随后写入主存；数据存入WriteBuffer后，CPU立立即继续执行；读数据时，可以被外设中止；写数据时，无法被外设中止</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Cached，write-through（WT，写通）mode；读数据时，如果Cache命中则从Cache中返回数据，不读取主存；读数据时，如果Cache确实则从读主存中返回数据，并导致“linefill”的动作；写数据时，数据先存入Write Buffer，并在随后写入主存；数据存入Write Buffer后，CPU立即继续执行；写数据时，如果Cache命中则新数据也写入Cache中；写数据时，无法被外设中止</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Cached，write-back（WB，写回）mode；读数据时，如果Cache命中则从Cache中返回数据，不读取主存；读数据时，如果Cache确实则从读主存中返回数据，并导致“linefill”的动作；写数据时，如果Cache缺失则将数据先存入Write Buffer，存储完毕后CPU立即继续执行，这些数据随后写入主存；写数据时，如果Cache命中则在Cache中更新数据，并设置这些数据为“脏”，但是不会写入主存；无论Cache命中与否，写数据都无法被外设中止。</td>
</tr>
</tbody></table>
<p>与TLB类似，使用Cache需要保证Cache、WriteBuffer的内容和主存保持一致，需要遵循以下两个原则：</p>
<ol>
<li>清空DCache，使得主存数据得到更新。</li>
<li>使无效ICache，使得CPU取值时重新读取主存。</li>
</ol>
<p>在实际编写程序前，需要注意以下几点：</p>
<ol>
<li>开启MMU之前，使无效ICache、DCache、WriteBuffer。</li>
<li>关闭MMU之前，清空ICache、DCache，即将“脏”数据写入主存。</li>
<li>如果代码有变，使无效ICache，这样CPU取指时会重新读取主存。</li>
<li>使用DMA操作可以被Cache的主存时：将内存的数据发送出去时，要清空Cache；将内存的数据读入时，要使无效Cache。</li>
<li>改变页表中地址映射关系时，也要慎重考虑。</li>
<li>开启ICache和DCache时，要考虑ICache或DCache中的内容是否与主存保持一致。</li>
<li>对于I&#x2F;O空间，不使用Cache和Write Buffer。所谓I&#x2F;O空间，就是对于其中的地址连续两次的写操作不能合并在一起，每次读写都必须直接访问设备，否则程序的运行结果无法预料。比如寄存器、非内存的外设（扩展串口、网卡等）。<br>S3C2410&#x2F;S3C2440提供了相关指令来操作Cache和Write buffer，可以使无效整个ICache或其中的条目，可以清空使无效整个DCache或其中的条目。</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440-MMU、TLB、Cache的控制指令"><a href="#S3C2410-x2F-S3C2440-MMU、TLB、Cache的控制指令" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU、TLB、Cache的控制指令"></a>S3C2410&#x2F;S3C2440 MMU、TLB、Cache的控制指令</h3><p>S3C2410&#x2F;S3C2440中，除了有一个ARM920T的CPU核之外，还有若干协处理器。协处理器也是一个微处理器，它被用来帮助主CPU来完成一些特殊功能，如浮点运算等。对MMU、TLB、Cache等的操作就涉及协处理器。CPU核与协处理器间传送数据时使用这两条指令：MRC和MCR，它们的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MCR | MRC&gt;&#123;cond&#125; p#,&lt;expression1&gt;,Rd,cn,cm,&#123;,&lt;expression2&gt;&#125;</span><br><span class="line">MRC             //从协处理器获得数据，传给ARM920T CPU核的寄存器</span><br><span class="line">MCR             //数据从ARM920T CPU核的寄存器传给协处理器</span><br><span class="line">&#123;cond&#125;          //执行条件  为空时表示无条件执行</span><br><span class="line">p#              //协处理器序号</span><br><span class="line">&lt;expression1&gt;  //一个常数</span><br><span class="line">Rd              //ARM920T核的寄存器</span><br><span class="line">cn和cm          //协处理器中的寄存器</span><br><span class="line">&lt;expression2&gt;   //一个常数</span><br></pre></td></tr></table></figure>
<p>其中，expression1、expression2、cn、cm仅供协处理器使用，它们的作用如何取决于具体的协处理器。</p>
<h1 id="MMU使用实例"><a href="#MMU使用实例" class="headerlink" title="MMU使用实例"></a>MMU使用实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本开发板的SDRAM的物理地址范围处于0x30000000-0x33ffffff，S3C2410&#x2F;S3C2440的寄存器地址范围都处于0x48000000-0x5FFFFFFF。在第五章中，通过往GPBCON和GPBDAT这两个寄存器的物理地址0x56000000、0x56000014写入特定的数据来驱动4个LED。<br>本章的实例将开启MMU，并将虚拟地址空间0xA0000000-0xA0100000映射到物理地址空间0x56000000-0x56100000上，这样，就可以通过操作地址0xA0000010、0xA0000014来达到驱动者4个LED的同样效果。<br>另外，将虚拟地址空间0xB0000000-0xB3FFFFFFF映射到物理地址空间0x30000000-0x33FFFFFF上，并在连接程序时将一部分代码的运行地址指定为0xB0004000，看看程序能否跳转到0xB0004000运行。<br>实例程序只是用一级页表，以段的方式进行地址映射。32位的CPU的虚拟地址空间达到4GB，一级页表中使用4096个描述符来表示这4GB（每个描述符对应1MB的虚拟地址），每个描述符占用4字节，所以一级页表占16KB。SDRAM的开始16KB来存放一级页表，所以剩下的内存开始物理地址为0xB0004000。<br>将程序代码分为两部分：第一部分的运行地址为0，它用来初始化SDRAM、复制第二部分的代码到SDRAM中（存放在0x30004000开始处），设置页表，启动MMU，最后跳转到SDRAM中（地址0xB0004000）去执行；第二部分的运行地址设为0xB0004000，它用来驱动LED。程序流程图如下：<br><img src="/2022/08/15/MMU/14.jpeg" alt="img not found"></p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="第一部分代码分析"><a href="#第一部分代码分析" class="headerlink" title="第一部分代码分析"></a>第一部分代码分析</h3><p>程序源码分3个文件：head.S、init.c、leds.c。</p>
<ol>
<li>head.S代码详解<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:head.S</span></span><br><span class="line"><span class="comment">功能：设置SDRAM，将第二部分代码复制到SDRAM，设置页表，启动MMU，然后跳到SDRAM继续执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_satrt:</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置栈指针，以下都是C函数，调用前需要设置好栈</span><br><span class="line">  bl  disable_watch_dog   @关闭WATCHDOG，否则CPU会不断重启</span><br><span class="line">  bl  memsetup            @设置控制存储器以使用SDRAM</span><br><span class="line">  bl  copy_2th_to_sdram   @将第二部分代码复制到SDRAM</span><br><span class="line">  bl  create_page_table   @设置页表</span><br><span class="line">  bl  mmu_init            @启动MMU</span><br><span class="line">  bl  sp,=<span class="number">0xB4000000</span>      @重设栈指针，指向SDRAM顶端（使用虚拟地址）</span><br><span class="line">  bl  pc,=<span class="number">0xB0004000</span>      @跳到SDRAM中继续执行第二部分代码</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">  b halt_loop</span><br></pre></td></tr></table></figure>
head.S调用的函数都在init.c中实现。<br>值得注意的是，在第15行开启MMU之后，无论是CPU取指还是CPU读写数据，使用的都是虚拟地址。<br>在第14行设置页表时，在create_page_table函数中令head.S、init.c程序所在的内存的虚拟地址和物理地址一样，这使得head.S和init.c中的代码在开启MMU后能够没有任何障碍的继续运行。</li>
<li>init.c代码详解<br>disable_watch_dog、memsetup两个接口已经在前两章讨论过，下面不再赘述。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">init.c：进行一些初始化，在Steppingstone中运行</span></span><br><span class="line"><span class="comment">它和head.S同属第一部分程序，此时MMU尚未开启，使用物理地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WATCHDOG寄存器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WTCON (*(volatile unsigned long *)0x53000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储控制器的寄存器起始地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CTL_BASE  0x48000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭WATCHAOG，否则CPU会不断重启</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_watch_dog</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  WTCON = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置存储控制器以使用SDRAM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memsetup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//SDRAM 13个寄存器的值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> mem_cfg_val[]=&#123;<span class="number">0x22011110</span>,<span class="comment">//BWSCON</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON0</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON1</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON2</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON3</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON4</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON5</span></span><br><span class="line">                                    <span class="number">0x00018005</span>,<span class="comment">//BANKCON6</span></span><br><span class="line">                                    <span class="number">0x00018005</span>,<span class="comment">//BANKCON7</span></span><br><span class="line">                                    <span class="number">0x008C07A3</span>,<span class="comment">//REFRESH</span></span><br><span class="line">                                    <span class="number">0x000000B1</span>,<span class="comment">//BANKSIZE</span></span><br><span class="line">                                    <span class="number">0x00000030</span>,<span class="comment">//MRSRB6</span></span><br><span class="line">                                    <span class="number">0x00000030</span><span class="comment">//MRSRB7</span></span><br><span class="line">                                    &#125;;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)MEM_CTL_BASE;</span><br><span class="line">  <span class="keyword">for</span>(;i &lt; <span class="number">13</span>;i++)</span><br><span class="line">    p[i] = mem_cfg_val[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
copy_2th_to_sdram函数用来将第二部分代码（即由leds.c编译得来的代码）从Steppingstone复制到SDRAM中。在连接程序时，第二部分代码的加载地址被指定为2048，重定位地址为0xB0004000。所以系统从NAND Flash启动后，第二部分代码Steppingstone中地址2048之后，需要把它复制到0x30004000处（此时尚未开启MMU，虚拟地址0xB0004000对应的物理地址在后面设为0x30004000）。Steppingstone总大小为4KB，不妨把地址2048后的所有数据复制到SDRAM中，所以源数据的结束地址为4096。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将第二部分代码复制到SDRAM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_2th_to_sdram</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *pdwSrc = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">2048</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *pdwDest = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x30004000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(pdwSrc &lt; (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">4096</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *pdwDest = *pdwSrc;</span><br><span class="line">    pdwDest++;</span><br><span class="line">    pdwSrc++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
剩下的create_page_table、mmu_init就是本章的重点了。前者用来设置页表，后者用来开启MMU。<br>先看看create_page_table函数，它用于设置3个区域的地址映射关系。<br>①将虚拟地址0-（1M-1）映射到同样的物理地址去，Steppingstone（从0地址开始的4KB内存）就处于这个范围中。使虚拟地址等于物理地址，可以让Steppingstone中的程序（head.S和init.c）在开启MMU前后不需要考虑太多的事情。<br>②GPIO寄存器的起始物理地址范围为0x56000000，将虚拟地址0xA0000000-（0xA0000000+1M-1）映射到物理地址0x56000000-（0x56000000+1M-1）。<br>③本开发板中SDRAM的物理地址范围为0x30000000-0x33fffffff，将虚拟地址0xB0000000-0xB3fffffff映射到物理地址0x30000000-0x33fffffff。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置页表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_page_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用于段描述符的一些宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_FULL_ACCESS (3 &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_DOMAIN (0 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SPECIAL (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_CACHEABLE (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_BUFFERABLE (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECTION (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | MMU_SECTION)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC_WB (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | MMU_SECTION | MMU_BUFFERABLE | MMU_CACHEABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC_SIZE (0x00100000)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> virtualaddr,physicaladdr;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *mmu_tlb_base = (<span class="type">unsigned</span> <span class="type">long</span> *)<span class="number">0x30000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Steppingstone的起始物理地址为0，第一部分程序的起始运行地址也是0，</span></span><br><span class="line"><span class="comment">  为了在开启MMU后仍能运行第一部分的程序，</span></span><br><span class="line"><span class="comment">  将0-1M的虚拟地址空间映射到同样的物理地址</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0</span>;</span><br><span class="line">  physicaladdr = <span class="number">0</span>;</span><br><span class="line">  *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  0x56000000是GPIO寄存器的起始物理地址</span></span><br><span class="line"><span class="comment">  GPBCON和GPBDAT这两个寄存器的物理地址0x56000010、0x56000014，</span></span><br><span class="line"><span class="comment">  为了在第二部分程序中能以地址0xA0000010、0xA0000014来操作GPBCON和GPBDAT这两个寄存器，</span></span><br><span class="line"><span class="comment">  把从0xA0000000开始的1MB虚拟地址空间映射到0x56000000开始的1MB物理地址空间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0xA0000000</span>;</span><br><span class="line">  physicaladdr = <span class="number">0x56000000</span>;</span><br><span class="line">  *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  SDRAM的物理地址范围是0x3000000-0x33FFFFFF，</span></span><br><span class="line"><span class="comment">  将虚拟地址0xB0000000-0xB3fffffff映射到物理地址0x30000000-0x33fffffff上</span></span><br><span class="line"><span class="comment">  总共64MB，涉及64个段描述符</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0xB0000000</span>;</span><br><span class="line">  physicaladdr = <span class="number">0x30000000</span>;</span><br><span class="line">  <span class="keyword">while</span>(virtualaddr &lt; <span class="number">0xB4000000</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line">    virtualaddr += <span class="number">0x100000</span>;</span><br><span class="line">    virtualphysicaladdraddr += <span class="number">0x100000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
mmu_tlb_base被定义为unsigned long 指针，所指向的内存为4字节，刚好是一个描述符的大小。在SDRAM的开始存放页表—第81行令mmu_tlb_base指向SDRAM的起始地址0x3000000。其中最能体现页表结构的代码是下列代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC;</span><br><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br></pre></td></tr></table></figure>
虚拟地址的位[31:20]用于索引一级页表，找到它所对应的描述符，对应于“(virtualaddr &gt;&gt; 20)”。<br>段描述符中位[31:20]中保存段的物理地址，对应于“(physicaladdr &amp; 0xFFF00000)”。<br>位[11:0]中用来设置段的访问权限，包括所属的域、AP位、C位（是否可Cache）、B位（是否使用Write buffer）—这对应“MMU_SECDESC”或“MMU_SECDESC_WB”，它们的域都被设为0，AP位被设为0b11（进行权限检查，读写操作都被允许）。“MMU_SECDESC”中C&#x2F;B位都没有设置，表示不使用Cache和Write Buffer，所以映射寄存器空间时使用“MMU_SECDESC”。“MMU_SECDESC_WB”中C&#x2F;B都设置了，表示使用Cache和Write Buffer，即所谓的回写式。在映射Steppingstone和SDRAM等内存时使用“MMU_SECDESC_WB”。<br>现在看看mmu_init函数。Create_page_table函数设置好了页表，还需要把页表地址告诉CPU，并且在开启MMU之前做好一些准备工作，比如使无效ICache、DCache，设置域访问控制寄存器等。代码的注释就可以帮助读者很好的理解mmu_init函数。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">启动MMU</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmu_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ttb <span class="number">0x30000000</span>;</span><br><span class="line"></span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;mov  r0,  #0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c7,  c7,   0\n&quot;</span>                  <span class="comment">//使无效ICache和DCache</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c7,  c10,  4\n&quot;</span>                  <span class="comment">//drain write buffer on v4</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c8,  c7,   0\n&quot;</span>                  <span class="comment">//使无效指令、数据TLB</span></span><br><span class="line">    <span class="string">&quot;mov  r4,   %0\n&quot;</span>                                     <span class="comment">//r4 = 页表基址</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r4,   c2,   c0,   0\n&quot;</span>                <span class="comment">//设置页表基址寄存器</span></span><br><span class="line">    <span class="string">&quot;mvn  r0,   #0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,   c3,   c0,   0\n&quot;</span>                <span class="comment">//域访问控制寄存器设为0xFFFFFFFFF，不进行权限检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于控制寄存器，先读出其值，在这基础上修改感兴趣的位</span></span><br><span class="line"><span class="comment">    然后再写入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">&quot;mrc  p15,  0,  r0, c1, c0, 0\n&quot;</span>                      <span class="comment">//读出控制寄存器的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    控制寄存器的低16位含义为：.RVI ..RS B... .CAM</span></span><br><span class="line"><span class="comment">    R：表示换出Cache中的条目时使用的算法，0 = Random repalcement；1 = Round robin replacement</span></span><br><span class="line"><span class="comment">    V：表示异常向量表所在的位置；0 = Low address = 0x00000000；1 = High address = 0xFFFF0000</span></span><br><span class="line"><span class="comment">    I：0 = 关闭ICache；1 = 开启ICache；</span></span><br><span class="line"><span class="comment">    R、S：用来与页表中的描述符一起确定内存的访问权限；</span></span><br><span class="line"><span class="comment">    B：0 = CPU为小字节序；1 = CPU为大字节序；</span></span><br><span class="line"><span class="comment">    C：0 = 关闭DCache；1 = 开启DCache；</span></span><br><span class="line"><span class="comment">    A：0 = 数据访问时不进行地址对齐检查；1 = 数据访问时进行地址对齐检查；</span></span><br><span class="line"><span class="comment">    M：0 = 关闭MMU；1 = 开启MMU；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    先清除不需要的位，往下若需要则重新设置它们</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*.RVI ..RS B... .CAM*/</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x3000\n&quot;</span>                             <span class="comment">//..11 .... .... .... 清除V、I位</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x0300\n&quot;</span>                             <span class="comment">//.... ..11 .... .... 清除R、S位</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x0087\n&quot;</span>                             <span class="comment">//.... .... 1... .111 清除B/C/A/M位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置需要的位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0002\n&quot;</span>                                <span class="comment">//.... .... .... ..1. 开启对齐检查</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0004\n&quot;</span>                                <span class="comment">//.... .... .... .1.. 开启DCache</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x1000\n&quot;</span>                                <span class="comment">//...1 .... .... .... 开启ICache</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0001\n&quot;</span>                                <span class="comment">//.... .... .... ...1 使能MMU</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,   c1,   c0,   0\n&quot;</span>                  <span class="comment">//将修改的值写入到控制寄存器</span></span><br><span class="line">    :<span class="comment">/*无输出*/</span></span><br><span class="line">    :<span class="string">&quot;r&quot;</span>(ttb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="第二部分代码分析"><a href="#第二部分代码分析" class="headerlink" title="第二部分代码分析"></a>第二部分代码分析</h3><p>第二部分代码leds.c中只有两个函数：wait和main。wait函数用来延时，main函数用来循环点亮4个LED。</p>
<ol>
<li>操作GPBCON、GPBDAT两个寄存器时使用虚拟地址0xA0000010、0xA0000014。在init.c中已经把虚拟地址0xA0000000-（0xA0000000 + 1M-1）映射到物理地址0x56000000-（0x56000000+1M-1）；</li>
<li>在定义wait函数时使用了一点小技巧，将它定义成“static inline”类型，原因在代码中给出：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  leds.c：循环点亮4个LED</span></span><br><span class="line"><span class="comment">  属于第二部分程序，此时MMU已开启，使用虚拟地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (* (unsigned long *) 0xA0000010)             <span class="comment">//物理地址0x56000010</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (* (unsigned long *) 0xA0000014)             <span class="comment">//物理地址0x56000014</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LED1-LED4对应GPB5、GPB6、GPB7、GPB8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">wait函数加上“static inline”是有原因的，</span></span><br><span class="line"><span class="comment">这样可以使得编译leds.c时，wait嵌入main中，编译结果只有main一个函数。</span></span><br><span class="line"><span class="comment">于是在连接时，main函数的地址就是由连接文件指定的运行地址。</span></span><br><span class="line"><span class="comment">而连接文件mmu.lds中，指定了leds.o的运行时装载地址为0xB0004000，</span></span><br><span class="line"><span class="comment">这样，head.s中的“ldr pc,=0xB0004000“就是跳去执行main函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> dly)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;dly &gt; <span class="number">0</span>;dly--)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将LED1NLED4对应的GPB5GPB8引脚设置为输出</span></span><br><span class="line">  GPBCON = GPB5out | GPB6_out | GPB7_out | GPB8_out;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">3000000</span>);</span><br><span class="line">    GPBDAT = (~(i&lt;&lt;<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span>(++i == <span class="number">16</span>)</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Makefile和连接脚本mmu-lds"><a href="#Makefile和连接脚本mmu-lds" class="headerlink" title="Makefile和连接脚本mmu.lds"></a>Makefile和连接脚本mmu.lds</h3><p>Makefile内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objs := head.o init.o leds.o</span><br><span class="line"></span><br><span class="line">mmu.bin:  $(objs)</span><br><span class="line">  arm-linux-ld -Tmmu.lds -o mmuj_elf $^</span><br><span class="line">  arm-linux-objcopy -O binary -S mmu_elf $@</span><br><span class="line">  arm-linux-objdump -D -m arm mmu_elf &gt; mmu.dis</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">  arm-linux-gcc -Wall -O2 -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">%.o:%.s</span><br><span class="line">  arm-linux-gcc -Wall -O2 -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -f mmu.bin mmu_elf mmu.lds *.o</span><br></pre></td></tr></table></figure>
<p>Makefile第4行命令用来连接程序，它使用连接脚本mmu.lds来控制连接器的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS  &#123;</span><br><span class="line">    first <span class="number">0x00000000</span>  : &#123;head.o init.o&#125;</span><br><span class="line">    second  <span class="number">0xB0004000</span>  : AT(<span class="number">2048</span>)  &#123;leds.o&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接脚本mmu.lds将程序分为两个段：first和second。前者由head.o和init.o组成，它的加载地址和运行地址都是0，所以运行前不需要重新移动代码。后者由leds.o组成，它的加载地址为2048，重定位地址为0xB0004000，这表明段second存放在编译所得映像文件地址2048处，在运行前需要将它复制到0xB0004000处，这由init.c中的copy_2th_to_sdram函数完成（此函数将代码复制到开始地址为0x30004000的内存中，这是开启MMU后虚拟地址0xB0004000对应的物理地址）。<br>实例程序涉及了代码的复制、开启MMU前使用物理地址寻址，开启MMU后使用虚拟地址寻址，相对复杂。下图更形象的演示了代码的执行。<br><img src="/2022/08/15/MMU/15.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/16.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/17.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/18.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/19.jpg" alt="img not found"></p>
<h1 id="实例测试结果"><a href="#实例测试结果" class="headerlink" title="实例测试结果"></a>实例测试结果</h1><p>程序烧入NAND Flash后，复位启动系统。可以看到4个LED被循环点亮，闪烁速度比SDRAM实验快，那是因为开启了Cache。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第7章 MMU</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>LCD控制器</title>
    <url>/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第13章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解LCD显示器的接口及时序</li>
<li>掌握S3C2410&#x2F;S3C2440LCD控制器的使用方法</li>
<li>了解帧缓冲区的概念，掌握如何设置帧缓冲区来显示图像</li>
</ol>
<h1 id="LCD和LCD控制器"><a href="#LCD和LCD控制器" class="headerlink" title="LCD和LCD控制器"></a>LCD和LCD控制器</h1><h2 id="LCD显示器"><a href="#LCD显示器" class="headerlink" title="LCD显示器"></a>LCD显示器</h2><h3 id="LCD的种类"><a href="#LCD的种类" class="headerlink" title="LCD的种类"></a>LCD的种类</h3><p>LCD（Liquid Crystal Display），即液晶显示器，是一种采用了液晶控制透光度技术来实现色彩的显示器。它与传统的CRT显示器相比有很多优点：轻薄、能耗低、辐射小等，市场占有率越来越大。LCD有很多种类，比如STN、TFT、LTPS TFT、OLED等，各有优缺点。<br>STN（Super Twisted Nematic，超扭曲向列），有CSTN和DSTN之分，是4种LCD屏中最低端的一种，仅有的优点就是功耗低，在色彩鲜艳度和画面亮度上相对于TFT和其他LCD屏存在明显不足，在日光下几乎不能显示，而且响应时间长达200ms左右，播放动画或视频拖影明显不足。<br>TFT（Thin Film Transistor，薄膜晶体管）可以大大缩短屏幕响应时间，其响应时间已经小于80ms，并改善了STN连续显示时屏幕闪烁模糊，有效提供了动态画面的播放力，呈现画面色彩饱和度、真实效果和对比度都很不错，完全超越STN，只是功耗稍高，是目前最为主流的液晶显示器类型。在MP3、MP4产品上大量应用，在桌面液晶显示器、笔记本电脑、手机等产品上的应用也非常普遍。<br>LTPS（Low Temperature Polycrystalline Silicon，低温多晶硅）由TFT衍生的新一代的技术产品，可以获得更高的分辨率和更丰富的色彩。LTPS LCD可以提供170°的水平和垂直可视角度，显示响应仅12ms，显示亮度达到500Cd&#x2F;m²，对比度可达500：1，这就是一些桌面液晶屏性能越来越出色的原因。虽然LTPS LCD已经出现很多年了，但由于LTPS TFT液晶屏的制造需要高于制造传统TFT屏的技术水平，目前仅有少数知名大厂能制造。<br>OLED（Organic Light Emitted Diode，有机发光二极管）各种物理特性都具备领先优势，色彩明亮、可视角度超大、非常省电，是未来发展的主流，只是目前受技术与成本限制，未能广泛普及。目前，彩色OLED比较广泛的存在中低端产品中。</p>
<h3 id="LCD的接口"><a href="#LCD的接口" class="headerlink" title="LCD的接口"></a>LCD的接口</h3><p>CPU或显卡发出的图像是TTL信号，LCD本身接收的也是TTL信号。但是由于TTL信号高速率的长距离传输性能不佳，抗干扰能力也比较差，后来又提出了多种接口，比如LVDS、TDMS、GVIF、P&amp;D、DVI和DFP等。它们实际上只是将CPU或显卡发出的TTL信号编码成各种信号以便传输，在LCD那边将接收到的信号进行解码得到TTL信号。<br>由于数字接口标准尚未统一，所以使用LCD时需要根据其手册了解具体接口定义。也是基于数字接口标准尚未统一的原因，市场上大多LCD都采用模拟接口信号，LCD先通过ADC将模拟信号转换为数字信号才能显示。<br>但是不管采用何种数字接口，本质的TTL信号是一样的。</p>
<ol>
<li><p>对于STN LCD<br>STN LCD 的数据传输方式有3种：4位单扫（4-bit single scan）、4位双扫（4-bit dual scan）、8位单扫（8-bit single scan）。所谓“单扫”是指对于一整屏的数据，从上到下、从左到右，一个一个的发送出来；“双扫”是指将一整屏的数据分为上下两部分，同时从上到下、从左到右，一个一个的发送出来。“4位”、“8位”是指发送数据时使用多少个数据线；需要注意的是，4位双扫方式也是用到8根数据线，其中4根用于上半屏数据，另外4根用于下半屏数据。<br>除数据信号外，还有其他控制信号，所有TTL信号如下表所示：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>VFRAME</td>
<td>帧同步信号</td>
</tr>
<tr>
<td>VLINE</td>
<td>行同步信号</td>
</tr>
<tr>
<td>VCLK</td>
<td>像素时钟信号</td>
</tr>
<tr>
<td>VD[7:0]</td>
<td>数据信号</td>
</tr>
<tr>
<td>VM</td>
<td>AV偏置信号</td>
</tr>
<tr>
<td>PWREN</td>
<td>电源开关信号</td>
</tr>
</tbody></table>
</li>
<li><p>对于TFT LCD<br>TFT LCD的信号与STN类似，只是其数据信号多达24根，对应像素值的每一位。</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>VSYNC</td>
<td>垂直同步信号</td>
</tr>
<tr>
<td>HSYNC</td>
<td>水平同步信号</td>
</tr>
<tr>
<td>HCLK</td>
<td>像素时钟信号</td>
</tr>
<tr>
<td>VD[23:0]</td>
<td>数据信号</td>
</tr>
<tr>
<td>LEND</td>
<td>行结束信号</td>
</tr>
<tr>
<td>PWREN</td>
<td>电源开关信号</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-LCD控制器介绍"><a href="#S3C2410-x2F-S3C2440-LCD控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 LCD控制器介绍"></a>S3C2410&#x2F;S3C2440 LCD控制器介绍</h2><h3 id="S3C2410-x2F-S3C2440-LCD控制器的特性与结构"><a href="#S3C2410-x2F-S3C2440-LCD控制器的特性与结构" class="headerlink" title="S3C2410&#x2F;S3C2440 LCD控制器的特性与结构"></a>S3C2410&#x2F;S3C2440 LCD控制器的特性与结构</h3><p>S3C2410&#x2F;S3C2440 LCD控制器被用来向LCD传输图像数据，并提供必要的控制信号，比如VFRAME、VLINE、VCLK、VM等。可以支持STN LCD、TFT LCD，其特性如下（BPP 表示bit per pixel，即每个颜色像素点用多少位来表示）。<br>STN LCD</p>
<ol>
<li>支持3种扫描方式：4位单扫，4位双扫和8位单扫</li>
<li>支持单色（1BPP）、4级灰度（2BPP）、16级灰度屏（4BPP）</li>
<li>支持256色（8BPP）和4096色（12BPP）彩色STN屏（CSTN）</li>
<li>支持分辨率为640x480、320x240、160x160以及其他规格的多种LCD</li>
<li>虚拟屏幕最大可达4MB</li>
<li>对于256色，分辨率有4094x1024、2048x2048、1024x4096等多种</li>
</ol>
<p>TFT LCD</p>
<ol>
<li>支持单色（1BPP）、4级灰度（2BPP）、16级灰度（4BPP）、256色（8BPP）的调色板显示模式</li>
<li>支持64K（16BPP）和16M（24BPP）色非调色板显示模式</li>
<li>支持分辨率为640x480、320x320及其他多种规格的LCD</li>
<li>虚拟屏幕最大可达4MB</li>
<li>对于64K色，分辨率有2048x1024等多种</li>
</ol>
<p>S3C2410&#x2F;S3C2440 LCD控制器提供了驱动STN LCD、TFT LCD所需的所有信号，另外，还特别提供额外的信号以支持SEC公司生产的TFT LCD。这3类信号中很大部分是复用的。<br>S3C2410&#x2F;S3C2440 LCD控制器的内部结构如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"><br>REGBANK是LCD控制器的寄存器组，含17个寄存器及一块256x16的调色板内存，用来设置各项参数。而LCDCDMA则是LCD控制器专用的DMA通道，可以自动地从系统总线（System Bus）上取到图像数据，这使得显示图像时不需要CPU的干涉。VIDPRCS将LCDCDMA中的数据组合成特定的格式，然后从VD[23:0]发送给LCD屏。同时TIMEGEN和LPC3600负责产生LCD屏所需要的控制时序，例如VSYNC、HSYNC、VCLK、VDEN，然后从VIDEO MUX送给LCD屏。其中LPC3600专用于SEC TFT LCD。<br>LCDCDMA中有2个FIFO：FIFOH容量为16（1个字为4个字节）个字，FIFOL容量为12个字。当使用“双扫”方式时，FIFOH、FIFIL分别用于传输上半屏、下班屏数据；当使用“单扫”方式时，只用到FIFOH。当FIFO为空或者其中的数据已经减少到设定的阈值时，LCDCDMA自动的发起DMA传输从内存中获得图像数据。</p>
<h3 id="显示器上数据的组织格式"><a href="#显示器上数据的组织格式" class="headerlink" title="显示器上数据的组织格式"></a>显示器上数据的组织格式</h3><p>一幅图像被称为一帧，每帧由多行组成，每行由多个像素组成，每个像素的颜色用若干位的数据表示。对于单色显示器，每个像素用1位来表示，称为1BPP，对于256色显示器，每个像素使用8位来表示，称为8BPP。<br>显示器从屏幕的左上方开始，一行一行的取得每个像素的数据并显示出来，当显示当一行的最右边时，跳到下一行的最左边开始显示下一行；当显示完所有行后，跳到左上方开始显示下一帧。显示器沿着“Z”字行的路线进行扫描，使用HSYNC、VSYNC信号来控制扫描路线的跳转。HSYNC表示“是时候跳到最左边了”，VSYNC表示“是时候跳到最上边了”。<br>在工作中的显示器上，可以在四周看到黑色的边框。上方的黑框是因为显示完所有行的数据时，显示器还没有扫描到最下边（VSYNC信号还未发出），这时数据已经无效。左边的黑框是因为当发出HSYNC信号时，需要经过若干像素之后第一列数据才有效；右边的黑框是因为显示完一行的数据时，显示器还每扫描到最右边（HSYNC信号还没有发出），这时数据已经无效。显示器只会依据VSYNC、HSYNC信号来取得、显示数据，并不理会该数据是否有效，何时发出有效数据由显卡决定。<br>VSYNC信号出现的频率表示1秒内能显示多少帧的图像，称为垂直频率或者场频率，这就是我们常说的“显示器的频率”；HSYNC信号出现的频率称为水平频率。<br>显示器上，一帧数据的存放位置与VSYNC、HSYNC信号的关系如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>有效数据的行数、列数即分辨率，它与VSYNC、HSYNC信号之间的“距离”等，都是可以设置的，这由显卡完成。</p>
<h3 id="TFT-LCD的操作"><a href="#TFT-LCD的操作" class="headerlink" title="TFT LCD的操作"></a>TFT LCD的操作</h3><p>目前市场上主流的LCD为TFT LCD，先了解TFT LCD的时序，这使得我们在设置各个寄存器时有个形象的概念。每个VSYNC信号表示一帧数据的开始；每个HSYNC信号表示一行数据的开始，无论这些数据是否有效；每个VCLK信号表示正在传输一个像素的数据，无论它是否有效。数据是否有效只是对CPU的LCD控制器来说的，LCD根据VSYNC、HSYNC、VCLK不停的读取总线数据、显示。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/3.jpeg" alt="img not found"></p>
<ol>
<li>VSYNC信号有效时，表示一帧数据的开始。</li>
<li>VSPW表示VSYNC信号的脉冲宽度为（VSPW + 1）个HSYNC信号周期，即（VSPW + 1）行，这（VSPW + 1）行数据无效。</li>
<li>VSYNC信号脉冲之后，还要经过（VBPD + 1）个HSYNC信号周期，有效的行数据才出现。所以在VSYNC信号有效之后，总共还要经过（VSPW + 1 + VBPD + 1）个无效的行，它对应图13.2上方的边框，第一个有效的行才出现。</li>
<li>随后即连续发出（LINEVAL + 1）行的有效数据。</li>
<li>最后是（VFPD + 1）个无效的行，它对应图13.2下方的边框，完整的一帧结束，紧接着就是下一帧的数据了（即下一个VSYNC信号）。</li>
</ol>
<p>现在深入到一行像素的传输过程。类似于行数据的传输过程。</p>
<ol>
<li>HSYNC信号有效时，表示一行数据的开始。</li>
<li>HSPW表示HSYNC信号的脉冲宽度为（HSPW + 1）个VCLK信号周期，即（HSPW + 1）个像素，这（HSPW + 1）个像素的数据无效。</li>
<li>HSYNC信号脉冲无效之后，还要经过（HBPD + 1）个VCLK信号周期，有效的像素数据才出现。所以，在HSYNC信号有效之后，总共还要经过（HSPW + 1 + HBPD + 1）个无效的像素，它对应图13.2的左边框，第一个有效像素才出现。</li>
<li>随后即连续发出（HOZVAL + 1）个像素的有效数据。</li>
<li>最后是（HFPD + 1）个无效的像素，它对应图13.2的右边框，完整的一行结束，紧接着就是下一行的数据了（即下一个HSYNC信号）。</li>
</ol>
<p>时序图中各信号的时间参数都可以在LCD控制寄存器中设置，VCLK作为时序图的基准信号，它的频率可由此计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VCLK(hz) = HCLK / [(CLKVAL + <span class="number">1</span> x <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>VSYNC信号的频率又称为帧频率、垂直频率、场频率、显示器的频率，它可以如下计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Frame Rate = <span class="number">1</span>/[&#123;(VSPW+<span class="number">1</span>)+(VBPD+<span class="number">1</span>)+(LINEVAL+<span class="number">1</span>)+(VFPD+<span class="number">1</span>)&#125; x &#123; (HSPW+<span class="number">1</span>)+(HBPD+<span class="number">1</span>)+(HFPD+<span class="number">1</span>)+(HOZVAL+<span class="number">1</span>) &#125; x &#123; <span class="number">2</span> x ( CLKVAL+<span class="number">1</span>) / (HCLK)&#125;]</span><br></pre></td></tr></table></figure>
<p>将VSYNC、HSYNC、VCLK等信号的时间参数设置好之后，并将帧内存（frame memory）的地址告诉LCD控制器，它即可自动发起DMA传输从帧内存得到图像数据，最终在上述信号的控制下出现在数据总线VD[23:0]上。用户只需要把要显示的图像数据写入帧内存中。<br>下面介绍各种图像的格式数据在内存中如何存储。<br>显示器上的每个像素的颜色都是由3个部分组成：红、绿、蓝。它们被称为三原色，这三者的混合几乎可以表示人眼所能识别到的所有颜色。比如可以根据颜色的浓烈程度将三原色都分为256个级别（0-255）。可以使用255级的红色、255级的绿色、255级的蓝色可以组成白色。0级的红色、0级的绿色、0级的蓝色可以组成黑色。<br>LCD控制器可以支持单色（1BPP）、4级灰度（2BPP）、16级灰度（8BPP）、256色（8BPP）的调色板显示模式，支持64K（16BPP）和16M（24BPP）非调色板显示模式。下面只介绍256色（8pp）、64K（16BPP）和16M（24BPP）色显示模式下，图像数据的存储格式。</p>
<ol>
<li>16M（24BPP）色<br>16M（24BPP）色的显示模式就是使用24位的数据来表示一个像素的颜色，每种原色使用8位。LCD控制器从内存中获得某个像素的24位颜色值后，直接通过VD[23:0]数据线发送给LCD。为了方便DMA传输，在内存中使用4个字节（32）位来表示一个像素，其中的3个字节从高到低分别表示红、绿、蓝，剩余的1个字节数据无效。是最低字节还是最高字节无效，这时可以选择的。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/4.jpeg" alt="img not found"></li>
<li>64K（16BPP）色<br>64K（16BPP）色的显示模式就是使用16位的数据来表示一个像素的颜色。这16位数据的格式又分为两种：5：6：5、5：5：5：1，前者使用高5位来表示红色，中间的6位来表示绿色，低5位来表示蓝色；后者的高15位从高到低分成3个5位来表示红色、绿色、蓝色，最低位表示透明度。5：5：5：1的格式也被称为RGBA（A表示Alpha，指代透明度）。<br>一个4字节可以表示两个16BPP的像素，使用高2字节还是低2字节来表示第一个像素，这也是可以选择的。<br>显示模式为16BPP时，内存数据与像素位置的关系如图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/5.jpeg" alt="img not found"><br>在5：5：5：1的格式下，VD[18]、VD[10]、VD[2]数据线上的值是一样的，都表示透明度。图中的NC表示没有连接（not connect）。</li>
<li>256（8BPP）色<br>256（8BPP）色的显示模式就是使用8位的数据来表示一个像素的颜色，但是对三种原色平均下来，每个原色只能使用不到3位的数据来表示，即每个原色最多不过8个级别，这不足以表示更丰富的颜色。<br>为了解决8BPP模式显示能力太弱的问题，需要使用调色板。每个像素对应8位数据不再用来表示RGB三原色，而是表示它在调色板中的索引值；要显示这个像素时，使用这个索引值从调色板中取得其RGB颜色值。所谓调色板就是一块内存，可以对每个索引值设置其颜色，可以使用24BPP或16BPP。S3C2410&#x2F;S3C2440中，调色板是一块256x16的内存，使用16BPP的格式来表示256色（8BPP）显示模式下各个索引值的颜色。这样即使使用256色（8BPP）的显示模式，最终在LCD数据总线上的仍是16BPP的数据。<br>一个4字节可以表示4个8BPP的像素，字节与像素的对应顺序是可以选择的，如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/6.jpeg" alt="img not found"><br>调色板中数据的存放格式与16BPP显示模式类似，也分为两种：5：6：5、5：5：5：1。调色板中数据的格式及与LCD数据线VD[23:0]的对应关系，如下表所示：</li>
</ol>
<p>5：6：5格式下调色板的数据格式</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>00H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D000400</td>
</tr>
<tr>
<td>01H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D000404</td>
</tr>
<tr>
<td>… …</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>… …</td>
</tr>
<tr>
<td>FFH</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D0007FC</td>
</tr>
<tr>
<td>VD引脚号</td>
<td>23</td>
<td>22</td>
<td>21</td>
<td>20</td>
<td>19</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>10</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td></td>
</tr>
</tbody></table>
<p>5：5：5：1格式下调色板的数据格式</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>00H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D000400</td>
</tr>
<tr>
<td>01H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D000404</td>
</tr>
<tr>
<td>… …</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>… …</td>
</tr>
<tr>
<td>FFH</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D0007FC</td>
</tr>
<tr>
<td>VD引脚号</td>
<td>23</td>
<td>22</td>
<td>21</td>
<td>20</td>
<td>19</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>注：</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>①0X4D000400是调色板的起始地址。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>②5：5：5：1格式下，VD18、VD10和VD2三个数据线中都是亮度值1，即最低位的值。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>③当LCDCCON5寄存器中的VSTATUS、HSTATUS有效时，不能读写调色板。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>各模式下用来传输红、绿、蓝三种原色的颜色值VD数据线如下表所示：</p>
<table>
<thead>
<tr>
<th>24BPP</th>
<th>16BPP&#x2F;8BPP 5：6：5格式</th>
<th>16BPP&#x2F;8BPP 5：5：5：1格式</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td>VD[23:16]</td>
<td>VD[23:19]</td>
</tr>
<tr>
<td>绿色</td>
<td>VD[15:8]</td>
<td>VD[15:10]</td>
</tr>
<tr>
<td>蓝色</td>
<td>VD[7:0]</td>
<td>VD[7:3]</td>
</tr>
</tbody></table>
<p>没有用到的数据线其电平为0，从这个观点来看，无论是24BPP模式还是16BPP、8BPP模式，24根数据线VD[23:0]都被用到了。事实上，一个TFT LCD能处理的像素位宽是固定的，即它的数据线的数目是固定的。红、绿、蓝3类信号线总是连接到各字节中的高位；软件设置24BPP、16BPP、8BPP以及调色板等，只会影响到色值的精度。</p>
<h3 id="使用TFT-LCD时LCD控制器的寄存器设置"><a href="#使用TFT-LCD时LCD控制器的寄存器设置" class="headerlink" title="使用TFT LCD时LCD控制器的寄存器设置"></a>使用TFT LCD时LCD控制器的寄存器设置</h3><p>LCD控制器中REGBANK的17个寄存器可以分为6种，如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDCON1-LCDCON5</td>
<td>用于选择LCD类型，设置各类控制信号的时间特性等</td>
</tr>
<tr>
<td>LCDSADDR1-LCDSADDR3</td>
<td>用于设置帧内存的地址</td>
</tr>
<tr>
<td>TPAL</td>
<td>临时调色板寄存器，可以快速的输出一帧单色的图像</td>
</tr>
<tr>
<td>LCDINTPND<br>LCDSRCPND<br>LCDINTMSK</td>
<td>用于LCD的中断，在一般应用中无需中断</td>
</tr>
<tr>
<td>REDLUT <br> GREENLUT <br> BLUELUT <br> DITHMODE</td>
<td>专用于STNLCD</td>
</tr>
<tr>
<td>TCONSEL</td>
<td>专用于SEC TFT LCD</td>
</tr>
</tbody></table>
<p>对于TFT LCD，一般情况下只需要设置前两种寄存器；在8BPP模式下，如果想快速的输出一帧单色图，可以借助TPAL寄存器。</p>
<ol>
<li><p>LCD控制寄存器LCDCON1<br>用于选择LCD类型、设置像素时钟、使能LCD信号的输出等，格式如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LINECNT</td>
<td>[27:18]</td>
<td>只读，每输出一个有效行其值减一，从LINEVAL减到0</td>
</tr>
<tr>
<td>CLKVAL</td>
<td>[17:8]</td>
<td>用于设置VCLK（时钟）<br> 对于TFT LCD，VCLK &#x3D; HCLK &#x2F; [(CLKVAL + 1) x 2](CLKVAL &gt;&#x3D; 0)</td>
</tr>
<tr>
<td>MMODE</td>
<td>[7]</td>
<td>设置VM信号的反转效率，用于STN LCD</td>
</tr>
<tr>
<td>PNRMODE</td>
<td>[6:5]</td>
<td>设置LCD的类型，对于TFT LCD 设为0b11</td>
</tr>
<tr>
<td>BPPMODE</td>
<td>[4:1]</td>
<td>设置BPP，对于TFT LCD：<br>0b1000 &#x3D; 1bpp <br> 0b1001 &#x3D; 2bpp <br> 0b1010 &#x3D; 4bpp <br> 0b1011 &#x3D; 8bpp <br> 0b1100 &#x3D; 16bpp <br> 0b1101 &#x3D; 24bpp</td>
</tr>
<tr>
<td>ENVID</td>
<td>[0]</td>
<td>LCD信号输出使能位，0：禁止，1：使能</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制寄存器LCDCON2<br>用于设置垂直方向各信号的时间参数，格式如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VBPD</td>
<td>[31:24]</td>
<td>VSYNC信号脉冲之后，还要经过（VBPD + 1）个HSYNC信号周期，有效的行数据才出现</td>
</tr>
<tr>
<td>LINEVAL</td>
<td>[23:14]</td>
<td>LCD的垂直宽度：（LINEVAL + 1）行</td>
</tr>
<tr>
<td>VFPD</td>
<td>[13:6]</td>
<td>一帧中的有效行数据完结后，到下一个VSYNC信号有效前的无效行数目：VFPD + 1</td>
</tr>
<tr>
<td>VSPW</td>
<td>[5:0]</td>
<td>表示VSYNC信号的脉冲宽度为（VSPW + 1）个HSYNC信号周期，即（VSPW + 1）行，这（VSPW + 1）行的数据无效</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制器LCDCON3<br>用于设置水平方向信号的时间参数，格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HBPD</td>
<td>[25:19]</td>
<td>HSYNC信号脉冲之后，还要经过（HBPD + 1）个VCLK信号周期，有效的行数据才出现</td>
</tr>
<tr>
<td>HOZVAL</td>
<td>[18:8]</td>
<td>LCD的水平宽度：（HOZVAL + 1）列（像素点）</td>
</tr>
<tr>
<td>HFPD</td>
<td>[7:0]</td>
<td>一行中的有效数据完结后，到下一个HSYNC信号有效前的无效像素数目：HFPD + 1</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制寄存器LCDCON4<br>对于TFT LCD，这个寄存器只用来设置HSYNC信号的脉冲宽度，位[7:0]的数值称为HSPW，表示脉冲宽度为（HSPW + 1）个VCLK周期。</p>
</li>
<li><p>LCD控制寄存器LCDCON5<br>用于设置各个控制信号的极性，并可以从中读到一些状态信息。如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VSTATUS</td>
<td>[16:15]</td>
<td>只读，垂直状态。<br> 00:正处于VSYNC信号脉冲期间 <br> 01:正处于VSYNC信号结束到行有效期间 <br>10:正处于行有效期间 <br>11:正处于行有效结束到下一个VSYNC之间</td>
</tr>
<tr>
<td>HSTATUS</td>
<td>[14:13]</td>
<td>只读，水平状态。<br> 00:正处于HSYNC信号脉冲期间 <br> 01:正处于HSYNC信号结束到像素有效期间 <br>10:正处于像素有效期间 <br>11:正处于像素有效结束到下一个HSYNC之间</td>
</tr>
<tr>
<td>BPP24BL</td>
<td>[12]</td>
<td>设置TFT LCD的显示模式为24BPP时，一个4字节中哪3个字节有效。<br> 0:LSB有效（低地址的3字节）；1：MSB（高地址的3字节）；</td>
</tr>
<tr>
<td>FRM565</td>
<td>[11]</td>
<td>设置TFT LCD的显示模式为16BPP时，使用的数据格式。<br> 0表示5：5：5：1格式；1表示5：6：5 格式</td>
</tr>
<tr>
<td>INVVCLK</td>
<td>[10]</td>
<td>设置VCLK信号有效沿的极性。 <br> 0：在VCLK的下降沿读取数据；1：在VCLK的上升沿读取数据。</td>
</tr>
<tr>
<td>INVVLINE</td>
<td>[9]</td>
<td>设置VLINE&#x2F;HSYNC脉冲的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVFRAME</td>
<td>[8]</td>
<td>设置VFRAME&#x2F;VSYNC脉冲的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVD</td>
<td>[7]</td>
<td>设置VD数据线表示数据（0&#x2F;1）的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVDEN</td>
<td>[6]</td>
<td>设置VDEN信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVPWREN</td>
<td>[5]</td>
<td>设置PWREN信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVLEND</td>
<td>[4]</td>
<td>设置LEND信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>PWREN</td>
<td>[3]</td>
<td>LCD_PWREN信号输出使能。<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>ENLEND</td>
<td>[2]</td>
<td>LEND信号输出使能。<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>BSWP</td>
<td>[1]</td>
<td>字节交换使能<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>HWSWP</td>
<td>[1]</td>
<td>半字（2字节）交换使能<br> 0：禁止；1：输出</td>
</tr>
</tbody></table>
</li>
<li><p>帧内存地址寄存器LCDSADDR1-LCDSADDR3<br>帧内存可以很大，而真正要显示的区域被称为视口（view point），它处于帧内存之内。这3个寄存器用于确定帧内存的起始地址，定位视口在帧内存的位置。下图给出了帧内存和视口之间的关系：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/7.jpeg" alt="img not found"><br>各寄存器格式如下表所示：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>LCDSADDR1 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDBANK</td>
<td>[29:21]</td>
<td>用来保存帧内存起始地址A[30:22]，帧内存起始地址为4MB对齐。</td>
</tr>
<tr>
<td>LCDBASEU</td>
<td>[20:0]</td>
<td>对于TFT LCD，用来保存视口（view point），所对应的内存起始地址A[21:1]，这块内存地址也称为LCD的帧缓冲区（frame buffer）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>LCDSADDR2 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDBASEL</td>
<td>[20:0]</td>
<td>对于TFT LCD，用来保存LCD的帧缓冲区结束地址A[21:1]，其值可如下计算：LCDBASEL &#x3D; LCDBASEU + （PAGEWIDTH + OFFSICE）x （LINEVAL + 1）</td>
</tr>
</tbody></table>
<p>注：可以修改LCDBASEU、LCDBASEL的值来实现图像的移动，不过不能在一帧图像的结束阶段（LCDCON1寄存器的LINECNT为0时）进行修改，因为此时LCD控制器会优先取得下一帧的数据，之后才会改变这些值，这样的话，这些数据就与新的帧缓冲区不一致。</p>
<table>
<thead>
<tr>
<th>LCDSADDR3 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OFFSIZE</td>
<td>[21:11]</td>
<td>表示上一行最后一个数据与下一行第一个数据间地址差值的一半，即以半字为单位的地址差（0表示两行数据是紧接着的，1表示它们之间相差2个字节，依次类推）</td>
</tr>
<tr>
<td>PAGEWIDTH</td>
<td>[10:0]</td>
<td>视口的宽带，以半字为单位</td>
</tr>
</tbody></table>
<p>注：OFFSIZE、PAGEWIDTH的值只能在ENVID（LCDCON1寄存器的信号输出使能）为0时修改。</p>
<ol start="7">
<li>临时调色板寄存器TPAL<br>如果要输出一帧单色的图像，可以在TPAL寄存器中设定这个颜色值，然后使能TPAL寄存器，这种方法可以避免修改整个调色板或帧缓冲区。TPAL寄存器格式如下表所示：<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TPALEN</td>
<td>[24]</td>
<td>调色板寄存器使能位。<br> 0：禁止 1：使能</td>
</tr>
<tr>
<td>TPALVAL</td>
<td>[23:0]</td>
<td>颜色值。 <br> TPALVAL[23:16]：红色 <br> TPALVAL[15:8]：绿色 <br> TPALVAL[7:0]：蓝色</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：临时调色板寄存器TPAL可以用在任何显示模式下，并非只能用在8BPP模式下。</p>
<h1 id="TFT-LCD显示实例"><a href="#TFT-LCD显示实例" class="headerlink" title="TFT LCD显示实例"></a>TFT LCD显示实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例的目的是从串口输出一个菜单，从中选择各种方法进行测试，比如画线、画圆、显示单色、使用调色板等。</p>
<h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><p>与LCD相关的文件有3个：lcddrv.c、framebuffer.c和lcdlib.c（及相应的头文件）。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/8.jpeg" alt="img not found"></p>
<ol>
<li>lcddrv.c封装了对LCD控制器、调色板的访问函数，可以设置LCD的显示模式、开启&#x2F;关闭LCD、设置调色板等。</li>
<li>framebuffer.c直接操作帧缓冲区（frame buffer），实现了画点、画线、画圆、清屏等操作。</li>
<li>lcdlib.c调用前两个文件提供的函数在LCD上进行各种操作。</li>
</ol>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(getc())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_8Bit_240320();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_16Bit_240320();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_8Bit_640480();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_16Bit_640480();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它根据串口的输入选择是以”240x320、8bpp“、”240x320、16bpp“、”640x480、8bpp“或”640x480、16bpp“的显示模式来操作LCD，所调用的4个函数都在lcdlib.c中实现。</p>
<h3 id="lcdlib-c"><a href="#lcdlib-c" class="headerlink" title="lcdlib.c"></a>lcdlib.c</h3><p>8BPP模式将用到调色板，其操作比16BPP模式稍为复杂，但是大部分仍是相似的。下面以<code>Test_Lcd_Tft_8Bit_240320()</code>为例进行说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以240x320、8bpp的显示模式测试TFT LCD</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_Lcd_Tft_8Bit_240320</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_Port_Init();                        <span class="comment">//设置LCD引脚</span></span><br><span class="line">    Tft_Lcd_Init(MODE_TFT_8BIT_240320);     <span class="comment">//初始化LCD控制器</span></span><br><span class="line">    Lcd_PowerEnable(<span class="number">0</span>,<span class="number">1</span>);                   <span class="comment">//设置LCD_PWREN有效，它用于打开LCD的电源</span></span><br><span class="line">    Lcd_EnvidOnOff(<span class="number">1</span>);                      <span class="comment">//使能LCD控制器输出信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6行所涉及的GPIO引脚用于LCD功能。<br>第7行调用Tft_Lcd_Init函数初始化LCD控制器，即设置各个控制信号的时间特性、设置LCD的显示模式、设置帧缓冲区的地址等，它是lcddrv.c中最复杂的函数，在后面会详细分析这个函数。<br>进行第6、7行的初始化之后，只要打开LCD，帧缓冲区中的数据就会被LCD控制器自动地发送到LCD上去显示。打开操作由8、9行来完成。<br>第8行发出LCD_PWREN信号。对于有电源开关控制引脚的LCD，可以使用LCD_PWREN来打开或关闭LCD。LCD_PWREN信号的极性可以设置。<br>第9行使能LCD控制器输出信号，这时，帧缓冲区中的数据就开始在LCD上显示出来了。<br>接下来就是按照设定的流程进行各类操作了，比如画线、清屏等，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Lcd_Palette8Bit_Init();                     <span class="comment">//初始化调色板</span></span><br><span class="line">ClearScr(<span class="number">0x0</span>);                              <span class="comment">//清屏</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">0</span>);                     <span class="comment">//颜色为DEMO256pal[0]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="number">1</span>);                    <span class="comment">//颜色为DEMO256pal[1]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">20</span>,<span class="number">2</span>);                    <span class="comment">//颜色为DEMO256pal[2]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">40</span>,<span class="number">4</span>);                    <span class="comment">//颜色为DEMO256pal[4]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">80</span>,<span class="number">8</span>);                    <span class="comment">//颜色为DEMO256pal[8]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">160</span>,<span class="number">16</span>);                  <span class="comment">//颜色为DEMO256pal[16]</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Mire();                                     <span class="comment">//画圆</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">ClearScr(<span class="number">128</span>);                              <span class="comment">//输出单色图像，颜色为DEMO256pal[128]</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">ClearScrWithTmpPlt(<span class="number">0x0000ff</span>);               <span class="comment">//输出单色图像，颜色为蓝色</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">DisableTmpPlt();                            <span class="comment">//关闭临时调色板寄存器</span></span><br><span class="line">ChangePalette(<span class="number">0xffff00</span>);                    <span class="comment">//改变整个调色板为黄色，输出单色图像</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Lcd_EnvidOnOff(<span class="number">0</span>);                          <span class="comment">//停止</span></span><br></pre></td></tr></table></figure>
<p>上述函数分3类：</p>
<ol>
<li>清屏函数ClearScr、画线函数DrawLine，都是通过framebuffer.c中的PutPixel函数来设置帧缓冲区中的数据，以像素为单位修改颜色来实现的。</li>
<li>Lcd_Palette8Bit_Init函数设置调色板，ChangePalette函数通过设置调色板来实现清屏功能，不涉及帧缓冲区，它在lcddrv.c中实现。</li>
<li>ClearScrWithTmpPlt函数则是通过临时调色板寄存器来快速的输出单色的图像，也不涉及帧缓冲区，它在lcddrv.c中实现。<br>lcddrv.c、framebuffer.c文件中的各个函数才是本实例的关键。可以认为lcddrv.c是对操作各寄存器的封装，framebuffer.c则是对操作图像数据的封装。先看lcddrv.c文件。</li>
</ol>
<h3 id="lcddrv-c"><a href="#lcddrv-c" class="headerlink" title="lcddrv.c"></a>lcddrv.c</h3><p>这个文件的重点在于Tft_Lcd_Init、Lcd_Palette8Bit_Init。</p>
<ol>
<li><p>Lcd_Port_Init函数<br>设置所涉及的GPIO引脚用于LCD功能。GPIO功能的设置对读者来说已经很熟悉了，不再赘述。</p>
</li>
<li><p>Tft_Lcd_Init函数<br>用于初始化LCD控制器，即设置各个控制信号的时间特性、设置LCD的显示模式、设置帧缓冲区的地址等。<br>首先是对5个控制寄存器LCDCON1-LCDCON5的设置，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化LCD控制器</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">type：显示模式</span></span><br><span class="line"><span class="comment">    MODE_TFT_8BIT_240320 : 240*320 8bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_16BIT_240320 : 240*320 16bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_8BIT_640480 : 640*480 8bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_16BIT_640480 : 640*480 16bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tft_Lcd_Init</span><span class="params">(<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MODE_TFT_8BIT_240320:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置LCD控制器的控制寄存器LCDCON1-LCDCON5</span></span><br><span class="line"><span class="comment">        1. LCDCON1</span></span><br><span class="line"><span class="comment">            设置VCLK的频率：VCLK（Hz）= HCLK/[(CLKVAL+1)x2]</span></span><br><span class="line"><span class="comment">            选择LCD类型：TFT LCD</span></span><br><span class="line"><span class="comment">            设置显示模式：8BPP</span></span><br><span class="line"><span class="comment">            先禁止LCD信号输出</span></span><br><span class="line"><span class="comment">        2. LCDCON2/3/4</span></span><br><span class="line"><span class="comment">            设置控制信号的时间参数</span></span><br><span class="line"><span class="comment">            设置分辨率，即行数及列数</span></span><br><span class="line"><span class="comment">        现在，可以根据公式计算出显示器的频率</span></span><br><span class="line"><span class="comment">        当HCLK = 100MHz时，</span></span><br><span class="line"><span class="comment">        Frame Rate = 1/[&#123;(VSPW+1)+(VBPD+1)+(LINEVAL+1)+(VFPD+1)&#125; x &#123; (HSPW+1)+(HBPD+1)+(HFPD+1)+(HOZVAL+1) &#125; x &#123; 2 x ( CLKVAL+1) / (HCLK)&#125;] = 60Hz</span></span><br><span class="line"><span class="comment">        3. LCDCON5</span></span><br><span class="line"><span class="comment">            设置显示模式为8BPP时，调色板中的数据格式为5：6：5</span></span><br><span class="line"><span class="comment">            设置HSYNC、VSYNC脉冲的极性：反转字节交换使能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        LCDCON1 = (CLKVAL_TFT_240320 &lt;&lt; <span class="number">8</span>) | (LCDTYPE_TFT &lt;&lt; <span class="number">5</span>) | (BPPMODE_8BPP &lt;&lt; <span class="number">1</span>) | (ENVID_DISABLE &lt;&lt; <span class="number">0</span>);</span><br><span class="line">        LCDCON2 = (VBPD_240320 &lt;&lt; <span class="number">24</span>) | (LINEVAL_TFT_240320 &lt;&lt; <span class="number">14</span>) | (VFPD_240320 &lt;&lt; <span class="number">6</span>) | (VSPW_240320);</span><br><span class="line">        LCDCON3 = (HBPD_240320 &lt;&lt; <span class="number">19</span>) | (HOZVAL_TFT_240320 &lt;&lt; <span class="number">8</span>) | (HFPD_240320);</span><br><span class="line">        LCDCON4 = (HSPW_240320);</span><br><span class="line">        LCDCON5 = (FORMAT8BPP_565 &lt;&lt; <span class="number">11</span>) | (HSYNC_INV &lt;&lt; <span class="number">9</span>) | (VSYNC_INV &lt;&lt; <span class="number">8</span>) | (BSWP &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的注释可以帮助读者理解这些代码，比较困难的是时间参数VSPW、VBPD、VFPD、HSPW、HBPD、HFPD、CLKVAL的设置。对于CRT显示器，当它的频率在60Hz时，人眼会感到明显的闪烁；而对于LCD，在60Hz时显示效果就很好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Frame Rate = <span class="number">1</span>/[&#123;(VSPW+<span class="number">1</span>)+(VBPD+<span class="number">1</span>)+(LINEVAL+<span class="number">1</span>)+(VFPD+<span class="number">1</span>)&#125; x &#123; (HSPW+<span class="number">1</span>)+(HBPD+<span class="number">1</span>)+(HFPD+<span class="number">1</span>)+(HOZVAL+<span class="number">1</span>) &#125; x &#123; <span class="number">2</span> x ( CLKVAL+<span class="number">1</span>) / (HCLK)&#125;];</span><br></pre></td></tr></table></figure>
<p>接下来是对地址寄存器LCDSADDR1-LCDSADDR3的设置。本程序中，帧内存与视图吻合，即图中的OFFSIZE为0，LCDBANK、LCDBASEU指向同一个地址（同一地址的不同位）。<br>需要注意的是，8BPP的显示模式要用到调色板，帧缓冲区中的数据不是像素的颜色值，而是调色板中的索引值，真正的颜色值在调色板中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置LCD控制器的地址寄存器LCDSADDR1-LCDSADDR3</span></span><br><span class="line"><span class="comment">帧内存与视口（view point）完全吻合，</span></span><br><span class="line"><span class="comment">图像数据格式如下（8BPP时，帧缓存区中的数据为调色板中的索引值）：</span></span><br><span class="line"><span class="comment">            |----width----|</span></span><br><span class="line"><span class="comment">        y/x 0   1    2   239</span></span><br><span class="line"><span class="comment">         0  idx idx  idx idx</span></span><br><span class="line"><span class="comment">         1  idx idx  idx idx</span></span><br><span class="line"><span class="comment">1. LCDSADDR1</span></span><br><span class="line"><span class="comment">    设置LCDBANK、LCDBASEU</span></span><br><span class="line"><span class="comment">2. LCDSADDR2</span></span><br><span class="line"><span class="comment">    设置LCDBASEL：帧缓冲区的结束地址A[21:1]</span></span><br><span class="line"><span class="comment">3. LCDSADDR3</span></span><br><span class="line"><span class="comment">    OFFSIZE等于0，PAGEWIDTH等于（240/2）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LCDSADDR1 = ((LCDFRAMEBUFFER &gt;&gt; <span class="number">22</span>) &lt;&lt; <span class="number">21</span>) | LOWER21BITS(LCDFRAMEBUFFER &gt;&gt; <span class="number">1</span>);</span><br><span class="line">LCDSADDR2 = LOWER21BITS((LCDFRAMEBUFFER + (LINEVAL_TFT_240320 + <span class="number">1</span>) x (HOZVAL_TFT_240320+<span class="number">1</span>) x1) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">LCDSADDR3 = (<span class="number">0</span> &lt;&lt;<span class="number">11</span> ) | (LCD_XSIZE_TFT_240320/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>第16行将帧缓冲区的起始地址写入LCDSADDR1寄存器。<br>第17行先计算帧缓冲区的结束地址，再取其位[21:1]存入LCDSADDR2中。这个地址值在本实例中即是“LCDFRAMEBUFFER + 320 x 240 x 1”,其中的“x1”表示在8BPP中一个像素使用1个字节来表示（对于16BPP，则是“x2”）。<br>在设置寄存器的最后，禁止临时调色板寄存器，现在还没有用到它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*禁止临时调色板寄存器*/</span></span><br><span class="line">TPAL = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>最后，将显示模式的主要参数记录下来，在framebuffer.c中需要用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fb_base_addr = LCDFRAMEBUFFER;</span><br><span class="line">bpp = <span class="number">8</span>;</span><br><span class="line">xsize = <span class="number">240</span>;</span><br><span class="line">ysize = <span class="number">320</span>;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，显示模式为8BPP时，LCDCON5中BSWAP位设为1，表示“字节交换使能”，这时帧缓存区中的数据与屏幕上的像素位置关系如上图13.6所示；显示模式为16BPP时，LCDCON5中HWSWAP位设为1，表示“半字交换使能”，这时帧缓冲区的数据与屏幕上的像素位置关系如图13.5所示。他们都是“低地址的数据”对应“位置靠前”的像素。</p>
</li>
<li><p>Lcd_Palette8Bit_Init函数<br>设置调色板中的数据：调试板大小为256x16，而8BPP模式中每个像素的索引值占据8位，刚好有256个索引值。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置调色板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_Palette8Bit_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *palette;</span><br><span class="line"></span><br><span class="line">    LCDCON5 |= (FORMAT8BPP_565 &lt;&lt; <span class="number">11</span>);              <span class="comment">//设置调色板中数据格式为5：6：5</span></span><br><span class="line"></span><br><span class="line">    palette = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)PALETTE;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">        *palette++ = DEMO256pal[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调色板中用16BPP的格式来表示颜色，第9行设置调色板中数据的格式为5：6：5。<br>第12、13行将数组DEMO256pal中的数据写入调色板中。</p>
</li>
<li><p>ChangePalette函数<br>以给定的颜色填充整个调色板。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改变调色板为一种颜色</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    color：颜色值，格式为0xRRGGBB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChangePalette</span><span class="params">(UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> red,green,blue;</span><br><span class="line">    UNT32 *palette;</span><br><span class="line"></span><br><span class="line">    palette = (UINT32 *)PALETTE;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        red = (color &gt;&gt; <span class="number">19</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        green = (color &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        blue = (color &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        color = (red &lt;&lt; <span class="number">11</span>) | (greee &lt;&lt; <span class="number">5</span>) | (blue);                <span class="comment">//格式5：6：5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((LCDCON5 &gt;&gt; <span class="number">16</span>) == <span class="number">2</span>);                                <span class="comment">//等待直到VSTATUS不为“有效”</span></span><br><span class="line">        *palette++ = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第15-19行从0xRRGGBB格式的变量中，提取8位红色值的高5位，8位绿色值的高6位，8位蓝色值的高5位组成5：6：5格式的16BPP颜色值。<br>第21行检测当前VSYNC信号的状态，如果它处于有效的状态，则等待。前面说过，读写调色板时，VSTATUS、HSTATUS不能处于有效状态。这里当VSTATUS不是“有效”状态时，HSTATUS也不能是“有效”状态。<br>第22行将新数据写入调色板。</p>
</li>
<li><p>Lcd_PowerEnable函数<br>用于是否控制发出LCD_PWREN信号。对于有电源开关控制引脚的LCD，可以使用LCD_PWREN来打开或关闭LCD。LCD_PWREN信号的极性可以设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置是否输出LCD电源开关信号LCD_PWREN</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    invpwren：</span></span><br><span class="line"><span class="comment">        0表示LCD_PWREN有效时为正常极性</span></span><br><span class="line"><span class="comment">        1表示LCD_PWREN有效时为反转极性</span></span><br><span class="line"><span class="comment">    pwren：</span></span><br><span class="line"><span class="comment">        0表示LCD_PWREN输出有效</span></span><br><span class="line"><span class="comment">        1表示LCD_PWREN输出无效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_PowerEnable</span><span class="params">(<span class="type">int</span> invpwren,<span class="type">int</span> pwren)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPGCON = (GPGCON &amp; (~ (<span class="number">3</span> &lt;&lt; <span class="number">8</span>))) | (<span class="number">3</span> &lt;&lt; <span class="number">8</span>);                <span class="comment">//GPG4用作LCD_PWREN</span></span><br><span class="line">    GPGUP = (GPGUP &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">4</span>))) | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);                  <span class="comment">//禁止内部上拉</span></span><br><span class="line"></span><br><span class="line">    LCDCON5 = (LCDCON5 &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">5</span>))) | (invpwrwen &lt;&lt; <span class="number">5</span>);      <span class="comment">//设置LCD_PWREN的极性：正常/反转</span></span><br><span class="line">    LCDCON5 = (LCDCON5 &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))) | (pwren &lt;&lt; <span class="number">3</span>);          <span class="comment">//设置是否输出LCD_PWREN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Lcd_EnvidOnOff函数<br>用于控制是否使能LCD控制器输出各个LCD信号，当设置如控制寄存器、地址寄存器之后，即可调用此函数输出各个LCD信号，这样，帧缓冲区中的数据即发送给LCD。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置LCD控制器是否输出信号</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">onoff：</span></span><br><span class="line"><span class="comment">    0：关闭</span></span><br><span class="line"><span class="comment">    1：打开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_EnvidOnOff</span><span class="params">(<span class="type">int</span> onoff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(onoff == <span class="number">1</span>)</span><br><span class="line">        LCDCON1 |= <span class="number">1</span>;           <span class="comment">//ENVID ON</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LCDCON1 &amp;= <span class="number">0x3fffe</span>;     <span class="comment">//ENVID OFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ClearScrWithTmpPlt、DisableTmpPlt函数<br>ClearScrWithTmpPlt函数设置颜色值并使能TPAL寄存器，这使得LCD上显示单一颜色的图像。DisableTmpPlt函数停止TPAL寄存器的功能，继续输出帧缓存区的图像。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用临时调色板寄存器输出单色图像</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    color：颜色值，格式为0xRRGGBB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearScrWithTmpPlt</span><span class="params">(UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    TPAL = (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) | ((color &amp; <span class="number">0xffffff</span>) &lt;&lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">停止使用临时调色板寄存器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisableTmpPlt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TPAL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="framebuffer-c"><a href="#framebuffer-c" class="headerlink" title="framebuffer.c"></a>framebuffer.c</h3><p>此文件中有4个函数：画点函数PutPixel、画线函数DrawLine、绘制同心圆函数Mire、清屏函数ClearScr。后3个函数都是基于PutPixel函数实现的。PutPixel函数是framebuffer.c的核心，它在缓冲区中找到给定坐标的像素的内存，然后修改它的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base_addr;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> bpp;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> xsize;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> ysize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">画点</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    x,y：像素坐标</span></span><br><span class="line"><span class="comment">    color：颜色值</span></span><br><span class="line"><span class="comment">    对于16BPP：color的格式为0xAARRGGBB  AA是透明度，0-256，需要转换为5:6:5格式</span></span><br><span class="line"><span class="comment">    对于8BPP：color为调色板的索引值，颜色取决于调色板中的数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutPixel</span><span class="params">(UINT32 x,UINT32 y,UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT8 red,green,blue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(bpp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            UINT16 *addr = (UINT16 *)fb_base_addr + (y * xsize + x);</span><br><span class="line">            red = (color &gt;&gt; <span class="number">19</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            green = (color &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            blue = (color &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">            color = (red &lt;&lt; <span class="number">11</span>) | (greee &lt;&lt; <span class="number">5</span>) | (blue);                <span class="comment">//格式5：6：5</span></span><br><span class="line">            *addr = (UINT16) color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            UINT8 *addr = (UINT8 *)fb_base_addr + (y * xsize + x);</span><br><span class="line">            *addr = (UINT8) color</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第1-4行的4个变量在lcddrv.c中的Tft_Lcd_Init函数中设置，PutPixel函数根据它们来确定给定坐标的像素在缓冲区中的地址。<br>第22、34行分别计算16BPP、8BPP模式下给定坐标的像素在帧缓冲中的地址。对于16BPP模式，每个像素占据2字节；对于8BPP模式，每个像素占据1字节。<br>对于16BPP的显示模式，第22-25行从0xAARRGGBB中提取8位红色值的高5位，8位绿色值的高6位，8位蓝色值的高5位组成5：6：5格式的16BPP颜色值。<br>最后，第28、35行将颜色值（8BPP模式下为调色板索引值）写入帧缓冲区中，这样下一次显示的时候，新颜色就可以显示出来了。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第13章 LCD控制器</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
</search>
