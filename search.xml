<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇博客</title>
    <url>/2022/07/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里是Nibil建立博客后的第一篇文章。</p>
<span id="more"></span>
<p>历时两个工作日，我采用了<a href="https://hexo.io/">Hexo博客框架</a>和Github Pages网页部署工具。在广大网友的帮助下，踩过一些坑，终于成功搭建并部署Nibil的博客。博客采用了<a href="https://github.com/next-theme/hexo-theme-next">Next</a>主题模板,在仿照<a href="https://carlyleliu.github.io/">CarlyleLiu</a>的博客模板的基础上，附带了我本人的一些个性化设置。于是，Nibil的私人博客诞生了，希望不要马上去世~~~<br>我建立博客的初衷是为了督促自己能抽出时间来学习，复习自己从事的嵌入式行业的专业知识，并分享在博客上，以此来达到温故而知新的目的，从而提高自己的行业竞争力。我暂时将博客大纲定性为四块，工作，学习，生活，杂项。工作包含自己在公司做项目过程中遇到的问题以及解决的问题，避免自己重复踩坑。学习包含自己主动去提升尚未掌握但是以后工作中会用到的领域的知识，避免一问三不知。生活属于是自己日常生活中的一些分享，毕竟这是一个博客。杂项就是我个人的一些感想，领悟啥的，属于是发牢骚。<br>暂时就写这么多，希望我的这第一篇文章不会成为我的最后一篇文章！</p>
]]></content>
      <categories>
        <category>杂</category>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Linux开发概述</title>
    <url>/2022/08/04/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第1章总结归纳</p>
<span id="more"></span>
<h1 id="嵌入式系统介绍"><a href="#嵌入式系统介绍" class="headerlink" title="嵌入式系统介绍"></a>嵌入式系统介绍</h1><h2 id="嵌入式系统的定义和特点"><a href="#嵌入式系统的定义和特点" class="headerlink" title="嵌入式系统的定义和特点"></a>嵌入式系统的定义和特点</h2><h3 id="嵌入式系统的定义"><a href="#嵌入式系统的定义" class="headerlink" title="嵌入式系统的定义"></a>嵌入式系统的定义</h3><p>嵌入式系统的定义为：以应用为中心，以计算机技术为基础、软硬件可裁剪、适用于应用系统，对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。它的主要特点是嵌入，专用。<br>含有嵌入式系统的设备成为嵌入式设备，这在生活中随处可见：电子表、手机、MP3播放器、遥控器等。涵盖了生产、工业控制、通信、网络、消费电子、汽车电子、军工等领域。从通俗，广义的角度来说，除电脑，超级计算机等具备比较强大计算能力及系统资源（比如内存，存储器等）的电子系统之外，凡具备计算能力的设备都可称为嵌入式设备。</p>
<h3 id="嵌入式设备的特点"><a href="#嵌入式设备的特点" class="headerlink" title="嵌入式设备的特点"></a>嵌入式设备的特点</h3><ol>
<li>软硬件可裁剪</li>
<li>对功能、可靠性、成本、体积、功耗严格要求</li>
</ol>
<h2 id="嵌入式技术的发展史"><a href="#嵌入式技术的发展史" class="headerlink" title="嵌入式技术的发展史"></a>嵌入式技术的发展史</h2><p>通用计算机和嵌入式计算机是两条不同的道路。通用计算机系统的技术要求是高速海量的数值计算；技术发展方向是总线速度的无限提升，存储容量的无限扩大。而嵌入式计算机系统的技术要求是对象的智能化控制能力；技术发展方向则是与对象系统密切相关的嵌入性能、控制能力与控制的可靠性。<br>嵌入式技术发展日新月异，经历了单片机（SCM）、微控制器（MCU）、系统级芯片（SOC）3个阶段。</p>
<h3 id="SCM（Single-Chip-Microcomputer）"><a href="#SCM（Single-Chip-Microcomputer）" class="headerlink" title="SCM（Single Chip Microcomputer）"></a>SCM（Single Chip Microcomputer）</h3><p>又称单片微型计算机，简称单片机，随着大规模集成电路的出现以及发展，计算机的CPU、RAM、ROM、定时计数器和多种I&#x2F;O接口集成在一片芯片上，形成芯片级计算机。<br>这个阶段主要寻求单片形态嵌入式系统的最佳体系结构。</p>
<h3 id="MCU（Micro-Controller-Unit）"><a href="#MCU（Micro-Controller-Unit）" class="headerlink" title="MCU（Micro Controller Unit）"></a>MCU（Micro Controller Unit）</h3><p>MCU即微型控制器的特征是：满足各类嵌入式应用，根据对象系统扩展各类外围电路和接口电路，突显其对象的智能化控制能力。它所涉及的领域都与对象系统有关。<br>实际上，SCM和MCU在日常工作中并不严格区分，很多时候一概以单片机称呼。随着能够运行更复杂软件（操作系统）的SOC的出现，单片机通常是指不允许操作系统，功能相对单一的嵌入式系统。但这也不是绝对的，比如8051上就可以运行RTX51实时操作系统，它的大小只有6KB，相比于嵌入式Linux，Windows CE等操作系统而言比较简单。</p>
<h3 id="SoC（System-on-a-Chip）"><a href="#SoC（System-on-a-Chip）" class="headerlink" title="SoC（System on a Chip）"></a>SoC（System on a Chip）</h3><p>随着设计与制造技术的发展，集成电路设计从晶体管的集成发展到逻辑门的集成，现在又发展到IP的集成，即SOC设计技术。Soc可以有效降低电子&#x2F;信息系统产品的开发成本，缩短开发周期，提高产品的竞争力，是未来工业界将采用的最主要的产品开发方式。<br>Soc的特征：</p>
<ol>
<li>实现复杂系统功能的VLSI；</li>
<li>采用超深亚微米工艺技术；</li>
<li>使用一个以上嵌入式CPU&#x2F;数字信号处理器DSP；</li>
<li>外部可以对芯片进行编程；</li>
<li>主要采用第三方IP进行设计。<br>从上述SoC特征来看，SoC中包含了微处理器、微控制器、存储器以及其他专用功能逻辑，但是并不包含微处理器、微控制器、存储器以及其他专用功能的芯片就是SoC。8051就集成了微处理器、存储器等部件，它不属于SoC。SoC的主要价值在于—缩短了产品的上市周期。<br>因此SoC更合理的定义：SoC是在一个芯片上由于广泛使用预定制模块IP（Intellectual Property）而得以快速开发的集成电路。<br>本书介绍的S3C2410&#x2F;S3C2440就属于SoC，它们集成了处理器、MMU、NAND Flash控制器等部件，而处理器的IP是基于ARM公司的。<br>以前写的单片机软件，通常是在main函数当中定义一个无限循环，然后在里面查询各类输入事件，并做相应处理，它直接操作硬件；而基于SoC的软件多是在操作系统上面运行，通过驱动程序操作硬件。</li>
</ol>
<h1 id="基于ARM处理器的嵌入式Linux系统"><a href="#基于ARM处理器的嵌入式Linux系统" class="headerlink" title="基于ARM处理器的嵌入式Linux系统"></a>基于ARM处理器的嵌入式Linux系统</h1><h2 id="ARM处理器介绍"><a href="#ARM处理器介绍" class="headerlink" title="ARM处理器介绍"></a>ARM处理器介绍</h2><h3 id="ARM处理器的概念"><a href="#ARM处理器的概念" class="headerlink" title="ARM处理器的概念"></a>ARM处理器的概念</h3><p>嵌入式处理器的种类繁多，又ARM、MIPS、PPC等多种架构。ARM的文档丰富，各类嵌入式软件大多选择ARM。在掌握ARM架构之后，上手其他处理器架构也会很快。<br>ARM(Advanced RISC Machine),既是一家公司的名字，也可以是一类处理器的统称，还可以认为是一种技术的名字。<br>ARM公司并不生产芯片，而是出售芯片授权。基于ARM的处理器以其高速度、低功耗、价格低等优点得到非常广泛的应用，它可以应用于以下领域：</p>
<ol>
<li>为无线通信、消费电子、成像设备等产品提供可运行复杂操作系统的开放应用平台；</li>
<li>在海量存储、汽车电子、工业控制和网络应用等领域提供实时嵌入式应用；</li>
<li>安全系统，比如SIM卡、信用卡等。</li>
</ol>
<h3 id="ARM体系架构的版本"><a href="#ARM体系架构的版本" class="headerlink" title="ARM体系架构的版本"></a>ARM体系架构的版本</h3><p>ARM体系架构的版本就是它所使用的指令集的版本。ARM公司支持32位的ARM指令集和16位的Thumb指令集，后者使得代码的存储空间大大减小。<br>还在使用的ARM指令集（ISA，Instruction Set Architecture）有以下版本：</p>
<ol>
<li>ARMv4<br>这是当前市场上最老的版本，ARMv4只支持32位的指令集，支持32位的地址空间。一些ARM7系列的处理器和Intel公司的StrongARM处理器采用ARMv4指令集。</li>
<li>ARMv4T<br>增加了16位的Thumb指令集，它可以产生更紧凑的代码，与相同功能的ARM代码相比，可以节省超过35%的存储空间，同时具备32位代码的所有优点。</li>
<li>ARMv5TE<br>1999年，ARMv5TE版本改进了Thumb指令集，增加了一些“增强型DSP指令”，简称E指令集。<br>这些指令用于增强处理器对于一些典型的DSP算法的处理性能，是的音频DSP应用可以提升70%的性能。许多系统在使用微控制器来进行各类控制的时候，还要具备数据处理能力，传统的做法要么是使用更高级的处理器，这会使得成本增加，要么是使用多个处理器，这会使得系统复杂度增高。通过E指令集可以在一个普通CPU中增加DSP的功能，这在成本、性能、简化设计等方面都有优势。</li>
<li>ARMv5TEJ<br>增加Jazelle技术用于提供Java加速功能。</li>
<li>ARMv6<br>2001年，ARMv6问世。它在很多方面都有改进：存储系统、异常处理，最重要的是增加了对多媒体功能的支持。ARMv6包含了一些媒体指令以支持SIMD媒体功能扩展。SIMD媒体功能扩展为音视频的处理提供了优化功能，可以使得音视频的处理性能提高4倍。<br>ARMv6中还引入了Thumb-2和TrustZone技术，这是两个可选的技术。之前的版本中，ARM指令和Thumb分别运行于不同的处理器状态下，执行不同的指令集的指令前需要进行切换。Thumb-2技术增加了混合模式的功能，定义了新的32位指令集，可以运行32位指令和16位指令的混合代码。这能够提供”ARM指令级别的性能“和”Thumb指令级别的代码密度“。TrustZone技术在硬件上提供了两个隔离的地址空间：安全域和非安全域，给系统提供了一个安全机制。</li>
<li>ARMv7<br>ARMv7架构使用Thumb-2技术，还使用了NEON技术，将DSP和媒体处理能力提高了近4倍，并支持改良的浮点运算，满足下一代3D图形、游戏物理应用以及传统嵌入式控制应用的需求。</li>
</ol>
<h3 id="ARM处理器系列"><a href="#ARM处理器系列" class="headerlink" title="ARM处理器系列"></a>ARM处理器系列</h3><p>在相同的指令集下，搭配不同的部件就可以组装出具有不同功能的处理器，比如有无内存管理单元，有无调试功能等。它们可以分为8个系列，系列名有7个后缀，这些后缀可以组合：<br>T：表示支持Thumb指令集。<br>D：表示支持片上调试（Debug）。<br>M：表示内嵌乘法器（Multiplier）。<br>I：支持片上断点和调试点。<br>E：表示支持增强型DSP功能。<br>J：表示支持Jazelle技术，即Java加速器。<br>S：表示全合成式（full synthesizable）。</p>
<ol>
<li>ARM7<br>ARM7系列处理器是低功耗32位RISC微处理器，它主要用于对成本、功耗特别敏感的产品。最高可达到130MIPS（Million Instructions Percent Second），支持Thumb16位指令集和ARM32位指令集。ARM7系列微处理器包括如下几种类型的核：ARM7TDMI、ARM7TDMI-S、ARM720T、ARM7EJ-S。其中。ARM7TMDI是目前使用最广泛的32位嵌入式RISC处理器，属于低端ARM处理器核。ARM7不带MMU。</li>
<li>ARM9<br>与ARM7相比，ARM9最大的差别在于：有MMU和Cach。它的指令执行效率较ARM7有较大提高，最高可达300MIPS。ARM9系列微处理器有ARM920T和ARM922T两种类型。</li>
<li>ARM9E<br>ARM9E系列微处理器在单一的处理器内核上提供了微控制器、DSP、Java应用系统的解决方案，极大的减少了芯片的面积和系统的复杂度。ARM9E系列微处理器提供了增强的DSP处理能力，适合于那些需要同时使用DSP和微控制器的应用场合。<br>ARM9E系列微处理器有ARM926EJ-S、ARM946E-S、ARM966E-S、ARM968E-S和ARM996HS共五种类型。</li>
<li>ARM10E<br>ARM10E微处理器具有更加杰出的高性能、低功耗特点，由于使用了新的体系结构，它拥有ARM系列中最高的主频。ARM10E系列微处理器采用了一种新的省电模式，支持”64 bit load-store micro-architecture“，含浮点运算协处理器。<br>ARM10E系列微处理器有ARM1020E、ARM1022E和ARM1026EJ-S三种类型。</li>
<li>ARM11<br>ARM11系列微处理器是ARM公司近年来推出的新一代RISC处理器，它是ARM新指令架构—ARMv6的第一代设计实现。ARM11的媒体处理能力和低功耗特点特别适用于无线和消费类电子产品，其高数据吞吐量和高性能的结合非常适合网络处理应用。另外在实时性能和浮点处理等方面ARM11可以满足汽车电子的应用需求。<br>ARM11系列微处理器有这4种类型：ARM11 MPCore、ARM1136J(F)-S、ARM1156T2(F)-S和ARM1176JZ(F)-S。</li>
<li>Cortex<br>Cortex基于ARMv7架构，分为Cortex-A、Cortex-R、Cortex-M三类。Cortex-A为传统的、基于虚拟内存的操作系统和应用程序而设计，支持ARM、Thumb、和Thumb-2指令集；Cortex-R针对实时系统设计，支持ARM、Thumb、和Thumb-2指令集；Cortex-M为对价格敏感的产品设计，只支持Thumb-2指令集。</li>
<li>SecureCore<br>SecureCore系列微处理器专为安全需要设计，提供了完善的32位RISC技术的安全解决方案，因此，SecureCore系列微处理器除了具有ARM体系结构的低功耗、高性能特点外，还具有其独特的优势，即提供了对安全解决方案的支持。<br>SecureCore系列微处理器有如下类型：SecureCoreSC100、SecureCoreSC200。</li>
<li>OptimoDE Data Engines<br>这是一个新的IP核，针对高性能的嵌入式信号处理应用而设计。<br>另外，Intel公司的StrongARM、Xscale系列处理器也属于ARM架构。Intel StrongARM处理器是便携式通信产品和消费电子产品的理想选择，已成功应用于多家公司的掌上电脑系列产品。Xscale处理器是基于ARMv5TE体系结构的解决方案，是一款全性能、高性价比、低功耗的处理器。它支持16位的Thumb指令和DSP指令集。</li>
</ol>
<h2 id="选择嵌入式Linux的理由"><a href="#选择嵌入式Linux的理由" class="headerlink" title="选择嵌入式Linux的理由"></a>选择嵌入式Linux的理由</h2><p>在嵌入式领域可以选择的操作系统有很多，比如：嵌入式Linux、VxWorks、Windows CE、μC&#x2F;OS-Ⅱ等。<br>VxWorks是美国WindRiver公司开发的嵌入式实时操作系统。但就性能而言，它是非常优秀的操作系统，具有可裁剪的微内核结构、高效的任务管理、灵活的任务间通信、微秒级的中断处理，支持POSIX 1003.1b实时扩展标准，支持多种物理介质及标准、完整的TCP&#x2F;IP网络协议等。缺点是它支持的硬件相对较少，源代码不开放，需要专门的技术人员进行维护，授权费用高。<br>Windows CE是微软公司针对嵌入式设备开发的32位、多任务、多线程的操作系统。它支持x86、ARM、MIPS、SH等架构的CPU，硬件驱动丰富，支持WiFi、USB2.0等新型设备，并且具有强大的多媒体功能；可以灵活裁剪以减少系统体积；与PC上的Windows操作系统相通，开发、调试工具使用方便。应用程序的开发流程与PC上的Windows程序开发流程类似。就开发的便利性而言，Windows CE是最好的。但是，它的源代码没有开放，开发人员难以进行更细致的定制，占用内存较多，整个相同相对庞大，版权许可费也比较高。<br>μC&#x2F;OS-Ⅱ是Micrium公司开发的操作系统，可用于8位、16位、32位处理器。可裁剪，对硬件要求低；可运行最多64个任务；任务调度方式位抢占式调度，总是运行最高优先级的就绪任务。用户可以获取μC&#x2F;OS-Ⅱ的全部代码，但是它不是完全免费的。用于商业目的，需要购买商业授权。μC&#x2F;OS-Ⅱ采用一次性收费的方式，价格低廉。μC&#x2F;OS-Ⅱ仅是一个实时内核，用户需要完成其他更多的工作，比如编写硬件驱动程序，实现文件操作等。<br>Linux是遵循GPL协议的开放源代码的操作系统，使用时无需缴纳许可费。内核可以任意裁剪，几乎支持所有的32位、62位CPU；内核中支持的硬件种类繁多，几乎可以从网络上找到所有的硬件驱动程序；支持几乎所有的网络协议；有大量的应用程序可以使用，从编译工具，调试工具到GUI程序，几乎都遵循GPL协议的相关版本；有庞大的开发人员群体，有数量众多的技术论坛，大多数问题可以得到快速而且免费的解答。<br>Linux的缺点在于实时性，虽然在2.6版本的Linux在实时性上有了较大的改进，但是仍然无法称作实时操作系统。不过正是因为Linux开放源代码、易于移植、资源丰富、免费等优点，使得它在嵌入式领域越来越流行。更重要的一点，由于嵌入式Linux与PC Linux基于同样的内核代码，只是裁剪的程度不一样，这使得很多为PC开发的软件再次编译后，可以直接在嵌入式设备上面运行，这使得软件资源极大丰富，比如各类使用的函数库等。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第1章 嵌入式Linux开发概述</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>何谓硬解码和软解码</title>
    <url>/2022/08/05/%E4%BD%95%E8%B0%93%E7%A1%AC%E8%A7%A3%E7%A0%81%E5%92%8C%E8%BD%AF%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于“硬解码”与“软解码”。</p>
<span id="more"></span>
<p>软解码和硬解码的区别：</p>
<ol>
<li>软解码使用CPU进行解码。</li>
<li>硬解码使用非CPU进行解码，如GPU、专用的DSP、FPGA、ASIC等芯片。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>何谓硬解码和软解码</category>
      </categories>
      <tags>
        <tag>多媒体编解码</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO接口</title>
    <url>/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第5章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>掌握嵌入式开发的步骤：编程、编译、烧写程序、运行</li>
<li>通过GPIO口的操作了解软件如何控制硬件</li>
</ol>
<h1 id="GPIO硬件介绍"><a href="#GPIO硬件介绍" class="headerlink" title="GPIO硬件介绍"></a>GPIO硬件介绍</h1><p>GPIO（Genaral Purpose I&#x2F;O Ports）意思是通过通用输入&#x2F;输出端口，通俗的说，就是一些引脚，可以通过它们输出高低电平或者通过它们读入引脚的状态—是高电平还是低电平。<br>S3C2410有117个I&#x2F;O端口，共分为A-H 8组，GPA、GPB、……、GPH。S3C2440有130个I&#x2F;O端口，共分为A-H 9组，GPA、GPB、……、GPJ。可以通过设置寄存器来确定某个引脚用于输入、输出还是其他特殊功能。比如可以设置GPH6作为一般的输入、输出引脚，或者用于串口。<br>GPIO的操作是所有硬件操作的基础，由此扩展开来可以了解所有硬件的操作，这是底层开发人员必须掌握的。</p>
<h2 id="通过寄存器来操作GPIO引脚"><a href="#通过寄存器来操作GPIO引脚" class="headerlink" title="通过寄存器来操作GPIO引脚"></a>通过寄存器来操作GPIO引脚</h2><p>既然一个引脚可以用于输入、输出或其他功能，那么一定有寄存器用来选择这些功能；对于输入，一定可以通过读取某个寄存器来确定引脚的电平是高还是低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电平还是低电平；对于其他特殊功能，则有另外的寄存器来控制它。<br>对于这几组GPIO引脚，它们的寄存器是相似的；GPxCON用于选择引脚功能。GPxDAT用于读写引脚数据。GPxUP用于确定是否使用内部上拉电阻。</p>
<h3 id="GPxCON寄存器"><a href="#GPxCON寄存器" class="headerlink" title="GPxCON寄存器"></a>GPxCON寄存器</h3><p>从寄存器的名字可以看出，它用于配置（Configure）—选择引脚的功能。<br>PORT A与PORT B-PORT H&#x2F;J在功能选择方面有所不同，GPACON中每一位对应一根引脚（共23根引脚）。当某位被设置为0时，相应引脚为输出引脚，此时我们可以在GPADAT中的相应位写入0或1让此引脚输出高电平或者低电平。当某位被设置为1时，相应的引脚为地址线，或用于地址控制。此时的GPADAT无用。通常而言GPACON全被设置为1，以便访问外部存储器件。<br>PORT B-PORT H&#x2F;J 在寄存器操作方面完全相同。GPxCON中每两位控制一根引脚，00表示输入、01表示输出、10表示特殊功能、11保留。</p>
<h3 id="GPxDAT寄存器"><a href="#GPxDAT寄存器" class="headerlink" title="GPxDAT寄存器"></a>GPxDAT寄存器</h3><p>GPxDAT用于读&#x2F;写引脚；当引脚被设置为输入时，读此寄存器可知相应引脚的电平状态是高还是低；当引脚被设置为输出时，写此寄存器相应位可令此引脚输出高电平或者低电平。</p>
<h3 id="GPxUP"><a href="#GPxUP" class="headerlink" title="GPxUP"></a>GPxUP</h3><p>某位为1时，相应引脚无内部上拉电阻；为0时，相应引脚使用内部上拉电阻。<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/1.jpeg" alt="img not found"><br>上拉、下拉电阻的作用在于，当GPIO引脚处于第三态（既不是输出高电平，也不是输出低电平，而是呈高阻态）时，它的电平状态由上拉、下拉电阻决定。</p>
<h2 id="怎样使用软件来访问硬件"><a href="#怎样使用软件来访问硬件" class="headerlink" title="怎样使用软件来访问硬件"></a>怎样使用软件来访问硬件</h2><h3 id="访问单个引脚"><a href="#访问单个引脚" class="headerlink" title="访问单个引脚"></a>访问单个引脚</h3><p>单个引脚的操作无外乎3种：输出高低电平、检测引脚状态、中断。对某个引脚的操作一般通过读写寄存器来完成。<br>比如对于图5.2所示的电路，可以设置GPBCON寄存器将GPB5、GPB6、GPB7和GPB8设为输出功能，然会写GPBDAT的寄存器使得这四个引脚输出高电平或低电平。输出高电平时，相应的LED灯熄灭，输出低电平时，相应的LED灯点亮。<br>还可以设置GPFCON寄存器将GPF0、GPF2、GPF3和GPF11设为输入功能，然后通过读出GPFDAT&#x2F;GPGDAT寄存器并判断相应位是0还是1来确定各个按键是否被按下。某个按键按下时，相应引脚电平为低，GPFDAT&#x2F;GPGDAT寄存器相应位为0，否则为1。<br>那么怎么访问这些寄存器呢，通过软件，读写它们的地址。比如，GPBCON和GPBDAT寄存器的地址都是0x56000010、0x56000014，可以通过如下的指令让GPB5输出低电平，点亮LED1。<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/2.jpeg" alt="img not found"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (*(volatile unsigned long *)0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (*(volatile unsigned long *)0x56000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line">GPBCON = GPB5_out;<span class="comment">//GPB5引脚设置为输出</span></span><br><span class="line">GPBDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//GPB5输出低电平</span></span><br></pre></td></tr></table></figure>
<h3 id="以总线方式访问硬件"><a href="#以总线方式访问硬件" class="headerlink" title="以总线方式访问硬件"></a>以总线方式访问硬件</h3><p>并非只能通过寄存器才能发出硬件信号，实际上，通过访问总线的方式控制硬件更常见。以NOR Flash的访问为例：<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/3.jpeg" alt="img not found"><br>图中，缓冲器的作用是为了提高驱动力、隔离前后级信号。NOR Flash AM29LV800BB的片选信号使用S3C2410&#x2F;S3C2440的nGCS0信号，当CPU发出的地址信号处于0x00000000-0x07FFFFFF之间时，nGCS0信号有效，于是NOR Flash被选中。这时，CPU发出的地址信号传到NOR Flash；进行写操作时，nWE信号为低，数据信号从CPU发出给NOR Flash；进行读操作时，nWE信号为高，数据信号从NOR Flash发给CPU。上图所示的硬件连线决定了读写操作都是以16位为单位的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址对齐的16位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> wVal;</span><br><span class="line">wVal = *pwAddr;</span><br></pre></td></tr></table></figure>
<p>上述代码就会向NOR Flash发起读操作：CPU发出的读地址为0x2，则地址总线ADDR1-ADDR20、A0-A19的信号都是1、0、…、0（CPU的ADDR0为0，不过ADDR0没有接到NOR Flash上）。NOR Flash接收到的地址就是0x1，NOR Flash在稍后的时间里将此址上的16位数据取出，并通过数据总线D0-D15发给CPU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址不对齐的16位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> wVal;</span><br><span class="line">wVal = *pwAddr;</span><br></pre></td></tr></table></figure>
<p>由于地址位0x1；不是2对齐的，但是BANK0的位宽被设为16，这将导致异常。我们可以设置异常处理函数来处理这种情况。在异常处理函数中，使用0x0、0x2发起两次读操作，然后将两个结果组合起来。使用地址0x0读到两字节数据D0、D1，再使用地址0x2读到D2、D3。最后D1、D2组合成一个16位的数返回给wVal。如果没有设置地址不对齐异常处理函数，那么上述代码将出错。如果某个BANK位宽被设置为n，访问此BANK时，在总线上永远只会看到地址对齐的n位操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*8位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *pucAddr = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">0x6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucVal;</span><br><span class="line">ucVal = *pucAddr;</span><br></pre></td></tr></table></figure>
<p>CPU首先使用地址0x6对NOR Flash发起16位的读操作，得到两字节的数据，假设位D1、D0，然后将D0取出赋值给uvVal。在读操作期间，地址总线ADDR1-ADDR20、A0-A19的信号都是1、1、1、…、0。CPU会自动丢弃D1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*32位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *pdwAddr = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwVal;</span><br><span class="line">dwVal = *pdwAddr;</span><br></pre></td></tr></table></figure>
<p>CPU首先使用地址0x6对NOR Flash发起16位的读操作，得到两字节的数据，假设为D0，D1；再使用地址0x8发起读操作，得到两字节的数据D2，D3，最后将这4个字节的数据组合后再赋值给变量dwVal。<br>由于NOR Flash的特性，使得对NOR Flash的写操作比较复杂—比如要先发出特定的地址信号通知NOR Flash准备接受数据，然后才发出数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*16位写操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x6</span>;</span><br><span class="line">*pwAddr = <span class="number">0x1234</span>;</span><br></pre></td></tr></table></figure>
<p>CPU发起一次对NOR Flash的写操作，地址总线ADDR1-ADDR20、A0-A19的信号都时1、1、…、0；数据线DATA0-DATA15、D0-D15的信号为0、0、1、0、1、1、0、0、0、1、0、0、1、0、0、0。<br>由此可见，CPU使用某个地址进行访问时，这个32位的地址值和ADDR0-ADDR31一一对应，外接的设备可以以8位、16位、32位进行操作—取决于硬件设计。如果以8位进行操作，那么数据出现在数据信号DATA0-DATA7上，如果以16位进行操作，则数值出现在数据线DATA0-DATA15上；如果以32位进行操作，则数值出现在DATA0-DATA31上。</p>
<h1 id="GPIO操作实例"><a href="#GPIO操作实例" class="headerlink" title="GPIO操作实例"></a>GPIO操作实例</h1><p>LED和按键与处理器的电路连接基于图5.2。程序基于裸机开发，不带操作系统。</p>
<h2 id="纯汇编实现点亮一个LED"><a href="#纯汇编实现点亮一个LED" class="headerlink" title="纯汇编实现点亮一个LED"></a>纯汇编实现点亮一个LED</h2><p>汇编程序实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    ldr r0,=0x56000010      @r0设置为GPBCON寄存器，用于配置GPIOB系列引脚。</span><br><span class="line">    mov r1,#0x00000400      @r1赋值立即数0x00000400</span><br><span class="line">    str r1,[r0]             @GPBCON写入0x00000400，设置GPB5为输出口，位[10:9]=0b01</span><br><span class="line">    ldr r0,=0x56000014      @r0设置为GPBDAT寄存器，用于读写GPIOB系列引脚的数据。</span><br><span class="line">    mov r1,#0x00000020      @r1赋值立即数0x00000020</span><br><span class="line">    str r1,[r0]             @点亮LED1</span><br><span class="line">main_loop:</span><br><span class="line">    b main_lopp             @死循环</span><br></pre></td></tr></table></figure>
<p>编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o led_on.o led_on.S                        @编译</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf        @链接</span><br><span class="line">arm-linux-objcopy -O binary -S led_on_elf led_on.bin            @将elf格式的可执行文件转换位二进制格式</span><br></pre></td></tr></table></figure>

<h2 id="C代码实现点亮一个LED"><a href="#C代码实现点亮一个LED" class="headerlink" title="C代码实现点亮一个LED"></a>C代码实现点亮一个LED</h2><p>C语言执行的第一条指令并不在main函数中。生成一个C程序的可执行文件时，编译器通常会在我们的代码中加上几个被称为启动文件的代码—crtl.o、crti.o、crtend.o、crtn.o等，它们是标准库文件。这些代码设置C程序的堆栈等，然后调用main函数。它们依赖于操作系统，在裸板上这些代码无法执行，所以需要自己写一个。<br>这段代码很简单，只有6条指令，自己编写的crt0.S文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:crt0.S</span></span><br><span class="line"><span class="comment">通过它转入C程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    ldr r0,=<span class="number">0x56000010</span>      @watchdog地址寄存器</span><br><span class="line">    mov r1,#<span class="number">0x0</span>             @</span><br><span class="line">    str r1,[r0]             @写入<span class="number">0</span>，禁止watchdog，否则CPU会不断重启</span><br><span class="line">    ldr sp,=<span class="number">1024</span>*<span class="number">4</span>          @设置堆栈，注意不能大于<span class="number">4</span>KB，因为当前可以内存只有<span class="number">4</span>KB</span><br><span class="line">                            @NAND Flash中的代码会在复位后移到内部RAM（只有<span class="number">4</span>KB）</span><br><span class="line">    bl main                 @调用C程序中的main函数</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">    b halt_loop</span><br></pre></td></tr></table></figure>
<p>设置好堆栈指针后，就可以调用C函数main了。C函数执行前，必须设置栈。<br>所以现在可以写出控制LED的C程序了。main函数在led_on_c.c中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (*(volatile unsigned long *)0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (*(volatile unsigned long *)0x56000014)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    GPBCON = <span class="number">0x00000040</span>;    <span class="comment">//设置GPB5为输出端口，位[10:9]=0b01</span></span><br><span class="line">    GPBDAT = <span class="number">0x00000000</span>;    <span class="comment">//GPB5输出0，LED1点亮</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o crt0.o crt0.S</span><br><span class="line">arm-linux-gcc -g -c -o led_on_c.0 led_on_c.c</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 -g crt0.o led_on_c.o -o led_on_c_elf</span><br><span class="line">arm-linux-objcopy -O binary -S led_on_c_elf led_on_c.bin</span><br><span class="line">arm-linux-objdump -D -m arm led_on_c_elf &gt; led_on_c.dis</span><br></pre></td></tr></table></figure>
<p>先分别编译crt0.S和led_on_c.c(不连接)。然后将编译的结果连接起来。然后把得到的ELF格式的文件led_on_c_elf转换成二进制的bin文件。最后将结果转换为汇编代码以供查看。</p>
<h2 id="按键来控制LED"><a href="#按键来控制LED" class="headerlink" title="按键来控制LED"></a>按键来控制LED</h2><p>当K1-K4某个按键按下时，点亮LED1-LED4中相应的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:key_led.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (* (unsigned long *) 0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (* (unsigned long *) 0x56000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFCON (* (unsigned long *) 0x56000050)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFDAT (* (unsigned long *) 0x56000054)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPGCON (* (unsigned long *) 0x56000060)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPGDAT (* (unsigned long *) 0x56000064)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LED1-LED4对应GPB5、GPB6、GPB7、GPB8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">K1-K4对应GPG11、GPG3、GPF2、GPF0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPG11_in ~(3&lt;&lt;(11*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPG3_in ~(3&lt;&lt;(3*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPF2_in ~(3&lt;&lt;(2*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPF0_in ~(3&lt;&lt;(0*2))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dwDat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LED1-LED4对应的4根引脚设置为输出</span></span><br><span class="line">    GPBCON = GPB5_out | GPB6_out | GPB7_out | GPB8_out ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//K1-K2对应的两根引脚设为输入</span></span><br><span class="line">    GPGCON = GPG11_in &amp; GPG3_in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwDat = GPGDAT;             <span class="comment">//读取GPG管脚电平状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>))       <span class="comment">//K1没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>);    <span class="comment">//LED1熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);   <span class="comment">//LED1点亮</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))        <span class="comment">//K2没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">6</span>);    <span class="comment">//LED2熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);   <span class="comment">//LED2点亮</span></span><br><span class="line"></span><br><span class="line">        dwDat = GPFDAT;             <span class="comment">//读取GPF管脚电平状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>))        <span class="comment">//K3没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);    <span class="comment">//LED3熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);   <span class="comment">//LED3点亮</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>))        <span class="comment">//K4没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">//LED4熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);   <span class="comment">//LED4点亮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码先将LED1-LED4对应的引脚GPB5-GPB8设为输出引脚。<br>然后将K1、K2对应的引脚GPG11、GPG3设为输入引脚，K3、K4对应的引脚GPF2、GPF0设为输入引脚。<br>然后就是一个无穷循环，读取GPGDAT、GPFDAT寄存器，从中判断K1、K2、K3、K4是否按下。若按下则点亮相应的LED，否则熄灭相应的LED。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第5章 GPIO接口</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>裸机</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之工厂模式</title>
    <url>/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之工厂模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在工厂模式中，我们创建对象时不会对客户暴露逻辑并且是通过一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；创建简单对象时，建议直接new完成一个实例对象的创建。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>主要特点是需要在工厂类中做判断，从而创建相应的产品，当增加新的产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。<br>缺点：工厂类中集中了所有产品的创建逻辑，如果产品量过大，会使工程类变得臃肿。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品种类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    Clothes_Min = <span class="number">-1</span>,</span><br><span class="line">    Clothes_pants,</span><br><span class="line">    Clothes_jeans,</span><br><span class="line">    Clothes_Max,</span><br><span class="line">&#125;Clothes_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Pants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Jeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Jeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Clothes *<span class="title">MakeClothes</span><span class="params">(Clothes_t clothes_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(clothes_type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Clothes_pants:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Pants</span>();</span><br><span class="line">            <span class="keyword">case</span> Clothes_jeans:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Jeans</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory fac;</span><br><span class="line"></span><br><span class="line">    Clothes *pants = fac.<span class="built_in">MakeClothes</span>(Clothes_pants);</span><br><span class="line">    pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    Clothes *jeans = fac.<span class="built_in">MakeClothes</span>(Clothes_jeans);</span><br><span class="line">    jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pants;</span><br><span class="line">    pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> jeans;</span><br><span class="line">    jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>定义一个创建对象的接口，其子类去具体实现这个接口已完成具体的创建工作。如果需要增加新的产品类，只需要扩展一个相应的工厂类即可。<br>缺点：产品类数据较多时，需要实现大量的工厂类，这无疑增加了代码量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Pants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Jeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Jeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Clothes* <span class="title">MakeClothes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PantsFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">Clothes* <span class="title">MakeClothes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Pants</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JeansFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">Clothes* <span class="title">MakeClothes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Jeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *pants_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Clothes *pants_clo = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    pants_fac = <span class="keyword">new</span> <span class="built_in">PantsFactory</span>();</span><br><span class="line">    pants_clo = pants_fac-&gt;<span class="built_in">MakeClothes</span>();</span><br><span class="line">    pants_clo-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pants_fac;</span><br><span class="line">    pants_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> pants_clo;</span><br><span class="line">    pants_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Factory *jeans_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Clothes *jeans_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    jeans_fac = <span class="keyword">new</span> <span class="built_in">JeansFactory</span>();</span><br><span class="line">    jeans_clo = jeans_fac-&gt;<span class="built_in">MakeClothes</span>();</span><br><span class="line">    jeans_clo-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> jeans_fac;</span><br><span class="line">    jeans_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> jeans_clo;</span><br><span class="line">    jeans_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/2.jpeg" alt="img not found"></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式提供创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。<br>当存在多个产品系列，而客户端只使用一格系列的产品时，可以考虑使用抽象工厂模式<br>缺点：当增加一个新系列的产品时，不仅需要实现具体的产品类，还需要增加一个新的创建接口，扩展相对困难。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhitePants</span> : <span class="keyword">public</span> Pants</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WhitePants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;WhitePants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackPants</span> : <span class="keyword">public</span> Pants</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlackPants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;BlackPants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhiteJeans</span> : <span class="keyword">public</span> Jeans</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WhiteJeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;WhiteJeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackJeans</span> : <span class="keyword">public</span> Jeans</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlackJeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;BlackJeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pants* <span class="title">MakePants</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Jeans* <span class="title">MakeJeans</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhiteFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pants* <span class="title">MakePants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WhitePants</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Jeans* <span class="title">MakeJeans</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WhiteJeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pants* <span class="title">MakePants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BlackPants</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Jeans* <span class="title">MakeJeans</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BlackJeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *white_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Pants* white_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    Jeans* white_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    white_fac = <span class="keyword">new</span> <span class="built_in">WhiteFactory</span>();</span><br><span class="line">    white_pants = white_fac-&gt;<span class="built_in">MakePants</span>();</span><br><span class="line">    white_pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    white_jeans = white_fac-&gt;<span class="built_in">MakeJeans</span>();</span><br><span class="line">    white_jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> white_fac;</span><br><span class="line">    white_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> white_pants;</span><br><span class="line">    white_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> white_jeans;</span><br><span class="line">    white_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Factory *black_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Pants* black_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    Jeans* black_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    black_fac = <span class="keyword">new</span> <span class="built_in">BlackFactory</span>();</span><br><span class="line">    black_pants = black_fac-&gt;<span class="built_in">MakePants</span>();</span><br><span class="line">    black_pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    black_jeans = black_fac-&gt;<span class="built_in">MakeJeans</span>();</span><br><span class="line">    black_jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> black_fac;</span><br><span class="line">    black_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> black_pants;</span><br><span class="line">    black_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> black_jeans;</span><br><span class="line">    black_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/3.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
        <tag>应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之单例模式</title>
    <url>/2022/08/17/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之单例模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>单例模式顾名思义，保证一个类在内存中仅有一个实例化对象，并提供一个可以访问它的全局化接口。实现单例模式必须注意以下几点：</p>
<ol>
<li>单例类只能有一个实例化对象。</li>
<li>单例类必须自己提供一个实例化对象。</li>
<li>单例类必须提供一个可以访问唯一实例化对象的接口。<br>单例模式分为懒汉式和饿汉式两种实现方式。</li>
</ol>
<h1 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h1><p>懒汉，顾名思义，不到万不得已就不会去实例化类，也就是说第一次用到类实例的时候才会去实例化一个对象。在访问量较小，甚至可能不会去访问的情况下，采用懒汉实现，以时间换空间。</p>
<h2 id="非线程安全的懒汉单例模式"><a href="#非线程安全的懒汉单例模式" class="headerlink" title="非线程安全的懒汉单例模式"></a>非线程安全的懒汉单例模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关键代码：构造函数私有，不能通过赋值运算，拷贝构造等方法实例化对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式一般实现：非线程安全，getInstance返回的实例指针需要delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">SingleMan</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line">&#125;;</span><br><span class="line">SingleMan *SingleMan::m_singleMan = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan *<span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_m_singleMan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="非线程安全的懒汉单例模式-1"><a href="#非线程安全的懒汉单例模式-1" class="headerlink" title="非线程安全的懒汉单例模式"></a>非线程安全的懒汉单例模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">SingleMan</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line"></span><br><span class="line">    std::mutex m_lock;</span><br><span class="line">&#125;;</span><br><span class="line">SingleMan *SingleMan::m_singleMan = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan *<span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_m_singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回一个reference指向local-static对象"><a href="#返回一个reference指向local-static对象" class="headerlink" title="返回一个reference指向local static对象"></a>返回一个reference指向local static对象</h2><p>这种单例模式实现方式多线程可能存在不确定性：任何一种non-const static 对象，不论它是local还是non-local，在多线程环境下”等待某事发生“都会有麻烦。<br>解决办法：在程序的单线程启动阶段手工调用所有reference-returing函数。<br>下面这种实现方式的好处就是你不需要去关心实例的释放，因为static修饰的变量生命周期和程序一样长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan&amp; <span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> SingleMan singleMan;</span><br><span class="line">    <span class="keyword">return</span> singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h1><p>饿汉模式，在访问量较大，或者访问线程较多时，采用饿汉实现，可以实现更好的性能。这是一种空间换时间的策略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式：线程安全，注意一定要在合适的地方去delete它</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line">​</span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">SingleMan* SingleMan::m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">​</span><br><span class="line"><span class="function">SingleMan* <span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/17/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
        <tag>应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之策略模式</title>
    <url>/2022/08/22/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之策略模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>策略模式是指定义一系列的算法，把它们一个个的封装起来，并且使它们可以互相替换。本模式可以使得算法独立于它的客户而变化。也就是说这些算法完成的功能一样，对外的接口一样，只是各自实现实现上存在差异。用策略模式来封装算法，效果比较好。<br>下面以高速缓存（Cache）的替换算法为例，实现策略模式。<br>所谓Cache的替换算法，就是当Cache发生缺失时，Cache控制器必须选择Cache中的一行并用欲获得的数据替换它。所采用的选择策略就是Cache的替换算法。相应的UML类图如下：<br><img src="/2022/08/22/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
<h1 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h1><p>这里首先给出算法的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">replace</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Least Recently Used replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFO_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;First in First out replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Random_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Random replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="实现方式1"><a href="#实现方式1" class="headerlink" title="实现方式1"></a>实现方式1</h1><p>接着给出Cache的定义，这里很关键，Cache的实现方式直接影响了客户的使用方式，其关键在于怎么指定替换算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cache</span>(ReplaceAlgorithm *ra)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ra = ra;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cache</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ra;</span><br><span class="line">        m_ra = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ra-&gt;<span class="built_in">replace</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ReplaceAlgorithm *m_ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cache <span class="title">cache</span><span class="params">(<span class="keyword">new</span> LRU_ReplaceAlgorithm())</span></span>; <span class="comment">//暴露了算法的定义  </span></span><br><span class="line">    cache.<span class="built_in">Replace</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式暴露给了客户具体的算法的定义。</p>
<h1 id="实现方式2"><a href="#实现方式2" class="headerlink" title="实现方式2"></a>实现方式2</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cache需要用到替换算法  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RA</span> &#123;LRU, FIFO, RANDOM&#125;; <span class="comment">//标签  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    ReplaceAlgorithm *m_ra;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Cache</span>(<span class="keyword">enum</span> RA ra)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(ra == LRU)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">LRU_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ra == FIFO)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">FIFO_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ra == RANDOM)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">Random_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">            m_ra = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~<span class="built_in">Cache</span>() &#123; <span class="keyword">delete</span> m_ra; &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span> </span>&#123; m_ra-&gt;<span class="built_in">Replace</span>(); &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">Cache <span class="title">cache</span><span class="params">(LRU)</span></span>; <span class="comment">//指定标签即可  </span></span><br><span class="line">    cache.<span class="built_in">Replace</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这种方式也是通过参数指定，不过不是传入指针，而是传入算法的枚举。这样客户就不需要知道算法的具体定义，只需要知道算法的标签即可。</p>
<h1 id="实现方式3"><a href="#实现方式3" class="headerlink" title="实现方式3"></a>实现方式3</h1><p>以上两种实现方式都需要构造函数传参才能实现，是否可以不需要构造函数传参的方式来实现？<br>利用模板来实现。算法通过模板的实参指定，虽然还是使用了参数，但是不是构造函数的参数。在策略模式中，参数的传递难以避免，客户必须指定某种算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cache需要用到的替换算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RA</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RA m_ra;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cache</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Cache</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ra.<span class="built_in">repalce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cache &lt;Random_ReplaceAlgorithm&gt; cache;<span class="comment">//模板实参</span></span><br><span class="line">    cache.<span class="built_in">replace</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>策略模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
        <tag>应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>通用异步收发器UART</title>
    <url>/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第11章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解UART的原理</li>
<li>掌握S3C2410&#x2F;S3C2440中UART的使用</li>
</ol>
<h1 id="UART原理以及UART部件使用方法"><a href="#UART原理以及UART部件使用方法" class="headerlink" title="UART原理以及UART部件使用方法"></a>UART原理以及UART部件使用方法</h1><h2 id="UART原理说明"><a href="#UART原理说明" class="headerlink" title="UART原理说明"></a>UART原理说明</h2><p>通用异步收发器简称UART（Universal Asynchronous Reciver Transmitter），它用来传输串行数据。发送数据时，CPU将并行数据写入UART，UART按照一定的格式在一根电线上发出；接收数据时，UART检测另一根电线上的信号，将串行收集放在缓冲区中，CPU即可读取UART获得这些数据。UART之间以全双工方式传输数据，最精简的连线方法只有三根电线，TxD用于发送数据，RxD用于接收数据，GnD用于给双方提供参考电平。<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/1.jpeg" alt="img not found"><br>UART使用标准的TTL&#x2F;CMOS逻辑电平（0-5V、0-3.3V、0-2.5V、0-1.8V）来表示数据，高电平表示1，低电平表示0。为了增强数据的抗干扰能力、提高传输长度，通常将TTL&#x2F;CMOS逻辑电平转换为RS-232逻辑电平，3<del>12V表示0，-3</del>-12V表示1。<br>TxD、RxD数据线以“位”为最小单位传输数据。帧（Frame）由具有完整意义、不可分割的若干位组成，它包含开始位、数据位、校验位（需要的话）和停止位。发送数据之前，UART之间要约定好数据的传输速率（即每位所占据的时间，其倒数称为波特率）、数据的传输格式（即有多少个数据位、是否使用校验位、奇校验还是偶校验、有多少个停止位）。<br>数据传输流程如下：</p>
<ol>
<li>平时数据线处于空闭状态（1状态）。</li>
<li>当要发送数据时，UART改变TxD数据线的状态（变为0状态），并维持1位的时间，这样接收方检测到开始位之后，再等待1.5位的时间就开始一位一位检测数据线的状态得到所传输的数据。</li>
<li>UART一帧中可以有5、6、7或8位得数据，发送方一位一位地改变数据线的状态将它们发送出去，首先发送最低位。</li>
<li>如果使用校验功能，UART在发送完数据位之后，还要发送一个校验位。有两种校验方法：奇校验、偶校验—数据位连同校验位中“1”的数目等于奇数还是偶数。</li>
<li>最后，发送停止位，数据线恢复到空闭状态（1状态）。停止位的长度有3种：1位、1.5位、2位。</li>
</ol>
<p>下图演示了UART使用7个数据位、偶校验、2个停止位的格式传输字符’A‘（二进制格式为0b1000001）时，TTL&#x2F;CMOS逻辑电平、RS232逻辑电平对应的波形。<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/2.jpeg" alt="img not found"></p>
<h2 id="S3C2410-x2F-S3C2440-UART的特性"><a href="#S3C2410-x2F-S3C2440-UART的特性" class="headerlink" title="S3C2410&#x2F;S3C2440 UART的特性"></a>S3C2410&#x2F;S3C2440 UART的特性</h2><p>S3C2410&#x2F;S3C2440 中UART的特性相似，有3个独立的通道，每个通道都可以工作于中断模式或DMA模式，即UART可以发出中断或DMA请求以便在CPU、UART之间传输数据。S3C2410&#x2F;S3C2440 UART由波特率发生器、发送器、接收器和控制逻辑组成。<br>使用系统时钟时，S3C2410的UART波特率可以达到230.4Kbit&#x2F;s，S3C2440则可以达到115.2Kbit&#x2F;s；如果使用UEXTCLK引脚提供的外部时钟，则可以达到更高的波特率。波特率可以通过编程控制。<br>S3C2410 UART的每个控制通道都有16字节的发送FIFO和16字节的接收FIFO，S3C2440 UART的FIFO深度为64。发送数据时，CPU先将数据写入发送FIFO中，然后UART控制器会自动将FIFO中的数据复制到“发送移位器（Transmit Shifter）”中，发送移位器将数据一位一位的发送到TxD数据线上。接收数据时，“接收移位器（Receive Shifter）”，将RxD数据线上的数据一位一位的接收进来，然后复制到接收FIFO中，CPU即可从中读取数据。<br>S3C2410&#x2F;S3C2440 UART的每个通道支持的停止位有1位、2位，数据位有5、6、7或8位，支持校验功能，另外还有红外发送&#x2F;接收功能。<br>S3C2410&#x2F;S3C2440 UART结构如下图所示：<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/3.jpeg" alt="img not found"></p>
<h2 id="S3C2410-x2F-S3C2440-UART的使用"><a href="#S3C2410-x2F-S3C2440-UART的使用" class="headerlink" title="S3C2410&#x2F;S3C2440 UART的使用"></a>S3C2410&#x2F;S3C2440 UART的使用</h2><p>在使用UART之前需要设置波特率、传输格式；对于S3C2410&#x2F;S3C2440，还要选择所涉及管脚为UART功能，选择UART通道的工作模式为中断模式还是DMA模式。设置好之后，往某个寄存器写入数据即可发送。可以通过查询状态寄存器或设置中断来获知数据是否已经发送完毕、是否已经接收到数据。</p>
<h3 id="将所涉及的UART通道管脚设为UART功能"><a href="#将所涉及的UART通道管脚设为UART功能" class="headerlink" title="将所涉及的UART通道管脚设为UART功能"></a>将所涉及的UART通道管脚设为UART功能</h3><p>比如UART通道0中，GPH2、GPH3分别用作TXD0、RXD0，要使用UART通道0时，先设置GPHCON寄存器将GPH2、GPH3引脚的功能设为TXD0、RXD0。</p>
<h3 id="UBRDIVn寄存器（UART-BAUD-RATE-DIVISOR）：设置波特率"><a href="#UBRDIVn寄存器（UART-BAUD-RATE-DIVISOR）：设置波特率" class="headerlink" title="UBRDIVn寄存器（UART BAUD RATE DIVISOR）：设置波特率"></a>UBRDIVn寄存器（UART BAUD RATE DIVISOR）：设置波特率</h3><p>S3C2410 UART的时钟源有两种选择：PCLK、UEXTCLK；S3C2440的时钟源有三种选择：PCLK、UEXTCLK、FCLK&#x2F;n，其中n通过UCON0<del>UCON2联合设置。<br>根据给定的波特率、所选择的时钟源的频率，可以通过以下公式计算UBRDIVn寄存器（n为0</del>2，对应3个UART通道）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBRDIVn = (<span class="type">int</span>)(UART clock/(baud rate x <span class="number">16</span>)) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上述公式计算出来的UBRDIVn寄存器值不一定是整数，只要误差在1.87%之内即可。误差计算公式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tUPCLK = (UBRDIVn + <span class="number">1</span>) x <span class="number">16</span> x <span class="number">1F</span>rame / (UART clock)     <span class="comment">//tUPCLK 实际的UART时钟</span></span><br><span class="line">tUEXACT = <span class="number">1F</span>rame / baud rate                            <span class="comment">//tUEXACT 理论的UART时钟</span></span><br><span class="line">UART error = (tUPCLK - tUEXACT) / tUEXACT x <span class="number">100</span>%        <span class="comment">//误差</span></span><br></pre></td></tr></table></figure>

<h3 id="ULCONn寄存器（UART-LINE-CONTROL）：设置传输格式"><a href="#ULCONn寄存器（UART-LINE-CONTROL）：设置传输格式" class="headerlink" title="ULCONn寄存器（UART LINE CONTROL）：设置传输格式"></a>ULCONn寄存器（UART LINE CONTROL）：设置传输格式</h3><p>ULCONn寄存器（n为0~2）格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数据位宽度</td>
<td>[1:0]</td>
<td>0b00：5位<br> 0b01：6位<br> 0b10：7位<br> 0b11：8位</td>
</tr>
<tr>
<td>停止位宽度</td>
<td>[2]</td>
<td>0：一帧中有一个停止位 <br>1：一帧中有两个停止位</td>
</tr>
<tr>
<td>校验模式</td>
<td>[5:3]</td>
<td>设置校验位的产生方法、检验方法: <br> 0b0xx：无校验 <br>0b100：奇校验<br>0b101：偶校验<br>0b110：发送数据时强制设为1，接收数据时检查是否为1<br>0b111：发送数据时强制设为0，接收数据时检查是否为0</td>
</tr>
<tr>
<td>红外模式</td>
<td>[6]</td>
<td>0：正常模式<br>1：红外模式</td>
</tr>
</tbody></table>
<p>UART通道被设为红外模式时，其串行数据的波形与正常模式稍有不同。</p>
<h3 id="ULCONn寄存器（UART-CONTROL）"><a href="#ULCONn寄存器（UART-CONTROL）" class="headerlink" title="ULCONn寄存器（UART CONTROL）"></a>ULCONn寄存器（UART CONTROL）</h3><p>ULCONn寄存器用于选择UART时钟源、设置UART中断方式等。S3C2410 UART的时钟源有两种选择：PCLK、UEXTCLK；S3C2440的时钟源有三种选择：PCLK、UEXTCLK、FCLK&#x2F;n。所以在时钟源的选择与设置方面稍有不同。<br>S3C2410的ULCONn寄存器格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>接收模式</td>
<td>[1:0]</td>
<td>选择如何从UART接收缓冲区中读取数据。<br>0b00：禁止接收数据 <br>0b01：中断方式或者查询方式 <br>0b10：DMA0请求（UART0） DMA3请求（UART2）<br>0b11：DMA1请求（UART1）</td>
</tr>
<tr>
<td>发送模式</td>
<td>[3:2]</td>
<td>选择如何将数据发送到UART发送缓存区。<br>0b00：禁止发送数据 <br>0b01：中断方式或者查询方式 <br>0b10：DMA0请求（UART0） DMA3请求（UART2）<br>0b11：DMA1请求（UART1）</td>
</tr>
<tr>
<td>自环模式</td>
<td>[5]</td>
<td>自环模式就是将TxDn和RxDn在内部相连，用于自发自收。<br>0：正常模式 1：自环模式</td>
</tr>
<tr>
<td>接收错误状态中断使能</td>
<td>[6]</td>
<td>用于使能当发生错误时（帧错误、溢出）时，产生中断。<br> 0：出错时不产生中断 <br>1：出错时产生中断</td>
</tr>
<tr>
<td>接收超时使能</td>
<td>[7]</td>
<td>当使用UART FIFO时，用于使能&#x2F;禁止接收超时的中断。 <br>0&#x3D;禁止 1&#x3D;使能</td>
</tr>
<tr>
<td>接收中断方式</td>
<td>[8]</td>
<td>如下情况发生时，将产生接收中断。<br> 不使用FIFO时，接收到一个数据；<br>使用FIFO时，FIFO中的数据达到RxFIFO的触发阈值。<br>中断方式如下设置。<br>0：脉冲 <br>1：电平</td>
</tr>
<tr>
<td>发送中断方式</td>
<td>[9]</td>
<td>如下情况发生时，将产生发送中断。<br> 不使用FIFO时，发送缓冲区变空；<br>使用FIFO时，FIFO中的数据达到TxFIFO的触发阈值。<br>中断方式如下设置。<br>0：脉冲 <br>1：电平</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[10]</td>
<td>选择UART时钟源。<br>0：PCLK <br>UEXTCLK</td>
</tr>
</tbody></table>
<p>S3C2440的UCONn寄存器在UART时钟的选择方面与S3C2410有所不同，从位[10]往上的位含义不一样，并且原来的位[4]用于选择是否发出“break”信号，这些位的含义如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“break”信号</td>
<td>[4]</td>
<td>设置此位时，UART会在一帧的时间内发出一个“break”信号。<br>0：正常发送  1：发出“break”信号</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[11:10]</td>
<td>选择UART时钟源。<br>0b00&#x2F;0b10：PCLK <br> 0b01：UEXTVLK <br> 0b11：FCLK&#x2F;n</td>
</tr>
<tr>
<td>FCLK分频率系数</td>
<td>[15:12]</td>
<td>用来设置“FCLK&#x2F;n”中的n值</td>
</tr>
</tbody></table>
<p>ULCON0、ULCON1、ULCON2这3个寄存器的位[15:12]一起用来确定n值，它们的意义如下。</p>
<ol>
<li>ULCON2[15]：“FCLK&#x2F;n”使能位。<br>它等于0时，禁止使用“FCLK&#x2F;n”作为UART时钟源；等于1时，可以用作UART时钟源。</li>
<li>n值的设置。<br>ULCON0[15:12]、ULCON1[15:12]、ULCON2[14:12]三者用于设置n值，当其中一个被设置为非0值时，其他两个必须为0。<ol>
<li>n值处于7~12时，UART时钟&#x3D;FCLK&#x2F;（divider + 6），divider为ULCON0[15:12]的值，大于0。</li>
<li>n值处于22~36时，UART时钟&#x3D;FCLK&#x2F;（divider + 21），divider为ULCON1[15:12]的值，大于0。</li>
<li>n值处于37~43时，UART时钟&#x3D;FCLK&#x2F;（divider + 36），divider为ULCON2[14:12]的值，大于0。</li>
<li>ULCON0[15:12]、ULCON1[15:12]、ULCON2[14:12]都等于0时，UART时钟：FCLK&#x2F;44。</li>
</ol>
</li>
</ol>
<h3 id="UFCONn寄存器（UART-FIFO-CONTROL）、UFSTATn寄存器（UART-FIFO-STATUS）"><a href="#UFCONn寄存器（UART-FIFO-CONTROL）、UFSTATn寄存器（UART-FIFO-STATUS）" class="headerlink" title="UFCONn寄存器（UART FIFO CONTROL）、UFSTATn寄存器（UART FIFO STATUS）"></a>UFCONn寄存器（UART FIFO CONTROL）、UFSTATn寄存器（UART FIFO STATUS）</h3><p>UFCONn寄存器用于设置是否使用FIFO，设置各FIFO的触发阈值，即发送FIFO中有多少个数据产生中断、接收FIFO中有多少个数据产生中断。并可以通过设置UFCONn寄存器来复位各个FIFO。<br>读取UFSTATn寄存器可以知道各个FIFO是否已经满、其中有多少个数据。<br>不适用FIFO时，可以认为FIFO的深度是1，使用FIFO时，S3C2410的FIFO深度是16，S3C2440的深度是64。</p>
<h3 id="UMCONn寄存器（UART-MODEM-CONTROL）、UMSTATn寄存器（UART-MODEM-STATUS）"><a href="#UMCONn寄存器（UART-MODEM-CONTROL）、UMSTATn寄存器（UART-MODEM-STATUS）" class="headerlink" title="UMCONn寄存器（UART MODEM CONTROL）、UMSTATn寄存器（UART MODEM STATUS）"></a>UMCONn寄存器（UART MODEM CONTROL）、UMSTATn寄存器（UART MODEM STATUS）</h3><p>这两类寄存器用于流量控制。</p>
<h3 id="UTRSTATn寄存器（UART-TX-x2F-RX-STATUS）"><a href="#UTRSTATn寄存器（UART-TX-x2F-RX-STATUS）" class="headerlink" title="UTRSTATn寄存器（UART TX&#x2F;RX STATUS）"></a>UTRSTATn寄存器（UART TX&#x2F;RX STATUS）</h3><p>UTRSTATn寄存器用来表明数据是否已经发送完毕、是否已经接收到数据。格式如下表所示。缓冲区其实就是FIFO，只不过不适用FIFO时，FIFO的深度为1。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>接收缓冲区数据就绪</td>
<td>[0]</td>
<td>当接收到数据时，此位被自动设为1</td>
</tr>
<tr>
<td>发送缓冲区空</td>
<td>[1]</td>
<td>当发送缓冲区没有数据时，此位被自动设为1</td>
</tr>
<tr>
<td>发送器空</td>
<td>[2]</td>
<td>当发送缓冲区中没有数据，并且最后一个数据也已经发送出去，此位被自动设为1</td>
</tr>
</tbody></table>
<h3 id="UERSTATn寄存器（UART-ERROR-STATUS）"><a href="#UERSTATn寄存器（UART-ERROR-STATUS）" class="headerlink" title="UERSTATn寄存器（UART ERROR STATUS）"></a>UERSTATn寄存器（UART ERROR STATUS）</h3><p>用来表示各种错误是否发生，位[0]~位[3]为1时分别表示溢出错误、校验错误、帧错误、检测到“break”信号。读取这个寄存器时，它会自动清0。<br>需要注意的是，接收数据时如果使用FIFO，则UART内部会使用一个“错误FIFO”来表明接收FIFO中哪个数据在接收过程中发生了错误。CPU只有在读出这个错误的数据时，才会察觉到发生了错误。要想清除“错误FIFO”，则必须读出错误的数据，并读出UERSTATn寄存器。</p>
<h3 id="UTXHn寄存器（UART-TRANSMIT-BUFFER-REGISTER）"><a href="#UTXHn寄存器（UART-TRANSMIT-BUFFER-REGISTER）" class="headerlink" title="UTXHn寄存器（UART TRANSMIT BUFFER REGISTER）"></a>UTXHn寄存器（UART TRANSMIT BUFFER REGISTER）</h3><p>CPU将数据写入这个寄存器，UART即会将它保存到缓冲区，并自动发送出去。</p>
<h3 id="URXHn寄存器（UART-RECEIVER-BUFFER-REGISTER）"><a href="#URXHn寄存器（UART-RECEIVER-BUFFER-REGISTER）" class="headerlink" title="URXHn寄存器（UART RECEIVER BUFFER REGISTER）"></a>URXHn寄存器（UART RECEIVER BUFFER REGISTER）</h3><p>当UART接收到数据，CPU读取这个寄存器，即可获得数据。</p>
<h1 id="UART操作实例"><a href="#UART操作实例" class="headerlink" title="UART操作实例"></a>UART操作实例</h1><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>本示例代码的目的是在串口上输出一串字符，单板接收到后将它的ASCII码加1后从串口输出。<br>首先设置MPLL提高系统时钟，令PCLK为50MHz，UART将选择PCLK为时钟源。将代码复制到SDRAM中之后，调用main函数。重点在于UART0的初始化、收发数据，这由3个函数来实现：uart0_init、getc和putc。</p>
<h3 id="UART初始化"><a href="#UART初始化" class="headerlink" title="UART初始化"></a>UART初始化</h3><p>uart0_init函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCLK                        50000000            <span class="comment">//init.c中的clock_init函数设置PCLK为50MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_CLK                    PCLK                <span class="comment">//UART0的时钟源设置为PCLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BAUD_RATE              115200              <span class="comment">//波特率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BRD                    ((UART_CLK / (UART_BAUD_RATE * 16 )) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化UART0</span></span><br><span class="line"><span class="comment">115200 8N1 无流控</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPHCON |= <span class="number">0xa0</span>;                     <span class="comment">//GPH2、GPH3用作TXD0、RXD0</span></span><br><span class="line">    GPHUP   = <span class="number">0x0c</span>;                     <span class="comment">//GPH2、GPH3内部上拉</span></span><br><span class="line"></span><br><span class="line">    ULCON0  = <span class="number">0x03</span>;                     <span class="comment">//波特率为115200，数据格式为：8个数据位、没有流控、1个停止位</span></span><br><span class="line">    UCON0   = <span class="number">0x05</span>;                     <span class="comment">//查询方式，UART时钟源位PLCK</span></span><br><span class="line">    UFCON0  = <span class="number">0x00</span>;                     <span class="comment">//不使用FIFO</span></span><br><span class="line">    UMCON0  = <span class="number">0x00</span>;                     <span class="comment">//不使用流控</span></span><br><span class="line">    UBRDIV0 = UART_BRD;                 <span class="comment">//波特率位115200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送字符的函数"><a href="#发送字符的函数" class="headerlink" title="发送字符的函数"></a>发送字符的函数</h3><p>本实例不使用FIFO，发送字符前，首先判断上一个字符是否已经被发送出去。如果没有，则不断查询UTRSTAT0寄存器的位[2]，当它为1时表示已经发送完毕。于是，即可向UTXH0寄存器中写入当前要发送的字符。代码如下（宏TXD0READY被定义为（1 &lt;&lt; 2））:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送一个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待，直到发送缓区中的数据已经全部发送出去</span></span><br><span class="line">    <span class="keyword">while</span>(!(UTRSTAT0 &amp; TXD0READY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向UTXH0寄存器中写入数据，UART即自动将它发送出去</span></span><br><span class="line">    UTXH0 = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收字符的函数"><a href="#接收字符的函数" class="headerlink" title="接收字符的函数"></a>接收字符的函数</h3><p>试图读取数据前，先查询UTRSTAT0寄存器的位[1]，当它为1时表示接收缓冲区有数据，于是，即可读取URXH0得到数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接收一个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">getc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待，直到接收缓存区有数据</span></span><br><span class="line">    <span class="keyword">while</span>(!(UTRSTAT0 &amp; RXD0READY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接读取URXH0寄存器，即可获得接收到的数据</span></span><br><span class="line">    <span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>在main函数中，初始化UART0之后，即不断读取串口数据，并判断它是否为数字或字母。如果是的话，就将它加1后从串口输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    uart0_init();               <span class="comment">//波特率115200，8N1（8个数据位，无校验位，1个停止位）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从串口接收到数据之后，判断其是否为数字或字母，若是则加1后输出</span></span><br><span class="line">        c = getc();</span><br><span class="line">        <span class="keyword">if</span>(isDigital(c) || isLetter(c))</span><br><span class="line">            putc(c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h2><p>首先使用串口将开发板的COM0和PC的串口相连，打开PC上的串口工具（推荐使用SecureCRT），设置其波特率为115200、8N1（8个数据位，无校验位，1个停止位）。然后将编译生成的uart.bin文件烧入NAND Flash后上电运行。最后在PC上的串口工具中输入数字或者字母，可以看到输出另一个字符（加1）；如果输入其他字符，则无输出。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第11章 通用异步收发器UART</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>UART总线</tag>
      </tags>
  </entry>
  <entry>
    <title>Oops信息解析</title>
    <url>/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>内核的Oops信息对于做嵌入式Linux开发的来说非常常见，在此单独划作一章。</p>
<span id="more"></span>

<h1 id="Oops信息及栈回溯"><a href="#Oops信息及栈回溯" class="headerlink" title="Oops信息及栈回溯"></a>Oops信息及栈回溯</h1><h2 id="Oops信息来源及格式"><a href="#Oops信息来源及格式" class="headerlink" title="Oops信息来源及格式"></a>Oops信息来源及格式</h2><p>Oops这个单词含义为“惊讶”，当内核出错时（比如访问非法地址）打印出来的信息被称为Oops信息。<br>Oops信息包含以下几部分内容。</p>
<ol>
<li>一段文本描述信息<br>比如类似<code>“Unable to handle kernel NULL pointer dereference at virtual address 00000000”</code>的信息，它说明了发生的是哪类错误。</li>
<li>Oops信息的序号。<br>比如是第1次、第2次等。这些信息与下面类似，中括号内的数据表示序号。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Internal error: Oops:805 [#1]</span><br></pre></td></tr></table></figure></li>
<li>内核中加载的模块名称，也可能没有，以下面字样开头。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Modules linked in:</span><br></pre></td></tr></table></figure></li>
<li>发生错误的CPU序号，对于单处理器的系统，序号为0，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU: 0 Not tainted (2.6.22.6 #36)</span><br></pre></td></tr></table></figure></li>
<li>发生错误时CPU的各个寄存器的值。</li>
<li>当前进程的名字及进程ID，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Process swapper (pid:1,stack limit = 0xc0480258)</span><br></pre></td></tr></table></figure>
并不是说发生错误的是这个进程，而是表示发生错误时，当前进程是它。错误可能发生在内核代码、驱动程序，也可能就是这个进程的错误。</li>
<li>栈信息</li>
<li>栈回溯信息，可以从中看出函数调用关系，形式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Backstrace:</span><br><span class="line">[&lt;c001a6f4&gt;] (s3c2410fb_probe + 0x0/0x560) from [&lt;c01bf4e8&gt;] (platform_drv_probe + 0x20/0x24)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>出错指令附近的指令的机器码，比如（出错指令在小括号里）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code : e24cb004 e24dd010 e59f34e0 e3a07000 (e5873000)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置内核使Oops信息的栈回溯信息更直观"><a href="#配置内核使Oops信息的栈回溯信息更直观" class="headerlink" title="配置内核使Oops信息的栈回溯信息更直观"></a>配置内核使Oops信息的栈回溯信息更直观</h2><p>Linux 2.6.22自身具备的调试功能，可以使得打印出的Oops信息更直观。通过Oops信息中PC寄存器的值可以知道出错指令的地址，通过栈回溯信息可以知道出错时的函数调用关系，根据这两点可以快速定位错误。<br>要让内核出错时能够快速打印栈回溯信息，<code>编译内核要增加“-fno-omit-frame-pointer”选项</code>，这可以通过<code>配置CONFIG_FRAME_POINTER</code>来实现。查看内核目录下的配置文件.config，确保CONFIG_FRAME_POINTER已经被定义，如果没有，执行“make menuconfig”命令重新配置内核。CONFIG_FRAME_POINTER有可能已经被其他配置项自动选上。</p>
<h2 id="使用Oops信息调试内核的实例"><a href="#使用Oops信息调试内核的实例" class="headerlink" title="使用Oops信息调试内核的实例"></a>使用Oops信息调试内核的实例</h2><h3 id="获得Oops信息"><a href="#获得Oops信息" class="headerlink" title="获得Oops信息"></a>获得Oops信息</h3><p>刻意修改LCD驱动程序<code>drivers/video/s3c2410fb.c</code>，加入错误代码：在<code>s3c2410fb_probe</code>函数开头增加如下两行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *ptest = NULL;</span><br><span class="line">*ptest = 0x1234;</span><br></pre></td></tr></table></figure>
<p>重新编译内核，启动后会出错并打印如下Oops信息：<br><img src="/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/1.jpeg" alt="img not found"><br><img src="/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/2.jpeg" alt="img not found"></p>
<h3 id="分析Oops信息"><a href="#分析Oops信息" class="headerlink" title="分析Oops信息"></a>分析Oops信息</h3><ol>
<li><p>明确出错原因<br>由出错信息<code>“Unable to handle kernel NULL pointer dereference at virtual address 00000000”</code>可知内核是因为<code>非法地址访问出错，使用了空指针</code>。</p>
</li>
<li><p>根据栈回溯信息找出函数调用关系<br>内核崩溃时，可以从pc寄存器得知崩溃发生时的函数、出错指令。但是很多情况下，错误有可能是它的调用者引入的，所以找出函数的调用关系也很重要。<br>部分栈回溯信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;c001a6f4&gt;] (s3c2410fb_probe + 0x0/0x560) from [&lt;c01bf4e8&gt;] (platform_drv_probe + 0x20/0x24)</span><br></pre></td></tr></table></figure>
<p>这行信息分为两部分，表示后面的<code>platform_drv_probe</code>函数调用了前面的<code>s3c2410fb_probe</code>函数。<br>前半部分含义为：“c001a6f4”是<code>s3c2410fb_probe</code>函数首地址偏移0的地址，这个函数大小为0x560。<br>后半部分含义为：“c01bf4e8”是<code>paltform_drv_probe</code>函数首地址偏移0x20的地址，这个函数大小为0x24。<br>另外，后半部的“[<c01bf4e8>]”表示<code>s3c2410fb_probe</code>执行后的返回地址。<br>对于类似下面的栈回溯信息，其中r8-r4表示<code>driver_probe_device</code>函数刚被调用时这些寄存器的值。</c01bf4e8></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;c01bd4c0&gt;] (driver_probe_device + 0x0/0x18c) from [&lt;c01bd788&gt;] (__driver_attach + 0x80/0xe0)</span><br><span class="line">r8:00000000 r7:c0389a3c r6:c01bd708 r5:c036256c r4:c0362644</span><br></pre></td></tr></table></figure>
<p>从上面的栈回溯信息可以知道内核出错时的函数调用关系如下，最后在<code>s3c2410fb_probe</code>函数内部崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do_exit -&gt;</span><br><span class="line">    kernel_init -&gt;</span><br><span class="line">        s3c2410fb_init -&gt;</span><br><span class="line">            platform_driver_register -&gt;</span><br><span class="line">                driver_register -&gt;</span><br><span class="line">                    bus_add_driver -&gt;</span><br><span class="line">                        driver_attch -&gt;</span><br><span class="line">                            bus_for_each_dev -&gt;</span><br><span class="line">                                __driver_attach -&gt;</span><br><span class="line">                                    driver_probe_device -&gt;</span><br><span class="line">                                        platform_drv_probe -&gt;</span><br><span class="line">                                            s3c2410fb_probe</span><br></pre></td></tr></table></figure></li>
<li><p>根据pc寄存器的值确定出错位置<br>上述Oops信息中出错时的寄存器值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC is at s3c2410fb_probe+0x18/0x560</span><br><span class="line">LR is at platform_drv_probe+0x20/0x24</span><br><span class="line">pc : [&lt;c001a70c&gt;] lr : [&lt;c01bf4e8&gt;] psr : a0000013</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>“PC is at s3c2410fb_probe+0x18/0x560”表示出错指令为s3c2410fb_probe函数中偏移为0x18的指令。</code><br>“pc : [<c001a70c>]”表示出错指令的地址为c001a70c（十六进制）。</c001a70c></p>
</li>
<li><p>结合内核源代码和反汇编代码定位问题<br>先生成内核的反汇编代码<code>vmlinux.dis</code>，执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/system/linux-2.6.22.6</span><br><span class="line">arm-linux-objdump -D vmlinux &gt; vmlinux.dis</span><br></pre></td></tr></table></figure>
<p>出错地址c001a70c附近的部分汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c001a6f4: &lt;s3c2410fb_probe&gt;:</span><br><span class="line">c001a6f4: e1a0c00d  mov ip, sp</span><br><span class="line">c001a6f8: e92ddff0  stmdb sp!, &#123;r4,r5,r6,r7,r8,r9,sl,fp,ip,lr,pc&#125;</span><br><span class="line">c001a6fc: e24cb004  sub fp, ip, #4; 0x4</span><br><span class="line">c001a700: e24dd010  sub sp, sp, #16; 0x10</span><br><span class="line">c001a704: e59f34e0  ldr r3, [pc, #1248]; c001abec&lt;.init + 0x1284c&gt;</span><br><span class="line">c001a708: e3a07000  mov r7, #0; 0x0</span><br><span class="line">c001a70c: e5873000  str r3, [r7] &lt;=========出错指令</span><br><span class="line">c001a710: e59030fc  ldr r3, [r0, #252]</span><br></pre></td></tr></table></figure>
<p>出错指令为<code>“str r3, [r7]”</code>，它把r3寄存器的值放到内存中，内存地址为r7寄存器的值。根据Oops信息中的寄存器值可知：<code>r3为0x00001234，r7为0。0地址不可访问，所以出错</code>。<br><code>s3c2410fb_probe</code>函数的部分c代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int __init s3c2410fb_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c2410fb_info *info;</span><br><span class="line">    struct fb_info  *fb_info;</span><br><span class="line">    struct s3c2410fb_hw *mregs;</span><br><span class="line">    int ret;</span><br><span class="line">    int irq;</span><br><span class="line">    int i;</span><br><span class="line">    u32 lcdcon1;</span><br><span class="line"></span><br><span class="line">    int *ptest = NULL;</span><br><span class="line">    *ptest = 0x1234;</span><br><span class="line"></span><br><span class="line">    mach_info = pdev-&gt;dev.paltform_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合反汇编代码，很容易知道是“*ptest &#x3D; 0x1234;”导致错误，其中的ptest为空。<br>对于大多数情况，从反汇编代码定位到C代码并不容易，这需要较强的汇编程序阅读能力。通过栈回溯信息知道函数的调用关系，这已经可以帮助定位很多问题了。</p>
</li>
</ol>
<h2 id="使用Oops的栈信息手工进行栈回溯"><a href="#使用Oops的栈信息手工进行栈回溯" class="headerlink" title="使用Oops的栈信息手工进行栈回溯"></a>使用Oops的栈信息手工进行栈回溯</h2><p>前面说过，从Oops信息的pc寄存器值可得知崩溃发生时的函数、出错指令。但是错误有可能是它的调用者引入的，所以还是要找出函数的调用关系。<br>由于内核配置了CONFIG_FRAME_POINTER，当出现Oops信息时，会打印栈回溯信息。如果内核没有配置CONFIG_FRAME_POINTER，这时可以自己分析栈信息，找到函数的调用关系。</p>
<h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>一个程序包含代码段、数据段、BSS段、堆、栈；其中数据段用来存储初始值不为0的全局数据，BSS段用来存储初始值为0的全局数据，堆用于动态内存分配，栈用于实现函数调用、存储局部变量。<br>被调用函数在执行之前，它会将一些寄存器的值保存在栈中,其中包括返回地址寄存器lr。如果知道了所保存的lr寄存器的值，那就可以知道它的调用者是谁。在栈信息中，一个函数一个函数地往上找出所有保存的lr值，就可以知道各个调用函数，这就是栈回溯的原理。</p>
<h3 id="栈回溯实例分析"><a href="#栈回溯实例分析" class="headerlink" title="栈回溯实例分析"></a>栈回溯实例分析</h3><p>仍以前面的LCD驱动程序为例，使用上面的Oops信息的栈信息进行分析，栈信息如下：<br><img src="/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/3.jpeg" alt="img not found"></p>
<ol>
<li>根据pc寄存器值找到第一个函数，确定它的栈大小，确定调用函数。<br>从Oops信息可知pc值为c001a70c，使用它在内核反汇编程序<code>vmlinux.dis</code>中可以知道它位于<code>s3c2410fb_probe</code>函数内。<br>根据这个函数开始部分的汇编代码可以在知道栈的大小、lr返回值在栈中保存的位置，代码如下：<br><img src="/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/4.jpeg" alt="img not found"><br>{r4,r5,r6,r7,r8,r9,sl,fp,ip,lr,pc}这11个寄存器都保存在栈中，指令“sub sp, sp, #16”又使得栈向下扩展了16字节，所以本函数的大小为（11 x 4 + 16）字节，即15个双字。<br>栈信息开始部分的15个数据就是本函数的栈内容，下面列出了它们所保存的寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1e60:           c02b1f70  00000020  c03625d4  c036256c  c036256c  00000000  c0389a3c</span><br><span class="line">                                                        r4        r5        r6</span><br><span class="line">1e80: c0389a3c  c03c420c  c0024864  00000000  c0481eac  c0481ea0  c01bf4e8  c001a704</span><br><span class="line">      r7        r8        r9        sl        fp        ip        lr        pc</span><br></pre></td></tr></table></figure>
其中lr值为c01bf4e8，表示函数s3c2410fb_probe执行完后的返回地址，它是调用函数中的地址。下面使用lr值再次重复本步骤的回溯过程。</li>
<li>根据lr寄存器值找到调用函数，确定它的栈大小，确定上一级调用函数。<br>根据上步得到的lr值（c01bf4e8）， 在内核反汇编程序vmlinux.dis中可以知道它位于<code>platform_drv_probe</code>函数内。<br>根据这个函数开始部分的反汇编代码可以知道栈的大小、lr返回值在栈中保存的位置。代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c01bf4c8  &lt;platform_drv_probe&gt;:</span><br><span class="line">c01bf4c8:   e1a0c00d    mov ip, sp</span><br><span class="line">c01bf4cc:   e92dd800    stmdb sp!,  &#123;fp,ip,lr,pc&#125;</span><br><span class="line">...   </span><br><span class="line">c01bf4e8:   e89da800    ldmia sp!,  &#123;fp,sp,pc&#125;      //lr值（c01bf4e8）对应的指令</span><br></pre></td></tr></table></figure>
{fp,ip,lr,pc}这4个寄存器都保存在栈中，本函数的栈大小为4个双字。Oops栈信息中，前一个函数s3c2410fb_probe的栈下面的4个数据就是函数platform_drv_probe的栈内容，如下所示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea0:   c0481ed0  c0481eb0  c01bd5a8  c01bf4d8</span><br><span class="line">        fp        ip        lr        pc  </span><br></pre></td></tr></table></figure>
其中lr值为c01bd5a8，表示函数<code>platform_drv_probe</code>执行完后的返回地址，它是上一级调用函数中的地址。使用lr值，重复本步骤的查找过程，知道栈信息分析完毕或者再也无法分析，这样就可以找出所有的函数调用关系。<br>有些函数很简单，没有使用栈（sp在这个函数中没有吧变化），或者没有在栈中保存lr值。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>DEBUG</category>
        <category>Linux Kernel</category>
        <category>Oops信息解析</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>bug定位</tag>
      </tags>
  </entry>
  <entry>
    <title>设备与模块</title>
    <url>/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Linux内核设计与实现》第17章总结归纳</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><ol>
<li>设备类型：在所有Unix系统中为了统一普通设备的操作所采用的分类</li>
<li>模块：Linux内核中用于按需加载和卸载目标码的机制</li>
<li>内核对象：内核数据结构支持面向对象的简单操作，还支持维护父子对象之间的关系</li>
<li>sysfs：表示系统中设备树的一个文件系统</li>
</ol>
<h1 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h1><p>在Linux以及所有的Unix中，设备被分为三种类型；</p>
<ol>
<li>块设备<br> 通常缩写为blkdev，块设备是可寻址的，寻址以块为单位。块设备通常支持重定位操作，即对数据的随机访问。常见的块设备有硬盘，光碟，Flash。块设备通常会被挂载为文件系统。</li>
<li>字符设备<br> 通常缩写为cdev，字符设备是不可寻址的，仅提供数据的流式访问（即一个一个字符或者一个一个字节）。常见的字符设备有键盘，鼠标，打印机等，还有大部分伪设备。应用程序可以直接访问字符设备节点与字符设备交互。</li>
<li>网络设备<br> 一般以Ethernet Device来称呼，它提供了对网络的访问，通过一种物理适配器（如网卡）和一种特定的协议（如IP）进行的。它不是通过文件节点来访问的，而是通过套接字来这样的特殊接口来访问。</li>
<li>伪设备<br> 并不是所有设备驱动都表示物理设备。有些设备驱动时虚拟的，仅仅提供访问访问内核功能而已，称之为伪设备。例如内核随机数发生器（&#x2F;dev&#x2F;null）,空设备（&#x2F;dev&#x2F;zero）,零设备（&#x2F;dev&#x2F;urandom），满设备（&#x2F;dev&#x2F;full），内存设备（&#x2F;dev&#x2F;mem）。</li>
</ol>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>Linux是单块内核的操作系统，即整个系统都运行与一个单独的保护域中，但是Linux内核却是模块化的。它允许内核在运行期间动态的向其中插入或删除代码。这些代码（相关的子例程，数据，函数出口，函数入口）被存放在一个单独的二进制镜像中，称之为模块。支持模块的好处就是基本的内核镜像能尽可能的小，因为可选的功能和驱动程序都可以以模块的形式再提供。当热插拔新设备时，可以重新载入新的驱动程序。</p>
<h2 id="一个最简单模块"><a href="#一个最简单模块" class="headerlink" title="一个最简单模块"></a>一个最简单模块</h2><p>虽然编写“Hello World”程序属于陈词滥调，但是它就是那么合适，下面就是属于内核模块的“Hello World”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello.c Hello World 我们的第一个内核模块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello_init--初始化函数，模块装载时被调用，如果成功装载，返回0，否则返回非零值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;hello init.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello_exit--退出函数，模块卸载时被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;hello exit.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LISENCE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Nibil&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A Hello World Module&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>hello_init()</code>函数是模块的入口点，它通过<code>module_init()</code>例程注册到系统中，在内核装载时被调用。<code>module_init()</code>是一个宏。<br>模块的所有初始化函数必须符合下面的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>因为它不会被外部调用，所以可以加上static修饰。在实际的模块初始化函数中，往往会注册资源，初始化硬件，分配数据结构等。如果这个文件被静态编译进入内核镜像，那么这个模块将会在内核启动时运行。<br><code>hello_exit()</code>函数是模块的出口函数，他由<code>module_exit()</code>例程注册到系统。在模块从内核中卸载时，便会调用<code>hello_exit()</code>。简单来说，该函数负责对模块生命周期内所做的一切事情的撤销工作，在<code>hello_exit()</code>返回后，模块就被卸载了。<br>退出函数必须符合下面的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>与init函数一样，你也可以用static修饰它。<br><code>MODULE_LISENCE()</code>用于指定模块的版权；<code>MODULE_AUTHOR()</code>和<code>MODULE_DESCRIPTION()</code>用于指定作者和模块的简要描述，他们完全是用作信息记录目的。</p>
<h2 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h2><p>在2.6的内核中采用了“KBuild”构建系统，现在构建模块相比从前更加容易。构建过程的第一步是决定在哪里管理模块代码。你可以把模块源码加入到内核源代码树上，或者是作为一个补丁，最终把你的代码合并到正式的内核代码树上；另一种可行的方法就是在内核源代码树之外维护和构建你的模块代码。</p>
<h3 id="放在内核源代码树上"><a href="#放在内核源代码树上" class="headerlink" title="放在内核源代码树上"></a>放在内核源代码树上</h3><p>当你决定了把你的模块放在内核源代码树上，下一步就要清楚放在内核源代码树的何处。设备驱动程序位于&#x2F;drivers的子目录下，在其内部，设备驱动程序被进一步按照类别，类型或者特殊驱动程序等更有序的组织起来。如字符设备存放于&#x2F;drivers&#x2F;char目录下，块设备存放于&#x2F;drivers&#x2F;block目录下，USB设备存放于&#x2F;drivers&#x2F;usb目录下。文件的具体组织规则并不是墨守成规，不容打破，很多USB设备也属于字符设备。不管怎样，这些组织关系对我们来说相当容易理解，而且也很准确。<br>假定你有一个字符设备，而且你希望将它存放于&#x2F;drivers&#x2F;char目录下，建议建立你自己代码的子目录。你的驱动程序是一个钓鱼竿和计算机的接口，那么你需要在&#x2F;drivers&#x2F;char下面建立一个fishing的子目录。接下来需要向&#x2F;drivers&#x2F;char下的Makefile文件添加一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-m += fishing/</span><br></pre></td></tr></table></figure>
<p>这行代码告诉模块构建系统，在模块编译时需要进入fishing&#x2F;子目录中。更有可能发生的是，你的驱动程序的编译取决于一个特殊配置选项；比如，可能的CONFIG_FISHING_POLE。那么，你可能需要用下面的指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing/</span><br></pre></td></tr></table></figure>
<p>最后，在&#x2F;drivers&#x2F;char&#x2F;fishing&#x2F;下，添加一个新的Makefile文件，其中需要有下面这行指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing.o</span><br></pre></td></tr></table></figure>
<p>以后，假如你的钓鱼竿程序需要更加智能化–它需要可以增加自动检测钓鱼线的功能。那么你的源程序就不止一个C文件了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing.o</span><br><span class="line">fishing-objs := fish-main.o fish-line.o</span><br></pre></td></tr></table></figure>
<p>每当设置了CONFIG_FISHING_POLE，fishing-main.c和fishing-line.c就会被一起编译链接到fishin.ko中去。最后需要注意的是，构建文件时你可能需要额外的编译标记，你只需要在Makefile中添加如下命令，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS += -DTITANIUM_POLE</span><br></pre></td></tr></table></figure>
<p>然后就开始编译吧！</p>
<h3 id="放在内核代码外"><a href="#放在内核代码外" class="headerlink" title="放在内核代码外"></a>放在内核代码外</h3><p>模块在内核内和在内核外的构建的区别在于构建过程。当模块在内核源码树外时，你必须告诉make如何找到内核源代码文件和Makefile文件，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make -C /kernel/source/location SUBDIRS=$PWD modules</span><br></pre></td></tr></table></figure>
<p>在这个例子中，&#x2F;kernel&#x2F;source&#x2F;location是你自己配置的内核源码树。</p>
<h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>编译后的模块将被装入到目录&#x2F;lib&#x2F;modules&#x2F;version&#x2F;kernel下，在将kernel&#x2F;目录下的每一个目录都对应着内核源码树中的模块位置。如果使用的是2.6.34的内核，而且将你的模块源代码直接放在&#x2F;drivers&#x2F;char下，那么编译后的钓鱼杆驱动程序的存放路径将是:&#x2F;lib&#x2F;modules&#x2F;2.6.34&#x2F;kernel&#x2F;drivers&#x2F;char&#x2F;fishing.ko。<br>下面的构建命令用来安装编译的模块到合适的目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<h2 id="产生模块依赖性"><a href="#产生模块依赖性" class="headerlink" title="产生模块依赖性"></a>产生模块依赖性</h2><p>Linux模块之间存在依赖性，也就是说钓鱼模块依赖于鱼饵模块，那么当你载入钓鱼模块时，鱼饵模块会自动被载入。你可以使用如下命令获取内核模块之间的依赖信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depmod</span><br><span class="line">depmod -A #模块依赖关系存放于/lib/modules/version/modules.dep中。</span><br></pre></td></tr></table></figure>

<h2 id="载入模块"><a href="#载入模块" class="headerlink" title="载入模块"></a>载入模块</h2><p>载入模块最简单的方法就是通过insmod命令，它的功能就是请求内核载入指定的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insmod module.ko</span><br><span class="line">rmmod module #卸载一个模块</span><br></pre></td></tr></table></figure>
<h2 id="管理配置选项"><a href="#管理配置选项" class="headerlink" title="管理配置选项"></a>管理配置选项</h2><p>这里我们继续以钓鱼竿驱动程序为例，看看一个新的配置选项如何加入。<br>由于2.6内核新引入了“Kbuild”系统，你所需要做的就是想Kconfig文件中添加一项，用以对应内核源码树。对驱动程序而言，kconfig通常和源代码处于同一目录。如果钓鱼杆驱动程序位于&#x2F;drivers&#x2F;char下，那么&#x2F;drivers&#x2F;char&#x2F;kconfig也会存在。<br>如果你新引入了一个子目录fishing&#x2F;，那么你必须在一个已经存在的kconfig文件中将它引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;drivers/char/fishing/kconfig&quot;</span><br></pre></td></tr></table></figure>
<p>请看kconfig中钓鱼竿模块的选项，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config FISHING_POLE</span><br><span class="line">    tristate &quot;Fish Mater 3000 support&quot;</span><br><span class="line">    default n</span><br><span class="line">    help </span><br><span class="line">        you can say N(no),M(Module),Y(yes) here,if unsure say N</span><br></pre></td></tr></table></figure>
<p>第一行定义了该选项所代表的配置目标，注意CONFIG_前缀并不需要带上。<br>第二行声明类型为tristate，也就是说可以编译进内核（Y），也可以作为模块编译（M），或者干脆不编译它（N）。如果配置选项代表的是一个系统功能，而不是一个模块，那么编译选项将用bool代替tristate，说明它不允许被编译成模块。<br>第三行指定默认编译选项，驱动程序一般默认不编译进入内核（N）。<br>help指令为该选项提供帮助文档。<br>除了上述选项外，还存在其他选项。比如depends指令指定了在该选项设置前，首先需要设置的选项。假设你加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depends on FISH_TANK</span><br></pre></td></tr></table></figure>
<p>到配置选项中，那么就意味着在CONFIG_FISH_TANK被选择前，我们的钓鱼竿模块是不能被使用的（Y或者M）。<br>select指令和depends类似，它们只有一点不同之处—那就是select指定了谁，它就会将被指定的选项强制打开，所以要慎重使用select</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select BAIT</span><br></pre></td></tr></table></figure>
<p>意味着当CONFIG_FISHING_POLE被激活时，配置选项CONFIG_BAIT必然被一起激活。<br>如果select和depends同时指定多个选项，那就需要通过&amp;&amp;指令来进行多选。使用的depends时，你还可以利用叹号前缀来指明禁止某个选项。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depends on EXAMPLE_DIRVERS &amp;&amp; !NO_FISHING_ALLOWED</span><br></pre></td></tr></table></figure>
<p>这行指令就指定驱动程序安装要求打开CONFIG_EXAMPLE_DIRVERS选项，同时禁止CONFIG_NO_FISHING_ALLOWED选项。<br>tristate和bool选项往往会结合if指令一起使用，这表示某个选项取决于另一个配置选项。如果条件不满足，配置选项不但会被禁止，甚至不会显示在配置工具中。比如，要求配置系统只有在CONFIG_x86配置选项时才显示某选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool &quot;x86 only&quot; if x86</span><br></pre></td></tr></table></figure>
<h2 id="导出符号表"><a href="#导出符号表" class="headerlink" title="导出符号表"></a>导出符号表</h2><p>模块被载入后，就会被动态的连接到内核。注意，它与用户空间的动态链接库类似，只有被显式导出后的外部函数，才可以被动态库调用。在内核中，导出内核函数需要使用特殊的指令<code>EXPORT_SYMBOL()</code>和<code>EXPORT_SYMBOL_GPL()</code>。<br>导出的内核函数可以被模块调用，而未导出的函数模块则无法被调用。函数代码的链接和调用规则相比核心内核镜像的的代码而言，要更加严格。核心代码在内核中可以调用任意非静态接口，因为所有的核心源代码文件被链接成了同一个镜像。当然，被导出的符号表所含的函数必然也要是非静态的。<br>导出的内核符号被看作导出的内核接口，甚至被称为内核API。导出符号相当简单，在声明函数后，紧跟上<code>EXPORT_SYMBOL()</code>指令就搞定了。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    返回当前priate胡须的颜色</span><br><span class="line">*/</span><br><span class="line">int get_priate_beard_color(struct priate *p)</span><br><span class="line">&#123;</span><br><span class="line">    return p-&gt;beard.color;</span><br><span class="line">&#125;</span><br><span class="line">EXPROT_SYMBOL(get_priate_beard_color)</span><br></pre></td></tr></table></figure>
<p>如果你希望先前的函数仅对标记为GPL协议的模块可见，那么你就需要用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPROT_SYMBOL_GPL(get_priate_beard_color)</span><br></pre></td></tr></table></figure>
<p>如果你的代码被配置为模块，那么你就必须确保它被编译为模块时，它所用的全部接口都已经被导出，否则就会出现连接错误（而且模块不能编译成功）。</p>
<h1 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h1><p>2.6的内核增加了一个引人注目的新特性—-统一设备模型（device model）。设备模型提供了一个独立的机制专门来表示设备，并描述其在系统中的拓扑结构，从而使得系统具有以下优点：</p>
<ol>
<li>代码重复最小化；</li>
<li>提供诸如引用计数这样的统一机制；</li>
<li>可以列举系统中的所有设备，观察他们的形态，并且查看他们连接的总线；</li>
<li>可以将系统中的全部设备结构以树的形式完整，有效的展示出来—-包括总线和所有的内部连接；</li>
<li>可以将设备和其对应的驱动联系起来，反之亦然；</li>
<li>可以将设备按照类型分类，比如分为输入设备，而无需理解物理设备的拓扑结构；</li>
<li>可以沿这设备树的叶子向其根节点的方向遍历，以保证能以正确的顺序关闭各个设备的电源。<br>内核无疑需要一棵设备树。</li>
</ol>
<h2 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h2><p>设备模型的核心部分就是kobject（kernel object），它由struct kobject结构体表示，定义域头文件<code>&lt;linux/kobject.h&gt;</code>中。它提供了诸如引用计数，名称，父指针等字段，可以创建对象的层次结构。具体结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject&#123;</span><br><span class="line">    const char          *name;</span><br><span class="line">    struct list_head    entry;</span><br><span class="line">    struct kobject      *parent;</span><br><span class="line">    struct kset         *kset;</span><br><span class="line">    struct kobi_type    *ktype;</span><br><span class="line">    struct sysfs_dirent *sd;</span><br><span class="line">    struct kref         kref;</span><br><span class="line">    unsigned int        state_initialized:1;</span><br><span class="line">    unsigned int        state_in_sysfs:1;</span><br><span class="line">    unsigned int        state_add_uevent_sent:1;</span><br><span class="line">    unsigned int        state_remove_uevent_sent:1;</span><br><span class="line">    unsigned int        uevent_suppress:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>name 指针指向该kobject的名称。<br>parent 指针指向kobject的父对象，这样一来，kobject就会在内核中构造一个对象层次结构，并且可以将多个对象间的关系表现出来。这便是sysfs的真面目：一个用户空间的文件系统，用来表示内核中kobject对象的层次结构。<br>sd 指针指向sysfs_dirent结构体，它在sysfs中表示的就是这个kobject。<br>kref 提供引用计数。ktype和kset对kobject进行描述和分类。<br>kobject通常是嵌入到其他结构中，其单独存在的意义不大。比如定义在<code>&lt;linux/cdev.h&gt;</code>下的struct cdev中才真正用到了kobj结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    该对象代表一个字符设备</span><br><span class="line">*/</span><br><span class="line">struct cdev&#123;</span><br><span class="line">    struct kobject          kobj;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当konject被嵌入到其他结构中时，该结构便拥有了kobject提供的标准功能。更重要的一点是，嵌入kobject的结构体可以成为对象层次架构中的一部分。比如cdev就可以通过其父指针cdev-&gt;kobj.parent 和链表 cdev-&gt;kobj.entry 插入到对象层次结构中。</p>
<h2 id="ktype"><a href="#ktype" class="headerlink" title="ktype"></a>ktype</h2><p>kobject对象被关联到一种特殊的类型，即ktype（kernel object type）。ktype由kobj_type结构体表示，定义于头文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strcut kobj_type&#123;</span><br><span class="line">    void (*release)(struct kobject *);</span><br><span class="line">    const struct sysfs_ops *sysfs_ops;</span><br><span class="line">    struct attribute       **defalut_attrs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ktype的存在就是为了描述一族kobject的普遍特性。如此一来，不需要每一个kobject都分别定义自己的特性，而是将这些普遍的特性在ktype中一次定义，然后所有的同类“kobject”都能共享一样的特性。<br>release函数指针指向kobject引用计数为零时要被调用的析构函数。该函数负责释放所有kobject使用的内存和其他相关清理工作。<br>sysyfs_ops变量指向sysfs_ops结构体。该结构体描述了sysfs文件读写时的特性。<br>default_attrs指向了一个attribute结构体数组。这些结构体定义了该kobject相关的默认属性。属性描述了给定对象的特征，如果该kobject导出到sysyfs，那么这些属性都将相应的作为文件而导出，数组的最后一项必须为NULL。</p>
<h2 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h2><p>kset是kobject对象的集合体。可以把它看作是一个容器，可将所有相关的kobject对象，比如”全部的块设备“置于同一位置。kset和ktype最大的区别就是：具有相同ktype的kobject可以被分组到不同的kset。也就是说，在Linux内核中，只有少数一些的ktype，却有多个kset。<br>kobject的kset指针指向相应的kset集合。kset集合由kset结构体表示，定义于头文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kset&#123;</span><br><span class="line">    struct list_head        list;</span><br><span class="line">    spinlock_t              list_lock;</span><br><span class="line">    struct kobject          kobj;</span><br><span class="line">    struct kset_uevent_ops  *uevenet_ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个结构中，其中list连接该集合中所有的kobject对象，list_lock是保护这个链表对象的自旋锁，kobj指向的konject对象代表了该集合的基类。uevent_ops指向了一个结构体—用于处理集合中kobject对象的热插拔操作。<code>uevent就是用户事件（user event）的缩写</code>，提供了与用户空间热插拔信息进行通信的机制。</p>
<h2 id="kobject、ktype、kset的相互关系"><a href="#kobject、ktype、kset的相互关系" class="headerlink" title="kobject、ktype、kset的相互关系"></a>kobject、ktype、kset的相互关系</h2><p><img src="/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/1.jpeg" alt="img not found"></p>
<h2 id="管理和操作kobject"><a href="#管理和操作kobject" class="headerlink" title="管理和操作kobject"></a>管理和操作kobject</h2><p>当了解了kobject的内部基本细节后，我们来看管理和操作他的外部接口了。<br>使用kobject的第一步需要先进行声明和初始化。kobject通过函数<code>kobject_init()</code>进行初始化，该函数定义在文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_init(struct kobject *kobj,struct kobj_type *ktype);</span><br></pre></td></tr></table></figure>
<p>该函数第一个参数就是需要初始化kobject对象，在调用初始化之前，kobject必须清空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memset(kobj,0,sizeof(*kobj));</span><br></pre></td></tr></table></figure>
<p>只有在初始化之后就可以安全的初始化parent和kset字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">kobj = kmalloc(sizeof(*kobj),GFP_KERNEL);</span><br><span class="line">if(!kobj)</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">memset(kobj,0,sizeof(*kobj));</span><br><span class="line">kobj-&gt;kset = my_kset;</span><br><span class="line">kobject_init(kobj,my_ktype);</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">kobj = kobject_create();</span><br><span class="line">if(!kobj)</span><br><span class="line">    return -ENOMEM;</span><br></pre></td></tr></table></figure>
<p>大多数情况下，应该调用<code>kobject_create()</code>而不是直接操作这个结构体。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>kobject的主要功能之一就是为我们提供了一个统一的引用计数系统。初始化后，koject的引用计数设置为1。只要引用计数不为零，那么该对象就会继续保留在内存中。任何包含对象引用的代码首先要增加该对象的引用计数，当代码结束后就减少它的引用计数。当引用计数跌为零时，对象便可以撤销，相关内存也都被释放。</p>
<h3 id="增加和递减引用计数"><a href="#增加和递减引用计数" class="headerlink" title="增加和递减引用计数"></a>增加和递减引用计数</h3><p>增加一个引用计数可通过<code>kobject_get()</code>函数完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_get(struct kobject *kobj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数正常情况下将返回一个指向kobject的指针，如果失败则返回NULL。<br>减少引用计数通过<code>kobject_put()</code>完成，这个函数也声明在<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_put(struct kobject *kobj);</span><br></pre></td></tr></table></figure>
<p>如果对应的kobject的引用计数减少到零，那么与该kobject关联的ktype中的析构函数将会被调用。</p>
<h3 id="kref"><a href="#kref" class="headerlink" title="kref"></a>kref</h3><p>kobject的引用计数是通过kref结构体实现的。该结构体定义在<code>&lt;linux/kref.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kref&#123;</span><br><span class="line">    atomic_t refcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中唯一的字段是用来存放引用计数的原子变量。那么为什么采用结构体，这是为了便于进行类型检测。在使用kref前，你必须通过<code>kref_init()</code>来初始化它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_init(strcut kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">    atomic_set(&amp;kref-&gt;refcount,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数简单的将原子变量置1，所以fref一旦被初始化，它所表示的引用计数便固定为1。<br>要获得对kref的引用，需要调用<code>kref_get()</code>函数，该函数增加引用计数值，没有返回值，这个函数在<code>&lt;linux/kref.h&gt;</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_get(strcut kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(!atomic_read(&amp;kref-&gt;refcount));</span><br><span class="line">    atomic_inc(&amp;kref-&gt;refcount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少对kref的引用，这个函数在<code>&lt;linux/kref.h&gt;</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_put(strcut kref *kref,void (*release) (strcut kref *kref))</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(release == NULL);</span><br><span class="line">    WARN_ON(release == (void (*release) (strcut kref *)) kfree);</span><br><span class="line"></span><br><span class="line">    if(atomic_dec_and_test(&amp;kref-&gt;refcount))&#123;</span><br><span class="line">        release(kref);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述所有函数定义和声明分别在<code>lib/kref.c</code>和<code>&lt;linux/kref.h&gt;</code>中。</p>
<h1 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h1><p>sysfs文件系统是一个处于内存中的虚拟文件系统，它为我们提供了kobject对象层次结构的视图。帮助用户能以一个简单文件系统的方式来视察系统中各种设备的拓扑结构。借助属性对象，kobject可以用导出文件的方式，将内核变量提供给用户读取或者写入。<br>虽然设备模型的初衷是为了方便电源管理而提出的一种设备拓扑结构，但是sysfs是颇为意外的收获。为了方便调试，设备模型的开发者决定将设备结构树导出为一个文件系统。今天所有的2.6内核的系统都拥有sysfs文件系统，而且几乎都将其挂载在<code>sys/</code>下。<br>sysfs的诀窍就是吧kobject对象和目录项（directory entries）紧密联系在一起，这点是通过kobject对象中的dentry字段实现的。dentry结构体表示目录项，通过连接kobject到指定的目录项上，无疑方便的将kobject映射到该目录上。从此，把kobject导出形成文件系统就变得跟在内存中构建目录项一样简单。kobject其实已经形成了一棵树—就是我们心爱的对象体系模型。由于kobject映射到目录项，同时对象层次结构也已经在内存中形成了一棵树，因此sysfs的生成便水到渠成般的简单了。<br><img src="/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/2.jpeg" alt="img not found"><br>sysfs的根目录下至少包含了十个目录：block、bus、class、dev、devices、firmware、fs、kernel、module和power。</p>
<ol>
<li>block下每个子目录都对应着系统中已注册的块设备。反过来，每个目录下又都包含了该块设备的所有分区。</li>
<li>bus目录提供了一个系统总线试图。</li>
<li>class目录包含了以高层功能逻辑组织起来的系统设备视图。</li>
<li>dev目录是已注册的设备节点的视图。</li>
<li>devices目录是系统中的设备拓扑结构视图，它直接映射了内核中设备结构体的组织层次。</li>
<li>firmware目录包含了一些诸如ACPI、EDD、EFI等低层子系统的特殊树。</li>
<li>fs目录是已注册的文件系统的视图。</li>
<li>kernel目录包含内核配置项和状态信息。</li>
<li>module目录则包含系统已加载模块的信息。</li>
<li>power目录包含系统范围的电源去管理数据。<br>其中最重要的目录是devices，该目录将设备模型导出到用户空间。目录结构就是系统中的实际的设备拓扑。其他目录中的很多数据都是将devices目录下的数据加以转换加工得来的。比如，<code>/sys/class/net/</code>目录是以注册网络接口这一高层概念来组织设备关系的，在这个目录中可能会有目录<code>eth0</code>，它里面包含的devices文件其实就是一个指回到devices下实际设备目录的符号链接。<br>随便看看你可以访问到的任何Linux系统的sys目录，这种系统设备视图相当准确和漂亮，而且可以看到class中高层概念与devices中的低层物理设备，以及bus中的实际驱动程序之间互相联络是非常广泛的。当你认识到这种数据是开放的，换句话说，这种内核中维持系统的很好表示方式时，整个经历都是弥足珍贵的。</li>
</ol>
<h2 id="sysfs中添加和删除kobject"><a href="#sysfs中添加和删除kobject" class="headerlink" title="sysfs中添加和删除kobject"></a>sysfs中添加和删除kobject</h2><p>仅仅初始化kobject是不能将其导入到sysfs中去的，想要将kobject导入sysfs，你需要用到<code>kobject_add()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kobject_add(struct kobject *kobj,struct kobject *parent,const char *fmt,...);</span><br></pre></td></tr></table></figure>
<p>kobject在sysfs的位置取决于kobject在对象层次结构中的位置。如果kobject的父指针被设置，那么在sysfs中kobject将被映射为其父目录下的子目录；如果parent没有被设置，那么kobject将被映射为kset-&gt;kobj中的子目录。如果给定的kobject中parent或kset字段都没有被设置，那么就认为kobject没有父对象，所以就会被映射成sysfs下的根级目录。这往往不是你所需要的，所以在调用<code>kobject_add()</code>之前，parent或者kset应该被适当的设置。sysfs中代表kobject的目录名字是由fmt指定的，它也接受<code>printf()</code>样式的格式化字符串。<br>辅助函数<code>kobject_create_and_add()</code>把<code>koject_create()</code>和<code>kobject_add()</code>所做的工作放在一个函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_create_and_add(const char *name,struct kobject *parent);</span><br></pre></td></tr></table></figure>
<p>从sysfs中删除一个kobject对应文件目录，需要使用函数<code>kobject_del()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_del(struct kobject *kobj);</span><br></pre></td></tr></table></figure>
<p>上述函数都定义于文件<code>lib/kobject.c</code>中，声明位于头文件<code>&lt;linux/kobject.h&gt;</code>中。</p>
<h2 id="向sysfs中添加文件"><a href="#向sysfs中添加文件" class="headerlink" title="向sysfs中添加文件"></a>向sysfs中添加文件</h2><p>我们已经看到kobject被映射为文件目录了，而且所有的对象层次结构都优雅的，一个不少的映射成sys下的目录结构。但是里面的文件是什么，sysfs仅仅是一个漂亮的树，但是没有提供实际数据的文件。</p>
<h3 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h3><p>默认的文件集合是通过kobject和kset中的ktype提供的。因此所有具有相同类型的kobject在它们对应的sysfs目录下都拥有相同默认文件集合。kobject_type字段含有一个字段—default_attrs，它是一个attribute结构体数组。这些属性负责将内核数据映射成sysfs中的文件。<br>attribute结构体定义在文件<code>&lt;linux/sysfs.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">attribute 结构体 - 内核数据映射成sysfs中的文件</span><br><span class="line">*/</span><br><span class="line">struct attribute&#123;</span><br><span class="line">    const char      *name;      /*属性名称*/</span><br><span class="line">    struct module   *owner;     /*所属模块，如果存在*/</span><br><span class="line">    mode_t          mode;       /*权限*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中名称字段提供了该属性的名称，最终出现在sysfs中的文件名就是它。owner字段在存在所属模块的情况下指向其所属的module结构体。如果一个模块没有该属性，那么该字段为NULL。mode 字段类型为mode_t，它表示了sysfs中该文件的权限。对于只读属性而言，如果是所有人都可以读它，则该字段设置为S_IRUGO;如果只限于所有者可读，则该字段被设置为S_IRUSR。同样对于可写属性，可能会设置该字段为S_IRUGO | S_IWUSR。sysfs中的所有文件和目录的uid与gid标志均为0。<br>虽然default_attr列出了默认的属性，sysfs_ops字段则描述了如何使用他们。sysfs_ops字段指向了一个定义于文件<code>&lt;linux/sysfs.h&gt;</code>的同名的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sysfs_ops&#123;</span><br><span class="line">    /*在读sysfs时被调用*/</span><br><span class="line">    ssize_t (*show) (struct kobject *kobj,struct attribute *attr,char *buffer);</span><br><span class="line">    /*在写sysfs时被调用*/</span><br><span class="line">    ssize_t (*store) (struct kobject *kobj,struct attribute *attr,char *buffer,size_t size);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当从用户空间读取sysfs的项时调用<code>show()</code>方法。它会拷贝由attr提供的属性值到buffer指定的缓冲区中，缓冲区大小为PAGE_SIZE字节；<br><code>store()</code>方法在写操作时调用，它会从buffer中读取size大小的字节，并将其存放入attr表示的属性结构体变量中。</p>
<h3 id="创建新属性"><a href="#创建新属性" class="headerlink" title="创建新属性"></a>创建新属性</h3><p>内核为能在默认集合上，再添加新属性而提供了<code>sysfs_create_file()</code>接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sysfs_create_file(struct kobject *kobj,const struct attribute *attr);</span><br></pre></td></tr></table></figure>
<p>注意，kobject中的ktype所对应的sysfs_ops操作将负责处理新属性。现有的<code>show()</code>和<code>store()</code>方法必须能够处理新属性。<br>除了添加文件外，还有可能需要创建符号链接。再sysf中创建一个符号链接很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sysyfs_create_link(struct kobject *kobj,struct kobject *target,char *name);</span><br></pre></td></tr></table></figure>
<p>该函数创建的符号链接名由name决定，连接则由kobj对应的目录映射到target指定的目录。如果成功该函数返回零，如果失败返回负的错误码。</p>
<h3 id="删除新属性"><a href="#删除新属性" class="headerlink" title="删除新属性"></a>删除新属性</h3><p>删除一个属性需要通过函数<code>sysfs_remove_file()</code>完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sysfs_remove_file(struct kobject *kobj,const struct attribute *attr);</span><br></pre></td></tr></table></figure>
<p>一但调用返回，给定的属性将不再存在于给定的kobject目录中。另外由<code>sysfs_create_link()</code>创建的符号链接可通过函数<code>sysfs_remove_link()</code>删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sysfs_remove_link(struct kobject *kobj,char *name);</span><br></pre></td></tr></table></figure>
<p>调用一旦返回，在kobj对应目录中的名为name的符号链接将不复存在。<br>上述四个函数在文件<code>&lt;linux/kobject.h&gt;</code>中声明；<code>sysfs_create_file()</code>和<code>sysfs_remove_file()</code>定义于文件<code>fs/sysfs/file.c</code>。<code>sysyfs_create_link()</code>和<code>sysfs_remove_link()</code>定义于文件<code>fs/sysfs/symlink.c</code>中。</p>
<h2 id="内核事件层"><a href="#内核事件层" class="headerlink" title="内核事件层"></a>内核事件层</h2><p>内核事件层实现了内核到用户的消息通知系统，就是建立在上文一直讨论的kobject基础之上。在2.6.0版本之后，显而易见，系统确实需要一种机制来帮助事件传出内核输入到用户空间，特别是对于桌面系统来说吗，因为他需要更完整和异步的系统。为此就要让内核将其事件压倒堆栈：硬盘满了，CPU过热了，分区挂载了。<br>早期的事件层没有采用kobject和sysfs，他们如过眼云烟，没有存在多久。现在的事件层借助kobject和sysfs实现以证明相当理想。内核事件层把事件模拟册成信号—从明确的kobject对象发出，所以每个事件源都是一个sysfs路径。如果请求的事件与你的第一个硬盘相关，那么<code>sys/block/had</code>便是源树。实质上，在内核中我们认为事件都是从幕后的kobject对象产生的。<br>每个事件都被赋予了一个动词或者动作字符串表示信号。该字符串会以“被修改过”或者“未挂载”等词语来描述事件。<br>最后。每个事件都有一个可选的负载（payload）。相比传递任意一个标识负载的字符串到用户空间而言，内核事件层使用sysfs属性代表负载。<br>从内部实现来讲，内核事件由内核空间传递到用户空间需要经过netlink。netlink是一个用于传送网络信息的多点传送套接字。使用netlink就意味着从用户空间获取内核事件就如同在套接字上堵塞一样易如反掌。方法就是用户空间实现一个系统后台服务用于监听套接字，处理任何读到的信息，并将事件传送到系统栈里面。对于这种用户后台服务来说，一个潜在的目的就是将事件融入D-BUS系统。D-BUS系统已经实现了一套系统范围的消息总线，这种总线可帮助内核如同系统中其他组件一样地发出信号。<br>在内核代码中向用户空间发送信号使用函数<code>kobject_uevent()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kobject_uevent(struct kobject* kobj,enum kobject_action action);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定发送该信号的对象。实际的内核事件将包含该kobject映射到sysfs的路径。<br>第二个参数指定了该信号的“动作”或者“动词”。实际的内核事件将包含一个映射成枚举类型kobject_action的字符串。该函数不是直接提供一个字符串，而是利用一个枚举变量来提高可重用性和保证类型安全，而且也消除了打字错误或者其他错误。该枚举变量定义于文件<code>&lt;linux/kobject_uevent.c&gt;</code>中，其形式为kOBJ_foo。当前值包含kOBJ_MOUNT、kOBJ_UNMOUNT、kOBJ_ADD、kOBJ_REOMOVE、kOBJ_CHNAGE等。这些值分别映射为字符串“mount”、“unmount”、“add”、“remove”、“change”等。当现有的这些值不够用时，允许添加新动作。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中涉及到的内核功能有设备驱动的实现、设备树的管理、包括模块、kobject、kset、ktype和sysfs。这些功能对于设备驱动程序的开发者来说是至关重要的。因为它能让我们写出更加模块化、更为高级的驱动程序。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第17章 设备与模块</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>存储控制器</title>
    <url>/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第6章总结归纳<br>总线的使用是嵌入式底层开发的基础，了解它之后，再根据外设的具体特性，就可以驱动该外设了。</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440地址空间的布局</li>
<li>掌握如何通过总线形式访问扩展的外设，比如内存、NOR Flash、网卡等。</li>
</ol>
<h1 id="使用存储控制器访问外设的原理"><a href="#使用存储控制器访问外设的原理" class="headerlink" title="使用存储控制器访问外设的原理"></a>使用存储控制器访问外设的原理</h1><h2 id="S3C2410-x2F-S3C2440的地址空间"><a href="#S3C2410-x2F-S3C2440的地址空间" class="headerlink" title="S3C2410&#x2F;S3C2440的地址空间"></a>S3C2410&#x2F;S3C2440的地址空间</h2><p>S3C2410&#x2F;S3C2440的”存储控制器“提供了访问外部设备所需的信号，它有如下特性：</p>
<ol>
<li>支持小字节序、大字节序（通过软件选择）；</li>
<li>每个BANK的地址空间为128MB，共1GB（8BANKs）；</li>
<li>可编程控制的范围总线位宽（8&#x2F;16&#x2F;32bit），不过BANK0只能选择两种位宽（16&#x2F;32bit）；</li>
<li>总共8个BANK，BANK0-BANK5可以支持外接ROM、SRAM等。BANK6-BANK7除了可以支持ROM、SRAM外，还支持SDRAM等；</li>
<li>BANK0-BANK7共7个BANK的起始地址是固定的；</li>
<li>BANK7的起始地址可编程选择；</li>
<li>BANK6、BANK7的地址空间大小是可编程控制的；</li>
<li>每个BANK的访问周期均可编程控制；</li>
<li>可以通过外部的”wait“信号延长总线的访问周期；</li>
<li>在外接SDRAM时，支持自刷新（self-refresh）和省电模式（power down mode）<br>S3C2410&#x2F;S3C2440对外引出的27根地址线ADDR0-ADDR26的访问范围只有128MB，那么如何达到上面所说的1GB的访问空间呢？CPU对外引出了8根片选信号nGCS0-nGCS7，对应于BANK0-BANK7，当访问BANKx的地址空间时，nGCSx的引脚输出低电平，用来选中外接的设备。这样，每个nGCSx对应的128MB空间，8个nGCSx信号总共就对应了1GB的地址空间。这8个BANK的地址空间如图所示：<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"><br>如图所示，左边对应不使用NAND Flash作为启动设备（单板上不接NAND BOOT跳线）时的地址空间布局，右边对应使用NAND Flash作为启动设备（单板上接NAND BOOT跳线）时的地址空间布局。<br>S3C2410&#x2F;S3C2440作为32位的CPU，可以使用的地址范围理论上达到4GB。除去上述用于连接外设的1GB地址空间外，还有一部分是CPU内部寄存器的地址，剩下的地址空间没有使用。<br>S3C2410&#x2F;S3C2440的寄存器地址范围都处于0x4800000-0x5fffffff，各功能部件的寄存器大体相同。（”-表示相同。”无“表示不含该功能部件。）<table>
<thead>
<tr>
<th>功能部件</th>
<th>S3C2410起始地址</th>
<th>S3C2410结束地址</th>
<th>S3C2440起始地址</th>
<th>S3C2440结束地址</th>
</tr>
</thead>
<tbody><tr>
<td>存储控制器</td>
<td>0x48000000</td>
<td>0x48000030</td>
<td>0x48000000</td>
<td>0x48000030</td>
</tr>
<tr>
<td>USB Host控制器</td>
<td>0x49000000</td>
<td>0x49000058</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>中断控制器</td>
<td>0x4A000000</td>
<td>0x4A00001C</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>DMA</td>
<td>0x4B000000</td>
<td>0x4B0000E0</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>时钟和电源管理</td>
<td>0x4C000000</td>
<td>0x4C000014</td>
<td>-</td>
<td>0x4C000018</td>
</tr>
<tr>
<td>LCD控制器</td>
<td>0x4D000000</td>
<td>0x4D000060</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>NAND Flash控制器</td>
<td>0x4E000000</td>
<td>0x4E000014</td>
<td>-</td>
<td>0x4E00003C</td>
</tr>
<tr>
<td>摄像头接口</td>
<td>无</td>
<td>无</td>
<td>0x4F000000</td>
<td>0x4F0000A0</td>
</tr>
<tr>
<td>UART</td>
<td>0x50000000</td>
<td>0x50008028</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>脉宽调制计时器</td>
<td>0x51000000</td>
<td>0x51000040</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>USB设备</td>
<td>0x52000140</td>
<td>0x5200026F</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>看门狗计时器</td>
<td>0x53000000</td>
<td>0x53000008</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>IIC控制器</td>
<td>0x54000000</td>
<td>0x5400000C</td>
<td>-</td>
<td>0x54000010</td>
</tr>
<tr>
<td>IIS控制器</td>
<td>0x55000000</td>
<td>0x55000012</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>I&#x2F;O端口</td>
<td>0x56000000</td>
<td>0x560000B0</td>
<td>-</td>
<td>0x560000CC</td>
</tr>
<tr>
<td>RTC</td>
<td>0x57000000</td>
<td>0x5700008B</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>A&#x2F;D转换器</td>
<td>0x58000000</td>
<td>0x58000010</td>
<td>-</td>
<td>0x58000014</td>
</tr>
<tr>
<td>SPI</td>
<td>0x59000000</td>
<td>0x59000034</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>SD接口</td>
<td>0x5A000000</td>
<td>0x5A000040</td>
<td>-</td>
<td>0x5A000043</td>
</tr>
<tr>
<td>AC97音频编码接口</td>
<td>无</td>
<td>无</td>
<td>0x5B000000</td>
<td>0x5B00001C</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="存储控制器与外设的关系"><a href="#存储控制器与外设的关系" class="headerlink" title="存储控制器与外设的关系"></a>存储控制器与外设的关系</h2><p>本书所用的开发板使用了存储控制器的BANK0-BANK6，分别接如下设备：NOR Flash、IDE接口、10M网卡 CS8900A、100M网卡DM9000、扩展串口芯片16C2550、SDRAM。连线方式如下图所示：<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>根据图6.1可以知道各个BANK的起始地址，但是还需要结合图6.2中用到的地址线才能确定相关外设的访问地址。这些地址线所确定的地址值，再加上这个BANK的起始地址，就是这个外设的访问地址。<br>选择一个复杂的BANK—扩展串口作为例子。</p>
<ol>
<li>它使用nGCS5，起始地址作为0x28000000；</li>
<li>nCSA&#x3D;ADDR24 || nGCS5，nCSB&#x3D;!ADDR24 || nGCS5。当ADDR24和nGCS5均为低电平时选中扩展串口A；当ADDR24为高电平、nGCS5为低电平时选中扩展串口B。</li>
<li>CPU的ADDR0-ADDR2连接到扩展串口的A0-A2。所以访问空间有8字节。<br>综上所述，扩展串口A的访问空间为：0x28000000-0x28000007；扩展串口B的访问空间为：0x29000000-0x29000007。</li>
</ol>
<p>BANK0-BANK5的连接方式都是相似的，BANK6连接SDRAM时复杂一点，CPU提供了一组用于SDRAM的信号。</p>
<ol>
<li>SDRAM时钟有效信号SCKE；</li>
<li>SDRAM时钟信号SCLK0&#x2F;SCLK1；</li>
<li>数据掩码信号DQM0、DQM1、DQM2、DQM3；</li>
<li>SDRAM片选信号nSCS0（它与nGCS6是同一个引脚的两个功能）；</li>
<li>SDRAM行地址选通脉冲信号nSRAS；</li>
<li>SDRAM列地址选通脉冲信号nSCAS；</li>
<li>写允许信号mWE（它不是专用于SDRAM的）。<br>SDRAM的内部是一个存储阵列，阵列就如同表格一样，把数据填进去，和表格的检索原理一样，先指定一个行（Row），再指定一个列（Column），就可以找到所需的单元格，这就是SDRAM的寻址的基本原理。这个单元格称为存储单元，这个表格就是逻辑BANK（L-BANK），SDRAM一般含有4个L-BANK。<br>对SDRAM的访问可以分为如下4个步骤：</li>
<li>CPU发出片选信号，nSCS0有效，它选中SDRAM芯片。</li>
<li>SDRAM中有4个L-BANK,需要两个地址线来选择其中一个，从图6.2可知使用ADDR24、ADDR25作为L-BANK的选择信号。</li>
<li>对被选中的芯片进行统一的行&#x2F;列（存储单元）寻址。<br>根据SDRAM芯片的列地址线数目选择CPU的相关寄存器后，CPU就会从32位的地址中自动分出L-BANK选择信号，行地址信号，列地址信号，然后发出行地址信号、列地址信号。L-BANK选择信号在发出行地址信号的同时发出，并维持到列地址信号结束。<br>在图6.2中，行地址、列地址公用地址线ADDR2-ADDR14（BANK6位宽位32，ADDR0&#x2F;1没有使用），使用nSRAS、nSCAS两个信号来区分它们。比如本开发板中，使用两根地址线ADDR24、ADDR25作为L-BANK的选择信号；SDRAM芯片K4S561632的行地址数位13，列地址数为9，所以当nSRAS信号有效时，ADDR2-ADDR14上发出的是行地址信号，它对应32位地址空间的bit[23::11]；当nSCAs信号有效时，ADDR2-ADDR10上发出的是列地址信号，它对应32位地址空间的bit[10:2]；由于图6.2中BANK6以32位的宽度外接SDRAM，ADDR0、ADDR1恒为0，不参与译码。</li>
<li>找到存储单元后，被选中的芯片就要进行统一的数据传输了。<br>开发板中使用两片16位的SDRAM芯片并联组成32位的位宽，与CPU的32根数据线（DATA0-DATA31）相连。<br>BANK6的起始地址为0x30000000，所以SDRAM的访问地址为0x30000000-0x33ffffff，共64M。<br>对6.2图中连接的外设，它们的访问地址（物理地址）如下表所示：<table>
<thead>
<tr>
<th>BANKx</th>
<th>外设名称</th>
<th>起始地址</th>
<th>结束地址</th>
<th>大小（字节）</th>
<th>位宽</th>
</tr>
</thead>
<tbody><tr>
<td>BANK0</td>
<td>NOR Flash</td>
<td>0x00000000</td>
<td>0x001FFFFF</td>
<td>2M</td>
<td>16</td>
</tr>
<tr>
<td>BANK1</td>
<td>IDE 接口命令块寄存器</td>
<td>0x08000000</td>
<td>0x0800000F</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>BANK2</td>
<td>IDE 接口控制块寄存器</td>
<td>0x10000000</td>
<td>0x1000000F</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>BANK3</td>
<td>10M网卡CS8900A</td>
<td>0x19000000</td>
<td>0x190FFFFF</td>
<td>1M</td>
<td>16</td>
</tr>
<tr>
<td>BANK4</td>
<td>10&#x2F;100M网卡DM9000</td>
<td>只有两个地址 0x20000000 和 0x20000004</td>
<td></td>
<td>2M</td>
<td>16</td>
</tr>
<tr>
<td>BANK5</td>
<td>扩展串口A</td>
<td>0x28000000</td>
<td>0x28000007</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>BANK6</td>
<td>扩展串口B</td>
<td>0x29000000</td>
<td>0x29000007</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>BANK7</td>
<td>SDRAM</td>
<td>0x30000000</td>
<td>0x33FFFFFF</td>
<td>64M</td>
<td>32</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：10M网卡CS8900A使用nIOR、nIOW作为读&#x2F;写使能信号时，ADDR24必须为1。</p>
<h2 id="存储控制器的寄存器使用方法"><a href="#存储控制器的寄存器使用方法" class="headerlink" title="存储控制器的寄存器使用方法"></a>存储控制器的寄存器使用方法</h2><p>存储控制器共有13个寄存器，BANK0-BANK5只需要设置BWSCON和BANKCONx（x为0-5）两个寄存器，BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</p>
<ol>
<li>位宽和等待控制寄存器BWSCON（BUS WIDTH &amp; WAIT CONTROL REGISTER）<br>BWSCON中每4位控制一个BANK。最高4位对应BANK7、接下来4位对应BANK6、依此类推。<br>STx：启动&#x2F;禁止SDRAM的数据掩码引脚，对于SDRAM，此位为0；对于SRAM此位为1。<br>DWx：使用两位来设置相应BANK的位宽。0b00对应8位，0b01对应16位，0b10对应32位，0b11保留。<br>WSx：是否使用存储器的WAIT信号，通常设为0。<br>比较特殊的是BANK0，他没有ST0和WS0，DW0（[2:1]）只读，0b01表示16位，0b10表示32位，BANK0只支持16、32两种位宽。</li>
<li>BANK控制寄存器BANKCONx（BANK CONTROL REGISTER x为0-5）<br>这几个寄存器控制BANK0-BANK5外接设备的访问时序。</li>
<li>BANK控制寄存器BANKCONx（BANK CONTROL REGISTER x为6-7）<br>在8个BANK中，只有BANK6和BANK7可以外接SRAM或者SDRAM，所以BANKCON6-BANKCON7与BANKCON0-BANKCON5有点不同。<br>MT[16:15]：用于设置本BANK外接的是ROM&#x2F;SRAM还是SDRAM。SRAM-0b00，SDRAM-0b11。当MT&#x3D;0b00时，此寄存器与BANKCON0-BANKCON5类似，当MT&#x3D;0b11时，此寄存器其他值如下设置：<br>Trcd[3:2]：RAS to CAS delay，设为推荐值，0b01。<br>SCAN[1:0]：SDRAM的列地址位数，对于本开发板使用的SDRAM K4S561632，列地址位数为9，所以SCAN&#x3D;0b01。如果使用其他型号的SDRAM，需要查看其数据手册来决定SCAN的取值。0b00表示8位，0b01表示9位，0b10表示10位。</li>
<li>刷新控制寄存器REFRESH（REFRESH CONTROL RFEGISTER）：设为0x008C0000 + R_CNT<br>REFEN[23]：0&#x3D;禁止SDRAM的刷新功能，1&#x3D;开启SDRAM的刷新功能。<br>TREFMD[22]：SDRAM的刷新模式，0&#x3D;CBR&#x2F;ATUO Refresh，1&#x3D;Self Refresh（一般在系统休眠时使用）。<br>Trp[21:20]设为0即可。<br>Tsrc[19:18]：设为默认值0b11即可。<br>Refresh Counter[10:0]：即上述的R_CNT。可如下计算（SDRFAM的时钟频率就是HCLK）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R_CNT = 2^11 + 1 - SDRAM时钟频率(MHZ) + SDRAM刷新周期（uS）</span><br></pre></td></tr></table></figure>
SDRAM的刷新周期在SDRAM的数据手册上有标明，在本开发板上使用的SDRAM K4S561632的数据手册上，可以看见这么一行”64ms refresh period （8K Cycle）“。所以，刷新周期&#x3D;64ms&#x2F;8192 &#x3D; 7.8125 us。<br>在未使用PLL时，SDRAM的时钟频率等于晶振频率，12MHz。现在可以计算：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R_CNT = 2^11 + 1 - 12 * 7.8125 = 1955</span><br></pre></td></tr></table></figure>
所以在未使用PLL时，REFRESH &#x3D; 0x008C0000 + 1955 &#x3D; 0x008C07A3。</li>
<li>BANKSIZE寄存器REFRESH （BANKSIZE REGISTER）<br>BURST_EN[7]：0&#x3D; ARM核禁止突发传输，1&#x3D;ARM核支持突发传输。<br>SCKE_EN[5]：0&#x3D;不使用SCKE信号令SDRAM进入省电模式，1&#x3D;使用SCKE信号令SDRAM进入省电模式。<br>SCLK_EN[4]：0&#x3D;时刻发出SCLK信号，1&#x3D;仅在访问SDRAM期间发出SCLK信号（推荐）。<br>BK76MAP[2:0]：设置BANK6&#x2F;7的大小。<br>BANK6&#x2F;7对应的地址空间与BANK0-5不同，BANK0-5的地址空间大小都是固定的128MB，地址范围是（x * 128M）到（x + 1）* 128M-1，x表示0到5。BANK6&#x2F;7的大小是可变的，以保持这两个空间的地址连续，即BANK7的起始地址会随他们的大小而变化。  BK76MAP的取值意义如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0b010 = 128MB/128MB,0b001 = 64MB/64MB,0b000 = 32MB/32MB,</span><br><span class="line">0b111 = 16MB/16MB,0b110 = 8MB/8MB,0b101 = 4M/4M,0b100 = 2M/2M</span><br></pre></td></tr></table></figure>
本开发板BANK6外接64MB的SDRAM，令[2:0]&#x3D;0b001，表示BANK6&#x2F;7的容量都是64MB，虽然BANK7未使用。</li>
<li>SDRAM模式设置寄存器MRSRBx（SDRAM MODE REGISTER SET REGISTER，x为6-7）<br>能修改的只有为CL[6:4]，这是SDRAM时序的一个时间参数：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[work]0b000 = 1 clock,0b010  = 2 clocks,0b011 = 3 clocks</span><br></pre></td></tr></table></figure>
SDRAM K4S561632不支持CL&#x3D;1的情况，所以位[6:4]取值为0b010(CL &#x3D; 2)或0b011(CL &#x3D; 3)。</li>
</ol>
<h1 id="存储控制器操作实例：使用SDRAM"><a href="#存储控制器操作实例：使用SDRAM" class="headerlink" title="存储控制器操作实例：使用SDRAM"></a>存储控制器操作实例：使用SDRAM</h1><h2 id="代码详解及程序的复制、跳转过程"><a href="#代码详解及程序的复制、跳转过程" class="headerlink" title="代码详解及程序的复制、跳转过程"></a>代码详解及程序的复制、跳转过程</h2><p>从NAND Flash启动CPU时，CPU会通过内部的硬件将NAND Flash开始的4KB数据复制到称为”Steppingstone“的4KB的内部RAM中（起始地址为0），然后跳到地址0开始执行。<br>本实例先使用汇编语言设置好存储控制器，使外接的SDRAM可用：然后把程序本身从Steppingstone复制到SDRAM处，最后跳到SDRAM中执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:head.S</span></span><br><span class="line"><span class="comment">功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDARM执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">.equ    MEM_CTL_BASE,       <span class="number">0x48000000</span></span><br><span class="line">.equ    SDRAM_BASE,         <span class="number">0x30000000</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    bl  disable_watch_dog                       @关闭看门狗，否则CPU会一直重启</span><br><span class="line">    bl  memsetup                                @设置存储控制器</span><br><span class="line">    bl  copy_steppingstone_to_sdram             @复制代码到SDRAM中</span><br><span class="line">    ldr pc,=on_sdram                            @跳到SDRAM中执行</span><br><span class="line">on_sdram:</span><br><span class="line">    ldr sp,=<span class="number">0x34000000</span>                          @设置栈</span><br><span class="line">    bl  main</span><br><span class="line">    </span><br><span class="line">halt_loop:</span><br><span class="line">    b   halt_loop</span><br><span class="line"></span><br><span class="line">disable_watch_dog:</span><br><span class="line">    mov r1,#<span class="number">0x53000000</span>                          @看门狗寄存器</span><br><span class="line">    mov r2,#<span class="number">0x0</span>                                 @往里写<span class="number">0</span></span><br><span class="line">    str r2,[r1]</span><br><span class="line">    mov pc,lr                                   @返回</span><br><span class="line"></span><br><span class="line">copy_steppingstone_to_sdram:</span><br><span class="line">                                                @将Steppingstone的<span class="number">4</span>KB数据全部复制到SDRAM中去。</span><br><span class="line">                                                @Steppingstone起始地址为<span class="number">0x00000000</span>，SDRAM中起始地址为<span class="number">0x30000000</span></span><br><span class="line">    mov r1,#<span class="number">0</span>                                   </span><br><span class="line">    ldr r2,=SDARM_BASE</span><br><span class="line">    mov r3,#<span class="number">4</span>*<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    ldr r4,[r1],#<span class="number">4</span>                              @从Steppingstone读取<span class="number">4</span>字节的数据，并让源地址加<span class="number">4</span></span><br><span class="line">    str r4,[r2],#<span class="number">4</span>                              @将此<span class="number">4</span>字节的数据复制到SDRAM中，并让目的地址加<span class="number">4</span></span><br><span class="line">    cmp r1,r3                                   @判断是否完成：源地址等于Steppingstone的末地址</span><br><span class="line">    bne lb                                      @若没有复制完，继续</span><br><span class="line">    mov pc, lr                                  @返回</span><br><span class="line"></span><br><span class="line">memsetup:</span><br><span class="line">                                                @设置存储控制器以便使用SDRAM外设</span><br><span class="line">    mov r1,#MEM_CTL_BASE                        @存储控制器的<span class="number">13</span>个寄存器的开始地址</span><br><span class="line">    adrl    r2,mem_cfg_val                      @这<span class="number">13</span>个值的起始存储地址</span><br><span class="line">    add r3,r1,#<span class="number">52</span>                               @<span class="number">13</span>*<span class="number">4</span> = <span class="number">52</span></span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    ldr r4,[r2],#<span class="number">4</span>                              @读取设置值，并让r2加<span class="number">4</span></span><br><span class="line">    str r4,[r1],#<span class="number">4</span>                              @将此值写入寄存器，并让r1加<span class="number">4</span></span><br><span class="line">    cmp r1,r3                                   @判断是否设置完所有<span class="number">13</span>个寄存器</span><br><span class="line">    bne lb                                      @若没有完成，继续</span><br><span class="line">    mov pc,lr                                   @返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">mem_cfg_val:</span><br><span class="line">                                                @存储控制器<span class="number">13</span>个寄存器的设置值</span><br><span class="line">    .<span class="type">long</span> <span class="number">0x22011110</span>    </span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00018005</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00018005</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x008C07A3</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x000000B1</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000030</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000030</span></span><br></pre></td></tr></table></figure>
<p>12-18行是程序的主题，为了使得程序结构明了，主要使用了函数调用的方式。<br>第12行禁止看门狗，否则看门狗会不断重启系统，往看门狗寄存器（0x53000000）里写0即可禁止看门狗。<br>第13行设置存储控制器的13个寄存器，以便使用SDRAM。<br>第14行将Steppingstone中的代码复制到SDRAM中（起始地址为0x30000000）。<br>第15行向pc寄存器直接赋值跳到SDRAM中执行下一条指令”ldr sp，&#x3D;0x34000000“。、<br>第17行设置栈，调用c函数之前必须设置好栈。<br>第18行调用C函数main。<br>程序是如何从Steppingstone跳到SDRAM中去执行的呢？<br>这是通过第15行的”ldr pc,&#x3D;on_sdram“指令完成的。程序标号”on_stream“这个地址值在连接程序时被确定为0x30000010（这是SDRAM的地址），执行”ldr pc,&#x3D;on_sdram“后，程序一下子就跳到SDRAM中去了。<br>”on_sdram“这个地址值为什么等于0x30000010？<br>Makefile中连接程序的命令为”arm-linux-ld -Ttext 0x30000000 head.o sdram.o -o sdram_elf“，意思就是代码段的起始地址为0x30000000，即程序的第一条指令（第12行）的连接地址为0x30000000，第二条指令（第13行）的连接地址是0x30000004，…,第五条指令（第17行）的连接地址为0x300000010，其程序标号”on_sdram“的值即为0x300000010。<br>虽然第12-14行指令的连接地址都在SDRAM中，但是由于它们都是位置无关的相对跳转指令，所以可以在Steppingstone里执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o head.o head.S</span><br><span class="line">arm-linux-gcc -g -c -o leds.o leds.c</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 -g head.o leds.o -o sdram_elf</span><br><span class="line">arm-linux-objcopy -O binary -S sdram_elf sdram_elf.bin</span><br><span class="line">arm-linux-objdump -D -m arm sdram_elf &gt; sdram_elf.dis</span><br></pre></td></tr></table></figure>
<p>下图所示程序从Steppingstone 到SDRAM 的执行过程。<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/4.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/5.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/6.png" alt="img not found"></p>
<h2 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h2><p>生成的sdram.bin下载到板子上运行之后，可以发现与leds程序相比，LED灯闪烁的更慢，原因是外部的SDRAM的性能比内部SRAM差一些。<br>把程序从性能更好的内部SRAM移到外部SDRAM中去，是否多此一举？内部的SRAM只有4KB大小，如果程序大于4KB，那么就不指望完全利用内部SRAM来运行了，就得想办法把存储在NAND Flash中的代码复制到SDRAM中去。对于NAND Flash的前4KB，芯片自动把它复制到内部SRAM中，可以很轻松的再把它复制到SDRAM中（实验代码中的函数copy_steppingstone_to_sdram就有此功能），要复制4KB后面的代码需要使用NAND Flash控制器来读取NAND Flash。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第6章 存储控制器</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>存储控制器</tag>
      </tags>
  </entry>
  <entry>
    <title>NAND_Flash控制器</title>
    <url>/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第8章总结归纳</p>
<span id="more"></span>
<h1 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h1><ol>
<li>了解NAND Flash芯片的接口</li>
<li>掌握通过NAND Flash控制器访问NAND Flash的方法</li>
</ol>
<h1 id="NAND-Flash介绍和NAND-Flash控制器使用"><a href="#NAND-Flash介绍和NAND-Flash控制器使用" class="headerlink" title="NAND Flash介绍和NAND Flash控制器使用"></a>NAND Flash介绍和NAND Flash控制器使用</h1><p>NAND Flash在嵌入式系统中地位与PC中的硬盘类似，用于保存系统运行所必须的操作系统、应用程序、用户数据、运行过程中产生的各类数据。与内存掉电后数据丢失不同，NAND Flash中的数据在掉电后仍可永久保存。</p>
<h2 id="Flash介绍"><a href="#Flash介绍" class="headerlink" title="Flash介绍"></a>Flash介绍</h2><p>常用的Flash类型有NOR Flash和NAND Flash两种。NOR Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和EEPROM。NAND Flash由Toshiba公司在1989年发明。两者主要差别如下表所示：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>NOR</th>
<th>NAND</th>
</tr>
</thead>
<tbody><tr>
<td>容量</td>
<td>1MB-32MB</td>
<td>16MB-512MB</td>
</tr>
<tr>
<td>XIP</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>擦除性能</td>
<td>非常慢（5S）</td>
<td>（快）3ms</td>
</tr>
<tr>
<td>写性能</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>读性能</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>可靠性</td>
<td>比较高，位反转的比例小于NAND Flash的10%</td>
<td>比较低，位反转比较常见，必须有校验措施。比如TNR必须有坏块管理措施</td>
</tr>
<tr>
<td>可擦除次数</td>
<td>10000-100000</td>
<td>100000-1000000</td>
</tr>
<tr>
<td>生命周期</td>
<td>低于NAND Flash的10%</td>
<td>是NOR Flash的10倍以上</td>
</tr>
<tr>
<td>接口</td>
<td>与RAM接口相同</td>
<td>I&#x2F;O接口</td>
</tr>
<tr>
<td>访问方法</td>
<td>随机访问</td>
<td>顺序访问</td>
</tr>
<tr>
<td>易用性</td>
<td>容易</td>
<td>复杂</td>
</tr>
<tr>
<td>主要用途</td>
<td>用于保存代码和关键数据</td>
<td>用于保存数据</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<p>NOR Flash支持XIP，即代码可以直接在NOR上运行，无须复制到内存中。这是由于NOR的接口与RAM完全相同，可以随机访问任意地址的数据。在NOR上进行读数据的效率非常高，但是擦除和写的效率很低。而且NOR的容量一般比较小。NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，NOR Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配NOR以存储程序。<br>Flash存储器件由擦除单元（块）组成，当要写某个块时，需要确保这个块已经被擦除。NOR Flash的块大小范围为64KB-128KB；NAND Flash的块大小为8KB-64KB。擦&#x2F;写一个NOR Flash块需要4S，而擦&#x2F;写一个NAND Flash块仅需2ms。NOR Flash的块太大，不仅增加了擦写时间，对于给定的操作，NOR Flash也需要更多的擦除操作–特别是小文件。比如一个文件只有1KB，但是为了保存它却需要擦除大小为64KB-128KB的NOR Flash块。<br>NOR Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的接口仅仅包含几个I&#x2F;O引脚，需要串行访问。NAND Flash一般以512字节为单位进行读写。这使得NOR Flash更适合运行程序，NAND Flash更适合存储数据。<br>容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上NOR Flash的容量通常为1MB-4MB(也有32MB的NOR Flash)。NAND Flash的容量为8MB-512MB。容量的差别也使得NOR Flash多用于存储程序，NAND Flash多用于存储数据。<br>基于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转问题：由于Flash固有的电气特性，在读写数据的过程中，偶尔会产生一位或几位数据错误，而NAND Flash出现的概率远大于NOR Flash。当位反转发生在关键的代码、数据时，有可能导致系统崩溃。当仅仅是报告位反转，重新读取即可；如果确实发生了位反转，则必须有相应的错误检测&#x2F;恢复措施。在NAND Flash上发生位反转的概率更高，推荐使用EDC&#x2F;ECC进行错误检测和恢复。NAND Flash上面会有坏块随机分布，在使用前需要将坏块扫描出来，确保不在使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右。是NOR Flash的10倍。另外，因为NAND Flash的块大小通常是NOR Flash的1&#x2F;8，所以NAND Flash的寿命远远超过NOR Flash。<br>嵌入式Linux对NOR、NAND Flash的软件支持都很成熟。在NOR Flash上常用jffs2文件系统，而在NAND Flash常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操作，它也实现了EDC&#x2F;ECC校验。</p>
<h2 id="NAND-Flash的物理结构"><a href="#NAND-Flash的物理结构" class="headerlink" title="NAND Flash的物理结构"></a>NAND Flash的物理结构</h2><p>以NAND Flash K9F1208U0M为例，K9F1208U0M是Samsung公司生产的容量为64MB的NAND Flash，常用于手持设备等消费电子产品。它的封装下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"></p>
<p>外部引脚如下表所示：</p>
<table>
<thead>
<tr>
<th>引脚名称</th>
<th>引脚功能</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O0-I&#x2F;O7</td>
<td>数据输入&#x2F;输出</td>
</tr>
<tr>
<td>CLE</td>
<td>命令锁存使能</td>
</tr>
<tr>
<td>ALE</td>
<td>地址锁存使能</td>
</tr>
<tr>
<td>CE</td>
<td>芯片使能</td>
</tr>
<tr>
<td>RE</td>
<td>读使能</td>
</tr>
<tr>
<td>WE</td>
<td>写使能</td>
</tr>
<tr>
<td>WP</td>
<td>写保护</td>
</tr>
<tr>
<td>R&#x2F;B</td>
<td>就绪&#x2F;忙输出信号</td>
</tr>
<tr>
<td>Vcc</td>
<td>电源</td>
</tr>
<tr>
<td>Vss</td>
<td>地</td>
</tr>
<tr>
<td>N.C</td>
<td>不接</td>
</tr>
</tbody></table>
<p>K9F1208U0M的功能结构图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>K9F1208U0M的内部结构包含10个功能部件：</p>
<ol>
<li>X-Buffers Latche &amp; Decoders：用于行地址。</li>
<li>Y-Buffers Latche &amp; Decoders：用于列地址。</li>
<li>Command Register：用于命令字。</li>
<li>Control Logic &amp; High Voltage Generator：控制逻辑及产生Flash所需高压。</li>
<li>Nand Flash Array：存储部件。</li>
<li>Page Register &amp; S&#x2F;A：页寄存器，当读、写某页时，会将数据先读入&#x2F;写入此寄存器，大小为528字节。</li>
<li>Y-Gating。</li>
<li>I&#x2F;O Buffers &amp; Latches。</li>
<li>Global Buffers。</li>
<li>Output Drivers。</li>
</ol>
<p>Nand Flash 存储单元组织结构如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/3.jpeg" alt="img not found"><br>K9F1208U0M容量为528Mbit，分为131072行（页）、528列。每一页大小为512字节，外加16字节的额外空间，这16字节额外空间的列地址为512-527。<br>命令、地址、数据都通过8个I&#x2F;O口输入&#x2F;输出，这种形式减少了芯片的引脚个数，并使得系统很容易升级到更大的容量。写入命令、地址或数据时，都需要将WE、CE信号同时拉低。<br>数据在WE信号的上升沿被NAND Flash锁存。命令锁存信号CLE、地址锁存信号ALE用来分辨、锁存命令或地址。K9F1208U0M的64MB存储空间需要26位地址，因此以字节为单位访问Flash时需要4个地址序列：列地址、行地址的低位部分，行地址的高位部分。读&#x2F;写页发出命令之后，需要4个地址序列，而擦除块在发出擦除命令后仅需要3个地址序列。</p>
<h2 id="Nand-Flash的访问方法"><a href="#Nand-Flash的访问方法" class="headerlink" title="Nand Flash的访问方法"></a>Nand Flash的访问方法</h2><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p>NAND Flash和S3C2410&#x2F;S3C2440的硬件连接图如下所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/4.jpeg" alt="img not found"><br>NAND Flash和S3C2410&#x2F;S3C2440的连线较少：8个I&#x2F;O引脚（I&#x2F;O0-I&#x2F;O7），5个使能信号（nWE、ALE、CLE、nCE、nRE）、1个状态引脚（RDY&#x2F;B）、1个写保护引脚（nWP）。地址、数据、命令都是在这些使能信号的配合下，通过8个I&#x2F;O引脚的传输。写地址、数据、命令时，nCE、nWE信号必须为低电平，它们在nWE信号的上升沿被锁存。命令锁存使能信号CLE和地址锁存信号ALE用来区分I&#x2F;O引脚上传输的是命令还是地址。</p>
<h3 id="命令字及操作方法"><a href="#命令字及操作方法" class="headerlink" title="命令字及操作方法"></a>命令字及操作方法</h3><p>操作NAND Flash时，先传输命令，然后传输地址，最后读写数据。期间要检查Flash的状态。对于K9F1208U0M，它的容量是64MB，需要一个26位的地址。发出命令后，后面要紧跟着4个地址序列。比如读Flash时，发出读命令和4个地址序列后，后续的读操作就可以得到这个地址及器后续地址的数据。相应的命令字和地址序列如下表所示：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>第1个访问周期</th>
<th>第2个访问周期</th>
<th>第3个访问周期</th>
</tr>
</thead>
<tbody><tr>
<td>Read1（读）</td>
<td>00h&#x2F;01h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read2（读）</td>
<td>50h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read ID（读芯片ID）</td>
<td>90h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Page Program（写页）</td>
<td>80h</td>
<td>10h</td>
<td>-</td>
</tr>
<tr>
<td>Block Erase（擦除块）</td>
<td>60h</td>
<td>D0h</td>
<td>-</td>
</tr>
<tr>
<td>Read Status（读状态）</td>
<td>70h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read Multi-Plane Status（读多层的状态）</td>
<td>71h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Reset（复位）</td>
<td>FFh</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Page Program（Dummy）</td>
<td>80h</td>
<td>11h</td>
<td>-</td>
</tr>
<tr>
<td>Copy-Back Program（True）</td>
<td>00h</td>
<td>8Ah</td>
<td>10H</td>
</tr>
<tr>
<td>Copy-Back Program（Dummy）</td>
<td>03h</td>
<td>8Ah</td>
<td>11H</td>
</tr>
<tr>
<td>Multi-Plane Block Erase</td>
<td>60h-60h</td>
<td>D0h</td>
<td>-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>&#x2F;</th>
<th>I&#x2F;O0</th>
<th>I&#x2F;O1</th>
<th>I&#x2F;O2</th>
<th>I&#x2F;O3</th>
<th>I&#x2F;O4</th>
<th>I&#x2F;O5</th>
<th>I&#x2F;O6</th>
<th>I&#x2F;O7</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>第1个地址序列</td>
<td>A0</td>
<td>A1</td>
<td>A2</td>
<td>A3</td>
<td>A4</td>
<td>A5</td>
<td>A6</td>
<td>A7</td>
<td>列地址</td>
</tr>
<tr>
<td>第2个地址序列</td>
<td>A9</td>
<td>A10</td>
<td>A11</td>
<td>A12</td>
<td>A13</td>
<td>A14</td>
<td>A15</td>
<td>A16</td>
<td>行地址（页地址）</td>
</tr>
<tr>
<td>第3个地址序列</td>
<td>A17</td>
<td>A18</td>
<td>A19</td>
<td>A20</td>
<td>A21</td>
<td>A22</td>
<td>A23</td>
<td>A24</td>
<td>行地址（页地址）</td>
</tr>
<tr>
<td>第4个地址序列</td>
<td>A25</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>行地址（页地址）</td>
</tr>
</tbody></table>
<p>注：<br>①K9F1208U0M一页大小为512字节，分两部分：上半部、下半部。<br>②列地址用来在半页（256字节）中寻址。<br>③当发出读命令00h时，表示列地址将在上半部寻址。当发出写命令01h时，表示列地址将在下半部寻址。<br>④A8被读命令00h设为低电平，被01h设为高电平。<br>⑤L表示低电平。</p>
<p>K9F1208U0M一页大小为508字节，而列地址A0-A7可以寻址的范围是256字节，所以必须辅以其他手段才能完全寻址着528字节。将一页分为A、B、C三个区：A区为0-255字节，B区为256-511字节，C区为512-527字节。访问某页时，需要选定特定的区，这称为“使地址指针指向特定的区”。这通过3个命令来实现：命令00h让地址指针指向A区、命令01h让地址指针指向B区、命令50h让地址指针指向C区。命令00h和命令50h会使得访问Flash的地址指针一直从A区或C区开始，除非发出了其他的修改地址指针的命令。命令01h的效果只能维持一次，当前的读、写、擦除、复位或者上电操作完成后，地址指针重新指向A区。写A区或C区的数据时，必须在发出命令80h之前发出命令00h或50h；写B区的数据时，发出命令01h后必须紧接着发出命令80h。下图形象的描述了这个过程：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/5.jpeg" alt="img not found"></p>
<ol>
<li>Read 1：命令字为00h或01h<br>在发出命令00h或者01h后，就选定了读操作是从A区还是B区开始。列地址A0-A7可以寻址的范围是256字节，命令00h和01h使得可以在512字节大小的页内任意寻址–这相当于A8被命令00h设为0，而命令01h设为1。<br>发出命令字后，随后发出4个地址序列，然后就可以检测R&#x2F;nB引脚以确定Flash是否准备好。如果准备好了，就可以发起读操作一次读出数据。</li>
<li>Read 2：命令字为50h<br>与Read 1类似，不过读取的是C区数据，操作序列为：发出命令字50h、发出4个地址序列、等待R&#x2F;nB引脚为高，最后读取数据。不同的是，地址序列中A0-A3用于设定C区（16字节）要读取的起始地址，A4-A7被忽略。</li>
<li>Read ID：命令字90h。<br>发出命令字90h，发出4个地址序列（都设为0），然后就可以连续读入5个数据，分别表示：厂商代码（Samsung格式为Ech）、设备代码（K9F1208U0M为76h）、保留的字节（K9F1208U0M为A5h）、多层操作代码（C0h表示支持多层操作）。</li>
<li>Reset：命令字为FFh<br>发出命令字FFh即可复位NAND Flash芯片。如果芯片正处于读、写、擦除状态，复位命令会终止这些命令。</li>
<li>Page Program（True）：命令字分两阶段，80h和10h<br>它的操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/6.jpeg" alt="img not found"><br>NAND Flash的写操作一般是以页为单位的，但是可以只写一页中的一部分。发出命令字80h后，紧接着的是4个地址序列，然后向Flash发送数据（最大可达528字节），然后发送命令字10h启动写操作，此时Flash内部会自动完成写、校验操作。一旦发出命令字10h后，就可以通过读状态命令70h获知当前写操作是否完成、是否成功。</li>
<li>Page Program（Dummy）：命令字分为两阶段，80h和11h。<br>NAND Flash K9F1208U0M分为4个128Mbit的存储层（plane），每个存储层包含1024个block和528字节的寄存器。这使得可以同时写多个页（page）或者同时擦除多个块（block）。块的地址经过精心安排，可以在4个连续的块内同时进行写或者擦除操作。下图为K9F1208U0M的块组织图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/7.jpeg" alt="img not found"><br>命令Page Program（Dummy）正是在这种结构下对命令Page Program（True）的扩展，后者仅能对一页进行写操作，前者可以同时写4页。操作序列如下图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/8.jpeg" alt="img not found"><br>发出命令字80h、4个地址序列及最多528字节的数据之后，发出命令字11h（11h称为“Dummy Page Program command”，相对的，10h称为“True Page Program Command”）；接着对相邻层（plane）上的页进行同样的操作。仅在第4页的最后使用10h替代11h，这样即可启动Flash内部的写操作。此时可以通过命令71h获知这些写操作是否完成、是否成功。</li>
<li>Copy-Back Program（True）：命令字分3阶段，00h、08h、10h。<br>此命令用于将一页复制到同一层（plane）内的另一页，它省略了读出源数据、将数据重新载入Flash，这使得效率大卫提高。此命令有两个限制：源页、目的页必须在同一层（plane）中，并且将源地址、目的地址的A14、A15必须相同。<br>操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/9.jpeg" alt="img not found"><br>首先发出命令Read 1（00h）、4个源地址序列，此时源页的528字节数据很快就被全部读入内部寄存器中；接着发出命令字8Ah（Page-Copy Data-input command）,随之发出4个目的地址序列；最后发出命令字10h启动对目的页的写操作。此后可以使用命令70h来查看此操作是否完成、是否成功。</li>
<li>Copy-Back Program（Dummy）：命令字分3个阶段，03h、8Ah、11h。<br>与命令Page Program（Dummy）类似，Copy-Back Program（Dummy）可以同时启动对多达4个连续plane内的Copy-Back Program操作。操作序列如下所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpeg" alt="img not found"><br>从图中可得知，首先发出命令字00h、源页地址，这使得源页的528字节数据被读入所在plane的寄存器；对于随后的其他plane的源页，发出命令字03h和相应的源页地址将数据读入该plane的寄存器；按照前述说明读出最多4页的数据到寄存器后，发出命令字8Ah、目的地址、命令字11h，在发出最后一页地址后，用10h代替11h启动写操作。</li>
<li>Block Erase：命令字分3阶段，60h、D0h。<br>此命令用于擦除NAND Flash块（block，大小为16KB）。发出命令字后，发出block地址—仅需要3个地址序列，并且A9-A13被忽略，操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/11.jpeg" alt="img not found"></li>
<li>Multi-Plane Block Erase：60h—-60h D0h。<br>此命令用于擦除不同的plane中的块，发出命令字60h后，紧接着发出block地址序列，如此最多可以发出4个block地址，最后发出命令字D0h启动擦除操作。操作序列如图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/12.jpeg" alt="img not found"></li>
<li>读状态命令字有如下两种：<br>①Read Status：命令字为70h。<br>②Read Multi-Plane Status：命令字为71h。<br>Falsh中有状态寄存器，发出命令字70h或71h后，启动读操作即可读入此寄存器。状态寄存器中各位的含义如下表所示：<table>
<thead>
<tr>
<th>I&#x2F;O引脚</th>
<th>所标识的状态</th>
<th>命令70h对应的定义</th>
<th>命令71h对应的定义</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O0</td>
<td>总标记：成功&#x2F;失败</td>
<td>成功：0 失败：1</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O1</td>
<td>Plane0的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O2</td>
<td>Plane1的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O3</td>
<td>Plane2的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O4</td>
<td>Plane3的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O5</td>
<td>保留</td>
<td>忽略</td>
<td>忽略</td>
</tr>
<tr>
<td>I&#x2F;O6</td>
<td>设备状态</td>
<td>忙：0 就绪：1</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O7</td>
<td>写保护状态</td>
<td>保护：0 没有保护：1</td>
<td>保护：0 没有保护：1</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：<br>①I&#x2F;O0是所有Plane的“总标记”，只要有一个Plane的操作是失败的，I&#x2F;O0就会被设为“失败”。<br>②I&#x2F;O0-I&#x2F;O4引脚只部件它对应的Plane。</p>
<h2 id="S3C2410-x2F-S3C2440-NAND-Flash控制器介绍"><a href="#S3C2410-x2F-S3C2440-NAND-Flash控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 NAND Flash控制器介绍"></a>S3C2410&#x2F;S3C2440 NAND Flash控制器介绍</h2><p>NAND Flash控制器提供几个寄存器来简化对NAND Flash的操作。比如要发出读命令时，只需要往NFCMD寄存器中写入0即可，NAND Flash控制器会自动发出各种控制信号。</p>
<h3 id="操作方法概述"><a href="#操作方法概述" class="headerlink" title="操作方法概述"></a>操作方法概述</h3><p>访问NAND Flash时需要先发出命令，然后发出地址序列，最后读写数据。需要使用各个使能信号来分辨是命令、地址还是数据。S3C2410的NAND Flash控制器提供了NFCONF、NFCMD、NFADDR、NFDATA、NFSTAT和NFECC等6个寄存器来简化这些操作。S3C2440的NAND Flash控制器则提供了NFCONF、NFCONT、NFCMMD、NFADDR、NFDATA、NFSTAT和其他与ECC有关的寄存器。对NAND Flash控制器的操作，S3C2410与S3C2440有一点小差别，有的寄存器地址不一样，有的寄存器内容不一样。<br>NAND Flash的读写操作次序如下：</p>
<ol>
<li>设置NFCONF（对于S3C2440，还要设置NFCONT）寄存器，配置NAND Flash。</li>
<li>向NFCMD寄存器写入命令。</li>
<li>向NFADDR写入地址。</li>
<li>读&#x2F;写数据，通过寄存器NFSTAT检测NAND Flash的状态，在启动某个操作之后，应该检测R&#x2F;nB信号以确定该操作是否完成、是否成功。</li>
</ol>
<h3 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h3><ol>
<li>NFCONF：NAND Flash配置寄存器<br>这个寄存器在S3C2410、S3C2440上功能有所不同。<br>S3C2410上的NFCONF寄存器，被用来使能&#x2F;禁止NAND Flash控制器，使能&#x2F;禁止控制引脚信号nFCE、初始化ECC、设置NAND Flash的时序参数等。TACLS、TWRPH0和TWRPH1这3个参数控制的是NAND Flash信号线CLE&#x2F;ALE与写控制信号nWE的时序关系。<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/13.jpeg" alt="img not found"><br>S3C2440的NFCONF寄存器，被用来设置NAND Flash的时序参数TACLS、TWRPH0、TWRPH1，设置数据位宽；还有一些只读位，用来指示是否支持其他大小的页（256&#x2F;512&#x2F;1024&#x2F;2048字节）。<br>它没有实现S3C2410的NFCONF寄存器的控制功能，这些功能在S3C2440的NFCONT寄存器里实现。</li>
<li>NFCONT：NAND Flash控制寄存器，S3C2410没有这个寄存器。<br>被用来使能&#x2F;禁止NAND Flash控制器、使能&#x2F;禁止控制引脚信号nFCE、初始化ECC。它还有其他功能，在一般的应用中用不到，比如锁定NAND Flash。</li>
<li>NFCMD：NAND Flash命令寄存器<br>对于不同型号的Flash，操作命令一般不一样。</li>
<li>NFADDR：NAND Flash地址寄存器。<br>当写这个寄存器时，它将对Flash发出地址信号。</li>
<li>NFDATA：NAND Flash数据寄存器。<br>只用到低8位，读写此寄存器将启动对NAND Flash的读数据、写数据操作。</li>
<li>NFSTAT：NAND Flash状态寄存器<br>只用到位0。0：busy，1：ready。</li>
</ol>
<h1 id="NAND-Flash控制器操作实例：读Flash"><a href="#NAND-Flash控制器操作实例：读Flash" class="headerlink" title="NAND Flash控制器操作实例：读Flash"></a>NAND Flash控制器操作实例：读Flash</h1><p>本实例讲述如何读取NAND Flash，擦除、写Flash的操作与读Flash类似，读者可以自行编写程序程序。</p>
<h2 id="读NAND-Flash的步骤"><a href="#读NAND-Flash的步骤" class="headerlink" title="读NAND Flash的步骤"></a>读NAND Flash的步骤</h2><p>下面讲述如何从NAND Flash中读出数据，假设读地址为addr。</p>
<h3 id="1-设置NFCONF（对于S3C2440，还要设置NFCONT）"><a href="#1-设置NFCONF（对于S3C2440，还要设置NFCONT）" class="headerlink" title="1.设置NFCONF（对于S3C2440，还要设置NFCONT）"></a>1.设置NFCONF（对于S3C2440，还要设置NFCONT）</h3><ol>
<li><p>对于S3C2410<br>实例中此寄存器设为0x9830—使能NAND Flash控制器、初始化ECC、NAND Flash片选信号nFCE&#x3D;1（inactive，真正使用时再让它等于0），设置TACLS&#x3D;0，TWRPH0&#x3D;3，TWRPH1&#x3D;0。这些时序参数的含义为：TACLS&#x3D;1个HCLK时钟，TWRPH0&#x3D;4个HCLK时钟，TWRPH1&#x3D;1个HCLK时钟。<br>K9F1208U0M的时间特性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLE setup Time = 0 ns,CLE Hold Time = 10 ns,</span><br><span class="line">ALE setup Time = 0 ns,ALE Hold Time = 10 ns,</span><br><span class="line">WE Pulse Width 25 ns</span><br></pre></td></tr></table></figure>
<p>参考上图：即使在HCLK&#x3D;100MHZ的情况下，TACLS+TWRPH0+TWRPH1&#x3D;6&#x2F;100μs&#x3D;60ns，也是可以满足NAND Flash K9F1208U0M的时序要求的。</p>
</li>
<li><p>对于S3C2440<br>时间参数也设为：TACLS&#x3D;0，TWRPH0&#x3D;3，TWRPH1&#x3D;0。NFCONF寄存器的值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF = 0x300</span><br></pre></td></tr></table></figure>
<p>NFCONT寄存器的取指如下，表示使能NAND Flash控制器、禁止控制引脚信号nFCE、初始化ECC。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT = (1&lt;&lt;4) | (1&lt;&lt;1) | (1&lt;&lt;0)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-在第一次操作NAND-Flash前，通常复位一下NAND-Flash"><a href="#2-在第一次操作NAND-Flash前，通常复位一下NAND-Flash" class="headerlink" title="2.在第一次操作NAND Flash前，通常复位一下NAND Flash"></a>2.在第一次操作NAND Flash前，通常复位一下NAND Flash</h3><ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF &amp;= ~(1&lt;&lt;11)  (发出片选信号)</span><br><span class="line">NFCMD   = 0xff      (reset命令)</span><br></pre></td></tr></table></figure>
然后循环查询NFSTAT位0，直到它等于1。<br>最后禁止片选信号，在实际使用NAND Flash时再使能。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF  |=  (1&lt;&lt;11) (禁止NAND Flash)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  &amp;=  ~(1&lt;&lt;11)    (发出片选信号)</span><br><span class="line">NFCMD    =  0xff        (reset命令)</span><br></pre></td></tr></table></figure>
然后循环查询NFSTAT位0，知道它等于1。<br>最后禁止片选信号，在实际使用NAND Flash时再使能。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  |=  0x2         (禁止NAND Flash)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-发出读命令"><a href="#3-发出读命令" class="headerlink" title="3.发出读命令"></a>3.发出读命令</h3><p>先使能NAND Flash，然后发出读命令。</p>
<ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF &amp;=   ~(1&lt;&lt;11)        (发出片选信号)</span><br><span class="line">NFCMD   =   0               (读命令)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  &amp;=  ~(1&lt;&lt;11)        (发出片选信号)</span><br><span class="line">NFCND    =  0               (读命令)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-发出地址信号"><a href="#4-发出地址信号" class="headerlink" title="4.发出地址信号"></a>4.发出地址信号</h3><p>这步请注意，表8.3列出了在地址操作的4个步骤对应的地址线，没用到A8（它由读命令设置，当读命令为0时，A8&#x3D;0；当读命令为1时，A8&#x3D;1），如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFADDR  = addr &amp; 0xff</span><br><span class="line">NFADDR  = (addr &gt;&gt; 9)   &amp;   0xff    (左移9位，不是8位)</span><br><span class="line">NFADDR  = (addr &gt;&gt; 17)  &amp;   0xff    (左移17位，不是16位)</span><br><span class="line">NFADDR  = (addr &gt;&gt; 25)  &amp;   0xff    (左移25位，不是24位)</span><br></pre></td></tr></table></figure>
<h3 id="5-循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了"><a href="#5-循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了" class="headerlink" title="5.循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了"></a>5.循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了</h3><h3 id="6-连续读取NFDATA寄存器512次，得到一页数据（512字节）"><a href="#6-连续读取NFDATA寄存器512次，得到一页数据（512字节）" class="headerlink" title="6.连续读取NFDATA寄存器512次，得到一页数据（512字节）"></a>6.连续读取NFDATA寄存器512次，得到一页数据（512字节）</h3><p>循环执行第3、4、5、6这四个步骤，直到读出所要求的所有数据。</p>
<h3 id="7-最后禁止NAND-Flash的片选信号"><a href="#7-最后禁止NAND-Flash的片选信号" class="headerlink" title="7.最后禁止NAND Flash的片选信号"></a>7.最后禁止NAND Flash的片选信号</h3><ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF |= (1&lt;&lt;11)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  |=  (1&lt;&lt;1)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>源文件为head.S、init.c和main.c。本实例的目的是把一部分代码存放在NAND Flash地址4096后，当程序启动NAND Flash控制器将它们读出来、执行。以前的代码都小于4096字节，开发板启动后它们被自动复制进“Steppingstone”中。<br>连接脚本nand.lds把它们分为两部分，nand.lds代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    first   0x00000000  ：&#123;head.o init.o nand.o&#125;</span><br><span class="line">    second  0x30000000  :   AT(4096)    &#123;main.o&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2行表示head.o、init.o、nand.o这3个文件的运行地址为0，它们在生成的映像文件中的偏移地址也为0（从0开始存放）。<br>第3行表示main.o的运行地址为0x30000000，它在生成的映像文件中的偏移地址为4096。<br>head.S调用init.c中的函数来关WATCH DOG、初始化SDRAM；调用nand.c中的函数来初始化NAND Flash，然后将main.c中的代码从NAND Flash地址4096开始处复制到SDRAM中；最后跳到main.c中的main函数继续执行。<br>由于S3C2410、S3C2440的NAND Flash控制器并非完全一样，这个程序要既能处理S3C2410，也能处理S3C2440，首先需要分辨是S3C2410还是S3C2440，然后使用不同的函数进行处理。读取GSTATUS1寄存器，如果它的值为0x32410000或0x32410002，就表示处理器是S3C2410，否则就是S3C2440。<br>nand.c向外引出两个函数：用来初始化NAND Flash的nand_init函数，用来将数据从NAND Flash读到SDRAM的nand_read函数。</p>
<h3 id="nand-init-函数分析"><a href="#nand-init-函数分析" class="headerlink" title="nand_init 函数分析"></a>nand_init 函数分析</h3><p>代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化NAND Flash</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH0  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH1  0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*判断是S3C2410还是S3C2440*/</span></span><br><span class="line">    <span class="keyword">if</span>((GSTATUS1 == <span class="number">0x32410000</span>) || (GSTATAUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        nand_chip.nand_reset            =   s3c2410_nand_reset;</span><br><span class="line">        nand_chip.wait_idle             =   s3c2410_wait_idle;</span><br><span class="line">        nand_chip.nand_select_chip      =   s3c2410_nand_select_chip;</span><br><span class="line">        nand_chip.nand_deselect_chip    =   s3c2410_nand_deselect_chip;</span><br><span class="line">        nand_chip.write_cmd             =   s3c2410_write_cmd;</span><br><span class="line">        nand_chip.write_addr            =   s3c2410_write_addr;</span><br><span class="line">        nand_chip.read_data             =   s3c2410_read_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*使能NAND Flash控制器，初始化ECC，禁止片选，设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (<span class="number">1</span>&lt;&lt;<span class="number">15</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">12</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (TACLS&lt;&lt;<span class="number">8</span>) | (TWRPH0&lt;&lt;<span class="number">4</span>) | (TWRPH1&lt;&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nand_chip.nand_reset            =   s3c2440_nand_reset;</span><br><span class="line">        nand_chip.wait_idle             =   s3c2440_wait_idle;</span><br><span class="line">        nand_chip.nand_select_chip      =   s3c2440_nand_select_chip;</span><br><span class="line">        nand_chip.nand_deselect_chip    =   s3c2440_nand_deselect_chip;</span><br><span class="line">        nand_chip.write_cmd             =   s3c2440_write_cmd;</span><br><span class="line">        nand_chip.write_addr            =   s3c2440_write_addr;</span><br><span class="line">        nand_chip.read_data             =   s3c2440_read_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line">        <span class="comment">/*使能NAND Flash控制器，初始化ECC，禁止片选，设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*复位NAND Flash*/</span></span><br><span class="line">    nand_reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第12行读取GSTATUS1寄存器来判断为S3C2410还是S3C2440，然后分别处理：S3C2410、S3C2440的NAND Flash控制器中，有一些寄存器的功能是相同的，但是它们的地址是不一样的；有一些寄存器的功能已经发生变化。所以使用两套函数来进行处理。<br>第14-20行设置S3C2410的NAND Flash处理函数，第27-33行设置S3C2440的NAND Flash处理函数，把这些函数赋值给nand_chip结构，以后通过这个结构来调用。<br>如果处理器是S3C2410，则调用第23行的代码设置NFCONF寄存器；使能NAND Flash控制器，初始化ECC，禁止片选，设置时序。如果处理器是S3C2440，则使用第36、38两行代码来进行相同的设置。<br>最后第41行调用nand_reset函数复位NAND Flash。在第一次使用前通常复位一下。其中涉及的各个函数都只有几行，主要是读写寄存器。</p>
<h3 id="nand-read-函数分析"><a href="#nand-read-函数分析" class="headerlink" title="nand_read 函数分析"></a>nand_read 函数分析</h3><p>它的原型如下，表示从NAND Flash位置satrt_addr开始，将数据复制到SDRAM地址buf处，共复制size字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">unsigned</span> <span class="type">long</span> start_addr,<span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">unsigned</span> <span class="type">long</span> start_addr,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((start_addr &amp; NAND_BLOCK_MASK) || (size &amp; NAND_BLOCK_MASK))&#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">/*地址或长度不对齐*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*选中芯片*/</span></span><br><span class="line">    nand_select_chip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = start_addr;i &lt; start_addr + size;)&#123;</span><br><span class="line">        <span class="comment">/*发出READ0命令*/</span></span><br><span class="line">        write_cmd(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Write Address*/</span></span><br><span class="line">        write_addr(i);</span><br><span class="line">        wait_idle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;i &lt; NAND_SECTOR_SIZE;j++,i++)&#123;</span><br><span class="line">            *buf = read_data();</span><br><span class="line">            buf++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*取消片选信号*/</span></span><br><span class="line">    nand_deselect_chip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，读NAND Flash的操作分为6步。</p>
<ol>
<li>选择芯片——nand_select_chip()；</li>
<li>发出读命令——write_cmd()；</li>
<li>发出地址——write_addr()；</li>
<li>等待数据就绪——wait_idle()；</li>
<li>读取数据——read_data()；</li>
<li>结束后，取消片选信号；</li>
</ol>
<p>流程图如下：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpeg" alt="img not found"><br>从NAND Flash复制代码到SDRAM并运行的过程：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/15.jpeg" alt="img not found"><br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/16.jpeg" alt="img not found"><br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/17.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第8章 NAND Flash控制器</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title>中断体系结构</title>
    <url>/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第9章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解ARM系统CPU的7中工作模式</li>
<li>了解S3C2410&#x2F;S3C2440中断体系结构</li>
<li>掌握S3C2410&#x2F;S3C2440的中断服务程序的编写方法</li>
</ol>
<h1 id="S3C2410-x2F-S3C2440中断体系结构"><a href="#S3C2410-x2F-S3C2440中断体系结构" class="headerlink" title="S3C2410&#x2F;S3C2440中断体系结构"></a>S3C2410&#x2F;S3C2440中断体系结构</h1><h2 id="ARM体系CPU的7种工作模式"><a href="#ARM体系CPU的7种工作模式" class="headerlink" title="ARM体系CPU的7种工作模式"></a>ARM体系CPU的7种工作模式</h2><ol>
<li>用户模式（usr）：ARM处理器正常的程序执行状态。</li>
<li>快速中断模式（fiq）：用于高速数据传输或通道处理。</li>
<li>中断模式（irq）：用于通用的中断处理。</li>
<li>管理模式（svc）：操作系统使用的保护模式。</li>
<li>数据访问终止模式（abt）：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。</li>
<li>系统模式（sys）：运行具有特权的操作系统任务。</li>
<li>未定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</li>
</ol>
<p>可以通过软件来进行模式切换，或者发生各类中断、异常时CPU自动进入相应的模式。除用户模式外，其他6种模式都属于特权模式。大多数程序运行于用户模式，进入特权模式是为了处理中断、异常，或者访问被保护的系统资源。<br>另外，ARM体系的CPU有以下两种工作状态。<br>ARM状态：此时处理器执行32位的字对齐的ARM指令。<br>Thumb状态：此时处理器执行16位的、半字对齐的Thumb指令。<br>实际上，本书所有的程序都是在ARM状态下运行的，而CPU一上电就处于ARM状态，所以无需关心CPU的工作状态。<br>ARM920T有31个通用的32位寄存器和6个程序状态寄存器。这37个寄存器分为7组，进入某个工作模式是就使用它的那组寄存器。有些寄存器，不同的工作模式有自己的副本，当切换到另一个工作模式时，那个工作模式的寄存器副本将被使用：这些寄存器被称为备份寄存器。<br>在ARM状态下，每种工作模式都有16个通用寄存器和1个（或2个，取决于工作模式）程序状态寄存器。下图列出了ARM状态下不同工作模式所使用的寄存器：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1.jpeg" alt="img not found"><br>图中R0-R15可以直接访问，这些寄存器除R15之外都是通用寄存器。即它们既可以保存数据也可以保存地址。另外，R13-R15稍有特殊。R13又被称为栈指针寄存器，通常用于保存栈指针。R14  又被称为程序连接寄存器或连接寄存器，当执行BL子程序调用指令时，R14中得到R15（程序计数器PC）的备份。而当发生中断或者异常时，对应的R14_svc、R14_irq、R14_fiq、R14_abt或R14_und中保存R15的返回值。R15是程序计数器。<br>快速中断模式有7个备份寄存器R8-R14（即R8_fiq-R14_fiq），这使得进入快速中断模式执行很大部分程序时（只要它们不改变R0-R7），甚至不需要保存任何寄存器。用户模式、管理模式、数据访问终止模式和未定义指令中止模式都含有两个独占的寄存器副本R13、R14，这样可以令每个模式拥有自己的栈指针寄存器和连接寄存器。<br>每种工作模式除R0-R15共有16个寄存器外，还有第17个寄存器CPSR，即“当前程序状态寄存器（Current Program Status Register）”。CPSR中一些位被用于表示各种状态，一些位被用于标识当前处于说明工作模式。<br>CPSR中各位意义如下：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2.jpeg" alt="img not found"></p>
<ol>
<li>T位：置位时，CPU处于Thumb状态，否则处于ARM状态。</li>
<li>中断禁止位：I位和F位属于中断禁止位。它们置位时，IRQ中断、FIQ中断分别被禁止。</li>
<li>工作模式位：表明CPU当前处于什么工作模式。可以编写这些位，使CPU进入指定的工作模式。</li>
</ol>
<p>除CPSR外，还有快速中断模式、中断模式、管理模式、数据访问终止模式和未定义指令中止模式等5种工作模式和一个寄存器–SPSR，即“程序状态保存寄存器（Saved Process Status Registers）”。当切换进入这些工作模式时，在SPSR中保存前一个工作模式的CPSR值，这样，当返回前一个工作模式时，可以将SPSR的值恢复到CPSR中。<br>综上所述，当一个异常发生时，将切换进入相应的工作模式（下文中将称为异常模式），这是CPU核将自动完成以下事情：</p>
<ol>
<li>在异常工作模式的连接寄存器R14中保存前一个工作模式的下一条，即将执行的指令的地址。对于ARM状态，这个值是当前PC值加4或加8。</li>
<li>将CPSR的值复制到异常模式的SPSR。</li>
<li>将CPSR的工作模式位设为这个异常对应的工作模式。</li>
<li>令PC值等于这个异常模式在异常向量表中的地址，即跳转去执行异常向量表中的相应指令。</li>
</ol>
<p>相反的，从异常工作模式推出到之前的工作模式时，需要通过软件完成如下事情。</p>
<ol>
<li>前面进入异常工作模式时，连接寄存器保存了前一工作模式的一个指令地址，将它减去一个适当的值后赋值给PC寄存器。</li>
<li>将SPSR的值复制回CPSR。</li>
</ol>
<table>
<thead>
<tr>
<th>异常模式</th>
<th>退出异常模式时PC的计算方法</th>
<th>进入异常模式时R14中保存的值（ARM状态）</th>
</tr>
</thead>
<tbody><tr>
<td>管理模式（通过SWI指令进入）</td>
<td>MOVS PC，R14</td>
<td>PC + 4 ①</td>
</tr>
<tr>
<td>未定义指令中止模式</td>
<td>MOVS PC，R14</td>
<td>PC + 4  ①</td>
</tr>
<tr>
<td>快速中断模式</td>
<td>SUBS PC，R14，#4</td>
<td>PC + 4 ②</td>
</tr>
<tr>
<td>中断模式</td>
<td>SUBS PC，R14，#4</td>
<td>PC + 4 ②</td>
</tr>
<tr>
<td>数据访问终止模式</td>
<td>异常原因：指令预取终止 SUBS PC，R14，#4</td>
<td>PC + 4 ①</td>
</tr>
<tr>
<td>数据访问终止模式</td>
<td>异常原因：指令访问终止 SUBS PC，R14，#8</td>
<td>PC + 8 ③</td>
</tr>
</tbody></table>
<p>注：<br>①PC值是这些指令的地址：SWI、未定义的指令、在预取时就失败的指令。<br>②PC值是这些指令的地址：进入快速中断模式、中断模式前、被打断而未执行的指令。<br>③PC值是这些指令的地址：导致数据访问终止的加载&#x2F;存储指令（LDR、STR、LDM、STM）。</p>
<h2 id="S3C2410-x2F-S3C2440中断控制器"><a href="#S3C2410-x2F-S3C2440中断控制器" class="headerlink" title="S3C2410&#x2F;S3C2440中断控制器"></a>S3C2410&#x2F;S3C2440中断控制器</h2><p>CPU运行过程中，如何知道各类外设发生了某些不预期的事件，比如串口收到了新数据，USB接口中插入了设备，按下了某个按键等。主要有以下两种方法：</p>
<ol>
<li>轮询方式：程序循环的查询各个设备的状态并作出相应反应。它实现简单，常用在功能相对单一的系统中。比如在一个温控系统中可以使用查询方式不断检测温度的变化。缺点是占用CPU资源过高，不适用于多任务系统。</li>
<li>中断方式：当某件事情发生时，硬件会设置某个寄存器；CPU在每执行完一条指令时，通过硬件查看这个寄存器，如果发现所关注的事情发生了，则中断当前程序流程，跳转到一个固定的地址处理这件事情，最后返回继续执行被中断的程序。它的实现相对复杂，但是效率很高，是常用的方法。</li>
</ol>
<p>参考下图，不论何种CPU，中断的处理过程是相似的：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/3.jpeg" alt="img not found"></p>
<ol>
<li>中断控制器汇集各类外设发出的中断信号，然后告诉CPU。</li>
<li>CPU保存当前程序的运行环境（各个寄存器等），调用中断服务程序（ISR，Interrupt Service Routine）来处理这些中断。</li>
<li>在ISR中通过读取中断控制器、外设的相关寄存器来识别这是哪个中断，并进行相应的处理。</li>
<li>清除中断：通过读写中断控制器和外设的相关寄存器来实现。</li>
<li>最后恢复被中断程序的运行环境（即上面保存的各个寄存器等），继续执行。</li>
</ol>
<p>对于不同的CPU而言，中断的处理只是细节的不同，S3C2410&#x2F;S3C2440的中断控制器结构如下图所示：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4.jpeg" alt="img not found"><br>SUBSRCPND和SRCPND寄存器表明有哪个中断被触发了，正在等待处理（pending）；SUBMASK（INTSUBMSK）和MASK（INTMSK）用于屏蔽某些中断。<br>图中的“Request sources （with sub -register）”表示INT_RXD0、INT_TXD0等中断源（S3C2410中这类中断有11个，而S3C2440中有15个）。它们不同于“Request sources （without sub -register）”。</p>
<ol>
<li>Request sources （without sub -register）中的中断源被触发之后，SRCPND寄存器中相应位被置1，如果此中断没有被INTMSK寄存器屏蔽或者快中断（FIQ）的话，它将被进一步处理。</li>
<li>对于Request sources （with sub -register）中的中断源被触发之后，SUBSRCPND寄存器中的相应位被置1，如果此中断没有被INTSUBMSK寄存器屏蔽的话，它在SRCPND寄存器中的相应位也被置1，之后的处理过程就和“Request sources （without sub -register）”一样了。</li>
</ol>
<p>在SRCPND寄存器中，被触发的中断的相应位被置1，等待处理：</p>
<ol>
<li>如果被触发的中断中有快速中断（FIQ）—MODE（INTMOD寄存器）中为1的位对应的中断是FIQ，则CPU进入快速中断模式（FIQ Mode）进行处理。</li>
<li>对于一般中断IRQ，可能同时有几个中断被触发，未被INTMSK寄存器屏蔽的中断经过比较后，选出优先级最高的中断，此中断在INTPND寄存器中的相应位被置1，然后CPU进入中断模式（IRQ Mode）进行处理。中断服务程序可以通过读取INTPND寄存器或者INTOFFSET寄存器来确定中断源。</li>
</ol>
<p>“Priority”表示中断的优先级判选，通过PRIORITY寄存器进行设置。</p>
<p>综上所述，使用中断的步骤如下：</p>
<ol>
<li>设置好中断模式和快速中断模式下的栈：当发生中断IRQ时，CPU进入中断模式，这是使用中断模式下的栈；当发生快速中断模式FIQ时，CPU进入快速中断模式，这时使用快速中断模式下的栈。</li>
<li>准备好中断处理函数。<br>  ①异常向量：<br>  在异常向量表中设置好当进入中断模式或快速中断模式时的跳转函数，它们的异常向量地址分别为0x00000018、0x0000001C。<br>  ②中断服务程序（ISR）：<br>  IRQ、FIQ的跳转函数，最终将调用具体中断的服务函数。对于IRQ，读取INTPND寄存器或者INTOFFSET寄存器的值来确定中断源，然后分别处理。<code>对于FIQ，因为只有一个中断可以设为FIQ</code>，因此无需判断。<br>  ③清除中断：<br>  如果不清除中断，则CPU会误以为这个中断又一次发生了。<br>  可以在调用ISR之前清除中断，也可以在调用ISR之后清除中断，这取决于在ISR执行过程中，这个中断是否可能继续发生、是否能够丢弃。如果在ISR执行过程中，这个中断可能发生并不能丢弃，则在调用ISR之前就清除中断，这样在ISR过程中发生的中断能够被各寄存器再次记录并通知CPU；如果在ISR过程中，这个中断并不能发生或者可以丢弃，则在调用ISR后清除中断。<br>  清除中断时，从源头开始：首先，需要的话，操作具体外设清除中断信号；其次，清除SUBSRCPND、SRCPND寄存器的相应位（往相应位写1即可）；最后，清除INTPND寄存器的相应位（往相应位写1即可），最简单的方法就是“INTPND&#x3D;INTPND”。</li>
<li>进入、退出中断模式或快速中断模式时，需要保存、恢复被中断程序的运行环境。<br>  ①对于IRQ：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub lr,lr,#4              @计算返回地址</span><br><span class="line">stmdb   sp!,&#123;r0-r12,lr&#125;   @保存使用到的寄存器</span><br><span class="line">... ...                   @处理中断</span><br><span class="line">ldmia   sp!,&#123;r0-r12,pc&#125;   @中断返回</span><br><span class="line">                          @^表示将spsr的值赋值给cpsr</span><br></pre></td></tr></table></figure>
  ②对于FIQ<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub lr,lr,#4              @计算返回地址</span><br><span class="line">stmdb   sp!,&#123;r0-r7,lr&#125;   @保存使用到的寄存器</span><br><span class="line">... ...                   @处理中断</span><br><span class="line">ldmia   sp!,&#123;r0-r7,pc&#125;   @中断返回</span><br><span class="line">                          @^表示将spsr的值赋值给cpsr</span><br></pre></td></tr></table></figure></li>
<li>根据具体中断，设置相关外设。不比如对于GPIO中断，需要将相应引脚的功能设置为“外部引脚”、设置中断触发条件（低电平出发、高电平触发、下降沿触发还是上升沿触发）等。一些中断拥有自己的屏蔽寄存器，还要开启它。</li>
<li>对于“Request sources （without sub -register）”中的中断，将INTSUBMSK寄存器中相应位设为0。</li>
<li>确定使用此中断的方式：FIQ或IRQ。<br>  ①如果是FIQ，则在INTMOD寄存器中设置相应位为1。<br>  ②如果是IRQ，则在PRIORITY寄存器中设置优先级。</li>
<li>如果是IRQ，将IMTMSK寄存器中相应位设为0（FIQ不受INTMSK寄存器控制）。</li>
<li>设置CPSR寄存器中的I-bit位（IRQ）或者F-bit（对于FIQ）为0，使能IRQ或者FIQ。</li>
</ol>
<h2 id="中断控制器寄存器"><a href="#中断控制器寄存器" class="headerlink" title="中断控制器寄存器"></a>中断控制器寄存器</h2><p>SUBSRCPND、INTSUBMSK这两个寄存器中相同的位对应相同的中断；SRCPND、INTMSK、INTMOD、INTPND这四个寄存器中相同的位对应相同的中断。</p>
<h3 id="SUBSRCPND寄存器（SUB-SOURCE-PENDING）"><a href="#SUBSRCPND寄存器（SUB-SOURCE-PENDING）" class="headerlink" title="SUBSRCPND寄存器（SUB SOURCE PENDING）"></a>SUBSRCPND寄存器（SUB SOURCE PENDING）</h3><p>SUBSRCPND寄存器被用来标识INT_RXD0、INT_TXD0等中断（S3C2410中这类中断有11个，而S3C2440中有15个）受否已经发生，每位对应一个中断。当这些中断发生并且没有被INTSUBSMSK寄存器屏蔽，则它们中的若干位将“汇集”出现在SRCPND寄存器的一位下。比如SUBSRCPND寄存器中的3个中断，INT_RXD0、INT_TXD0、INT_ERR0，只要有一个发生了并且它没有被屏蔽，则SRCPND寄存器中的INT_UART0位被置1。<br>要清除中断时，往SUBSRCPND寄存器中某位写入1即可令此位为0；写入0无效果，数据保持不变。</p>
<h3 id="INTSUBMSK寄存器（INTERRUPT-SUB-MSK）"><a href="#INTSUBMSK寄存器（INTERRUPT-SUB-MSK）" class="headerlink" title="INTSUBMSK寄存器（INTERRUPT SUB MSK）"></a>INTSUBMSK寄存器（INTERRUPT SUB MSK）</h3><p>INTSUBMSK寄存器被用来屏蔽SUBSRCPND寄存器标识的中断。INTSUBMSK寄存器中某位被设为1时，对应的中断被屏蔽。</p>
<h3 id="SRCPND寄存器（SOURCE-PENDING）"><a href="#SRCPND寄存器（SOURCE-PENDING）" class="headerlink" title="SRCPND寄存器（SOURCE PENDING）"></a>SRCPND寄存器（SOURCE PENDING）</h3><p>SRCPND中每一位被用来表示一个（或者一类）中断是否已经发生。例如：</p>
<ol>
<li>使用SUBSRCPND&#x2F;INTSUBMSK控制的中断。</li>
<li>不使用SUBSRCPND&#x2F;INTSUBMSK控制的中断。<br>SRPND寄存器的操作与SUBSRCPND类似，若想清除某一位，往此位写入1。</li>
</ol>
<h3 id="INTMSK-寄存器（INTERRUPT-MASK）"><a href="#INTMSK-寄存器（INTERRUPT-MASK）" class="headerlink" title="INTMSK 寄存器（INTERRUPT MASK）"></a>INTMSK 寄存器（INTERRUPT MASK）</h3><p>INTMSK寄存器被用来屏蔽SRCPND寄存器所标识的中断。INTMSK寄存器中某位被设为1时，对应的中断被屏蔽。<br>INTMSK寄存器只能屏蔽被设为IRQ的中断，不能屏蔽被设为FIQ的中断。</p>
<h3 id="INTMOD-寄存器（INTERRUPT-MODE）"><a href="#INTMOD-寄存器（INTERRUPT-MODE）" class="headerlink" title="INTMOD 寄存器（INTERRUPT MODE）"></a>INTMOD 寄存器（INTERRUPT MODE）</h3><p>当INTMOD寄存器中某位被设为1时，它对应的中断被设为FIQ，即此中断发生时，CPU将进入快速中断模式，这通常用来处理特别紧急的中断。</p>
<h3 id="PRIORITY-寄存器"><a href="#PRIORITY-寄存器" class="headerlink" title="PRIORITY 寄存器"></a>PRIORITY 寄存器</h3><p>上面INTMOD寄存器中，将设为1的中断称为快速中断（FIQ），将其余设为0的中断称为普通中断（IRQ）。<br>当有多个普通中断发生时，中断处理器将选出优先级最高的中断，首先处理它。中断优先级的判选通过7个仲裁器来完成，包括6个以及仲裁器和1个二级仲裁器：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/5.jpeg" alt="img not found"><br>每个仲裁器含6个输入引脚REQ0-REQ5。对于每个仲裁器，PRIORITY寄存器使用三位来控制其行为：一位被用于选择仲裁器工作模式，称为ARB_MODE；两位被用于控制各输入信号的优先级，称为ARB_SEL。<br>ARB_SEL的取值和REQ0-REQ5的优先级如下表所示：</p>
<table>
<thead>
<tr>
<th>ARB_SEL</th>
<th>优先级（从高到低）</th>
</tr>
</thead>
<tbody><tr>
<td>00b</td>
<td>REQ0、REQ1、REQ2、REQ3、REQ4、REQ5</td>
</tr>
<tr>
<td>01b</td>
<td>REQ0、REQ2、REQ3、REQ4、REQ1、REQ5</td>
</tr>
<tr>
<td>10b</td>
<td>REQ0、REQ3、REQ1、REQ1、REQ2、REQ5</td>
</tr>
<tr>
<td>11b</td>
<td>REQ0、REQ4、REQ4、REQ2、REQ3、REQ5</td>
</tr>
</tbody></table>
<p>注：REQ0的优先级永远是最高的、REQ5的优先级永远是最低的。</p>
<p>当某个仲裁器的ARB_MODE位被设为0时，它的ARB_SEL位是不会自动变化的，此时这个仲裁器的6个输入引脚的优先级固定不变（当然，可以通过软件修改ARB_SEL来改变它们的优先级）。当ARB_MODE位被设为1时，ARB_SEL会随着“已经被服务的REQx”（x&#x3D;1~4）自动变化：</p>
<table>
<thead>
<tr>
<th>已经被服务的REQx</th>
<th>ARB_SEL的新值</th>
</tr>
</thead>
<tbody><tr>
<td>REQ0&#x2F;REQ5</td>
<td>维持不变</td>
</tr>
<tr>
<td>REQ1</td>
<td>01b</td>
</tr>
<tr>
<td>REQ2</td>
<td>10b</td>
</tr>
<tr>
<td>REQ3</td>
<td>11b</td>
</tr>
<tr>
<td>REQ4</td>
<td>00b</td>
</tr>
<tr>
<td>结合上表可知：当ARB_MODE为1时，某个REQx（x&#x3D;1~4）被服务之后，它的优先级变为REQ0-REQ4中的最低。</td>
<td></td>
</tr>
<tr>
<td>PRIORITY寄存器中位[0:6]对应这7个仲裁器的ARB_MODE位（位[0]是ARB_MODE0，依此类推），位[7:20]位对应这7个仲裁器的ARB_SEL位（[7:8]是ARB_SEL0，依此类推）。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="INTPND寄存器（INTERRUPT-PENDING）"><a href="#INTPND寄存器（INTERRUPT-PENDING）" class="headerlink" title="INTPND寄存器（INTERRUPT PENDING）"></a>INTPND寄存器（INTERRUPT PENDING）</h3><p>经过中断优先级仲裁器选出的优先级最高的中断后，这个中断在INTPND寄存器中的相应位被置1，随后，CPU将进入中断模式处理它。<br>同一时间内，此寄存器只有一位被置1；在ISR中，可以根据这个位确定是哪个中断。清除中断时，往这个位写1。</p>
<h3 id="INTOFFSET-寄存器（INTERRUPYT-OFFSET）"><a href="#INTOFFSET-寄存器（INTERRUPYT-OFFSET）" class="headerlink" title="INTOFFSET 寄存器（INTERRUPYT OFFSET）"></a>INTOFFSET 寄存器（INTERRUPYT OFFSET）</h3><p>这个寄存器被用来表示INTPND寄存器中哪位被置1了，即INTPND寄存器中位[X]为1时，INTOFFSET寄存器中的值为x（x为0~31）。<br>在清除SRCPND、INTPND寄存器时，INTOFFSET寄存器被自动清除。</p>
<h1 id="中断控制器操作实例：外部中断"><a href="#中断控制器操作实例：外部中断" class="headerlink" title="中断控制器操作实例：外部中断"></a>中断控制器操作实例：外部中断</h1><h2 id="按键中断代码实详解"><a href="#按键中断代码实详解" class="headerlink" title="按键中断代码实详解"></a>按键中断代码实详解</h2><p>开发板上，K1-K4四个按键所接的CPU引脚可以设成外部中断功能。本程序的main函数是一个不做任何事的无限循环，程序的功能完全靠中断来驱动：当按下某个按键时，CPU调用其中断服务程序来点亮对应的LED。</p>
<h3 id="head-S代码详解"><a href="#head-S代码详解" class="headerlink" title="head.S代码详解"></a>head.S代码详解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@******************************************************</span><br><span class="line">@File:head.S</span><br><span class="line">@功能：初始化，设置中断模式、系统模式的栈，设置好中断处理函数</span><br><span class="line">@******************************************************</span><br><span class="line"></span><br><span class="line">.<span class="keyword">extern</span> main</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">@******************************************************</span><br><span class="line">@中断向量，本程序中，除Reset和HandleIRQ外，其他异常都没有使用</span><br><span class="line">@******************************************************</span><br><span class="line">  b Reset</span><br><span class="line"></span><br><span class="line">@<span class="number">0x04</span>：未定义指令终止模式的向量地址</span><br><span class="line">HandleUndef：</span><br><span class="line">  b HandleUndef</span><br><span class="line"></span><br><span class="line">@<span class="number">0x08</span>：管理模式的向量地址，通过SWI指令进入此模式</span><br><span class="line">HandleSWI：</span><br><span class="line">  b HandleSWI</span><br><span class="line"></span><br><span class="line">@<span class="number">0x0c</span>：指令预取终止导致的异常的向量地址</span><br><span class="line">HandlePrefetchAbort：</span><br><span class="line">  b HandlePrefetchAbort</span><br><span class="line"></span><br><span class="line">@<span class="number">0x10</span>：数据访问终止导致的异常的向量地址</span><br><span class="line">HandleDataAbort：</span><br><span class="line">  b HandleDataAbort</span><br><span class="line"></span><br><span class="line">@<span class="number">0x14</span>：保留</span><br><span class="line">HandleNotUsed:</span><br><span class="line">  b HandleNotUsed</span><br><span class="line"></span><br><span class="line">@<span class="number">0x18</span>：中断模式的向量地址</span><br><span class="line">  b HandleIRQ</span><br><span class="line"></span><br><span class="line">@<span class="number">0x1c</span>：快中断模式的向量地址</span><br><span class="line">HandleFIQ：</span><br><span class="line">  b HandleFIQ</span><br></pre></td></tr></table></figure>
<p>上面7行指令所对应的地址为0x00、0x04、…、0x1C，这些地址上的指令称为“异常向量”。当发生各类异常时，CPU进入相应的工作模式，并跳转去执行它的异常向量。比如当复位时，CPU进入系统模式，并跳到0x00地址开始执行；发生中断时，CPU进入中断模式，并跳到地址0x18开始执行。<br>本程序中，只能使用“复位”和“中断”对应的异常向量，其他异常向量没有实际作用。<br>0x00地址处的指令为“b Reset”，在系统复位后，这条指令将跳去执行“Reset”开始的代码，它们完成一些初始化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reset:</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置栈指针，以下都是C函数，调用前需要设置好栈</span><br><span class="line">  bl disable_watch_dog    @关闭看门狗，否则CPU会不断重启</span><br><span class="line">  </span><br><span class="line">  msr cpsr_c,#<span class="number">0xd2</span>        @进入中断模式</span><br><span class="line">  ldr sp,=<span class="number">3072</span>            @设置中断模式栈指针</span><br><span class="line"></span><br><span class="line">  msr cpsr_c,#<span class="number">0xdf</span>        @进入系统模式</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置系统模式栈指针</span><br><span class="line">                          @其实复位之后，CPU就处于系统模式</span><br><span class="line">                          @前面的“ldr sp,=<span class="number">4096</span>”完成同样的功能，此句可省略</span><br></pre></td></tr></table></figure>
<p>第5-6行、第8-9行代码的功能相似，前者用于设置中断模式的栈指针，后者用于设置系统模式的栈指针。注意，这是尚未设完成所有初始化，所以还不能开开中断—第5、第8行代码中，CPSR中寄存器的I、F位都被设为1。第6、第9行代码中sp寄存器并不是同一个寄存器，前者为sp_irq、后者为sp_sys。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bl  init_led                  @初始化LED的GPIO管脚</span><br><span class="line">bl  init_irq                  @调用中断初始化函数，在init.c中</span><br><span class="line">msr cpsr_c, #<span class="number">0x5f</span>             @设置I-bit=<span class="number">0</span>, 开IRQ中断</span><br><span class="line"></span><br><span class="line">ldr lr, =halt_loop            @设置返回地址</span><br><span class="line">ldr pc, =main                 @调用main函数</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">  b halt_loop</span><br></pre></td></tr></table></figure>
<p>第1行调用init_led函数设置LED1-LED4这四个LED的GPIO为输出功能，第2行进行中断管脚的初始化。<br>当完成所有初始化后，第3行将CPSR寄存器中的I位设置为0，开IRQ中断。<br>标号“HandleIRQ”开始的代码用于处理中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HandleIRQ:</span><br><span class="line">  sub lr, lr,#<span class="number">4</span>                         @计算返回地址</span><br><span class="line">  stmdb sp!,  &#123;r0-r12,lr&#125;               @保存使用到的寄存器</span><br><span class="line">                                        @注意，此时的sp是中断模式的sp</span><br><span class="line">                                        @初始值是上面设置的<span class="number">3072</span></span><br><span class="line">  ldr lr, =int_return                   @设置调用ISR即EINT_Handle函数后的返回地址</span><br><span class="line">  ldr pc, =EINT_Handle                  @调用中断服务函数，在interrupt.c中。</span><br><span class="line"></span><br><span class="line">int_return:</span><br><span class="line">  ldmia sp!,  &#123;r0-r12,lr&#125;^              @中断返回,^表示将spsr的值复制到cpsr</span><br></pre></td></tr></table></figure>
<p>第2行计算处理中断处理完毕后的返回地址，lr寄存器的值等于被中断指令的地址加4，所以返回地址为lr的值减去4。<br>第3行用于保存被中断程序的运行环境，即各个寄存器。其中的sp为中断模式的栈，在上面的“ldr sp,&#x3D;3072”中初始化。这样，r0-r12,lr这14个寄存器被保存在中断模式的栈中。<br>第6行用于设置EINT_Handle函数执行完后的返回地址，这个地址为第10行指令的地址。<br>第7行调用中断服务函数EINT_Handle（代码在interrput.c中）。<br>当EINT_Handle函数处理完所发生的中断后，返回第10行的指令。它恢复前面第3行保存的各个寄存器，即恢复被中断程序的运行环境：从栈中恢复r0-r12、pc这14个寄存器的值，同时，将SPSR寄存器的值复制到CPSR（在进入中断模式时，CPU自动将原来的CPSR值保存到SPSR中），这导致CPU切换到原来的工作模式。</p>
<h3 id="init-c中与中断相关的代码详解"><a href="#init-c中与中断相关的代码详解" class="headerlink" title="init.c中与中断相关的代码详解"></a>init.c中与中断相关的代码详解</h3><p>下面详述init_irq函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化GPIO引脚作为外部中断</span></span><br><span class="line"><span class="comment">GPIO引脚用作外部中断时，默认为低电平触发、IRQ方式（不用设置INTMOD）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPFCON = GPF0_eint | GPF2_eint;</span><br><span class="line">  GPGCON = GPG3_eint | GPG11_eint;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于EINT11、EINT19，需要在EINTMASK寄存器中使能它们。</span></span><br><span class="line">  EINTMASK &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">11</span>)) &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  设定优先级：</span></span><br><span class="line"><span class="comment">  ARB_SEL0 = 00b，ARB_MODE0 = 0：REQ1 &gt; REQ3,即EINT0 &gt; EINT2</span></span><br><span class="line"><span class="comment">  仲裁器1、6无需设置</span></span><br><span class="line"><span class="comment">  最终：</span></span><br><span class="line"><span class="comment">  EINT0 &gt; EINT2 &gt; ETIN11、EINT9。即K4 &gt; K3 &gt; K1、K2</span></span><br><span class="line"><span class="comment">  EINT11 和 EINT9优先级相同</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  PRIORITY = (PRIORITY &amp; ((~<span class="number">0x01</span>) | (<span class="number">0x3</span> &lt;&lt; <span class="number">7</span>))) &amp; (<span class="number">0x0</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//EINT0、EINT2、EINT8_23使能</span></span><br><span class="line">  INTMSK  &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) &amp; (~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7、8行用于设置K1-K4对应的GPIO管脚为中断功能。使用GPIO的中断功能时，还需要确定它们的中断触发模式（低电平触发、高电平触发、下降沿触发、上升沿触发）。我们默认使用低电平触发，无需额外设置。<br>第11行在EINTMASK寄存器中开启EINT19、EINT11中断，它们对应的K1、K2。K3、K4对应的EINT2、EINT10不受EINTMASK寄存器控制。EINTMASK可以屏蔽的中断可以参考数据手册。<br>第21行用于设置中断优先级。本开发板中，外部中断EINT9、EINT11、EINT2和EINT0分别对应K1、K2、K3和K4四个按键。EINT0、EINT2被接到仲裁器0的REQ1、REQ3，程序中设置ARB_SEL0为0（即0b00），所以REQ1的优先级高于REQ3，即K4的优先级高于K3。程序中设置ARB_MODE0为0，所以仲裁器0中各优先级保持不变。EINT8-EINT23共用仲裁器1的REQ1，所以EINT11和EINT9的中断优先级相同。仲裁器0、1的输出接到仲裁器6的REQ0、REQ1，而仲裁器中REQ0的优先级总是高于REQ1，所以这4个按键的优先级：K4 &gt; K3 &gt; K1、K2。<br>本程序使用的GPIO的默认中断方式—IRQ，不是FIQ，所以不用设置INTMOD寄存器。<br>最后，第24行将INTMSK寄存器中EINT0、EINT2、EINT8_23这3个中断对应的位设为0，使能中断。但是仍未完全开启中断，head.S中的“msr cpsr_c, #0x5f”才打开了最后一个开关。</p>
<h3 id="interrupt-c中的中断处理函数"><a href="#interrupt-c中的中断处理函数" class="headerlink" title="interrupt.c中的中断处理函数"></a>interrupt.c中的中断处理函数</h3><p>上面说明了中断的初始化、中断的进入与退出。真正的处理函数为EINT_Handle，它被称为中断服务程序（ISR），代码在interrupt.c中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EINT_Handle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> oft = INTOFFSET;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(oft)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//K4被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |= (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//所有LED灯熄灭</span></span><br><span class="line">      GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);         <span class="comment">//LED4点亮</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//K3被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |= (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//所有LED灯熄灭</span></span><br><span class="line">      GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);         <span class="comment">//LED3点亮</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//K1或K2被被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |=  (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);      <span class="comment">//所有LED熄灭</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//需要进一步判断是K1还是K2被按下，或者K1、K2被同时按下</span></span><br><span class="line">      val = EINTPEND;</span><br><span class="line">      <span class="keyword">if</span>(val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>))</span><br><span class="line">        GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);       <span class="comment">//K2被按下，LED2点亮</span></span><br><span class="line">      <span class="keyword">if</span>(val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">19</span>))</span><br><span class="line">        GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//K1被按下，LED1点亮</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清除中断</span></span><br><span class="line">  <span class="keyword">if</span>(oft == <span class="number">5</span>)</span><br><span class="line">    EINTPEND = (<span class="number">1</span> &lt;&lt; <span class="number">11</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">19</span>);   <span class="comment">//EINT8-EINT23合用IRQ5</span></span><br><span class="line">  SRCPND = <span class="number">1</span> &lt;&lt; oft;</span><br><span class="line">  INTPND = <span class="number">1</span> &lt;&lt; oft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要关注中断的识别与清除，其余代码根据所识别出来的中断（按键）点亮对应的LED。第5行用来读取INTOFFSET寄存器，它的值被用来标识INTPND寄存器中哪位被设为1。此值为0是表示INTPND寄存器的位[0]为1，即EINT0中断发生了，说明K4被按下；此值为2时表示INTPND寄存器的位[2]为1，即EINT2中断发生了，说明按键K3被按下；此值为5时表示INTPND寄存器的位[5]为1，即EINT8-EINT23中至少一个中断发生了，在本程序中这表明K1、K2中至少按下了一个，至于是哪一个，需要进一步判断。<br>第27行用来读取EINTPEND寄存器，它的位x为1时，表示EINTx已经发生了（x为4-23）。本程序就是通过读取EINTPEND寄存器的值来进一步判断EINT11还是EINT19发生了，即是K1还是K2按下了。<br>第45行用于清除EINTPEND寄存器，往某位写入1即可清除此位。<br>第46、47行用于清除SRCPND、INTPND寄存器。</p>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>程序的主函数很简单，在main.c中，只是个不做任何事情的无限循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图演示了代码的运行过程，注意PC和SP寄存器的变化：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第9章 中断体系结构</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>系统时钟和定时器</title>
    <url>/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第10章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440的时钟体系结构</li>
<li>掌握通过设置MPLL改变系统时钟的方法</li>
<li>掌握在不同频率下设置存储控制器的方法</li>
<li>掌握PWM定时器的用法</li>
<li>了解WATCHDOG定时器的用法</li>
</ol>
<h1 id="时钟体系以及各类时钟部件"><a href="#时钟体系以及各类时钟部件" class="headerlink" title="时钟体系以及各类时钟部件"></a>时钟体系以及各类时钟部件</h1><h2 id="S3C2410-x2F-S3C2440时钟体系"><a href="#S3C2410-x2F-S3C2440时钟体系" class="headerlink" title="S3C2410&#x2F;S3C2440时钟体系"></a>S3C2410&#x2F;S3C2440时钟体系</h2><p>S3C2410&#x2F;S3C2440的时钟控制逻辑既可以外接晶振，然后通过内部电路产生时钟源；也可以直接使用外部提供的时钟源，它们通过引脚的设置来选择。时钟控制逻辑给整个芯片提供了3种时钟。FCLK用于CPU核，HCLK用于AHB总线上的设备，比如CPU核、存储控制器、中断控制器、LCD控制器、DMA和USB主机模块等，PCLK用于APB总线上的设备，比如WATCHDOG、IIS、IIC、PWM定时器、MMC接口、ADC、UART、GPIO、RTC、SPI。<br>AHB（Advanced High performance Bus）总线主要用于高性能模块（CPU、DMA和DSP等）之间的连接；APB（Advanced Peripheral Bus）总线主要用于低带宽的周边外设之间的连接，例如UART，IIC等。<br>S3C2410核的工作电压为1.8V时，主频可达200MHz；工作电压为2.0V，主频可达266MHz。S3C2440核的工作电压为1.2V时，主频可达300MHz；工作电压为1.3V时，主频可达300MHz。为了降低电磁干扰，降低板间布线的要求，S3C2410&#x2F;S3C2440外接晶振的频率一般很低，本开发板上的为12MHz，需要通过时钟控制逻辑的PLL提高系统时钟。<br>S3C2410&#x2F;S3C2440有两个PLL，MPLL和UPLL。UPLL专用于USB设备，MPLL用于设置FCLK、HCLK、PCLK。它们的设置方式类似。以MPLL为例。<br>上电时，PLL没启动，FCLK即等于外部输入的时钟，称为Fin。若要提高系统时钟，需要软件来启动PLL。结合下图来介绍PLL的设置过程。<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/1.jpeg" alt="img not found"></p>
<ol>
<li>上电几毫秒后，晶振（图中的OSC）输出稳定，FCLK&#x3D;Fin（晶振频率），nRESET信号恢复高电平之后，CPU开始执行指令。</li>
<li>可以在程序开头启动MPLL，设置MPLL的几个寄存器之后，需要等待一段时间（Lock Time），MPLL的输出才稳定。这段时间（Lock Time）内，FCLK停振，CPU停止工作。Lock Time的长短由寄存器LOCKTIME设定。</li>
<li>Lock Time之后，MPLL的输出才稳定，CPU工作在新的FCLK下。</li>
</ol>
<p>FCLK、HCLK、PCLK的比例是可以改变的，设置它们三者的比例，启动MPLL只需要设置3个寄存器。</p>
<ol>
<li>LOCKTIME寄存器（LOCK TIME COUNT），用于设置“Lock Time”的长度。<br>MPLL启动后需要等待一段时间（Lock Time），使得其输出稳定。S3C2410中，位[23:12]用于UPLL，位[11:0]用于MPLL。S3C2440中，位[31:16]用于UPLL，位[15:0]用于MPLL。一般而言。使用它的默认值即可，S3C2410中默认值为0x00FFFFFF，S3C2440中的默认值为0xFFFFFFFF。</li>
<li>MPLLCON寄存器（Main PLL Control），用于设置FCLK与Fin的倍数，<br>位[19:12]的值称为MDIV，位[9:4]的值称为PDIV，位[1:0]的值称为SDIV。FCLK与Fin的关系有如下计算公式：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于S3C2410</span></span><br><span class="line">MPLL（FCLK） = （m*Fin）/(p*<span class="number">2</span>^s)</span><br><span class="line">其中：m = MDIV + <span class="number">8</span>，p = PDIV + <span class="number">2</span>,s = SDIV。</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于S3C2440</span></span><br><span class="line">MPLL（FCLK） = （<span class="number">2</span>*m*Fin）/(p*<span class="number">2</span>^s)</span><br><span class="line">其中：m = MDIV + <span class="number">8</span>，p = PDIV + <span class="number">2</span>,s = SDIV。</span><br></pre></td></tr></table></figure>
设置MPLLCON就相当于之前图中说的“首先使用软件来设置PLL”，Lock Time就被自动插入。Lock Time之后，MPLL输出稳定，CPU工作在新的FCLK下。</li>
<li>CLKDIVN寄存器（CLOCK DIVIDER CONTROL），用于设置FCLK、HCLK、PCLK三者的比例。<br>对于S3C2410、S3C2440这个寄存器表现稍有不同<table>
<thead>
<tr>
<th>CLKDIVN</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HDIVN1</td>
<td>2</td>
<td>0表示保留，1表示FCLK：HCLK：PCLK&#x3D;1：4：4，此时HDIVN、PDIVN必须设为0b00</td>
</tr>
<tr>
<td>HDIVN</td>
<td>1</td>
<td>HCLK的分频系数，0-HCLK&#x3D;FCLK，1-HCLK&#x3D;FCLK&#x2F;2</td>
</tr>
<tr>
<td>PDIVN</td>
<td>0</td>
<td>PCLK的分频系数，0-PCLK&#x3D;HCLK，1-PCLK&#x3D;HCLK&#x2F;2</td>
</tr>
</tbody></table>
</li>
</ol>
<p>对于S3C2440的一些时钟比例，还需要额外设置一个寄存器CAMDIVN。下图中，HDIVN为CLKDIVN寄存器的位[2:1]，PDIVN为位[0]；HCLK4_HALF、HCLK3_HALF分别为CAMDIVN寄存器的位[9]、[8]。各种时钟比例对应的寄存器设置如下图所示：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/2.jpeg" alt="img not found"><br>对于S3C2410，HDIVN是CLKCIVN寄存器的位[1]，对于S3C2440，HDIVN是CLKDIVN寄存器的位[2:1]。如果HDIVN非0，CPU的总线模式应该从“fast bus mode”变为“asynchronous bus mode”，这可以通过如下指令来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#MMU_SetAsyncBusMode</span><br><span class="line">mrc p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line">orr r0,r0,#R1_nF:OR:R1_iA</span><br><span class="line">mcr p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>其中的“#R1_nF:OR:R1_iA”等于0xC0000000。如果HDIVN非0时，而CPU的总线模式仍是“fast bus mode”，则CPU的工作频率将自动变为HCLK，而不再是FCLK。</p>
<h2 id="PWM定时器"><a href="#PWM定时器" class="headerlink" title="PWM定时器"></a>PWM定时器</h2><p>S3C2410&#x2F;S3C2440的定时器部件完全一样，共有5个16位的定时器。其中定时器0、1、2、3有PWM（Pulse Width Modulation）功能，即它们都只有一个输出引脚，可以通过定时器来控制引脚周期性的高低电平变化；定时器4没有输出引脚。<br>定时器部件的时钟源为PCLK，首先通过两个8位的预分频器降低频率：定时器0、1共用第一个预分频器，定时器2、3、4共用第一个预分频器。预分频器的输出将进入第二级分频器。它们输出5种频率的时钟，2、4、8、16分频或者外部时钟TCLK0&#x2F;TCLK1。每个定时器的工作时钟可以从这5种频率中选择。<br>两个预分频都可以通过TCFG0寄存器来设置，每个定时器工作在哪个频率下也可以通过TCFG1寄存器来选择。下图形象的说明了定时器的结构：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/3.jpeg" alt="img not found"><br>上面只是确定了定时器的工作频率，至于定时器如何工作还得了解其内部结构。定时器内部控制逻辑的工作流程如下：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/4.jpeg" alt="img not found"></p>
<ol>
<li>程序初始化，设定TCMPBn、TCNTBn这两个寄存器，它们表示定时器n的比较值，初始计数值。</li>
<li>随之设置TCON寄存器启动定时器n，这时，TCMPBn、TCNTBn的值将被装入其内部寄存器TCMPn、TCNTn中。在定时器n的工作频率下，TCNTn开始减1计数，其值可以通过读取TCNTOn寄存器得知。</li>
<li>当TCNTn的值等于TCMPn的值时，定时器n的输出管脚TOUTn反转；TCNTn继续减1计数。</li>
<li>当TCNTn的值到达0时，其输出管脚TOUTn再次反转，并触发定时器n的中断（如果使能了中断的话）。</li>
<li>当TCNTn的值到达0时，如果在TCON寄存器中将定时器n设为自动加载，则TCMPB0和TCNTB0寄存器的值被自动装入TCMP0和TCNT0寄存器中，下一个计数流程开始。<br>定时器n的输出管脚TOUTn初始状态为高电平，以后在TCNTn的值等于TCMPn的值、TCNTn的值时反转。也可以通过TCON寄存器设置其初始电平，这样TOUTn的输出就完全反相了。通过设置TCMPBn、TCNTBn的值可以设置管脚TOUTn输出信号的占空比，这就是所谓的可调制脉冲（PWM），所以这些定时器就可以称为PWM定时器。</li>
</ol>
<p>定时器的寄存器：</p>
<ol>
<li>TCFG0寄存器（TIMER CONTFIGURATION）<br>位[7:0]、位[15:8]分别用来控制预分频器0、1。它们的值为0-255。经过预分频器出来的时钟频率为PCLK&#x2F;{prescaler value + 1}。</li>
<li>TCFG1寄存器（TIMER CONTFIGURATION）<br>经过预分频器的得到的时钟将被2分频、4分频、8分频和16分频，除这4种频率外，额外的，定时器0、1还可以工作在外接的TCLK0时钟下，定时器2、3、4还可以工作在外接的TCLK1时钟下。<br>通过TCFG1寄存器来设置这5个定时器，分别工作于这5个频率的哪一个之下，如下表所示：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/4.jpeg" alt="img not found"><br>这样，定时器n的工作频率或者是外接的TCLK0或TCLK1可通过这个公式进行计算：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定时器工作频率 = PCLK / &#123;presacaler value + 1&#125; / &#123;divider value&#125;</span><br><span class="line">&#123;prescaler value&#125; = 0-255</span><br><span class="line">&#123;divider value&#125; = 2,4,8,16</span><br></pre></td></tr></table></figure></li>
<li>TCNTBn&#x2F;TCMPBn寄存器（COUNT BUFFER REGISTER &amp; COMPARE BUFFER REGISTER）<br>n为0-4，这四个寄存器都只用到位[15:0],TCNTBn中保存定时器的初始计数值，TCMPBn中保存比较值。它们的值在启动定时器时，被传到定时器内部寄存器TCNTn、TCMPn中。<br>没有TCMPB4因为定时器4没有输出引脚。</li>
<li>TCNTOn寄存器（COUNT OBSERVATION）。<br>n为0-4，定时器n被启动后，内部寄存器TCNTn在其工作时钟下不断减1计数，可以通过读取TCNTOn寄存器得知其值。</li>
<li>TCON寄存器（TIMER CONTROL）。<br>它有以下4个作用:<ol>
<li>第一次启动定时器时“手动”将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中。</li>
<li>启动、停止定时器。</li>
<li>决定在定时器计数到达0时是否自动将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中。</li>
<li>决定定时器的管脚TOUTn的输出电平是否反转。<br>TCON寄存器位[3:0]、位[11:8]、位[15:12]、位[19:16]、位[22:20]分别用于定时器0-4。除定时器因为没有输出引脚在没有“输出反转”位外，其他位的功能相似，下表以定时器0为例说明这些寄存器：<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>开启&#x2F;停止</td>
<td>0</td>
<td>0：停止定时器  1：开启定时器</td>
</tr>
<tr>
<td>手动更新</td>
<td>1</td>
<td>0：无用  1：将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中</td>
</tr>
<tr>
<td>输出反转</td>
<td>2</td>
<td>0：TOUT0不反转  1：TOUT0反转</td>
</tr>
<tr>
<td>自动加载</td>
<td>3</td>
<td>0：不自动加载   1：在定时器计数达到0时，TCNTBn&#x2F;TCMPBn寄存器的值自动装入内部寄存器TCNTn、TCMPn中</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<p>第一次使用定时器时，需要设置“手动更新”位为1以使TCNTBn&#x2F;TCMPBn寄存器的值装入TCNTn、TCMPn中。下一次如果还要设置这一位，需要先将它清0。</p>
<h2 id="WATCHDOG-定时器"><a href="#WATCHDOG-定时器" class="headerlink" title="WATCHDOG 定时器"></a>WATCHDOG 定时器</h2><p>WATCHDOG定时器可以像一般16位定时器一样用于产生周期性的中断，也可以用于发出复位信号以重启失常的系统。它与PWM定时器结构类似。<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/6.jpeg" alt="img not found"><br>同样的，WATCHDOG定时器的8位预分频器将PCLK分频后，将再次分频得到4种频率。16、32、64、128分频。WATCHDOG 定时器可以选择工作于哪种频率之下。WTCNT寄存器按照其工作频率减1计数，当达到0时，可以产生中断信号，可以输出复位信号。在第一次使用WATCHDOG 定时器时，需要往WTCNT寄存器中写入初始计数值，以后在计数值达到0时自动从WATDAT寄存器中装入，重新开始下一个计数周期。<br>使用WATCHDOG 定时器的“WATCHDOG 功能”时，在正常的程序中，必须不断重新设置WTCNT寄存器使得它不为0，这样可以保证系统不被重启，称为“喂狗”。当程序崩溃时不能正常喂狗，计数值达到0后系统将被重启，这样程序将程序运行。为了克服各种干扰、避免各类系统错误时系统彻底死机，经常使用WATCHDOG 功能。<br>WATCHDOG 定时器涉及到的寄存器如下：</p>
<ol>
<li>WTCON寄存器（WATCHDOG TIMER CONTROL）<br>用于设置预分频系数，选择各种频率，决定是否使能中断，是否启用WATCHDOG 功能（即是否输出复位信号）。<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WATCHDOG功能</td>
<td>0</td>
<td>当定时器达到0时，0：不输出复位信号  1：输出复位信号</td>
</tr>
<tr>
<td>中断使能</td>
<td>1</td>
<td>0：禁止中断  1：使能中断</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[4:3]</td>
<td>选择分频系数  0b00：16  0b01：32 0b10：64 0b11：128</td>
</tr>
<tr>
<td>定时器启动</td>
<td>5</td>
<td>0：停止  1：启动</td>
</tr>
<tr>
<td>预分频系数</td>
<td>[15:8]</td>
<td>预分频系数：0-255</td>
</tr>
</tbody></table>
</li>
</ol>
<p>与PWM定时器相似，WATDOG定时器的工作频率可以通过这公式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WATDOG定时器工作频率=PCLK/&#123;presacler value + 1&#125;/&#123;divider value&#125;</span><br><span class="line">&#123;prescaler value&#125; = 0-255</span><br><span class="line">&#123;divider value&#125; = 16,32,64,128</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>WTDAT寄存器（WATCHDOG TIMER DATA）<br>WTDAT寄存器被用来决定WATCHDOG定时器的超时周期，在定时器启动后，当计数达到0时，WTDAT寄存器的值会自动传入WTCNT寄存器。不过，第一次启动WATCHDOG定时器时，WTDAT寄存器的值会自动传入WTCNT寄存器。</li>
<li>WTCNT寄存器（WATCHDOG TIMER COUNT）<br>在启动WATCHDOG前，必须往这个寄存器写入初始计数值。启动定时器后，它减1计数，当计数值达到0时：如果中断被使能的话发出中断，如果WATCHDOG功能被使能的话就发出复位信号，装载WTDAT寄存器的值并重新计数。</li>
</ol>
<h1 id="MPLL和定时器操作实例"><a href="#MPLL和定时器操作实例" class="headerlink" title="MPLL和定时器操作实例"></a>MPLL和定时器操作实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例讲解MPLL、定时器的使用。首先启动MPLL提高系统时钟，初始化存储控制器使SDRAM工作在新的HCLK下，然后将定时器0设为0.5s产生一次中断，在中断程序里改变LED的状态。</p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>4个关键点：设置&#x2F;启动MPLL、根据HCLK设置存储控制器、初始化定时器0、定时器中断。</p>
<h3 id="设置-x2F-启动MPLL"><a href="#设置-x2F-启动MPLL" class="headerlink" title="设置&#x2F;启动MPLL"></a>设置&#x2F;启动MPLL</h3><p>clock_init函数用于设置MPLL，本开发板的输入时钟频率Fin为12MHz，将FCLK、HCLK、PCLK分别设为200MHz、100MHz和50MHz。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_MPLL_200MHZ ((0x5C &lt;&lt; 12) | (0x04 &lt;&lt; 4) | (0x00))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_MPLL_200MHZ ((0x5C &lt;&lt; 12) | (0x01 &lt;&lt; 4) | (0x02))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于MPLLCON寄存器，[19:12]为MDIV，[9:4]为PDIV，[1:0]为SDIV</span></span><br><span class="line"><span class="comment">有如下计算公式：</span></span><br><span class="line"><span class="comment">S3C2410：MPLL（FCLK） = （m*Fin）/ (p*2^s)</span></span><br><span class="line"><span class="comment">S3C2440：MPLL（FCLK） = （2*m*Fin）/ (p*2^s)</span></span><br><span class="line"><span class="comment">其中 m = MDIV + 8，p = PDIV + 2,s = SDIV。</span></span><br><span class="line"><span class="comment">本开发板Fin = 12MHz</span></span><br><span class="line"><span class="comment">设置CLKDIVN，令分频比为FCLK：HCLK：PCLK=1：2：4</span></span><br><span class="line"><span class="comment">FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LOCKTIME = 0x00ffffff;                   //使用默认值即可</span></span><br><span class="line">    CLKDIVN = <span class="number">0x03</span>;                             <span class="comment">//FCLK：HCLK：PCLK=1：2：4  HDIVN = 1,PDIVN = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果HDIVN非0，CPU的总线模式应该从“fast bus mode”变为“asynchronous bus mode”</span></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mrc p15,0,r1,c1,c0,0\n&quot;</span>                <span class="comment">//读出控制寄存器</span></span><br><span class="line">        <span class="string">&quot;orr r1,r1,#0xc0000000\n&quot;</span>               <span class="comment">//设置为“asynchronous bus mode”</span></span><br><span class="line">        <span class="string">&quot;mcr p15,0,r1,c1,c0,0\n&quot;</span>                <span class="comment">//写入控制寄存器</span></span><br><span class="line">    ); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是S3C2410还是S3C2440</span></span><br><span class="line">    <span class="keyword">if</span>((GSTATUS1 == <span class="number">0x3241000</span>) || (GSTATUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        MPLLCON = S3C2410_MPLL_200MHZ;          <span class="comment">//FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        MPLLCON = S3C2440_MPLL_200MHZ;          <span class="comment">//FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第17行设置FCLK、HCLK、PCLK三者分频比为1：2：4。<br>当HDIVN非0时，需要将CPU总线模式从“fast bus mode”设为“asynchronous bus mode”，第21-23行的汇编代码即完成此事。<br>第27-34行代码判断芯片是S3C2410还是S3C2440，它们的MPLL计算公式稍有不同，需要区分开来。如果处理器为S3C2410，使用第29行设置MPLL寄存器，令MDIV&#x3D;0x5C，PDIV&#x3D;0x04，SDIV&#x3D;0，所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MPLL(FCLK)=(m * Fin)/(p * 2 ^ s) = (0x5c + 8)*12MHz / ((0x04+2)*2^0) = 200MHz</span><br><span class="line">HCLK = FCLK / 2 = 100MHz</span><br><span class="line">PCLK = FCLK / 4 = 50MHz</span><br></pre></td></tr></table></figure>
<p>类似的，S3C2440的FCLK &#x3D; 200MHz，HCLK &#x3D; 100MHz，PCLK &#x3D; 50MHz。</p>
<h3 id="设置存储控制器"><a href="#设置存储控制器" class="headerlink" title="设置存储控制器"></a>设置存储控制器</h3><p>memsetup函数被用来设置存储控制器，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用存储控制器以使用SDRAM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memsetup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)MEM_CTL_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个函数之所以这样赋值，而不是像前面的实验（MMU）那样将配置值写在数组中，是因为要生成位置无关的代码，使得这个函数可以被复制到SDRAM之前就可以在Steppingstone中运行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*存储控制器13个寄存器的值*/</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0x22011110</span>;                  <span class="comment">//BWSCON</span></span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON0</span></span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON1</span></span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON2</span></span><br><span class="line">    p[<span class="number">4</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON3</span></span><br><span class="line">    p[<span class="number">5</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON4</span></span><br><span class="line">    p[<span class="number">6</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON5</span></span><br><span class="line">    p[<span class="number">7</span>] = <span class="number">0x00018005</span>;                  <span class="comment">//BANKCON6</span></span><br><span class="line">    p[<span class="number">8</span>] = <span class="number">0x00018005</span>;                  <span class="comment">//BANKCON7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    REFRESH,</span></span><br><span class="line"><span class="comment">    HCLK = 12MHz:0x008C07A3</span></span><br><span class="line"><span class="comment">    HCLK = 100MHz:0x008C04F4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    p[<span class="number">9</span>] = <span class="number">0x008C04F4</span>;                  </span><br><span class="line">    p[<span class="number">10</span>] = <span class="number">0x000000B1</span>;                  <span class="comment">//BANKSIZE</span></span><br><span class="line">    p[<span class="number">11</span>] = <span class="number">0x00018030</span>;                  <span class="comment">//MRSRB6</span></span><br><span class="line">    p[<span class="number">12</span>] = <span class="number">0x00018030</span>;                  <span class="comment">//MRSRB7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在HCLK的值等于100MHz，REFRESH寄存器的值需要重新计算。<br>R_CNT &#x3D; 2^11 + 1 - 100MHz * 7.8125μS &#x3D; 0x04F4，所以REFRESH &#x3D; 0x008C0000 + R_CNT &#x3D; 0x008C0000 + 0x04F4 &#x3D; 0x008C04F4。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REFRESH = 0x008c0000 + R_CNT</span><br><span class="line">R_CNT = 2 ^ 11 + 1 - SDRAM时钟频率（MHz） * SDRAM刷新周期（μS）</span><br></pre></td></tr></table></figure>
<p>对于第12到第20行为何用这么笨拙的方式设置存储控制器的13个寄存器，在连接脚本timer.lds中，全部代码的起始运行地址都被设为0x30000000，但是在执行memsetup函数时，代码仍在SRAM（Steppingstone）中，为了能够在Steppingstone中运行这个函数，它应该是位置无关的代码，而第12到第20行得手工赋值可以达到这个要求。</p>
<h3 id="初始化定时器0"><a href="#初始化定时器0" class="headerlink" title="初始化定时器0"></a>初始化定时器0</h3><p>tiemr0_init函数用于初始化定时器0，根据相关寄存器的格式并参考代码中的注释就可以理解这个函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Timer input clock Frequence = PCLK / &#123;prescaler value + 1&#125;/&#123;divider value&#125;</span></span><br><span class="line"><span class="comment">&#123;prescaler value&#125; = 0-255</span></span><br><span class="line"><span class="comment">&#123;divider value&#125; = 2,4,8,16</span></span><br><span class="line"><span class="comment">本实验的Timer0的时钟频率=100MHz/(99 + 1)/(16) = 62500Hz</span></span><br><span class="line"><span class="comment">设置Timer0 0.5s触发一次中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCFG0 = <span class="number">99</span>;                 <span class="comment">//预分频器0 = 99</span></span><br><span class="line">    TCFG1 = <span class="number">0x03</span>;               <span class="comment">//选择16分频</span></span><br><span class="line">    TCNB0 = <span class="number">31250</span>;              <span class="comment">//0.5s触发一次中断</span></span><br><span class="line">    TCON |= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);           <span class="comment">//手动更新</span></span><br><span class="line">    TCON = <span class="number">0x09</span>;                <span class="comment">//自动加载，清除“手动更新位”，启动定时器0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h3><p>head.S中调用timer0_init函数之后，定时器0即开始工作；调用init_irq函数使能定时器0中断，设置CPSR寄存器开启IRQ中断之后，每当定时器0达到0就会触发中断。init_irq函数很简单，在init.c中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定时器0中断使能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定时器0中断使能</span></span><br><span class="line">    INTMSK &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生定时器中断时，CPU将调用其中断服务程序Timer0_Handle,它在interrupt.c中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Handle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每次中断令4个LED改变状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(INTOFFSET == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPBDAT = ~(GPBDAT &amp; (<span class="number">0xf</span> &lt;&lt; <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清除中断</span></span><br><span class="line">    SRCPND = <span class="number">1</span> &lt;&lt; INTOFFSET;</span><br><span class="line">    INTPND = INTPND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器0的中断使用SRCPND、INTPND寄存器中的位10来表示。中断服务程序Timer0_Handle先判断是否定时器0的中断，若是则反转4个LED的状态。</p>
<h3 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h3><p>编译生成的bin文件烧入NAND Flash后，上电运行，即可看到4个LED每1S闪烁一次。<br>将head.S中对clock_init函数的调用去掉，不启用MPLL，并随之将init.c中的memesetup函数的REFRESH寄存器改为12MHz对应的0x008C07A3。重新编译、烧写。可以看到差不多8S这4个LED才闪烁一次。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第10章 系统时钟和定时器</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>时钟</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC</title>
    <url>/2022/08/25/IIC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第12章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解IIC总线协议</li>
<li>掌握S3C2410&#x2F;S3C2440中IIC的使用方法</li>
</ol>
<h1 id="IIC总线协议及硬件介绍"><a href="#IIC总线协议及硬件介绍" class="headerlink" title="IIC总线协议及硬件介绍"></a>IIC总线协议及硬件介绍</h1><h2 id="IIC总线协议"><a href="#IIC总线协议" class="headerlink" title="IIC总线协议"></a>IIC总线协议</h2><h3 id="IIC总线的概念"><a href="#IIC总线的概念" class="headerlink" title="IIC总线的概念"></a>IIC总线的概念</h3><p>IIC（Inter-Integrated Circuit）总线是一种由PHILIPS公司开发的串行总线，用于连接微控制器及其外围设备。</p>
<ol>
<li>只有两条总线线路：一条串行数据线（SDA），一条串行时钟线（SCL）。</li>
<li>每个连接到总线的器件都可以使用软件根据它的唯一地址来识别。</li>
<li>传输数据的设备间是简单的主从关系。</li>
<li>主机可以用作主机发送器或主机接收器。</li>
<li>它是一个真正的多主机总线，两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏。</li>
<li>串行的8位双向数据传输，位速率在标准模式下可达100kbit&#x2F;s，在快速模式下可达400kbit&#x2F;s，在高速模式下可达3.4Mbit&#x2F;s。</li>
<li>片上的滤波器可以增加抗干扰功能，保证数据的完整。</li>
<li>连接到同一总线上的IC数量只受到总线最大电容400pF的限制。</li>
</ol>
<p>下图是一条IIC总线多个设备相连的例子：<br><img src="/2022/08/25/IIC/1.jpeg" alt="img not found"></p>
<p>一些术语如下表：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>发送器</td>
<td>发送数据到总线的器件</td>
</tr>
<tr>
<td>接收器</td>
<td>从总线接收数据的器件</td>
</tr>
<tr>
<td>主机</td>
<td>发起&#x2F;停止数据传输、提供时钟信号的器件</td>
</tr>
<tr>
<td>从机</td>
<td>被主机寻址的器件</td>
</tr>
<tr>
<td>多主机</td>
<td>可以有多个主机试图去控制总线，但是不会破坏数据</td>
</tr>
<tr>
<td>仲裁</td>
<td>当多个主机试图去控制总线时，通过仲裁可以使得只有一个主机获得总线控制权，并且它传输的信息不会被破坏</td>
</tr>
<tr>
<td>同步</td>
<td>多个器件同步时钟信号的过程</td>
</tr>
</tbody></table>
<h3 id="IIC总线的信号类型"><a href="#IIC总线的信号类型" class="headerlink" title="IIC总线的信号类型"></a>IIC总线的信号类型</h3><p>IIC总线在传送数据的过程中共有3种类型信号：开始信号、结束信号和响应信号。</p>
<ol>
<li>开始信号（S）：SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据。</li>
<li>结束信号（P）：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。</li>
<li>响应信号（ACk）：接收器在接收到8位数据之后，在第9个时钟周期，拉低SDA电平。</li>
</ol>
<p>它们的波形如下图：<br><img src="/2022/08/25/IIC/2.jpeg" alt="img not found"></p>
<p>SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化，如下图所示：<br><img src="/2022/08/25/IIC/3.jpeg" alt="img not found"></p>
<h3 id="IIC总线的数据传输格式"><a href="#IIC总线的数据传输格式" class="headerlink" title="IIC总线的数据传输格式"></a>IIC总线的数据传输格式</h3><p>发送到SDA线上的每个字节必须是8位的，每次传输可以发送的字节数量不受限制。每个字节后必须跟一个响应位。首先传输的是数据的最高位。如果从机要完成一些其他功能后（例如一个内部中断程序）才能继续接收或发送下一个字节，从机可以拉低SCL迫使主机进入等待状态。当从机准备好接收下一个数据并释放SCL后，数据继续传输。如果主机在传输数据期间也需要完成一些其他功能（例如一个内部中断程序）也可以拉低SCL以占住总线。<br>启动一个传输时，主机发出S信号，然后发出8位数据。这8位数据中前7位为从机的地址，第8位表示传输的方向（0表示写操作，1表示读操作）。被选中的从机发出响应信号。紧接着传输一系列字节及其响应位。最后，主机发出P信号结束本次传输。<br>下图是IIC数据传输的3种类型读、写、读写转换：<br><img src="/2022/08/25/IIC/4.jpeg" alt="img not found"></p>
<p>并非每传输8位之后就会由ACK信号，以下3种例外：</p>
<ol>
<li>当主机不能响应从机地址时（例如它正忙着其他事情而无法响应IIC总线的操作，或者这个地址没有对应的主机），在第9个SCL周期内SDA线没有被拉低，即没有ACK信号。这时，主机发出一个P信号终止传输或者重新发出一个S信号开始新的传输。</li>
<li>如果从机接收器在传输过程中不能接收更多数据时，它也不会发出ACK信号。这样，主机就可以意识到这点，从而发出一个P信号终止传输或者重新发出一个S信号开始新的传输。</li>
<li>主机接收器在接收到最后一个字节后，也不会发出ACK信号，于是，从机发送器释放SDA线，以允许主机发出P信号结束传输。</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-IIC-总线控制器"><a href="#S3C2410-x2F-S3C2440-IIC-总线控制器" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线控制器"></a>S3C2410&#x2F;S3C2440 IIC 总线控制器</h2><h3 id="S3C2410-x2F-S3C2440-IIC-总线控制器介绍"><a href="#S3C2410-x2F-S3C2440-IIC-总线控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线控制器介绍"></a>S3C2410&#x2F;S3C2440 IIC 总线控制器介绍</h3><p>S3C2410&#x2F;S3C2440 IIC 接口有4种工作模式：主机发送器、主机接收器、从机发送器、从机接收器。其内部结构如下图所示：<br><img src="/2022/08/25/IIC/5.jpeg" alt="img not found"><br>S3C2410&#x2F;S3C2440提供4个寄存器来完成所有的IIC操作，SDA线上的数据从IICDS寄存器发出，或传入IICDS寄存器中；IICADD寄存器中保存S3C2410&#x2F;S3C2440当作从机的地址：IICCON、IICSTAT两个寄存器用来控制或标识各种各种状态，比如选择工作模式，发出S信号，P信号，决定是否发出ACK信号，检测是否收到ACK信号。寄存器的用法如下：</p>
<ol>
<li>IICCON寄存器（Multi-master IIC-bus control）<br>IICCON寄存器用于控制是否发出ACK信号、设置发送器的时钟、开启IIC中断，并标识中断是否发生。<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACK信号使能</td>
<td>[7]</td>
<td>0 &#x3D; 禁止 1 &#x3D; 使能 <br> 在发送模式，此位无意义 <br> 在接收模式，此位使能时，SDA线在响应周期内将被拉低，即发出ACK信号</td>
</tr>
<tr>
<td>发送模式时钟源选择</td>
<td>[6]</td>
<td>0 &#x3D; IICCLK 为PCLK&#x2F;6，1 &#x3D; IICCLK为PCLK&#x2F;512</td>
</tr>
<tr>
<td>发送&#x2F;接收中断使能</td>
<td>[5]</td>
<td>0 &#x3D; IIC总线 Tx&#x2F;Rx中断使能 <br> 1 &#x3D; IIC总线 Tx&#x2F;Rx中断使能</td>
</tr>
<tr>
<td>中断标记</td>
<td>[4]</td>
<td>此位用来标识是否有IIC中断发生，读出为0时表示没有中断发生，读出为1时表示有中断发生。当此位为1时，SCL线被拉低，此时所有IIC传输停止：如果需要继续传输，需写入0清除它</td>
</tr>
<tr>
<td>发生模式时钟分频系数</td>
<td>[3:0]</td>
<td>发送器时钟&#x3D;IICCLK&#x2F;(IICCON[3:0] + 1)</td>
</tr>
</tbody></table>
</li>
</ol>
<p>使用IICCON寄存器时，有如下注意事项：<br>①发送模式的时钟频率由位[6]、位[3:0]联合决定。另外，当IICCON[6]&#x3D;0时，IICCON[3:0]不能取0或1。<br>②IIC中断在以下3种情况下发生：当发出地址信息或者接收到一个从机地址并且吻合时，当总线仲裁失败时，当发送&#x2F;接收完一个字节的数据（包括ACK）时。<br>③基于SDA、SCL线上时间特性的考虑，要发送数据时，先将数据写入IICDS寄存器，然后再清除中断。<br>④如果IICCON[5] &#x3D; 0，IICCON[4]将不能正常工作。所以，即使不使用IIC中断，也要将IICCON[5]设为1。</p>
<ol start="2">
<li><p>IICSTAT（Multi-master IIC-bus control&#x2F;status）<br>IICSTAT寄存器用于选择IIC接口的工作模式，发出S信号、P信号，使能接收&#x2F;发送功能，并标识各种状态，比如总线仲裁是否成功、作为从机是否被寻址、是否接受到0地址、是否接收到ACK信号等。<br>IICSTAT寄存器的各位表示如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>工作模式</td>
<td>[7:6]</td>
<td>0b00：从机接收器 <br> 0b01：从机发送器 <br> 0b10：从机接收器 <br> 0b11：从机发送器</td>
</tr>
<tr>
<td>忙状态位&#x2F;S信号、P信号</td>
<td>[5]</td>
<td>读此位时0：总线空闲，1：总线忙 <br> 写此位时0：发出P信号，1：发出S信号。当发出S信号后，IICDS寄存器中的数据将被自动发送。</td>
</tr>
<tr>
<td>串行输出使能位</td>
<td>[4]</td>
<td>0：禁止接收&#x2F;发送功能，1：使能接收&#x2F;发送功能</td>
</tr>
<tr>
<td>仲裁状态</td>
<td>[3]</td>
<td>0：总线仲裁成功 1：总线仲裁失败</td>
</tr>
<tr>
<td>从机地址状态</td>
<td>[2]</td>
<td>作为从机时，在检测到S&#x2F;P信号时此位被自动清0 <br> 接收到的地址与IICADD寄存器中的值相等时，此位被置1</td>
</tr>
<tr>
<td>0地址状态</td>
<td>[1]</td>
<td>在检测到S&#x2F;P信号时此位被自动清0 <br> 接收到的地址为0b0000000时，此位被置1</td>
</tr>
<tr>
<td>最后一位的状态</td>
<td>[0]</td>
<td>0：接收到的最后一位为0（接收到ACK信号） <br> 1：接收到的最后一位为1 （没有接受到ACK信号）</td>
</tr>
</tbody></table>
</li>
<li><p>IICADD寄存器（Multi-master IIC-bus address）<br>用到IICADD寄存器的位[7:1]，表示从机地址。IICADD寄存器在串行输出使能位IICSTAT[4]为0时，才可以写入；在任何时间都可以读出。</p>
</li>
<li><p>IICDS寄存器（Multi-master IIC-bus Tx&#x2F;Rx data shift）<br>用到IICDS寄存器的位[7:0]，其中保存的是要发送或已经接受的数据。IICDS寄存器在串行输出使能位IICSTAT[4]为1时，才可以写入；在任何时候都可以读出。</p>
</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440-IIC-总线操作方法"><a href="#S3C2410-x2F-S3C2440-IIC-总线操作方法" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线操作方法"></a>S3C2410&#x2F;S3C2440 IIC 总线操作方法</h3><p>启动或恢复S3C2410&#x2F;S3C2440 的IIC传输有以下两种方法：</p>
<ol>
<li>当IICCON[4]即中断状态位为0时，通过写IICSTAT寄存器启动IIC操作，有以下两种情况：<br>①在主机模式，令IICSTAT[5:4]等于0b11，将发出S信号和IICDS寄存器的数据（寻址），令IICSTAT[5:4]等于0b01，将发出P信号。<br>②在从机模式，令IICSTAT[4]等于1将等待其他主机发出S信号及地址信息。</li>
<li>当IICCON[4]即中断位为1时，表示IIC操作被暂停。在这期间设置好其他寄存器之后，向IICCON[4]中写入0即可恢复IIC操作。所谓“设置其他寄存器”，有以下3种情况。<br>①对于主机模式，可以按照上面①的方法写IICSTAT寄存器，恢复IIC操作后即可发出S信号和IICDS寄存器的值（寻址），或者发出P信号。<br>②对于发送器，可以将下一个要发送的数据写入IICDS寄存器中，恢复IIC操作后即可发出这个数据。<br>③对于接收器，可以从IICDS寄存器中读出接收到的数据。最后向IICCON[4]写入0的同时，设置IICCON[7]以决定在接收到下一个数据后是否发出ACK信号。</li>
</ol>
<p>通过中断服务程序来驱动IIC传输。</p>
<ol>
<li>当仲裁失败时发生中断—本次传输没有抢到总线，可以稍后继续。</li>
<li>对于主机模式，当发出S信号、地址信息并经过一个SCL周期（对于ACK信号）后，发生中断—主机可在此时判断是否成功寻址到从机。</li>
<li>对于从机模式，当接收到的地址与IICADD寄存器吻合时，先发出ACK信号，然后发生中断—从机可在此时准备后续的传输。</li>
<li>对于发送器，当发送完一个数据并经过一个SCL周期（对于ACK信号）后，发生中断。这是可以准备下一个要发送的数据，或者发送P信号以停止传输。</li>
<li>对于接收器，当接收到一个数据时，先根据IICCON[7]决定是否发出ACK信号后，然后发生中断。这时可以读取IICDS寄存器得到数据，并设置IICCON[7]以决定接收到下一个数据后是否发出ACK信号。</li>
</ol>
<p>对于4种工作模式，S3C2410&#x2F;S3C2440数据手册中都有它们的操作流程图。现在以主机发送器作为例子说明，它的工作流程如图所示：<br><img src="/2022/08/25/IIC/6.jpeg" alt="img not found"></p>
<ol>
<li>配置主机发送器的各类参数。<br>设置GPE15、GPE14引脚用于SDA、SCL，设置IICCON寄存器选择IIC发送时钟，最后设置IICSTAT[4]为1。这样，后面才能写IICDS寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips：初始时IICCON[4]为0，不能将IICSTAT设为主机模式，否则就会立刻发出S信号，发送IICDS寄存器的值。</span><br></pre></td></tr></table></figure></li>
<li>将要寻址的从机地址写入IICDS寄存器。</li>
<li>将0xF0写入IICSTAT寄存器，即设为主机发送器、使能串行输出功能、发出S信号。</li>
<li>发出S信号后，步骤2中设置的IICDS寄存器值也将被发出，它用来寻址从机。</li>
<li>在响应周期之后，发生中断，此时IICCON[4]为1，IIC传输暂停。</li>
<li>如果没有数据要发送，则跳到步骤10，否则跳到步骤7。</li>
<li>将下一个要发送的数据写入IICDS寄存器中。</li>
<li>往IICCON[4]中写入0，恢复IIC传输。</li>
<li>这时IICDS寄存器中的值将被一位一位地发送出去。当8位数据发送完毕，在经过另一个SCL周期（对应ACK信号）后，中断再次发生，跳到步骤5。</li>
<li>将0xF0写入IICSTAT寄存器，即：设为主机发送器、使能串行输出功能、发出P信号。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips：这时的P信号并没有实际发出，只有清除了IICCON[4]后才会发出P信号。</span><br></pre></td></tr></table></figure></li>
<li>清除IICCON[4]，P信号得以发出。</li>
<li>等待一段时间，使得P信号完全发出。</li>
</ol>
<h1 id="IIC总线操作实例"><a href="#IIC总线操作实例" class="headerlink" title="IIC总线操作实例"></a>IIC总线操作实例</h1><h2 id="IIC接口RTC芯片M41t11的操作方法"><a href="#IIC接口RTC芯片M41t11的操作方法" class="headerlink" title="IIC接口RTC芯片M41t11的操作方法"></a>IIC接口RTC芯片M41t11的操作方法</h2><p>本书所用的开发板中，通过IIC总线连接RTC（实时时钟）芯片的M41t11，它使用电池供电，系统断电时也可以维持日期和时间。S3C2410&#x2F;S3C2440作为IIC主机向M41t11发送数据以设置日期和时间、读取M41t11以获得日期和时间。连接图如下图所示：<br><img src="/2022/08/25/IIC/7.jpeg" alt="img not found"><br>M41t11中有8个寄存器，分别对应秒、分、时、天、日、月、年、控制寄存器，其中的数据都是以BCD格式保存（0x15表示数值15），如下表所示：<br><img src="/2022/08/25/IIC/8.jpeg" alt="img not found"><br>除上表的8个寄存器（地址为0-7）之外，M41t11内部还有56字节的RAM（地址为8-63）。访问M41t11前，先设置寄存器地址，以后每次读写操作完成后，M41t11内部会自动将寄存器地址加1。<br>所以读写M41t11分为以下两个步骤：</p>
<ol>
<li>主机向M41t11发出要操作的寄存器地址（0-7）。</li>
<li>要设置M41t11时，主机连续发出数据；要读取M41t11时，主机连续读取数据。M41t11的IIC从机地址为0xD0。</li>
</ol>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例将在串口上输出一个菜单，可以选择设置时间和日期，或者将它们读出来。将通过本实例验证IIC主机的发送、接收操作。</p>
<h2 id="设置-x2F-读取M41t11的源码详解"><a href="#设置-x2F-读取M41t11的源码详解" class="headerlink" title="设置&#x2F;读取M41t11的源码详解"></a>设置&#x2F;读取M41t11的源码详解</h2><p>文件i2c.c封装了S3C2410&#x2F;S3C2440作为主机发送器、主机接收器的4个操作函数：i2c_init用于初始化，i2c_write用于发起发送数据，i2c_read用于发起读取数据，I2CHandle是IIC中断服务程序，它用于完成后续的数据传输。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC控制器初始化"><a href="#S3C2410-x2F-S3C2440-IIC控制器初始化" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC控制器初始化"></a>S3C2410&#x2F;S3C2440 IIC控制器初始化</h3><p>i2c_init函数对应于图12.7的步骤1，它用来初始化IIC，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IIC初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPEUP |= <span class="number">0xc000</span>;                <span class="comment">//禁止内部上拉</span></span><br><span class="line">    GPECON  |=  <span class="number">0xa0000000</span>;         <span class="comment">//选择引脚功能，GPE15：IICSDA  GPE14：IICSCL</span></span><br><span class="line"></span><br><span class="line">    INTMSK  &amp;=  ~(BIT_IIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    bit[7]=1，使能ACK</span></span><br><span class="line"><span class="comment">    bit[6]=0，IICCLK=PCLK/16</span></span><br><span class="line"><span class="comment">    bit[5]=1，使能中断</span></span><br><span class="line"><span class="comment">    bit[3:0] = 0xf，Tx clock = IICCLK/16</span></span><br><span class="line"><span class="comment">    PCLK = 50MHz，IICCLK = 3.125MHz，Tx Clock = 0.195MHz</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    IICCON = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">6</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) | (<span class="number">0xf</span>);        <span class="comment">//0xaf</span></span><br><span class="line"></span><br><span class="line">    ICCADD = <span class="number">0x10</span>;                                          <span class="comment">// S3C24xx slave address = [7:1]</span></span><br><span class="line">    IICSTAT = <span class="number">0x10</span>;                                         <span class="comment">// IIC串行输出使能（Rx/Tx）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6、7行代码将GPE15、GPE14的功能选择用于IIC：IICSDA、IICSCL。<br>第9行在INTMSK寄存器中开启IIC中断，这样，以后调用i2c_read、i2c_write启动传输时，即可以触发中断，进而可以在中断服务程序中进一步完成后续传输。<br>第19行用于选择发送时钟，并进行一些设置：使能ACK、使能中断。<br>第21行用于设置S3C2410&#x2F;S3C2440作为IIC从机时的地址。<br>第22行使能IIC串行输出（设置IICSTAT[4]为1），这样，在i2c_write、i2c_read函数中就可以写IICDS寄存器了。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-主机发送函数"><a href="#S3C2410-x2F-S3C2440-IIC-主机发送函数" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 主机发送函数"></a>S3C2410&#x2F;S3C2440 IIC 主机发送函数</h3><p>初始化完成后，就可以调用i2c_read、i2c_write函数读写IIC从机了。它们的使用方法从参数名称中可以看出。这两个函数仅仅是启动IIC传输，然后等待，直到数据在中断服务程序中传输完毕后再返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主机发送</span></span><br><span class="line"><span class="comment">slvAddr：从机地址，buf：数据存放的缓冲区，len：数据长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slvaddr,<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tS3C24xx_IIC.Mode         = WRDATA;           <span class="comment">//写操作</span></span><br><span class="line">    g_tS3C24xx_IIC.Pt           = <span class="number">0</span>;                <span class="comment">//索引初始值为0</span></span><br><span class="line">    g_tS3C24xx_IIC.pData        = buf;              <span class="comment">//保存缓冲区地址</span></span><br><span class="line">    g_tS3C24xx_IIC.DataCount    = len;              <span class="comment">//传输长度</span></span><br><span class="line"></span><br><span class="line">    IICDS   = slvAddr;</span><br><span class="line">    IICSTAT = <span class="number">0xf0</span>;                                 <span class="comment">//主机发送，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*等待直至数据发送完毕*/</span></span><br><span class="line">    <span class="keyword">while</span>(g_tS3C24xx_IIC.DataCount != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7-10行用于设置全局变量g_tS3C24xx_IIC，它表明当前是写操作，并保存缓冲区地址、要传送数据的长度，将缓冲区索引值初始化为0。<br>第12行将从机地址写入IICDS寄存器，这样，再第13行启动传输并发出S信号后，紧接着就自动发出从机地址。<br>第13行设置IICSTAT寄存器，将S3C2410&#x2F;S3C2440设为主机发送器，并发出S信号。后续的传输工作将在中断服务程序中完成。<br>第16行等待g_tS3C24xx_IIC.DataCount在中断服务程序中被设为-1，这表明传输完成，于是返回。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-主机接收函数"><a href="#S3C2410-x2F-S3C2440-IIC-主机接收函数" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 主机接收函数"></a>S3C2410&#x2F;S3C2440 IIC 主机接收函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主机接收</span></span><br><span class="line"><span class="comment">slvAddr：从机地址，buf：数据存放的缓冲区，len：数据长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slvAddr,<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tS3C24xx_IIC.Mode         = RDDATA;                   <span class="comment">//读操作</span></span><br><span class="line">    g_tS3C24xx_IIC.Pt           = <span class="number">-1</span>;                       <span class="comment">//索引值初始化为-1，表示第一个中断时不接受数据（地址中断）</span></span><br><span class="line">    g_tS3C24xx_IIC.pData        = buf;                      <span class="comment">//保存缓冲区地址</span></span><br><span class="line">    g_tS3C24xx_IIC.DataCount    = len;                      <span class="comment">//传输长度</span></span><br><span class="line"></span><br><span class="line">    IICDS = slvAddr;</span><br><span class="line">    IICSTAT = <span class="number">0xb0</span>;                                         <span class="comment">//主机接收，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*等待直至数据传输完毕*/</span></span><br><span class="line">    <span class="keyword">while</span>(g_tS3C24xx_IIC.DataCount != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是第8行将索引值设为-1，在中断处理函数中根据这个值决定是否从IICDS寄存器中读取数据。读操作时，第一次中断发生时表示发出了地址，这时候还不能读取数据。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-中断服务程序"><a href="#S3C2410-x2F-S3C2440-IIC-中断服务程序" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 中断服务程序"></a>S3C2410&#x2F;S3C2440 IIC 中断服务程序</h3><p>IIC操作的主体在中断服务程序，它分为3部分：首先是在SRCPND、INTPND中清除中断，后面两部分分别对应于写操作、读操作。先看清除中断的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IIC中断服务程序</span></span><br><span class="line"><span class="comment">根据剩余的数据长度选择继续传输或者结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2CIntHandle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> iicSt,i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清中断</span></span><br><span class="line">    SRCPND = BIT_IIC;</span><br><span class="line">    INTPND = BIT_IIC;</span><br><span class="line"></span><br><span class="line">    iicSt = IICSTAT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iicSt &amp; <span class="number">0x8</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Bus arbitration failed\n\r&quot;</span>);&#125;         <span class="comment">//仲裁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第10、11行用来清除IIC中断的代码。需要注意的是，即使清除中断之后，IICCON寄存器中的位[4]（中断标志位）仍为1，这导致IIC传输暂停。<br>第13行读取状态寄存器IICSTAT,发生中断时有可能因为仲裁失败，在第15行对它进行处理。<br>接下来一个swicth语句，分别处理读、写操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(g_tS3C24xx_IIC.Mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> WRDATA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((g_tS3C24xx_IIC.DataCount--) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//下面两行用来恢复IIC操作，发出P信号</span></span><br><span class="line">            IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">            IICCON = <span class="number">0xaf</span>;</span><br><span class="line">            Delay(<span class="number">10000</span>);   <span class="comment">//等待一段时间以便P信号发出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        IICDS = g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据写入IICDS后，需要一段时间才能出现在SDA线上</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line"></span><br><span class="line">        IICCON = <span class="number">0xaf</span>;          <span class="comment">//恢复IIC传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>g_tS3C24xx_IIC.DataCount表示剩余等待传输的数据个数，第4行判断数据是否已经全部发送完毕：若是，则通过第7、8行发出P信号，停止传输。<br>第7行设置IICSTAT寄存器以便发出P信号，但是由于这时IICCON[4]仍为1，P信号还没有实际发出。当8行清除IICCON[4]后，P信号才真正发出。第9行等待一段时间，确保P信号已经发送完毕。<br>如果数据还没有发送完毕，第12行从缓冲区得到下一个要发送的数据，将它写入IICDS寄存器中。稍加等待之后，即可在第17行清除IICCON[4]以恢复IIC传输，这时，IICDS寄存器中的数据就会发送出去，这将触发下一个中断。<br>IIC的读操作代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(g_tS3C24xx_IIC.Mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> RDDATA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g_tS3C24xx_IIC.Pt == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这次中断是在发送IIC设备地址后发生的，没有数据</span></span><br><span class="line">            <span class="comment">//只接收一个数据时，不要发出ACK信号</span></span><br><span class="line">            g_tS3C24xx_IIC.Pt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(g_tS3C24xx_IIC.DataCount == <span class="number">1</span>)</span><br><span class="line">                IICCON = <span class="number">0x2f</span>;      <span class="comment">//恢复IIC传输，开始接收数据，接收数据时不发出ACK</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                IICCON = <span class="number">0xaf</span>;      <span class="comment">//恢复IIC传输，开始接收数据</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((g_tS3C24xx_IIC.DataCount--) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++] = IICDS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面两行用来恢复IIC操作，发出P信号</span></span><br><span class="line">            IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">            IICCON = <span class="number">0xaf</span>;</span><br><span class="line">            Delay(<span class="number">10000</span>);   <span class="comment">//等待一段时间以便P信号发出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++] = IICDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收最后一个数据时，不要发出ACK信号</span></span><br><span class="line">        <span class="keyword">if</span>(g_tS3C24xx_IIC.DataCount == <span class="number">0</span>)</span><br><span class="line">            IICCON = <span class="number">0x2f</span>;          <span class="comment">//恢复IIC传输，接收到下一数据时无ACK</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            IICCON = <span class="number">0xaf</span>;          <span class="comment">//恢复IIC传输，接收到下一数据时发出ACK</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读操作比写操作多了一个步骤：第一次中断发生时表示发出了地址，这时候还不能读取数据，在代码中要分辨这点。对应第5-15行：如果g_tS3C24xx_IIC.P等于-1，表示这是第一次中断，然后修改g_tS3C24xx_IIC.Pt为0，并设置IICCON寄存器恢复IIC传输（第10-14行）。<br>当数据传输开始后，每接收到一个数据就会触发一次中断。后面的代码读取数据，判断所有的数据是否已经完成：如果完成就发出P信号，否则就继续下一次传输。<br>第17行判断数据是否已经全部接收完毕：若是，先通过第19行将当前数据从IICDS寄存器中取出存入缓冲区，然后通过22、23行发出P信号停止传输。<br>第22行设置IICSTAT寄存器以便发出P信号，但是由于这时IICCON[4]仍为1，P信号没有实际发出。第23行清除IICCON[4]后，P信号才真正发出。第24行等待一段时间，确保P信号已经发送完毕。<br>第28-25用来启动下一个数据的接收。<br>第28行将当前数据从IICDS寄存器中取出存入缓存区中。<br>第31-35行判断是否只剩下最后一个数据了：若是，就通过第32行中清除IICCON[4]、IICCON[7]，这样即可恢复IIC传输，并使得接收到数据后，S3C2410&#x2F;S3C2440不发出ACK信号（这样从机即可知道数据传输完毕）；否则，在第34行中只要清除IICCON[4]以恢复IIC传输。<br>中断服务程序中，当数据传输完毕时，g_tS3C24xx_IIC.DataCount将自减为-1，这样，i2c_read或i2c_write函数即可跳出等待，直接返回。</p>
<h3 id="RTC芯片M41t11特性相关的操作"><a href="#RTC芯片M41t11特性相关的操作" class="headerlink" title="RTC芯片M41t11特性相关的操作"></a>RTC芯片M41t11特性相关的操作</h3><p>M41t11.c文件中提供两个函数M41t11_set_datetime、M41t11_get_datetime，前者用来设置日期和时间，后者用来读取日期与时间。它们都通过调用i2c_read或i2c_write函数来完成与M41t11的交互。<br>前面说过，操作M41t11只需要两个步骤：发出寄存器地址，发出数据或读出数据。M41t11_set_datetime函数把这两个步骤合为一个IIC写操作。M41t11_get_datetime函数先发起一个IIC写传输，再发起一个IIC读传输。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写M41t11、设置日期与时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">M41t11_set_datetime</span><span class="params">(<span class="keyword">struct</span> rtc_time *dt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> leap_yr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtc_registers</span> <span class="title">rtc</span>;</span></span><br><span class="line">    &#125;__attribute__((packed)) addr_and_regs;</span><br><span class="line">    ... ... <span class="comment">/*设置rtc结构，即根据传入的参数构造各寄存器的值*/</span></span><br><span class="line">    i2c_write(<span class="number">0xD0</span>,(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;addr_and_regs,<span class="keyword">sizeof</span>(addr_and_regs));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略号表示的代码用来设置addr_and_regs结构。这个结构分为两部分：addr_and_regs.addr表示M41t11寄存器地址（它被设为0），addr_and_regs.rtc表示M41t11的8个寄存器。<br>根据传入的参数填充好addr_and_regs结构之后，就可以启动IIC写操作了。“<strong>attribute</strong>((packed))”设置这个结构体为紧凑格式，使得它的大小为9Byte（否则按照内存对齐的规则为12Byte）：1个字节用来保存寄存器地址，8个字节用来保存8个寄存器的值。<br>第12行发起一次IIC写操作，将addr_and_regs结构中的数据发送给M41t11：M41t11会把接收到的第一个数据当作寄存器的起始地址，随后是要写入寄存器的数据。<br>M41t11_get_datetime函数的代码与M41t11_set_datetime函数类似，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">读取M41t11，获取日期与时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">M41t11_get_datetime</span><span class="params">(<span class="keyword">struct</span> rtc_time *dt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> addr[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_registers</span> <span class="title">rtc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;rtc,<span class="number">0</span>,<span class="keyword">sizeof</span>(rtc));</span><br><span class="line"></span><br><span class="line">    i2c_write(<span class="number">0xD0</span>,addr,<span class="number">1</span>);</span><br><span class="line">    i2c_read(<span class="number">0xD0</span>,(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;rtc,<span class="keyword">sizeof</span>(rtc));</span><br><span class="line"></span><br><span class="line">    ... ...<span class="comment">/*根据读出的各寄存器的值，设置dr结构*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第12行发起一次IIC写传输，设置要操作的M41t11寄存器地址为0。<br>第13行发起一次IIC读传输，读出M41t11各寄存器的值。<br>省略号对应的代码根据读出的各寄存器的值，设置dr结构。M41t11下中以BCD码表示日期与时间，需要转换为程序使用的一般二进制格式。</p>
<h2 id="IIC实例的连接脚本"><a href="#IIC实例的连接脚本" class="headerlink" title="IIC实例的连接脚本"></a>IIC实例的连接脚本</h2><p>本实例要用到第8章NAND Flash控制器的函数将代码从NAND Flash复制到SDRAM中。由于nand代码中用到了全局变量，而全局变量要运行于可读写的内存中，为了方便，使用连接脚本将这些初始化代码放在Steppingstone中。<br>连接脚本为i2c.lds,内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    . = <span class="number">0x00000000</span>;</span><br><span class="line">    .init : AT(<span class="number">0</span>) &#123;head.o init.o nand.o&#125;</span><br><span class="line">    . = <span class="number">0x30000000</span>;</span><br><span class="line">    .text : AT(<span class="number">4096</span>) &#123; *(.text) &#125;</span><br><span class="line">    .rodata <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span> : <span class="title function_">AT</span><span class="params">((LOADADDR(.text) + SIZEOF(.text) + <span class="number">3</span>) &amp;~ (<span class="number">0x03</span>))</span> &#123; *(.rodata*) &#125; </span><br><span class="line">    .data <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>  : <span class="title function_">AT</span><span class="params">((LOADADDR(.rodata) + SIZEOF(.rodata) + <span class="number">3</span>) &amp;~ (<span class="number">0x03</span>))</span> &#123; *(.data) &#125;</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>   : &#123;*(.bss) *(COMMON) &#125;</span><br><span class="line">    __bss_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2-3行将head.S、init.c和nand.c对应的代码的运行地址设为0，加载地址（存在NAND Flash上的地址）设为0。从NAND Flash启动时，这些代码被复制到Steppingstone后就可以直接运行。<br>第4行设置其余代码的运行地址为0x3000000；第5行将代码段的加载地址设为4096，表示代码段将存在NAND Flash地址4096处。<br>第6-7行的“AT(…)”设置rodata段，data段的加载地址依次位于代码段之后。“LOADADDR(…)”表示某段的加载地址，“SIZEOF(…)”表示它的大小。这两行的前面使用“ALIGN(4)”使得它们的运行地址为4字节对齐，为了使各段之间加载地址的相对偏移值等于运行地址的相对偏移值，需要将“AT(…)”中的值也设为4字节对齐：先加上3，然后与~(0x03)进行与操作（将低2位设为0）。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第12章 IIC</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>IIC总线</tag>
      </tags>
  </entry>
  <entry>
    <title>ADC和TP接口</title>
    <url>/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第14章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440 ADC和触摸屏的结构</li>
<li>了解电阻触摸屏的工作原理和等效电路图</li>
<li>了解S3C2410&#x2F;S3C2440触摸屏控制器的多种工作方式</li>
<li>掌握S3C2410&#x2F;S3C2440 ADC和触摸屏的编程方法</li>
</ol>
<h1 id="ADC和触摸屏硬件介绍和使用"><a href="#ADC和触摸屏硬件介绍和使用" class="headerlink" title="ADC和触摸屏硬件介绍和使用"></a>ADC和触摸屏硬件介绍和使用</h1><h2 id="S3C2410-x2F-S3C2440-ADC和触摸屏接口概述"><a href="#S3C2410-x2F-S3C2440-ADC和触摸屏接口概述" class="headerlink" title="S3C2410&#x2F;S3C2440 ADC和触摸屏接口概述"></a>S3C2410&#x2F;S3C2440 ADC和触摸屏接口概述</h2><p>S3C2410&#x2F;S3C2440 的CMOS模数转换器（ADC，Analog to Digital Converter）可以接收8个通道的模拟信号输入，并将它们转换为10位的二进制数据。在2.5MHz的A&#x2F;D转换时钟下，最大的转换速率可达500KSPS（samples per second，每秒采样的次数）。<br>S3C2410&#x2F;S3C2440 都提供触摸屏的接口，不过有所不同。S3C2410的触摸屏接口向外提供4个控制信号引脚（nYPON、YMON、nXPON、XMON）和2个模拟信号输入引脚（AIN[7]、AIN[5]）。这6个引脚通过4个晶体管与触摸屏的4个引脚相连。而S3C2440提供了与触摸屏直接相连的4个引脚，不在需要外接晶体管。<br>S3C2410&#x2F;S3C2440 ADC和触摸屏接口有如下特性：</p>
<ol>
<li>分辨率：10位</li>
<li>微分线性度误差：±1.0LSB</li>
<li>积分线性度误差：±2.0LSB</li>
<li>最大转换功率：500KSPS</li>
<li>低功耗</li>
<li>供电电压：3.3V</li>
<li>输入模拟电压范围：0-3.3V</li>
<li>片上采样保持功能</li>
<li>普通转换模式</li>
<li>分离的x&#x2F;y轴坐标转换模式</li>
<li>自动（连续）x&#x2F;y轴坐标转换模式</li>
<li>等待中断模式</li>
</ol>
<p>ADC和触摸屏接口结构如图所示：<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/1.jpeg" alt="img not found"><br>从上图可以知道，ADC和触摸屏接口中只有一个A&#x2F;D转换器可以通过设置寄存器来选择对哪路模拟信号（多达8路）进行采样。图中有两个中断信号：INT_ADC、INT_TC，前者表示A&#x2F;D转化器已经转换完毕，后者表示触摸屏被按下了。<br>对于S3C2410，在使用触摸屏时，AIN[7]和AIN[5]被用来测量XP、YP的电平，只剩下AIN[6]、AIN[4:0]共6个引脚被用于一般的ADC输入。对于S3C2440，在使用触摸屏时，引脚XP、XM、YP和YM被用于和触摸屏直接相连，只剩下AIN[3:0]共4个引脚用于一般的ADC输入；当不使用触摸屏时，XP、XM、YP和YM这4个引脚也可以用于一般的ADC输入。<br>S3C2410与触摸屏的连接比S3C2440复杂，需要增加几个外接晶体管，如下图所示：<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/2.jpeg" alt="img not found"></p>
<h2 id="S3C2410-x2F-S3C2440-ADC接口的使用方法"><a href="#S3C2410-x2F-S3C2440-ADC接口的使用方法" class="headerlink" title="S3C2410&#x2F;S3C2440 ADC接口的使用方法"></a>S3C2410&#x2F;S3C2440 ADC接口的使用方法</h2><p>ADC的启动方式有两种：手工启动、读结果时就自动启动下一次转换。也有两种方法获知当前转换是否已经结束：查询状态位、转换结束时就发出中断。<br>ADC的操作只涉及3个寄存器：ADCCON、ADCTSC、ADCDAT0。下面介绍它们的用法，有关触摸屏的数据位将在下面的小节介绍。<br>ADCCON寄存器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ECFLG</td>
<td>[15]</td>
<td>只读，A&#x2F;D转换结束标志。<br> 0：正在转换。1：转换结束。</td>
</tr>
<tr>
<td>PRSCEN</td>
<td>[14]</td>
<td>决定A&#x2F;D转换器的时钟是否分频。<br> 0：不使用。1：使用。</td>
</tr>
<tr>
<td>PRSCVL</td>
<td>[13:6]</td>
<td>预分频系数，取值0-255：A&#x2F;D时钟 &#x3D; PCLK&#x2F;(PRSCVL + 1)。<br>注意：A&#x2F;D时钟必须小于PCLK的1&#x2F;5。</td>
</tr>
<tr>
<td>SEL_MUX</td>
<td>[5:3]</td>
<td>选择进行A&#x2F;D转换的通道。 <br> 对于S3C2410,取值如下：<br>000：AIN 0； 001：AIN 1；010：AIN 2；011：AIN 3；<br>100：AIN 4；101：AIN 5；110：AIN 6；111：AIN 7（XP）；<br>对于S3C2440，取值如下：<br>000：AIN 0； 001：AIN 1；010：AIN 2；011：AIN 3；<br>100：YM；101：YP；110：XM；111：XP；</td>
</tr>
<tr>
<td>STDBM</td>
<td>[2]</td>
<td>选择静态模式（Standby Mode）。<br>0：正常模式；1：静态模式。</td>
</tr>
<tr>
<td>READ_START</td>
<td>[1]</td>
<td>读转换数据时是否启动下一次转换。<br> 0：不启动；1：启动；</td>
</tr>
<tr>
<td>ENABLE_START</td>
<td>[0]</td>
<td>启动A&#x2F;D转换（当READ_START为1时，此位无效）。<br> 0：无作用；1：启动A&#x2F;D转换（转换真正开始时，此位被清零）。</td>
</tr>
</tbody></table>
<p>ADCDAT0寄存器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>UPDOWN</td>
<td>[15]</td>
<td>对于触摸屏，使用“等待中断模式”时，<br>0：触摸屏被按下；1：触摸屏没有被按下。</td>
</tr>
<tr>
<td>AUTO_PST</td>
<td>[14]</td>
<td>决定是否使用自动（连续）x&#x2F;y轴坐标转换模式。<br>0：正常转换；1：自动（连续）x&#x2F;y坐标轴转换。</td>
</tr>
<tr>
<td>XY_PST</td>
<td>[13:12]</td>
<td>手动x&#x2F;y轴坐标转换模式。<br>00：无操作；01：x轴坐标转换；<br>10：y轴坐标转换；11：等待中断模式。</td>
</tr>
<tr>
<td>Reserved</td>
<td>[11:10]</td>
<td>保留</td>
</tr>
<tr>
<td>XPDATA（普通ADC转换数据）</td>
<td>[9:0]</td>
<td>x轴坐标转换数据值（或普通ADC转换数据值）<br> 数值范围：0-0x3FF</td>
</tr>
</tbody></table>
<p>ADC的使用分4个步骤：</p>
<ol>
<li>设置ADCCON寄存器，选择信号输入通道，设置A&#x2F;D转换器的时钟。<br>使能A&#x2F;D转化器时钟的预分频功能时，A&#x2F;D时钟的计算公式如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A/D时钟 = PCLK / (PRSCVL + <span class="number">1</span>)</span><br><span class="line">注：A/D时钟最大为 <span class="number">2.5</span>MHz，并且应该小于PCLK的<span class="number">1</span>/<span class="number">5</span>。</span><br></pre></td></tr></table></figure></li>
<li>设置ADCTSC寄存器，使用设为普通转换模式，不使用触摸屏功能。<br>ADCTSC寄存器多用于触摸屏，对于普通ADC，使用它的默认值即可，或设置其位[2]为0。ADCTSC寄存器的格式在下面的小节介绍。</li>
<li>设置ADCCON寄存器，启用A&#x2F;D转换。<br>如果设置READ_START位，则读转换数据（读ADCDAT0寄存器）时即启动下一次转换；否则，可以通过设置ENABLE_START位来启动A&#x2F;D转换。</li>
<li>转换结束时，读取ADCDAT0寄存器获得数值。<br>如果使用查询方式，则可以不断读取ADCCON寄存器的ECFLG位来确定转换是否结束；否则可以使用INT_ADC中断，发生INT_ADC中断时表示转换结束。</li>
</ol>
<h2 id="触摸屏原理及接口"><a href="#触摸屏原理及接口" class="headerlink" title="触摸屏原理及接口"></a>触摸屏原理及接口</h2><h3 id="电阻触摸屏的原理"><a href="#电阻触摸屏的原理" class="headerlink" title="电阻触摸屏的原理"></a>电阻触摸屏的原理</h3><p>触摸屏已经在现实生活中大量使用，种类也有很多，比如超声波触摸屏、红外触摸屏、电容触摸屏、电阻触摸屏等。电阻触摸屏由于造价低廉，在电气上可以直接接入用户的系统而得到大量使用。电阻触摸屏有几种类型，比如“四线”、“五线”、“八线”。线越多，精度就越高，温度漂移也越少，但是基本的操作是一样的。它本质是个电阻分压器，将矩形区域中的触摸点（x，y）的物理位置转换为代表x坐标和y坐标的电压。<br>S3C2410&#x2F;S3C2440的触摸屏接口可以驱动四线电阻触摸屏，四线电阻触摸屏的等效电路如下图所示:<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/3.jpeg" alt="img not found"><br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/4.jpeg" alt="img not found"><br>图中粗黑线表示相互绝缘的两层导电层，当按压时，它们在触点外相连；不同的触点在x，y方向上的分压值不一样，将这两个电压值经过A&#x2F;D转换后即可得到x，y坐标。下面根据等效电路图说明触摸屏的工作过程。</p>
<ol>
<li>平时触摸屏没有被按下时，等效电路如图14.5所示。<br>S4、S5闭合，S1、S2、S3断开，即YM接地、XP上拉、XP作为模拟输入（对CPU而言）、YP作为模拟输入（对CPU而言）、XM高阻。<br>平时触摸屏没有按下时，由于上拉电阻的关系，Y_ADC为高电平；当x轴和y轴受挤压而接触导通之后，Y_ADC的电压由于联通到y轴接地而变为低电平，此此低电平可作为中断触发信号来通知CPU发生“Pen Down”事件。在S3C2410&#x2F;S3C2440中，称为等待中断模式。</li>
<li>采样X_ADC电压，得到x坐标，等效电路如图14.6所示。<br>S1、S3闭合，S2、S4、S5断开，即XP接上电源、XM接地、YP作为模拟输入（对CPU而言）、YM高阻、XP禁止上拉。这时，YP即X_ADC就是x轴的分压点，进行A&#x2F;D转化后得到x坐标。</li>
<li>采样Y_ADC电压，得到y坐标，等效电路如图14.7所示。<br>S2、S4闭合，S1、S3、S5断开，即YP接上电源、YM接地、XP作为模拟输入（对CPU而言）、XM高阻、XP禁止上拉。这时，XP即Y_ADC就是y轴的分压点，进行A&#x2F;D转换后得到y坐标。</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440触摸屏接口"><a href="#S3C2410-x2F-S3C2440触摸屏接口" class="headerlink" title="S3C2410&#x2F;S3C2440触摸屏接口"></a>S3C2410&#x2F;S3C2440触摸屏接口</h3><p>与上面描述的触摸屏工作过程的3个步骤对应，触摸屏控制器也有4种工作模式。</p>
<ol>
<li>等待中断模式（Waiting for Interrupt Mode）<br>设置ADCTSC寄存器为0xD3即可令触摸屏控制器处于这种模式。这时，它在等待触摸屏按下。当触摸屏被按下时，触摸屏控制器将发出INT_TC中断信号，这时触摸屏控制器要转入以下两种工作模式中的一种，以读取x、y坐标。<br>对于S3C2410，当触摸屏按下或松开的时候，都产生INT_TC中断信号。<br>对于S3C2440，可以设置ADCTSC寄存器的位[8]为0或1时，表示等待Pen Down中断或Pen Up中断。</li>
<li>分离的x&#x2F;y轴坐标转换模式<br>这分别对应上述触摸屏工作过程的第2、3步骤。设置ADCTSC寄存器为0x69进入x轴坐标转换模式，x坐标值转换完毕后被写入ADCDAT0，然后发出INT_ADC中断；相似的，设置ADCTSC寄存器为0x9A进入y轴坐标转换模式，y坐标轴转换完毕后被写入ADCDAT1，然后发出INT_ADC中断。</li>
<li>自动（连续）x&#x2F;y轴坐标转换模式<br>上述触摸屏工作过程的第2、3步骤可以合成一个步骤，设置ADCTSC寄存器值为0x0C，进入自动（连续）x&#x2F;y轴坐标转换模式，触摸屏控制器就会自动转换x、y坐标值，并分别写入ADCDAT0、ADCDAT1寄存器中，然后发出INT_ADC中断。</li>
<li>普通转换模式<br>不使用触摸屏时，触摸屏控制器处于这种模式。在这种模式下，可以通过设置ADCCON寄存器启动普通的A&#x2F;D转换，转换完成时数据被写入ADCDAT0寄存器中。<br>ADCTSC寄存器被用来选择触摸屏的工作模式，下面介绍ADCTSC寄存器。<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Reserved&#x2F;UD_SEN</td>
<td>[8]</td>
<td>对于S3C2410，此位必须为0。<br> 对于S3C2440，此位表示将检测哪类中断（触点按下、触点松开）。<br>0：按下；1：松开。</td>
</tr>
<tr>
<td>YM_SEN</td>
<td>[7]</td>
<td>对于S3C2410，用于选择YMON的输出值。<br>0：YMON输出0（YM：高阻）；1：YMON输出1（YM：GND）<br> 对于S3C2440,YM使能开关。<br>0：YM驱动禁止（高阻）；1：YM驱动使能（接地）</td>
</tr>
<tr>
<td>YP_SEN</td>
<td>[6]</td>
<td>对于S3C2410，用于选择nYPON的输出值。<br>0：nYPON输出0（YP：外部电压）；1：nYPON输出1（YM接AIN[5]）<br> 对于S3C2440,YP使能开关。<br>0：YP驱动禁止（接外部电压）；1：YP驱动使能（接模拟输入）</td>
</tr>
<tr>
<td>XM_SEN</td>
<td>[5]</td>
<td>对于S3C2410，用于选择XMON的输出值。<br>0：XMON输出0（XM：高阻）；1：XMON输出1（XM：GND）<br> 对于S3C2440,XM使能开关。<br>0：XM驱动禁止（高阻）；1：XM驱动使能（接地）</td>
</tr>
<tr>
<td>XP_SEN</td>
<td>[4]</td>
<td>对于S3C2410，用于选择nXPON的输出值。<br>0：nXPON输出0（XP：外部电压）；1：nXPON输出1（XM接AIN[7]）<br> 对于S3C2440,XP使能开关。<br>0：XP驱动禁止（接外部电压）；1：XP驱动使能（接模拟输入）</td>
</tr>
<tr>
<td>PULL_UP</td>
<td>[3]</td>
<td>XP上拉使能。 <br> 0：使能上拉；1：禁止上拉</td>
</tr>
<tr>
<td>AUTO_PST</td>
<td>[2]</td>
<td>是否使用自动（连续）x&#x2F;y轴坐标转换模式。<br>0：普通转换模式 1：自动（连续）x&#x2F;y轴坐标转换模式</td>
</tr>
<tr>
<td>XY_PST</td>
<td>[1:0]</td>
<td>手动测量x、y轴坐标。<br> 00：无操作模式；01：测量x轴坐标；<br>10：测量y轴坐标；11：等待中断模式</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：<br>①处于等待中断模式时，XP_SEN必须设为1（XP接模拟输入），PULL_UP必须设为0（使能上拉）。<br>②AUTO_PST设为1时，必须处于自动（连续）x&#x2F;y轴坐标转换模式下。</p>
<p>对于S3C2410，当触摸控制器处于等待中断模式时，触摸屏被按下时，可以不断发出INT_TC中断信号，以便进入自动（连续）x&#x2F;y轴转换模式转换x、y坐标。发出中断信号的间隔可以通过ADCDLY寄存器来设置。<br>对于S3C2440，当CPU处于休眠模式下，触摸屏被按下时可以不断发出INT_TC中断信号以唤醒CPU。发出中断信号的间隔可以通过ADCDLY寄存器来设置。<br>另外，对于普通转换模式、分离的x&#x2F;y轴坐标转换模式、自动（连续）x&#x2F;y轴坐标转换模式，都可以通过ADCDLY来设置采样的延时时间。<br>ADCDLY寄存器格式如下表所示，在等待中断模式时，延时时钟为X-tal（3.68MHz），其他情况为PCLK。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DELAY</td>
<td>[15:0]</td>
<td>采样的延时值，或发出中断的间隔值</td>
</tr>
</tbody></table>
<p><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/5.jpeg" alt="img not found"></p>
<p>ADCDAT1寄存器的格式如下表所示。它与ADCDAT0寄存器格式相似，ADCDAT1寄存器中保存y坐标值；而ADCDAT0寄存器中保存普通A&#x2F;D转换的值或x坐标值。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>UPDOWN</td>
<td>[15]</td>
<td>对于触摸屏，使用“等待中断模式”时如下。<br>0：触摸屏被按下；1：触摸屏没有被按下</td>
</tr>
<tr>
<td>AUTO_PST</td>
<td>[14]</td>
<td>决定是否使用自动（连续）x&#x2F;y坐标转换模式。 <br> 0：正常转换；1：自动（连续）x&#x2F;y轴坐标转换</td>
</tr>
<tr>
<td>XY_PST</td>
<td>[13:12]</td>
<td>手动x&#x2F;y轴坐标转换模式 <br> 00：无操作；01：x轴坐标转换 <br> 10：y轴坐标转换 11：等待中断模式</td>
</tr>
<tr>
<td>Reserved</td>
<td>[11:10]</td>
<td>保留</td>
</tr>
<tr>
<td>YPDATA</td>
<td>[9:0]</td>
<td>x轴坐标转换数据值</td>
</tr>
</tbody></table>
<h1 id="ADC和触摸屏操作实例"><a href="#ADC和触摸屏操作实例" class="headerlink" title="ADC和触摸屏操作实例"></a>ADC和触摸屏操作实例</h1><h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>模拟输入引脚AIN0、AIN1外接可调电阻器，电路图如下图所示：<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/6.jpeg" alt="img not found"><br>图中的两个电阻器是可调电阻器，程序通过AIN0、AIN1这两个通道采集、转换电压值。<br>触摸屏的接口是标准的，它的电路图如图14.4所示。</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>测试ADC时，程序不断测量AIN0、AIN1的电压，并在串口上显示出来。测试触摸屏时，只是测试触笔按下、松开的事件，并且把按下时采集到的x、y坐标打印出来，它们只是原始的数据。<br>主要文件为adc_ts.c。主要接口为adc_ts.c中的Test_Adc、Test_Ts函数。</p>
<h2 id="测试ADC的代码详解"><a href="#测试ADC的代码详解" class="headerlink" title="测试ADC的代码详解"></a>测试ADC的代码详解</h2><h3 id="ADC主入口函数Test-Adc"><a href="#ADC主入口函数Test-Adc" class="headerlink" title="ADC主入口函数Test_Adc"></a>ADC主入口函数Test_Adc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试ADC</span></span><br><span class="line"><span class="comment">通过A/D转换，测量可变电阻器的电压值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_Adc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> vol0,vol1;</span><br><span class="line">    <span class="type">int</span> t0,t1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!awaitkay(<span class="number">0</span>))                                     <span class="comment">//串口无输出，则不断测试</span></span><br><span class="line">    &#123;</span><br><span class="line">        vol0 = ((<span class="type">float</span>)ReadAdc(<span class="number">0</span>)*<span class="number">3.3</span>)/<span class="number">1024.0</span>;              <span class="comment">//计算电压值</span></span><br><span class="line">        vol1 = ((<span class="type">float</span>)ReadAdc(<span class="number">1</span>)*<span class="number">3.3</span>)/<span class="number">1024.0</span>               <span class="comment">//计算电压值</span></span><br><span class="line">        t0   = (vol0 - (<span class="type">int</span>)vol0) * <span class="number">1000</span>;                   <span class="comment">//计算小数部分</span></span><br><span class="line">        t1   = (vol1 - (<span class="type">int</span>)vol1) * <span class="number">1000</span>;                   <span class="comment">//计算小数部分</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AIN0 = %d.%-3dV     AIN1 = %d.%-3dV\r&quot;</span>,(<span class="type">int</span>)vol0,t0,(<span class="type">int</span>)vol1,t1,);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第12、13行先调用ReadAdc函数发起A&#x2F;D转换，返回10位转换值（最大值为1023）；然后计算实际电压值（S3C2410&#x2F;S3C2440模拟信号最大电压3.3V）。</p>
<h3 id="ReadAdc-函数：设置、启动ADC，获取转换结果"><a href="#ReadAdc-函数：设置、启动ADC，获取转换结果" class="headerlink" title="ReadAdc 函数：设置、启动ADC，获取转换结果"></a>ReadAdc 函数：设置、启动ADC，获取转换结果</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用查询方式读取A/D转换值</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    ch：模拟信号通道，取值为0-7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ReadAdc</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用模拟通道，使能预分频功能，设置A/D转换器的时钟 = PCLK/（49 + 1）</span></span><br><span class="line">    ADCCON = PRESCALE_EN | PRSCVL(<span class="number">49</span>) | ADC_INPUT(ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除位[2]，设为普通转换模式</span></span><br><span class="line">    ADCTSC &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置位[0]为1，启动A/D转换</span></span><br><span class="line">    ADCCON |= ADC_START;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当A/D转换真正开始时，位[0]会自动清0</span></span><br><span class="line">    <span class="keyword">while</span>(ADCCON &amp; ADC_START);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测位[15]，当它为1时表示转换结束</span></span><br><span class="line">    <span class="keyword">while</span>(!(ADCCON &amp; ADC_ENDCVT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="keyword">return</span> (ADCDAT0 &amp; <span class="number">0x3ff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序流程与前面介绍的ADC的4个步骤一一对应。</p>
<ol>
<li>第10行选择模拟通道，使能预分频功能，设置A&#x2F;D转化器的时钟。<br>本程序中，PCLK为50MHz，所以A&#x2F;D转换器的时钟为50MHz&#x2F;(49 + 1) &#x3D; 1MHz，小于最大A&#x2F;D时钟2.5MHz。</li>
<li>第13行清除ADCTSC寄存器位[2]，设为普通转换模式，ADCTSC寄存器格式上文有表格描述。</li>
<li>第16行设置ADCCON寄存器位[0]，启动A&#x2F;D转换。<br>ADC的启动有两种方式，如果使用“读启动”方式（此时ADCCON寄存器位[1]被设为1），则读一下ADCDAT0寄存器即可启动；如果使用手动方式，设置ADCCON寄存器位[0]即可启动。</li>
<li>第22行循环检测ADCCON的位[15]，直到它为1为止，这表示A&#x2F;D转换结束。<br>也可以使用中断方式，当A&#x2F;D转换结束时，ADC会发出INT_ADC中断信号。</li>
<li>最后，第25行读取ADCDAT0即可得到转换的数据（低10位为有效数据）。</li>
</ol>
<h3 id="测试触摸屏的代码详解"><a href="#测试触摸屏的代码详解" class="headerlink" title="测试触摸屏的代码详解"></a>测试触摸屏的代码详解</h3><p>触摸屏的操作稍微复杂，下面将程序流程图和触摸屏控制的状态转换图合并在一起，以便代码分析。<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/7.jpeg" alt="img not found"></p>
<h4 id="触摸屏的主入口函数Test-Ts"><a href="#触摸屏的主入口函数Test-Ts" class="headerlink" title="触摸屏的主入口函数Test_Ts"></a>触摸屏的主入口函数Test_Ts</h4><p>Test_Ts函数进行初始化、开启ADC中断之后，就不再参与触摸屏的操作，这都通过中断服务程序来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试触摸屏，打印触点坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_Ts</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    isr_handle_array[ISR_ADC_OFT] = AdcTsIntHandlel;                <span class="comment">//设置中断服务程序</span></span><br><span class="line">    INTMSK &amp;= ~BIT_ADC;                                             <span class="comment">//开启ADC总中断</span></span><br><span class="line">    INTSUBMSK &amp;= ~(BIT_SUB_TC);                                     <span class="comment">//开启INT_TC中断，即触摸屏被按下或松开时产生中断</span></span><br><span class="line">    INTSUBMSK &amp;= ~(BIT_SUB_ADC);                                    <span class="comment">//开启INT_ADC中断，即A/D转换结束时产生中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使能预分频功能，设置A/D转换器的时钟 = PCLK / (49 + 1);</span></span><br><span class="line">    ADCCON = PRESCALE_EN | PRSCVL(<span class="number">49</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    采样延时时间 = (1/3.6864M)*50000 = 13.56ms</span></span><br><span class="line"><span class="comment">    即按下触摸屏后，再过13.56ms才能采样 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ADCDLY = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    wait_down_int();                                                <span class="comment">//进入“等待中断模式”，等待触摸屏按下</span></span><br><span class="line"></span><br><span class="line">    getc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏蔽ADC中断</span></span><br><span class="line">    INTSUBMSK |= BIT_SUB_TC;</span><br><span class="line">    INTSUBMSK |= BIT_SUB_ADC;</span><br><span class="line">    INTMSK |= BIT_ADC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6行设置ADC中断的处理函数，第7-9行开启ADC中断。ADC中断有两类：INT_TC和INT_ADC，前者表示触摸屏被按下或松开，后者表示A&#x2F;D转换结束。<br>第12行使能预分频功能，设置A&#x2F;D转化器的时钟为PCLK&#x2F;（49 + 1）；本程序中，PCLK为50MHz，所以A&#x2F;D转换器的时钟为50MHz&#x2F;(49 + 1) &#x3D; 1MHz，小于最大A&#x2F;D时钟2.5MHz。<br>第18行设置延时时间。<br>第20行调用wait_down_int()宏，令触摸屏控制器进入“等待中断模式”，等待触摸屏被按下。<br>第22行等待串口的输入，以退出测试。等待期间通过中断来驱动触摸屏的操作。<br>第25-28行屏蔽ADC中断。<br>wait_down_int、wait_up_int、mode_auto_xy都是宏定义，它们用于设置触摸屏进入“等待Pen Down中断模式”、“等待Pen Up中断模式”、“自动（连续）x&#x2F;y轴坐标转换模式”。<br>需要注意以下几点：</p>
<ol>
<li>对于S3C2410，ADCTSC的位[8]属于保留位，只能设为0；当处于“等待中断模式”时，无论是“Pen Down”中断还是“Pen Up”中断都可以检测到。</li>
<li>对于S3C2440，ADCTSC的位[8]为0、1时分别表示等待Pen Down中断或者Pen Up中断。</li>
<li>要进入“自动（连续）x&#x2F;y坐标轴坐标转换模式”，XP、XM、YP、YM的状态不必理会，触摸屏在采样时会自动控制它们。</li>
</ol>
<p>上述宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置进入等待中断模式，XP_PU、XP_Dis、XM_Dis、YP_Dis、YM_En</span></span><br><span class="line"><span class="comment">1. 对于S3C2410，位[8]只能为0，所以只能使用下面的wait_down_int,它既等待Pen Down中断，也等待Pen Up中断</span></span><br><span class="line"><span class="comment">2. 对于S3C2440，位[8]为0、1时分别表示等待Pen Down中断或Pen Up中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*进入“等待中断模式”，等待触摸屏被按下*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_down_int() &#123;   ADCTSC = DOWN_INT | XP_PULL_UP_EN | \</span></span><br><span class="line"><span class="meta">                            XP_AIN | XM_HIZ | YP_AIN | YM_GND | \</span></span><br><span class="line"><span class="meta">                            XP_PST(WAIT_INT_MODE);&#125;</span></span><br><span class="line"><span class="comment">/*进入“等待中断模式”，等待触摸屏被松开*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_up_int() &#123;   ADCTSC = UP_INT | XP_PULL_UP_EN | \</span></span><br><span class="line"><span class="meta">                            XP_AIN | XM_HIZ | YP_AIN | YM_GND | \</span></span><br><span class="line"><span class="meta">                            XP_PST(WAIT_INT_MODE);&#125;</span></span><br><span class="line"><span class="comment">/*进入自动（连续）x/y轴坐标转换模式*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mode_auto_xy()  &#123;ADCTSC = CONVERT_AUTO | XP_PULL_UP_DIS | XP_PST(NOP_MODE);&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="触摸屏中断处理函数：转换触摸屏的工作模式"><a href="#触摸屏中断处理函数：转换触摸屏的工作模式" class="headerlink" title="触摸屏中断处理函数：转换触摸屏的工作模式"></a>触摸屏中断处理函数：转换触摸屏的工作模式</h4><p>执行Test_Ts函数之后，触摸屏控制器处于“等待Pen Down中断模式”。这时，如果按下触摸屏，则发生INT_TC中断，进入AdcTsIntHandle中断处理函数。它很简单，只是判断当前中断时INT_TC还是INT_ADC，然后分别调用他们的中断服务程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ADC、触摸屏的中断服务程序</span></span><br><span class="line"><span class="comment">对于INT_TC、INT_ADC中断，分别调用它们的处理程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(SUBSRCPND &amp; BIT_SUB_TC)</span><br><span class="line">        Isr_Tc();</span><br><span class="line">    <span class="keyword">if</span>(SUBSRCPND &amp; BIT_SUB_ADC)</span><br><span class="line">        Isr_Adc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>INT_TC的中断服务程序Isr_Tc代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INT_TC的中断服务程序</span></span><br><span class="line"><span class="comment">当触摸屏被按下时，进入自动（连续）x/y轴坐标转换模式</span></span><br><span class="line"><span class="comment">当触摸屏被松开时，进入等待中断模式，再次等待INT_TC中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ADCDAT0 &amp; <span class="number">0x8000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wait_down_int();                                <span class="comment">//进入“等待中断模式”，等待触摸屏被按下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mode_auto_xy();                                 <span class="comment">//进入自动（连续）x/y轴坐标转换模式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置位[0]为1，启动A/D转换</span></span><br><span class="line"><span class="comment">        注意：ADCDLY为50000，PCLK = 50MHz</span></span><br><span class="line"><span class="comment">            要经过（1/50MHz）x 50000 = 1ms 后才开始转换x坐标</span></span><br><span class="line"><span class="comment">            再经过1ms之后才开始转换y坐标</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ADCCON |= ADC_START;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除INT_TC中断</span></span><br><span class="line">    SUBSRCPND |= BIT_SUB_TC;</span><br><span class="line">    SRCPND |= BIT_ADC;</span><br><span class="line">    INTPND |= BIT_ADC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7行首先判断是“Pen Down”还是“Pen Up”中断，如果是“Pen Up”中断，表示触摸完成，在第9行通过wait_down_int()宏令触摸屏控制器进入“等待Pen Down中断模式”，等待下一次操作。<br>如果是“Pen Down”中断，则在第13行通过mode_auto_xy()宏令触摸屏控制器进入“自动（连续）x&#x2F;y轴坐标转换模式”，然后在20行启动A&#x2F;D转换。也可以使用“分离的x&#x2F;y轴坐标转换模式”手动的分别转换x坐标、y坐标。<br>第24-26行清除INT_TC中断。</p>
<h4 id="在ADC中断处理函数中获取x、y坐标"><a href="#在ADC中断处理函数中获取x、y坐标" class="headerlink" title="在ADC中断处理函数中获取x、y坐标"></a>在ADC中断处理函数中获取x、y坐标</h4><p>在“自动（连续）x&#x2F;y轴坐标转换模式”下，x、y坐标都转换完毕后，产生INT_ADC中断，进入AdcTsIntHandle中断处理函数，它进而调用INT_ADC的中断服务程序Isr_Adc，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INT_ADC的中断服务程序</span></span><br><span class="line"><span class="comment">A/D转换结束时发生此中断</span></span><br><span class="line"><span class="comment">先读取x、y坐标值，在进入等待中断模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Isr_Adc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//打印x、y坐标值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xdata = %4d, ydata = %4d\r\n&quot;</span>,(<span class="type">int</span>)(ADCDAT0 &amp; <span class="number">0x3ff</span>),(<span class="type">int</span>)(ADCDAT1 &amp; <span class="number">0x3ff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是S3C2410还是S3C2440</span></span><br><span class="line">    <span class="keyword">if</span>((GSTATUS1 == <span class="number">0x32410000</span>) || (GSTATUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//S3C2410</span></span><br><span class="line">        wait_down_int();        <span class="comment">//进入“等待中断模式”，等待触摸屏松开</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//S3C2440</span></span><br><span class="line">        wait_up_int();          <span class="comment">//进入“等待中断模式”，等待触摸屏松开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除INT_ADC中断</span></span><br><span class="line">    SUBSRCPND |= BIT_SUB_ADC;</span><br><span class="line">    SRCPND |= BIT_ADC;</span><br><span class="line">    INTPND |= BIT_ADC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，第9行从ADCDAT0、ADCDAT1寄存器中读出x、y的值，并打印出来。然后，通过第13（S3C2410）、18（S3C2440）行进入“等待Pen Up中断模式”，等待触摸屏松开。S3C2410的触摸屏控制器既等待Pen Down中断，又等待Pen Up中断；S3C2440的触摸屏控制器可以分开设置：等待被按下或（和）等待被松开。<br>最后，第22-24行清除ADC中断。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第14章 ADC和TP接口</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>ADC数模转化</tag>
        <tag>Touchscreen</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核调试技术</title>
    <url>/2022/09/20/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统移植之Linux内核调试技术</p>
<p>《嵌入式Linux应用完全开发手册》第3篇第18章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>掌握几种调试内核的方法：printk、kgdb、分析Oops、栈回溯</li>
<li>使用调试工具：gdb、ddd</li>
</ol>
<h1 id="内核打印函数printk"><a href="#内核打印函数printk" class="headerlink" title="内核打印函数printk"></a>内核打印函数printk</h1><h2 id="printk的使用"><a href="#printk的使用" class="headerlink" title="printk的使用"></a>printk的使用</h2><h3 id="printk函数的记录级别"><a href="#printk函数的记录级别" class="headerlink" title="printk函数的记录级别"></a>printk函数的记录级别</h3><p>调试内核、驱动最简单的方法，是使用printk函数打印信息。printk函数与用户空间的printf函数格式完全相同，它所打印的字符串头部可以加入“<n>”样式的字符，其中n为0-7，表示这条信息的记录级别。<br>在内核代码<code>include/linux/kernel.h</code>中，下面几个宏控制了printk函数所能输出的信息的记录级别。</n></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> console_loglevel (console_printk[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_message_loglevel (console_printk[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> minimun_message_loglevel (console_printk[2])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_console_loglevel (console_printk[3])</span></span><br></pre></td></tr></table></figure>
<p>举例说明这几个宏的含义。<br>①对于printk(“<n>…”)，只有n小于console_loglevel时，这个信息才会被打印。<br>②假设default_message_loglevel的值小于4，如果printk的参数开头没有“<n>”样式的字符，则在printk函数中进一步处理前会自动加上“&lt;4&gt;”；<br>③minimun_console_loglevel是一个预设值，平时不起作用。通过其他工具来设置console_loglevel的值时，这个值不能小于minimun_console_loglevel。<br>④default_console_loglevel也是一个预设值，平时不起作用。它表示设置console_loglevel时的默认值，通过其他工具来设置console_loglevel的值时，会用到这个值。</n></n></p>
<p>minimun_console_loglevel和default_console_loglevel这两个值的作用，可以参考内核源文件<code>kernel/printk.c</code>的<code>do_syslog</code>函数。<br>上面代码中，console_printk是一个数组，它在<code>kernel/printk.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* printk&#x27;s without a loglevel use this.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MESSAGE_LOGLEVEL 4 <span class="comment">/* KERN_WARNING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We show everything that is MORE important than this.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINIMUM_CONSOLE_LOGLEVEL 1 <span class="comment">/* Minimum loglevel we let people use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CONSOLE_LOGLEVEL 7 <span class="comment">/* anything MORE serious than KERN_DEBUG */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> console_printk[<span class="number">4</span>] = &#123;</span><br><span class="line">	DEFAULT_CONSOLE_LOGLEVEL,	<span class="comment">/* console_loglevel */</span></span><br><span class="line">	DEFAULT_MESSAGE_LOGLEVEL,	<span class="comment">/* default_message_loglevel */</span></span><br><span class="line">	MINIMUM_CONSOLE_LOGLEVEL,	<span class="comment">/* minimum_console_loglevel */</span></span><br><span class="line">	DEFAULT_CONSOLE_LOGLEVEL,	<span class="comment">/* default_console_loglevel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="在用户空间修改printk函数的记录级别"><a href="#在用户空间修改printk函数的记录级别" class="headerlink" title="在用户空间修改printk函数的记录级别"></a>在用户空间修改printk函数的记录级别</h3><p>挂接proc文件系统后，读取<code>/proc/sys/kernel/printk</code>文件可以得知console_loglevel、default_message_loglevel、minimun_console_loglevel和default_console_loglevel这4个值。<br>比如执行以下命令，它的结果是“7 4 1 7”表示这4个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/printk</span><br><span class="line">7   4   1   7</span><br></pre></td></tr></table></figure>
<p>也可以直接修改<code>/proc/sys/kernel/printk</code>文件来改变这4个值，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;1 4 1 7&quot; &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>
<p>这使得console_loglevel被改为1，于是所有的printk信息都不会被打印。</p>
<h3 id="printk函数记录级别的名称及使用"><a href="#printk函数记录级别的名称及使用" class="headerlink" title="printk函数记录级别的名称及使用"></a>printk函数记录级别的名称及使用</h3><p>在内核代码<code>include/linux/kernel.h</code>中有如下代码，它们表示0-7这8个记录级别的名称。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_EMERG	<span class="string">&quot;&lt;0&gt;&quot;</span>	<span class="comment">/* system is unusable			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_ALERT	<span class="string">&quot;&lt;1&gt;&quot;</span>	<span class="comment">/* action must be taken immediately	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_CRIT	<span class="string">&quot;&lt;2&gt;&quot;</span>	<span class="comment">/* critical conditions			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_ERR	<span class="string">&quot;&lt;3&gt;&quot;</span>	<span class="comment">/* error conditions			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_WARNING	<span class="string">&quot;&lt;4&gt;&quot;</span>	<span class="comment">/* warning conditions			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_NOTICE	<span class="string">&quot;&lt;5&gt;&quot;</span>	<span class="comment">/* normal but significant condition	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_INFO	<span class="string">&quot;&lt;6&gt;&quot;</span>	<span class="comment">/* informational			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_DEBUG	<span class="string">&quot;&lt;7&gt;&quot;</span>	<span class="comment">/* debug-level messages			*/</span></span></span><br></pre></td></tr></table></figure>
<p>在使用printk函数时，可以这样使用记录级别；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk(KERN_WARNING<span class="string">&quot;there is a warning here!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="串口控制台"><a href="#串口控制台" class="headerlink" title="串口控制台"></a>串口控制台</h2><h3 id="串口与printk函数的关系"><a href="#串口与printk函数的关系" class="headerlink" title="串口与printk函数的关系"></a>串口与printk函数的关系</h3><p>在嵌入式Linux开发中，printk信息常常从串口输出，这时串口被称为串口控制台。从内核<code>kernel/printk.c</code>的printk函数开始，往下查看它的调用关系，可以知道printk函数是如何与具体设备的输出函数挂钩的。<br>printk函数调用的子函数的主要脉络如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printk  -&gt;</span><br><span class="line">    vprintk -&gt;</span><br><span class="line">        emit_log_char   //把要打印的数据写入一个全局缓冲区（log_buf）中</span><br><span class="line">        release_console_sem -&gt;</span><br><span class="line">            call_console_drivers -&gt;</span><br><span class="line">                _call_console_drivers -&gt;</span><br><span class="line">                    __call_console_drivers -&gt;</span><br><span class="line">                        con-&gt;write  //con是console_drivers链表的表项，调用具体的输出函数</span><br></pre></td></tr></table></figure>
<p>对于可以作为控制台的设备，在初始化时会通过register_console函数向console_drivers链表注册一个console结构，里面有write函数指针。<br>以<code>drivers/serial/s3c2410.c</code>文件中的串口初始化函数s3c24xx_serail_initconsole为例，它的部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_serial_initconsole</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	register_console(&amp;s3c24xx_serial_console);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第4行的s3c24xx_serial_console就是console结构，它在相同的文件中定义，部分内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console</span> <span class="title">s3c24xx_serial_console</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">	.name		= S3C24XX_SERIAL_NAME,                  <span class="comment">//这个宏被定义为“SAC”</span></span><br><span class="line">	.device		= uart_console_device,                  <span class="comment">//init进行、用户程序打开/dev/console时用到</span></span><br><span class="line">	.flags		= CON_PRINTBUFFER,                      <span class="comment">//打印先前在log_buf中保存的信息</span></span><br><span class="line">	.index		= <span class="number">-1</span>,                                   <span class="comment">//表示使用哪个串口由命令行决定</span></span><br><span class="line">	.write		= s3c24xx_serial_console_write,         <span class="comment">//串口控制台的输出函数</span></span><br><span class="line">	.setup		= s3c24xx_serial_console_setup          <span class="comment">//串口控制台的设置函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第5行的CON_PRINTBUFFER表示注册这个结构之后，要把log_buf缓冲区中的所有信息打印出来。这表明，在实际的硬件被初始化之前，就可以使用printk函数，只不过这时的打印信息时保存在log_buf缓冲区中，还没有真正输出。<br>第7行的s3c24xx_serial_console_write是串口输出函数，它会调用s3c24xx_serial_console_putchar函数将要打印的字符一个一个的从串口输出。<br>s3c24xx_serial_console_putchar是最底层的函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">s3c24xx_serial_console_putchar</span><span class="params">(<span class="keyword">struct</span> uart_port *port, <span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ufcon = rd_regl(cons_uart, S3C2410_UFCON);</span><br><span class="line">	<span class="keyword">while</span> (!s3c24xx_serial_console_txrdy(port, ufcon))</span><br><span class="line">		barrier();</span><br><span class="line">	wr_regb(cons_uart, S3C2410_UTXH, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以知道，从串口输出printk打印信息时，是一个一个字符地发送、等待发送完成、发送、接着等待，…，效率很低。调试完毕后，通常需要将printk信息去掉。</p>
<h3 id="设置内核命令行参数使用串口控制台"><a href="#设置内核命令行参数使用串口控制台" class="headerlink" title="设置内核命令行参数使用串口控制台"></a>设置内核命令行参数使用串口控制台</h3><p>在使用U-Boot时，设置了命令行参数“console&#x3D;ttySAC0”，它使得printk的信息从串口0输出。<br>内核是怎样根据这些命令行参数确定printk的输出设备呢，在<code>kernel/printk.c</code>中有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__setup(&quot;console=&quot;,console_setup);</span><br></pre></td></tr></table></figure>
<p>内核开始执行时，发现形如“console&#x3D;…”的命令行参数时，就会调用console_setup函数进行解析。对于命令行参数“console&#x3D;ttySAC0”，它会解析出：设备名（name）为ttySAC，索引（index）为0，这些信息被保存在类型为console_cmdline、名称为console_cmdline的全局数组中。<br>在后面使用“register_console(&amp;s3c24xx_serial_cosole)”注册控制台时，会将s3c24xx_serial_cosole结构与console_cmdline数组中的设备进行比较，发现名字、索引相同。<br>①s3c24xx_serial_console结构中名字（name）为S3C24XX_SERIAL_NAME，即“ttySAC”，而根据“console&#x3D;ttySAC0”解析出来的名字也是“ttySAC”。<br>②s3c24xx_serial_console结构中索引为-1，表示使用命令行中解析出来的索引0，表示串口0。<br>综上所述，命令行参数“console&#x3D;ttySAC0”决定printk信息将通过s3c24xx_serial_console结构中的相关函数，从串口0输出。<br>最后，既然printk输出的信息是先保存在缓冲区log_buf中，那么也可以读取log_buf以获得这些信息：系统启动后，想查看printk信息时，直接运行dmesg命令即可。通过其他非串口的手段（ssh、telnet）登录系统时，也可以使用dmesg查看printk信息。</p>
<h1 id="内核源码级别的调试方法"><a href="#内核源码级别的调试方法" class="headerlink" title="内核源码级别的调试方法"></a>内核源码级别的调试方法</h1><h2 id="内核调试工具KGDB的作用与原理"><a href="#内核调试工具KGDB的作用与原理" class="headerlink" title="内核调试工具KGDB的作用与原理"></a>内核调试工具KGDB的作用与原理</h2><h3 id="KGDB介绍"><a href="#KGDB介绍" class="headerlink" title="KGDB介绍"></a>KGDB介绍</h3><p>KGDB是一个源码级别的Linux内核调试器。使用KGDB调试内核时，需要结合GDB一起使用。它们使得调试内核就像调试调试应用程序一样，可以在内核代码中设置断点、一步一步地执行指令、观察变量的值。<br>使用KGDB时，需要两台机器，即主机和目标机，两者通过串口线相连。要调试的内核需要增加KGDB功能，它在目标机上运行，GDB在主机上运行。串口线被GDB用来与内核通信。<br>KGDB是一个内核补丁，目前支持i386、x86_64、ppc、s390、ARM等架构。将内核打上KGDB补丁后才能够使用GDB来调试。</p>
<h3 id="KGDB的原理"><a href="#KGDB的原理" class="headerlink" title="KGDB的原理"></a>KGDB的原理</h3><p>安装KGDB调试环境需要为Linux内核加上kgdb补丁，补丁实现GDB远程调试所需要的功能，包括命令处理、陷阱处理及串口通信3个主要的部分。KGDB补丁的主要作用是在Linux内核中添加一个调试stub。调试stub是Linux内核中的一小段代码，是运行GDB的开发机和所调试内核之间的一个媒介。GDB和调试stub之间通过GDB串行协议进行通信。GDB串行协议是一种基于消息的ASCII码协议，包含了各种调试命令。当设置断点时，KGDB将断点的指令替换为一条trap指令，当执行到断点时控制权就转移到调试stub中去。此时，调试stub的任务就是使用远程串行通信协议将当前环境传送给GDB，然后从GDB处接收命令。GDB命令告诉stub下一步做什么，当stub收到继续执行的命令时，将恢复程序的运行环境，把对CPU的控制权重新交给内核。<br>KGDB补丁给内核添加以下3个部件。</p>
<ol>
<li>GDB stub<br>GDB stub被称为调试桩机（简称stub），是KGDB调试器的核心。它是Linux内核中的一小段代码，用来处理主机上GDB发来的各种请求；并且在内核处于被调试状态时，控制目标板上的机器。</li>
<li>修改异常处理函数<br>当这个异常发生时，内核将控制权交给KGDB调试器，程序进入KGDB提供的异常处理函数中。在里面，可以分析程序的各种情况。</li>
<li>串口通信<br>GDB和stub之间通过GDB串行协议进行通信。它是基于消息的ASCII码协议，包含了各种调试命令。<br>除串口外，也可以使用网卡进行通信。<br>以设置内核断点为例说明KGDB与GDB之间的工作过程。设置断点时，KGDB修改内核代码，将断点位置的指令替换成一条异常指令（在ARM中这是一条未定义的指令）。当执行到断点发生异常时，控制权将转移到stub的异常处理函数中。此时，stub的任务就是使用GDB串行通信协议将当前环境传送给GDB，然后从GDB接收命令，GDB命令告诉stub下一步该做什么。当stub收到继续执行的命令时，将恢复原来替换的指令、恢复程序的运行环境，把对CPU的控制权重新交还给内核。</li>
</ol>
<h2 id="给内核添加KGDB功能支持S3C2410-x2F-S3C2440"><a href="#给内核添加KGDB功能支持S3C2410-x2F-S3C2440" class="headerlink" title="给内核添加KGDB功能支持S3C2410&#x2F;S3C2440"></a>给内核添加KGDB功能支持S3C2410&#x2F;S3C2440</h2><h3 id="给内核添加KGDB补丁"><a href="#给内核添加KGDB补丁" class="headerlink" title="给内核添加KGDB补丁"></a>给内核添加KGDB补丁</h3><p>略</p>
<h3 id="修改补丁本身带入的错误"><a href="#修改补丁本身带入的错误" class="headerlink" title="修改补丁本身带入的错误"></a>修改补丁本身带入的错误</h3><p>略</p>
<h3 id="编写S3C2410-x2F-S3C2440的KGDB串口函数"><a href="#编写S3C2410-x2F-S3C2440的KGDB串口函数" class="headerlink" title="编写S3C2410&#x2F;S3C2440的KGDB串口函数"></a>编写S3C2410&#x2F;S3C2440的KGDB串口函数</h3><p>目前的KGDB补丁不支持S3C2410&#x2F;S3C2440的串口，需要自己编写相关函数。可以参考<code>arch/arm/mach-pxa/kgdb-serial.c</code>，在<code>arch/arm/mach-s3c2410/</code>目录下也建立一个kgdb-serial.c文件。<br>KGDB只需要3个函数：初始化函数、发送单字符函数、接收单字符函数。然后将它们填入同一文件中，一个名为kgdb_io_ops的struct kgdb_io结构中。</p>
<ol>
<li>串口初始化函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kgdb_serial_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clock_p</span>;</span></span><br><span class="line">    u32 pclk;</span><br><span class="line">    u32 ubrdiv;</span><br><span class="line">    u32 val;</span><br><span class="line">    u32 index = CONFIG_KGDB_PORT_NUM;</span><br><span class="line"></span><br><span class="line">    clock_p = clk_get(<span class="literal">NULL</span>,<span class="string">&quot;pclk&quot;</span>);</span><br><span class="line">    pclk = clk_get_rate(clock_p);</span><br><span class="line"></span><br><span class="line">    ubrdiv = (pclk / (UART_BAUDRATE * <span class="number">16</span>)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置GPIO用作串口，并且禁止内部上拉</span></span><br><span class="line"><span class="comment">        GPH2 GPH3 用作TXD0、RXD0</span></span><br><span class="line"><span class="comment">        GPH4 GPH5 用作TXD1、RXD1</span></span><br><span class="line"><span class="comment">        GPH6 GPH3 用作TXD2、RXD2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt; MAX_PORT)</span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">2</span> + index * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        val = inl(S3C2410_GPHUP) | (<span class="number">0x3</span> &lt;&lt; index);</span><br><span class="line">        outl(val,S3C2410_GPHUP);</span><br><span class="line"></span><br><span class="line">        index *= <span class="number">2</span>;</span><br><span class="line">        val = (inl(S3C2410_GPHCON) &amp; ~(~(<span class="number">0xF</span> &lt;&lt; index))) |  \</span><br><span class="line">              (<span class="number">0xA</span> &lt;&lt; index);</span><br><span class="line">        outl(val,S3C2410_GPHCON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8N1(8个数据位，无校验位，1个停止位)</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_ULCON,<span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中断/查询方式，UART时钟源为PCLK</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_UCON,<span class="number">0x3c5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用FIFO</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_UFCON,<span class="number">0x51</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不使用流控</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_UMCON,<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置波特率</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_UBRDIV,ubrdiv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
要使用串口，需要选择相关的GPIO引脚用作串口，并且设置串口的数据格式、时钟源、波特率等。</li>
<li>发送单字符函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kgdb_serial_putchar</span><span class="params">(u8 c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*等待，知道发送缓冲区中的数据已经全部发送出去*/</span></span><br><span class="line">    <span class="keyword">while</span>(!(rd_regb(CONFIG_KGDB_PORT_NUM,S3C2410_UTRSTAT) &amp; S3C2410_UTRSTAT_TXE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*向UTXH寄存器中写入数据，UART即自动将它发送出去*/</span></span><br><span class="line">    wr_regb(CONFIG_KGDB_PORT_NUM,S3C2410_UTXH,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接收单字符函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kgdb_serial_getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*等待，直到接收缓冲区中有数据*/</span></span><br><span class="line">    <span class="keyword">while</span>(!(rd_regb(CONFIG_KGDB_PORT_NUM,S3C2410_UTRSTAT) &amp; S3C2410_UTRSTAT_RXDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*直接读取URXH寄存器，即可获得接收到的数据*/</span></span><br><span class="line">    <span class="keyword">return</span> rd_regb(CONFIG_KGDB_PORT_NUM,S3C2410_TRXH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用这些函数构建kgdb_io_ops结构。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kgdb_io</span> <span class="title">kgdb_io_ops</span> =</span> &#123;</span><br><span class="line">    .init = kgdb_serial_init,</span><br><span class="line">    .read_char = kgdb_serial_getchar,</span><br><span class="line">    .write_char = kgdb_serial_putchar,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
kgdb_io_opsj结构将在<code>kernel/kgdb.c</code>中被用到，这个结构封装了开发板相关的串口操作函数。其他的KGDB代码都是具体开发板无关的。</li>
</ol>
<h3 id="修改内核配置文件、Makefile"><a href="#修改内核配置文件、Makefile" class="headerlink" title="修改内核配置文件、Makefile"></a>修改内核配置文件、Makefile</h3><ol>
<li><p>修改<code>arch/arm/mach-s3c2410/Makefile</code>，将新增的kgdb-serial.c文件编译进内核。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ obj-$(CONFIG_KGDB_S3C24XX_SERIAL) += kgdb-serial.o</span><br></pre></td></tr></table></figure></li>
<li><p>上面的CONFIG_KGDB_S3C24XX_SERIAL是新加的配置项，是修改配置文件lib&#x2F;Kconfig.kgdb来支持它。<br>修改了4个地方，下面的修改内容仿照补丁文件的格式，首字母为“-”的行表示是老文件中的代码，首字母为“+”的行表示是新文件中的代码。<br>①在“Method for KGDB communication”下增加一个选择项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choice </span><br><span class="line">    prompt &quot;Method for KGDB communication&quot;</span><br><span class="line">    depends on KGDB</span><br><span class="line">+   default KGDB_S3C24XX_SERIAL if ARCH_S3C2410</span><br></pre></td></tr></table></figure>
<p>②用来配置KGDB_S3C24XX_SERIAL选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+   config KGDB_S3C24XX_SERIAL</span><br><span class="line">+   bool &quot;KGDB: On the S3C24XX serial port&quot;</span><br><span class="line">+   depends on ARCH_S3C2410</span><br><span class="line">+   help    </span><br><span class="line">+       Enables the KGDB serial driver for s3c24xx</span><br></pre></td></tr></table></figure>
<p>③配置KGDB_S3C24XX_SERIAL后，也可以设置KGDB所用的串口的波特率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config KGDB_BAUDRATE</span><br><span class="line">        int &quot;Debug serial port baud rate&quot;</span><br><span class="line">        depends on (KGDB_8250 &amp;&amp; KGDB_SIMPLE_SERIAL) || \</span><br><span class="line">                KGDB_MPSC || KGDB_CPM_UART || \</span><br><span class="line">-               KGDB_TXX9 || KGDB_PXA_SERIAL || KGDB_AMBA_PL011</span><br><span class="line">-               KGDB_TXX9 || KGDB_PXA_SERIAL || KGDB_AMBA_PL011 || KGDB_S3C24XX_SERIAL</span><br></pre></td></tr></table></figure>
<p>④配置KGDB_S3C24XX_SERIAL后，也可以设置KGDB使用哪个串口，默认使用第1个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config KGDB_PORT_NUM</span><br><span class="line">        int &quot;Serial port number for KGDB&quot;</span><br><span class="line">        range 0 1 if KGDB_MPSC</span><br><span class="line">        range 0 3</span><br><span class="line">-       depends on (KGDB_8250 &amp;&amp; KGDB_SIMPLE_SERIAL) || KGDB_MPSC || KGDB_TXX9</span><br><span class="line">-       default &quot;1&quot;</span><br><span class="line">+       depends on (KGDB_8250 &amp;&amp; KGDB_SIMPLE_SERIAL) || KGDB_MPSC || KGDB_TXX9 || KGDB_S3C24XX_SERIAL</span><br><span class="line">+       default &quot;0&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置内核，使能KGDB功能<br>执行“make menuconfig”来配置内核，如下配置以使能KGDB功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kernel hacking ---&gt;</span><br><span class="line">    [*]KGDB: kernel debugging with remote gdb   //表示使能KGDB</span><br><span class="line">    [*]KGDB: Console messages through gdb       //表示控制台信息（printk）会发送到GDB</span><br><span class="line">        Method for KGDB communication (KGDB: On the S3C24XX serial port) ---&gt;   //S3C24XX串口</span><br><span class="line">        &lt;&gt;KGDB: On ethernet (NEW)</span><br><span class="line">        (115200) Debug serial port baud rate (NEW)      //波特率115200</span><br><span class="line">        (0) Serial port number for KGDB (NEW)           //使用第一个S3C24XX串口</span><br></pre></td></tr></table></figure>
<p>然后执行“make uImage”即可生成内核vmlinux、arch&#x2F;arm&#x2F;boot&#x2F;uImage。</p>
</li>
</ol>
<h2 id="结合可视化图形前端DDD和GDB来调试内核"><a href="#结合可视化图形前端DDD和GDB来调试内核" class="headerlink" title="结合可视化图形前端DDD和GDB来调试内核"></a>结合可视化图形前端DDD和GDB来调试内核</h2><h3 id="DDD介绍与安装"><a href="#DDD介绍与安装" class="headerlink" title="DDD介绍与安装"></a>DDD介绍与安装</h3><p>略</p>
<h3 id="GDB介绍及安装"><a href="#GDB介绍及安装" class="headerlink" title="GDB介绍及安装"></a>GDB介绍及安装</h3><p>通过GDB这类调试器，程序员可以知道一个程序执行时内部动作过程，可以知道一个程序崩溃时发生了什么事。<br>GDB可以完成以下4个主要功能，这可以帮助程序员捕捉到程序的错误。</p>
<ol>
<li>启动程序，并指定各类能够影响程序运行的参数。</li>
<li>使程序在指定条件下停止运行。</li>
<li>当程序停止时，观察各种状态，检查发生了什么事情</li>
<li>修改程序的执行参数，比如修改某个变量，这使得查错时可以试验各种参数。<br>GDB支持多种编程语言，可以调试用c&#x2F;c++、Modula-2和Fortan等语言编写的程序。GDB是基于命令行的，GDB启动后，在它的控制界面使用各种命令进行操作。<br>Ubuntu 7.10自带的GDB工具是基于X86系列的，需要自己下载源码为ARM平台编译的一个GDB工具，为便于区分，将它命名为arm-linux-gdb。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xjf gdb-6.7.tar.bz2</span><br><span class="line">cd gdb-6.7/</span><br><span class="line">./configure --target=arm-linux</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用arm-linux-gdb-调试内核（命令行方式）"><a href="#使用arm-linux-gdb-调试内核（命令行方式）" class="headerlink" title="使用arm-linux-gdb 调试内核（命令行方式）"></a>使用arm-linux-gdb 调试内核（命令行方式）</h3><p>先启动支持KGDB的内核，然后在主机上启动arm-linux-gdb。</p>
<ol>
<li>启动内核<br>要使用KGDB功能，需要增加两个命令参数，：console&#x3D;kgdb和kgdbwait。前者表示内核打印信息会被发送给GDB，即通过什么增加的kgdb-serial.c中的相关函数进行发送；后者表示内核启动时先停住，等待GDB的连接。<br>假设将上面编译好的内核uImage放在<code>/work/nfs_root</code>目录下，则可以在U-Boot上使用以下命令设置命令行参数、启动内核。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set bootargs noinitrd root=/dev/mtdblock 2 console=kgdb kgdbwait</span><br><span class="line">nfs 0x31000000 192.168.1.57:/work/nfs_root/uImage</span><br><span class="line">bootm 0x31000000</span><br></pre></td></tr></table></figure>
这时可以看到以下启动信息：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting kernel ...</span><br><span class="line">Uncompressing</span><br><span class="line">Linux .......................................done,booting the kernel.</span><br></pre></td></tr></table></figure>
内核在等待主机arm-linux-gdb的连接。</li>
<li>启动arm-linux-gdb<br>启动arm-linux-gdb之前，先退出刚才操作U-Boot所用的工具，因为arm-linux-gdb也要使用这个串口。<br>然后在主机上进入内核目录，启动arm-linux-gdb，可以执行以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/system/linux-2.6.22.6</span><br><span class="line">sudo arm-linux-gdb ./vmlinux</span><br></pre></td></tr></table></figure>
这时会看到arm-linux-gdb的启动信息，进入控制界面：<br><img src="/2022/09/20/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/1.jpeg" alt="img not found"><br>最后，执行两个命令设置口、连接目标板。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set remotebaud 115200</span><br><span class="line">(gdb) target remote /dev/ttyS0</span><br></pre></td></tr></table></figure>
这时就会看到如下信息，表明已经连接上目标板，目标板在<code>kernel/kgdb.c</code>的1775行暂停运行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remote debugging using /dev/ttyS0</span><br><span class="line">0xc0067a28 in breakpoint () at kernel/kdb.c:1775</span><br><span class="line">1775            atomic_set(&amp;kgdb_setting_breakpoint,1);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
现在就可以使用GDB的命令控制内核的执行、进行调试了。比如输入n命令执行下一条指令，输入c命令全速运行，输出q命令退出。<br>为了避免每次启动arm-linux-gdb时手工设置串口、连接目标板，可以在内核目录建立一个名为“.gdbinit”文件，内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set remotebaud 115200</span><br><span class="line">target remote /dev/ttyS0</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="通过DDD调用arm-linux-gdb来调试内核（图形界面）"><a href="#通过DDD调用arm-linux-gdb来调试内核（图形界面）" class="headerlink" title="通过DDD调用arm-linux-gdb来调试内核（图形界面）"></a>通过DDD调用arm-linux-gdb来调试内核（图形界面）</h3><p>略</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第3篇第18章 Linux内核调试技术</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动程序</title>
    <url>/2022/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux设备驱动开发之字符设备驱动程序</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第19章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解Linux系统中驱动程序的地位和作用</li>
<li>了解驱动程序开发的一般流程</li>
<li>掌握简单的字符设备驱动程序的开发方法</li>
</ol>
<h1 id="Linux驱动程序开发概述"><a href="#Linux驱动程序开发概述" class="headerlink" title="Linux驱动程序开发概述"></a>Linux驱动程序开发概述</h1><h2 id="应用程序、库、内核、驱动程序的关系"><a href="#应用程序、库、内核、驱动程序的关系" class="headerlink" title="应用程序、库、内核、驱动程序的关系"></a>应用程序、库、内核、驱动程序的关系</h2><p>从上到下，一个软件系统可以分为：应用程序、库、操作系统、驱动程序。开发人员可以专注于自己熟悉的部分，对于相邻层，只需要了解它的接口，无需关注它的实现细节。<br>以点亮一个LED为例，这4层软件的协作关系如下：<br><img src="/2022/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1.jpeg" alt="img not found"></p>
<ol>
<li>应用程序使用库提供的open函数打开代表LED的设备文件。</li>
<li>库根据open函数传入的参数执行“swi”指令，这条指令会引起CPU异常，进入内核。</li>
<li>内核的异常处理函数根据这些参数找到相应的驱动程序，返回一个句柄给库，进而返回给应用程序。</li>
<li>应用程序得到文件句柄后，使用库提供的write或ioctl函数发出控制命令。</li>
<li>库根据write或ioctl函数传入的参数执行“swi”指令，这条指令会引起CPU异常，进入内核。</li>
<li>内核的异常处理函数根据这些参数调用驱动程序的相关函数，点亮LED。</li>
</ol>
<p>库（例如glic）给应用程序提供的open、read、write、ioctl、mmap函数等接口函数称为系统调用，它们都是设置好相关寄存器后，执行某条指令引发异常进入内核。对于ARM架构的CPU，这条指令为swi。除系统调用接口之外，库还提供其他函数，比如字符串处理函数，输入输出函数，数学库，还有应用程序的启动代码。<br>在异常处理函数中，内核会根据传入的参数执行各种操作，比如根据设备文件找到对应的驱动程序，调用驱动程序的相关函数等。<br>一般来说，当应用程序调用open、read、write、ioctl、mmap等函数后，将会使用驱动程序中的open、read、write、ioctl、mmap函数来进行相关操作。比如初始化、读、写等。<br>实际上，内核和驱动程序之间并没有界限，因为驱动程序最终要编进内核去的：通过静态链接或动态加载。<br>从上面操作LED的过程可以知道，与应用程序不同，驱动程序从不主动进行，它是被动的：根据应用程序的要求进行初始化，根据应用程序的要求进行读写。驱动程序加载进内核时，只是告诉内核“我这这里，我能做这些工作”，至于“工作”何时开始，取决于应用程序。当然，这不是绝对的，比如用户完全可以写一个由系统时钟触发的驱动程序，让它自己点亮LED。<br>在Linux系统中，应用程序运行于“用户空间”，拥有MMU的系统能够限制应用程序的权限（比如将它限制在某一块内存中），这可以避免应用程序的错误使整个操作系统崩溃。而驱动程序运行于内核空间，它是系统信任的一部分，驱动程序的错误可能导致整个操作系统崩溃。</p>
<h2 id="Linux-驱动程序的分类和开发步骤"><a href="#Linux-驱动程序的分类和开发步骤" class="headerlink" title="Linux 驱动程序的分类和开发步骤"></a>Linux 驱动程序的分类和开发步骤</h2><h3 id="Linux-驱动程序分类"><a href="#Linux-驱动程序分类" class="headerlink" title="Linux 驱动程序分类"></a>Linux 驱动程序分类</h3><p>Linux的外设可以分为3类：字符设备、块设备和网络接口。<br>字符设备是能够像字节流一样被访问的设备，就是说对它的读写是以字节为单位的。比如串口在进行收发数据时就是一个一个字节进行的，我们可以在驱动程序内部使用缓冲区来存放数据以提高效率，但是串口本身对这并没有要求。字符设备的驱动程序中实现了open、close、read、write等系统调用，应用程序可以通过设备文件（比如&#x2F;dev&#x2F;ttySAC0等）来访问字符设备。<br>块设备上的数据以块的形式存放，比如NAND Flash上的数据就是以页为单位存放的。块设备驱动程序向用户层提供的接口与字符设备一样，应用程序也可以通过相应的设备文件（&#x2F;dev&#x2F;mtdblock0、&#x2F;dev&#x2F;hda1）来调用open、close、read、write等系统调用，与块设备传送任意字节的数据。对用户而言，字符设备和块设备的访问方式没有差别。块设备驱动程序的特别之处如下：</p>
<ol>
<li>操作硬件的接口实现方式不一样。<br>块设备驱动程序先将用户发来的数据组织成块，在写入设备；或从设备中读出若干块数据，再从中挑出用户需要的。</li>
<li>数据块上的数据可以有一定的格式<br>通常在块设备上按照一定的格式存放数据，不同文件系统类型就是用来定义这些格式的。内核中，文件系统的层次位于块设备块驱动程序上面，这意味着块设备驱动程序除了向用户层提供像字符设备一样的接口之外，还要向内核其他部件提供一些接口，这些接口用户是看不到的。这些接口使得可以在块设备上存放文件系统，挂接块设备。<br>网络设备同时具有字符设备、块设备的部分特点，无法将它归入两类中：如果说它是字符设备，它的输入输出确是有结构的、成块的（报文、包、帧）；如果说它是块设备，它的块又不是固定大小的，大到几百几千字节，小到几字节。UNIX式的操作系统访问网络接口的方法是给它们分配一个唯一的名字（eth0），但这个名字在文件系统中不存在对应的文件节点。应用程序、内核和网络驱动程序之间的通信完全不同于字符设备、块设备。库、内核还提供了一套和数据包传输相关的函数，而不是open、read、write等。</li>
</ol>
<h3 id="Linux-驱动程序开发步骤"><a href="#Linux-驱动程序开发步骤" class="headerlink" title="Linux 驱动程序开发步骤"></a>Linux 驱动程序开发步骤</h3><p>Linux内核就是由各种驱动组成，内核源码中有大约85%是各种驱动程序的代码。内核中驱动程序种类齐全，可以在同类型驱动的基础上进行修改以符合具体单板。<br>编写驱动程序的难点并不是硬件的具体操作，而是弄清楚现有驱动程序的框架，在这个框架中加入这个硬件。比如，x86架构的内核对IDE硬盘的支持非常完善：首先通过BIOS得到硬盘的信息，或者使用默认的I&#x2F;O地址去枚举硬盘，然后识别分区、挂接文件系统。对于其他架构的内核，只要指定了硬盘的访问地址和中断号，后面的枚举、识别和挂接的过程完全是一样的。也许修改的代码不超过10行，花费精力的地方在于：了解硬盘驱动的框架，找到修改的位置。<br>编写驱动程序还有很多需要注意的地方，比如：驱动程序可能同时被多个进程使用，这需要考虑并发的问题；尽可能发挥硬件的作用以提高性能。比如在硬盘驱动程序中既可以使用DMA也可以不用，使用DMA时程序比较复杂，但是可以提高效率；处理硬件的各种异常情况，否则出错时可能导致整个系统崩溃。<br>一般来说，编写一个Linux设备驱动程序的大致流程如下。</p>
<ol>
<li>查看原理图、数据手册，了解设备的操作方法。</li>
<li>在内核中找到相近的驱动程序，以它为模板进行开发，有时候需要从零开始。</li>
<li>实现驱动程序的初始化：比如向内核注册这个驱动程序，这样应用程序传入文件名时，内核才能找到相应的驱动程序。</li>
<li>设计所要实现的操作：open、read、write、close等。</li>
<li>实现中断服务（中断并不是每个设备驱动所必需的）。</li>
<li>编译该驱动程序到内核中，或者用insmod命令加载。</li>
<li>测试驱动程序。</li>
</ol>
<h2 id="驱动程序的加载和卸载"><a href="#驱动程序的加载和卸载" class="headerlink" title="驱动程序的加载和卸载"></a>驱动程序的加载和卸载</h2><p>可以将驱动程序静态编译进内核中，也可以将它作为模块在使用时加载。在配置内核时，如果某个配置项被设为m，就表示它将会被编译成一个模块。在2.6的内核中，模块的扩展名为.ko，可以只用insmod命令加载，使用rmmod命令卸载，使用lsmod命令查看内核中已经加载了哪些模块。<br>当使用insmode加载模块时，模块的初始化函数被调用，它用来向内核注册驱动程序；当使用rmmod卸载模块时，模块的清除函数被调用。在驱动代码中，这两个函数要么取固定的名字：init_module和cleanup_module，要么使用以下两行来标记它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_cleanup);</span><br></pre></td></tr></table></figure>


<h1 id="字符设备驱动程序开发"><a href="#字符设备驱动程序开发" class="headerlink" title="字符设备驱动程序开发"></a>字符设备驱动程序开发</h1><h2 id="字符设备驱动程序中重要的数据结构和函数"><a href="#字符设备驱动程序中重要的数据结构和函数" class="headerlink" title="字符设备驱动程序中重要的数据结构和函数"></a>字符设备驱动程序中重要的数据结构和函数</h2><p>Linux操作系统将所有的设备看作文件，以操作文件的方式访问设备。应用程序不能直接操作硬件，而是使用统一的接口函数调用硬件驱动程序。这组接口被称为系统调用，在库函数中定义。可以在glibc的fcntl.h、unistd.h、sys&#x2F;ioctl.h等文件中看到如下定义，这些文件也可以在交叉编译工具链的<code>/usr/local/arm/3.4.1/include</code>目录下找到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">open</span><span class="params">(__const <span class="type">char</span> *__file,<span class="type">int</span> __oflag,...)</span>__<span class="title function_">nonnull</span><span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> __fd,<span class="type">void</span> *__buf,<span class="type">size_t</span> __nbyte)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> __fd,__const <span class="type">void</span> *__buf,<span class="type">size_t</span> __n)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> __fd,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __request,...)</span>;__THROW;</span><br></pre></td></tr></table></figure>
<p>对于上述每个系统调用，驱动程序都有一个与之对应的函数。对于字符设备驱动程序，这些函数集合在一个file_operations类型的数据结构中。file_operations结构在Linux内核的<code>include/linux/fs.h</code>文件中定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendfile) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">read_actor_t</span>, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*dir_notify)(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当应用程序使用open函数打开某个设备时，设备驱动程序的file_operations结构中的open成员就会被调用；当应用程序使用read、write、ioctl等函数读写、控制设备时，驱动程序的file_operations结构中的相应成员（read、write、ioctl等）就会被调用。从这个角度来说，编写字符设备驱动程序就是为具体硬件的file_operations结构编写各个函数（并不需要全部实现file_operations结构中的成员）。<br>那么，当应用程序通过open、read、write等系统调用访问某个设备文件时，Linux系统怎么知道去调用哪个驱动程序的file_operations结构中的open、read、write等成员呢。</p>
<ol>
<li>设备文件有主次设备号。<br>设备文件分为字符设备、块设备，比如PC机上的串口属于字符设备，硬盘属于块设备。在PC上运行命令”ls &#x2F;dev&#x2F;ttyS0 &#x2F;dev&#x2F;hda1 -l”可以看到。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brw-rw----  1 root  disk  3,  1 Jan 30  2003  /dev/hda1</span><br><span class="line">crw-rw----  1 root  uucp  4, 64 Jan 30  2003  /dev/ttyS0</span><br></pre></td></tr></table></figure>
“brw-rw—-”中的“b”表示&#x2F;dev&#x2F;hda1是个块设备，它的主设备号是3，次设备号是1；“crw-rw—-”中的“c”表示&#x2F;dev&#x2F;ttyS0是一个字符设备，它的主设备号是4，次设备号是64。</li>
<li>模块初始化时，将主设备号与file_operations结构一起向内核注册。<br>驱动程序有一个初始化函数，在安装驱动程序时会调用它。在初始化函数中，会将驱动程序的file_operations结构连同其主设备号一起向内核进行注册。对于字符设备使用如下函数进行注册。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major,<span class="type">const</span> <span class="type">char</span> *name,<span class="keyword">struct</span> file_operations *fops)</span>;</span><br></pre></td></tr></table></figure>
这样，应用程序操作设备文件时，Linux系统就会根据设备文件的类型（字符设备或者块设备）、主设备号找到在内核中注册的file_operations（对于块设备为block_device_operations结构），次设备号供驱动程序自身来分辨它是同类设备中的第几个。<br>编写字符设备驱动的过程大概如下：<br>①编写驱动程序初始化函数<br>  进行必要的初始化，包括硬件初始化、向内核注册驱动程序等。<br>②构造file_operations结构中要用到的各个成员函数。<br>实际的驱动程序当然比上述两个步骤复杂，但是这两个步骤已经可以让我们编写比较简单的驱动程序，比如LED控制。其他比较高级的技术，比如中断、select机制、fsync异步通知机制，将在其他章节的例子中介绍。</li>
</ol>
<h2 id="LED-驱动程序源码分析"><a href="#LED-驱动程序源码分析" class="headerlink" title="LED 驱动程序源码分析"></a>LED 驱动程序源码分析</h2><p>本书以一个简单的LED驱动程序作为例子，让读者初步了解驱动程序的开发。<br>本书的开发板使用引脚使用引脚GPB5-8外接4个LED，它们的操作方法之前的章节已经做了细致的说明。</p>
<ol>
<li>引脚功能设置为输出。</li>
<li>点亮LED，引脚输出0；熄灭LED，引脚输出1。<br>硬件连接如下图所示：<br><img src="/2022/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/2.jpeg" alt="img not found"></li>
</ol>
<h3 id="LED驱动代码分析"><a href="#LED驱动代码分析" class="headerlink" title="LED驱动代码分析"></a>LED驱动代码分析</h3><p>模块的初始化函数和卸载函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行“insmod s3c24xx_leds.ko”命令时就会调用这个函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3c24xx_leds_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      注册字符设备驱动程序</span></span><br><span class="line"><span class="comment">      参数为主设备号、设备名字、file_operations结构</span></span><br><span class="line"><span class="comment">      这样，主设备号就和具体的file_operations结构联系起来了，</span></span><br><span class="line"><span class="comment">      操作主设备为LED_MAJOR的设备文件时，就会调用s3c24xx_led_fops中的相关成员函数</span></span><br><span class="line"><span class="comment">      LED_MAJOR可以设为0，表示由内核自动分配主设备号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = register_chrdev(LED_MAJOR,DEVICE_NAME,&amp;s3c24xx_led_fops);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(DEVICE_NAME<span class="string">&quot;can&#x27;t register major number\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(DEVICE_NAME<span class="string">&quot;initialized\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行“rmmod s3c24xx_leds.ko”命令时就会调用这个函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">s3c24xx_leds_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*卸载驱动程序*/</span></span><br><span class="line">    unregister_chrdev(LED_MAJOR,DEVICE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这两行知道驱动程序地初始化函数和卸载函数*/</span></span><br><span class="line">module_init(s3c24xx_leds_init);</span><br><span class="line">module_exit(s3c24xx_leds_exit);</span><br></pre></td></tr></table></figure>
<p>最后两行用来指明装载、卸载模块时所调用的函数。也可以不使用这两行，但是需要将这两个函数的名字改为init_module、cleanup_module。<br>执行“insmod s3c24xx_leds.ko”命令时就会调用<code>s3c24xx_leds_init</code>函数，这个函数的核心的代码是<code>register_chrdev</code>函数。它向内核注册驱动程序：将主设备号LED_MAJOR与file_operations结构s3c24xx_leds_fops联系起来。以后应用程序操作主设备号为LED_MAJOR的设备文件时，比如open、read、write、ioctl，s3c24xx_leds_fops中的相应成员函数将会被调用。但是并不需要实现所有成员函数，用到哪个实现哪个。<br>执行“rmmod s3c24xx_leds.ko”命令时就会调用<code>s3c24xx_leds_exit</code>函数，它进而调用<code>unregister_chrdev</code>函数卸载驱动程序，它的功能与<code>register_chrdev</code>函数相反。<br><code>s3c24xx_leds_init</code>、<code>s3c24xx_leds_exit</code>函数前的“__init”、“__exit”只有在将驱动程序静态链接进内核时才有意义。前者表示<code>s3c24xx_leds_init</code>函数的代码被放在<code>“.init.text”</code>段中，这个段在使用一次之后被释放（可以节省内存）；后者表示<code>s3c24xx_leds_exit</code>函数的代码被放在<code>“.exit.data”</code>段中，在连接内核时这个段没有使用，因为不可能卸载静态链接的驱动程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个结构时字符设备驱动程序的核心</span></span><br><span class="line"><span class="comment">    当应用程序操作设备文件时所调用的open、read、write等函数</span></span><br><span class="line"><span class="comment">    最终会调用这个结构中的对应函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">s3c24xx_leds_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,           <span class="comment">//这是一个宏，指向编译模块时主动创建的__this_module变量</span></span><br><span class="line">    .open  = s3c24xx_leds_open,</span><br><span class="line">    .ioctl = s3c24xx_leds_ioctl，</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>宏THIS_MODULE在<code>include/linux/module.h</code>中定义如下，__this_module变量在编译模块时自动创建，无需关注。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THIS_MODULE (&amp;__this_module)</span></span><br></pre></td></tr></table></figure>
<p>file_operations类型的s3c24xx_leds_fops结构是驱动中最重要的数据结构，编写字符设备驱动程序的主要工作也是填充其中的各个成员。比如本驱动程序中用到的open、ioctl成员被设为<code>s3c24xx_leds_open</code>、<code>s3c24xx_leds_fops</code>函数前者用来初始化LED所用的GPIO引脚，后者用来根据用户传入的参数设置GPIO的输出电平。<br>s3c24xx_leds_open函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    应用程序对设备文件/dev/leds执行open时，</span></span><br><span class="line"><span class="comment">    就会调用s3c24xx_leds_open</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_leds_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="comment">//设置GPIO引脚的功能：本驱动中LED所涉及的GPIO引脚设为输出功能</span></span><br><span class="line">        s3c2410_gpio_cfgpin(led_table[i],led_cfg_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在应用程序执行<code>open(&quot;/dev/leds&quot;,...)</code>系统调用时，<code>s3c24xx_leds_open</code>函数将被调用。它用来将LED所涉及的GPIO引脚设为输出功能。不在模块的初始化函数中进行这些设置的原因是：虽然加载了模块，但是这个模块却不一定被用到，就是说这些引脚不一定用于这些用途，它们可能在其他模块中另作他用。所以，在使用时才去设置它，我们把对引的初始化放在open操作中。<br><code>s3c2410_gpio_cfgpin</code>函数是内核中实现的，它用来选择引脚的功能。其实现原理是设置GPIO的控制寄存器。<br>s3c24xx_leds_ioctl函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    应用程序对设备文件/dev/leds 执行ioctl()时，</span></span><br><span class="line"><span class="comment">    就会调用s3c24xx_leds_ioctl函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_leds_ioctl</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swicth(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_LED_ON:</span><br><span class="line">        <span class="comment">//设置指定引脚的输出电平为0</span></span><br><span class="line">        s3c2410_gpio_setpin(led_table[arg],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> IOCTL_LED_OFF:</span><br><span class="line">        <span class="comment">//设置指定引脚的输出电平为1</span></span><br><span class="line">        s3c2410_gpio_setpin(led_table[arg],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用程序执行系统调用<code>ioctl(fd,cmd,arg)</code>时，<code>s3c24xx_leds_ioctl</code>函数将被调用。第18、22行根据传入的cmd、arg参数调用<code>s3c2410_gpio_setpin</code>函数，来设置引脚的输出电平；输出0时点亮LED，输出1时熄灭LED。<br><code>s3c2410_gpio_setpin</code>函数也是内核中实现的，它通过GPIO的数据寄存器来设置输出电平。<br>系统调用函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> request,...)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>file_operations结构中的成员如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，这些参数有很大一部分相似。</p>
<ol>
<li>系统调用open传入的参数已经被内核文件系统层处理了，在驱动程序中看不出原来的参数了。</li>
<li>系统调用ioctl的参数个数可变，一般最多传入3个：后面两个参数与file_operations结构中ioctl成员后的两个参数对应。</li>
<li>系统调用read传入的buf、count参数，对应file_operations结构中read成员的buf、count参数。而参数offp表示用户在文件中进行存取的位置，当执行完读写操作后由驱动程序进行设置。</li>
<li>系统调用write与file_operations结构中write成员的参数关系，与第3点相似。</li>
</ol>
<p>在驱动程序的最后，有如下描述信息，它们不是必须的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*描述驱动程序的一些信息，不是必须的*/</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Nibil&quot;</span>);             <span class="comment">//驱动程序的作者</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;LED Driver&quot;</span>);   <span class="comment">//一些描述信息</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);              <span class="comment">//遵循的协议</span></span><br></pre></td></tr></table></figure>

<h3 id="驱动程序编译"><a href="#驱动程序编译" class="headerlink" title="驱动程序编译"></a>驱动程序编译</h3><p>将驱动文件放入内核<code>drivers/char</code>子目录下，在<code>drivers/char/Makefile</code>中增加下面一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m += s3c24xx_leds.o</span><br></pre></td></tr></table></figure>
<p>然后在内核根目录下执行“make modules”，就可以生成模块<code>drivers/char/s3c24xx_leds.ko</code>。把它放到单板根文件系统的<code>lib/modules/2.6.22.6</code>目录下，就可以使用“insmode s3c24xx_leds”、“rmmod s3c24xx_leds”命令进行加载卸载了。</p>
<h3 id="驱动程序测试"><a href="#驱动程序测试" class="headerlink" title="驱动程序测试"></a>驱动程序测试</h3><p>首先要编译测试程序<code>led_test.c</code>，它的代码很简单，关键部分如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_LED_ON  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_LED_OFF 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/leds&quot;</span>,<span class="number">0</span>);         <span class="comment">//打开设备</span></span><br><span class="line">...</span><br><span class="line">    led_no = strtoul(argv[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>) - <span class="number">1</span>;<span class="comment">//操作哪个LED？</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        ioctl(fd,IOCTL_LED_ON,led_no);<span class="comment">//点亮它    </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;off&quot;</span>)) &#123;</span><br><span class="line">        ioctl(fd,IOCTL_LED_OFF,led_no);<span class="comment">//熄灭它    </span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的open、ioctl最终会调用驱动程序中的<code>s3c24xx_leds_open</code>、<code>s3c24xx_leds_ioctl</code>函数。<br>在测试程序目录下执行“make”命令生成可执行程序led_test，将它放入单板根文件系统<code>/usr/bin</code>目录下后。<br>然后在单板根文件系统中建立设备文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod /dev/leds c 231 0</span><br></pre></td></tr></table></figure>
<p>运行测试程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led_test 1 on</span><br><span class="line">led_test 1 off</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第4篇第19章 字符设备驱动程序</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式编程基础知识</title>
    <url>/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第3章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解交叉编译工具链的各种选项</li>
<li>掌握连接脚本的编译方法</li>
<li>了解Makefile文件中常用的函数</li>
<li>了解几个常用的ARM汇编指令</li>
<li>了解汇编程序调用C函数所遵循的ATPCS规则</li>
</ol>
<h1 id="交叉编译工具选项说明"><a href="#交叉编译工具选项说明" class="headerlink" title="交叉编译工具选项说明"></a>交叉编译工具选项说明</h1><p>源文件需要经过编译才能生成可执行文件。在Windows上进行开发时，只需要单击几个按钮即可编译，集成开发环境已经将各种编译工具的使用封装好了。Linux下也有很多优秀的集成开发工具，但是更多的是时候是直接使用编译工具；即使使用集成开发工具，也需要掌握一些编译选项。<br>PC上的编译工具链为gcc、ld、objcopy、objdump等，它们编译出来的程序在x86平台上运行。要编译出在ARM平台上运行的程序，必须要使用交叉编译工具arm-linux-gcc、arm-linux-ld。</p>
<h2 id="arm-linux-gcc选项"><a href="#arm-linux-gcc选项" class="headerlink" title="arm-linux-gcc选项"></a>arm-linux-gcc选项</h2><p>一个c&#x2F;c++文件需要经过预处理，编译，汇编，链接等4步才能变成可执行文件。</p>
<ol>
<li>预处理<br>c&#x2F;c++源文件中，以”#“开头的命令被称为预处理命令。如包含命令”#include“，宏定义命令”#define“，条件编译命令”#if“，”#ifdef“等。预处理就是将要包含的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些代码输入到一个”.i“文件中等待进一步处理。预处理将要用到arm-linux-cpp工具。</li>
<li>编译<br>编译就是把c&#x2F;c++代码”翻译“汇编代码，所用到的工具为ccl（它的名字就是ccl，而不是arm-linux-ccl）。</li>
<li>汇编<br>汇编就是将第二步输出的汇编代码翻译成一定格式的机器代码，在Linux系统上一般表现为ELF（OBJ文件），用到的工具为arm-linux-as。”反汇编“是指将机器代码转换为汇编代码，这在调试程序时常常用到。</li>
<li>连接<br>连接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件连接起来，最终生成可以在特定平台运行的可执行文件，用到的工具是arm-linux-ld。<br>编译器利用这4个步骤中的一个或者多个来处理输入文件，源文件的后缀名表示源文件所用的语言，后缀名控制着编译器的默认动作。</li>
</ol>
<table>
<thead>
<tr>
<th>后缀名</th>
<th>语言种类</th>
<th>后期操作</th>
</tr>
</thead>
<tbody><tr>
<td>.c</td>
<td>c源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.C</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cc</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cxx</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.m</td>
<td>Object-C 源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.i</td>
<td>预处理后的c文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.ii</td>
<td>预处理后的c++文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.s</td>
<td>汇编语言源程序</td>
<td>汇编</td>
</tr>
<tr>
<td>.S</td>
<td>汇编语言源程序</td>
<td>预处理、汇编</td>
</tr>
<tr>
<td>.h</td>
<td>预处理器文件</td>
<td>通常不出现在命令行上</td>
</tr>
</tbody></table>
<p>其他后缀名的文件被传递给连接器（linker），通常包括一下两种：<br>.o：目标文件（Object file，OBJ文件）。<br>.a：归档库文件（Archive file）。<br>在编译过程中，除非使用了”-c“，”-S“,或者”-E“选项，或者编译错误组织了完整的编译过程，否则最后的步骤总是连接。在连接阶段中，所有对应于源程序的.o文件、”-l“选项指定的库文件、无法识别的文件名（包括指定的”.o“目标文件和”.a“库文件）按命令行中的顺序传递给连接器。<br>以一个简单的”Hello World“C程序为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*File : hello.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用arm-linux-gcc，只需要一个命令就可以生成可执行文件hello，它包含了4个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>加上”-v“选项，可以查看编译的细节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ccl hello.c -o /tmp/cctETob7.s</span><br><span class="line">as -o /tmp/ccvv2KbL.o /tmp/cctETob7.s</span><br><span class="line">collect2 -o hello   crtl.o  crti.o  crtbegin.o /tmp/ccvv2KbL.o crtend.o crtn.o</span><br></pre></td></tr></table></figure>
<p>以上三个命令分别对应于编译步骤中的预处理+编译、汇编和连接，ld被collect2调用来连接程序。预处理和编译被放在了一个命令中（ccl）进行，可以把它再次拆分为一下两步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp -o hello.i hello.c</span><br><span class="line">ccl hello.i -o /tmp/cctETob7.s</span><br></pre></td></tr></table></figure>
<p>可以通过各种选项来控制arm-linux-gcc的动作，下面介绍一些常用的选项。</p>
<h3 id="总体选项"><a href="#总体选项" class="headerlink" title="总体选项"></a>总体选项</h3><ol>
<li>-c<br>预处理、编译和汇编源文件，但是不作连接，编译器根据源文件生成OBJ文件。默认情况下，GCC通过用”.o“替换文件名的后缀”.c“，”.i“，”.s“等，产生OBJ文件名。可以使用”-o“选项选择其他名字。GCC忽略”-c“选项后面任何无法识别的输入文件。</li>
<li>-S<br>编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。默认情况下，GCC通过用”.s“替换源文件名后缀”.c“，”.i“等，产生汇编文件名。可以使用”-o“选项选择其他名字。GCC忽略任何不需要汇编的输入文件。</li>
<li>-E<br>预处理后即停止，不进行编译。预处理后的代码送往标准输出。GCC忽略任何不需要预处理的输入文件。</li>
<li>-o file<br>指定输出文件为file。无论下是预处理、编译、汇编还是连接，这个选项都可以使用，</li>
<li>-v<br>显示制作GCC工具自身时的配置命令；同时显示编译器驱动程序、预处理器、编译器的版本号。<br>以一个程序为例，它包含三个文件：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">File:main.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main fun\n&quot;</span>);</span><br><span class="line">    sub_fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File:sub.h</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">File:sub.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pintf(<span class="string">&quot;Sub fun\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用上述命令进行编译：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
其中，main.o、sub.o是经过了预处理、编译、汇编后生成的OBJ文件，它们还没有被连接成可执行文件；最后一步将它们连接成可执行文件test，可以直接运行以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Main fun</span><br><span class="line">Sub fun</span><br></pre></td></tr></table></figure>
现在试试其他选项，以下命令生成的main.s是main.c的汇编语言文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -S -o main.s  main.c</span><br></pre></td></tr></table></figure>
以下命令对main.c进行预处理，并将得到的结果打印出来，里面包含了所有包含的文件、所有定义的宏。在编写程序时，有时候查找某个宏定义是非常繁琐的事情，可以使用”-dM-E“选项来查看。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -E main.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="警告选项"><a href="#警告选项" class="headerlink" title="警告选项"></a>警告选项</h3><p>”-Wall“选项基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明前就使用的函数、局部变量除了声明就没有再使用等。<br>编译上面的main.c文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -Wall -c main.c</span><br></pre></td></tr></table></figure>
<p>得到的警告信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.c:In function &quot;main&quot;</span><br><span class="line">main.c:6 warning: unused variable &quot;i&quot;</span><br></pre></td></tr></table></figure>
<p>这个警告虽然对程序没有坏的影响，但是有些警告需要加以关注，比如匹配类型的警告等。</p>
<h3 id="调试选项"><a href="#调试选项" class="headerlink" title="调试选项"></a>调试选项</h3><p>-g: 加入只有GDB才使用的额外调试信息。</p>
<h3 id="优化选项"><a href="#优化选项" class="headerlink" title="优化选项"></a>优化选项</h3><ol>
<li>-O或者-O1<br>优化：对于大多数函数，优化编译的过程将占用较长的时间和相当大的内存。不使用”-O“选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的。如果在两条语句之间用断点中止程序，可以对任何变量进行赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确获取所期待的结果。<br>不使用”-O“或者”-O1“选项时，只有声明了register的变量才分配使用寄存器。<br>使用了”-O“或者”-O1“选项时，编译器会试图减少目标码的大小和执行时间。如果指定了”-O“或者”-O1“选项，”-fthread-jumps“和”-fdefer-pop“选项被打开。在有delay slot的机器上，”-fdelayed-branch“选项将被打开。在既没有帧指针又支持调试的机器上，”-fomit-frame-pointer“选项将被打开。某些机器上还可能打开其他选项。</li>
<li>-O2<br>多优化一些。除了涉及空间和速度的优化选项，执行几乎所有的优化工作。例如不进行循环展开和函数内嵌。和”-O“选项相比，这个选项既增加了编译时间，也提高了生成代码的运行效果。</li>
<li>-O3<br>优化的更多，除了打开”-O2“所做的一切，它还打开了”-finline-functions“选项。</li>
<li>-O0<br>不优化。<br>如果指定了多个”-O0“选项，不管带不带数字，生效的是最后一个选项。</li>
</ol>
<h3 id="链接器选项"><a href="#链接器选项" class="headerlink" title="链接器选项"></a>链接器选项</h3><p>下面的选项用于连接OBJ文件，输出可执行文件或者库文件。</p>
<ol>
<li>object-file-name<br>如果某些文件没有特别明确的后缀。GCC就认为它是OBJ文件或者库文件。如果GCC执行连接操作，这些OBJ文件就会成为连接器的输入文件。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
main.o和sub.o就是输入的文件。</li>
<li>-llibrary<br>连接名为library的库文件。<br>连接器在搜索标准目录中寻找这个库文件，库文件的真正名字”liblibrary.a“。搜索目录除了一些系统标准目录外，还包括用户以”-L“选项指定的路径。一般来说用这个方法找到的文件就是<code>库文件---即由OBJ文件组成的归档文件</code>。连接器处理归档文件的方法是：扫面归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义。但是，如果连接器普通的OBJ文件，而不是库文件，就把这个OBJ文件按照平常方式连接进来。指定”-l“选项和指定文件名的唯一区别是，”-l“选项用”lib“和”.a“把library包裹起来，而且搜索一些目录。<br>即使不明显的使用”-llibrary“选项，一些默认的库也被连接进去，可以使用”-v“选项看到这点。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker /lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtl.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../ctri.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtbegin.o</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o</span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtend.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtn.o</span><br></pre></td></tr></table></figure>
可以看见，除了main.o、sub.o两个文件外，还连接了启动文件crtl.o、crti.o、crtend.o、crtn.o，还有一些库文件（-lgcc、-lgcc_eh、-lc、-lgcc、-lgcc_eh）。</li>
<li>-nostartfiles<br>不连接系统标准启动文件，而标准库文件依然正常使用：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -nostartfiles -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/ld:warning:cannot find entry symbol _start;defaulting to 08048184</span><br></pre></td></tr></table></figure>
可以看见启动文件ctll.o、ctri.o、crtend.o、crtn.o没有被连接进去。需要说明的是，对于一般应用程序，这些启动文件是必须的，这里仅是作为例子（这样编译出来的test文件无法执行）。在编译bootloader、内核时，将用到这个选项。</li>
<li>-nostdlib<br>不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器，这个选项常用于编译内核，bootloader等程序，它们不需要启动文件，标准库文件。仍以options程序作为例子：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">/usr/bin/ld:warning:cannot find entry symbol _start;defaulting to 08048074</span><br><span class="line">main.o(.text + 0x19):In function &quot;main&quot;:</span><br><span class="line">:undefined referendce to &quot;printf&quot;</span><br><span class="line">sub.o(.text + 0xf):In function &quot;sub_fun&quot;:</span><br><span class="line">:undefined reference to &quot;printf&quot;</span><br><span class="line">collect2:ld returned 1 exit status</span><br></pre></td></tr></table></figure>
出现了一大堆错误，因为printf等函数是在库文件中实现的。在编译bootloader、内核时，用到这个选项，它们用的很多函数都是自包含的。</li>
<li>-static<br>在支持动态连接的的系统上阻止连接共享库。<br>仍以options程序作为例子,使用和不使用”-static“选项编译出来的可执行程序大小相差巨大：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.c</span><br><span class="line">$ gcc -c -o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br><span class="line">$ gcc -o test_static mian.o sub.o -static </span><br><span class="line">$ ls -l test test_static</span><br><span class="line">6591 test</span><br><span class="line">546479 test_static</span><br></pre></td></tr></table></figure>
其中test文件为6591字节，test_static为546479字节。当不使用”-static“编译文件时，程序执行前要连接共享库文件，所以还需要将共享库文件放入文件系统中。</li>
<li>-shared<br>生成一个共享OBJ文件，它可以和其他OBJ文件连接产生可执行文件。只有部分系统支持该选项。<br>当不想以源代码发布程序时，可以使用”-shared“选项生成库文件，比如对于options程序，可以如下制作库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure>
以后要使用sub.c中的sub_fun时，在连接程序时，将sub.a加入即可。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure>
可以将多个文件制作为一个库文件，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub.o sub2.o sub3.o</span><br></pre></td></tr></table></figure></li>
<li>-Xlinker option<br>把选项option传递给连接器。可以用来传递系统特定的连接选项，GCC无法识别这些选项。如果需要传递携带参数的选项，必须使用两次”-Xlinker“，一次传递选项，另一次传递其参数。例如，如果传递”-arsset-definitions“，要写成”-Xlinker -assert -Xlinker definitions“，而不能写成”-Xlinker -assert definitions“。因为这样会把整个字符串当作一个参数传递，显然不是连接器期待的。</li>
<li>-Wl，option<br>把选项option传递给连接器 。如果option中含有逗号，就在逗号处分割成多个选项。连接器通常都是通过gcc，arm-linux-gcc等命令间接启动的，要向他传入参数时，参数前面加上”-Wl,“。</li>
<li>-u symbol<br>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义。可以使用多个”-u“选项，各自跟上不同的符号，使得连接器调入附加的模块。</li>
</ol>
<h3 id="目录选项"><a href="#目录选项" class="headerlink" title="目录选项"></a>目录选项</h3><p>下列选项指定搜索路径，用于查找头文件，库文件或者编译器的某些成员。</p>
<ol>
<li>-Idir<br>在头文件的搜索路径列表添加dir目录。头文件的搜索方法为：如果以”#include &lt;&gt;“包含文件，则只会在标准库目录开始搜索（包括使用-Idir选项定义的目录）；如果以”#include “包含文件，则先从用户的工作目录开始搜索，再搜索标准库目录。</li>
<li>-I-<br>任何在”-I-“前面用”-I“选项指定的搜索路径只适用于”#include ’file‘“这种情况；它们不能用来搜索”#include&lt;&gt;“包含的头文件。如果用”-I“选项指定的搜索路径位于”-I-“选项后面，就可以在这些路径中搜索所有的”#include“指令。”-I-“选项能够阻止当前目录成为搜索”#include ’file‘“的第一选择。</li>
<li>-Ldir<br>在”-L“选项的搜索路径中添加dir目录，仍然使用options程序进行说明，先制作库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o libsub.a sub.o</span><br></pre></td></tr></table></figure>
编译main.c：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br></pre></td></tr></table></figure>
连接程序，下面的指令将会出错，提示找不到库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o -lsub</span><br><span class="line">/usr/bin/ld: cannot find lsub</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
可以使用”-Ldir“选项将当前目录加入搜索路径，如下则连接成功：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -L. -o test main.o -lsub</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-ld选项"><a href="#arm-linux-ld选项" class="headerlink" title="arm-linux-ld选项"></a>arm-linux-ld选项</h2><p>arm-linux-ld将用于多个目标文件、库文件连接成可执行文件。</p>
<h3 id="直接指定代码段、数据段、bss段的起始地址"><a href="#直接指定代码段、数据段、bss段的起始地址" class="headerlink" title="直接指定代码段、数据段、bss段的起始地址"></a>直接指定代码段、数据段、bss段的起始地址</h3><p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure>
<p>其中的”startaddr“分别代表代码段、数据段和bss段的起始地址，它是一个十六进制数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure>
<p>它代表的代码段的运行地址为0x00000000，<code>由于没有定义数据段、bss段的起始地址，它们被依次放在代码段的后面</code>。<br>以一个例子来说明”-Ttext“选项的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text </span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">  b step1</span><br><span class="line">step1:</span><br><span class="line">  ldr pc, =step2</span><br><span class="line">step2:</span><br><span class="line">  b step2 </span><br></pre></td></tr></table></figure>
<p>使用下面的命令编译、连接、反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -c -o link.o link.s</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 link.o -o  link_elf_0x00000000</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 link.o -o  link_elf_0x30000000</span><br><span class="line">arm-lihux-objdump -D link_elf_0x00000000 &gt; link_0x00000000.dis</span><br><span class="line">arm-lihux-objdump -D link_elf_0x30000000 &gt; link_0x30000000.dis</span><br></pre></td></tr></table></figure>
<p>例子中用到了两种跳转方法：b跳转指令、直接向pc寄存器赋值。先列出不同“-Ttext”选项下生成的反汇编文件，在详细分析由于不同运行地址带来的差异及影响。两个反汇编文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_0x00000000.dis                       link_0x30000000.dis</span><br><span class="line">0: eaffffff b 0x4                         0: eaffffff b 0x4</span><br><span class="line">4: e59ff000 ldr pc, [pc, #0]              4: e59ff000 ldr pc, [pc, #0]</span><br><span class="line">8: eafffffe b 0x8                         8: eafffffe b 0x8</span><br><span class="line">c: 00000008 andeq r0, r0, r8              c: 30000008 tsteq r0, #8 ; 0x8</span><br></pre></td></tr></table></figure>
<p>“b step1”是个相对跳转指令，其机器码的格式如下：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpeg" alt="img not found"></p>
<ol>
<li>[31:28]位是条件码。</li>
<li>[27:24]位为“1010”时，表示b跳转指令；为“1011”时，表示b1跳转指令。</li>
<li>[23::0]表示偏移地址。<br>使用“b”或者“b1”跳转时，下一条指令的地址是这样计算的：将指令中24位带符号的补码扩展为32位（扩展其符号位），将此32位数左移两位，将得到的值加到pc寄存器中，将得到跳转的目标地址。</li>
</ol>
<p>“b step1”的机器码为eaffffff。</p>
<ol>
<li>24位带符号的补码为0xffffff，将它扩展为32位得到0xffffffff。</li>
<li>将此32位数左移两位得到0xfffffffc，其值就是-4.</li>
<li>pc的值是当前指令下的下两条指令的地址，加上步骤2得到的-4，这恰好是第二条指令step1的地址。<br>请不要被反汇编代码的“b 0x4”迷惑。它不是指跳转到0x4处执行，绝对地址需要按照上述3个步骤计算。可以发现，b跳转指令依赖于当前PC寄存器的值，这个特性使得使用b指令的程序不依赖于代码存储的位置—即不管这条代码放在什么位置，b指令都可以跳到正确的位置。这类指令称为位置无关码。使用不同的“-Ttext”选项，生成的代码仍旧是一样的。<br>“ldr pc, &#x3D;step2”，从汇编码“ldr pc, [pc, #0]”可以看出，这条指令从内存中的某个位置读出数据，并赋值给PC寄存器。这个位置的地址是当前pc寄存器的值加上偏移量0。其中存放的值依赖于连接命令的“-Ttext”选项。执行这条指令之后，对于link_0x00000000.dis，pc &#x3D; 0x0000000；对于link_0x30000000.dis，pc &#x3D; 0x30000008。执行第三条指令“b step2”后，程序的运行地址就不同了：分别是0x00000008、0x30000008。<br>Bootloader、内核程序刚开始执行时，它们所处的地址通常不等于运行地址。在程序的开头，先使用b、bl、mov等“位置无关”的指令将代码从Flash等设备复制到内存的“运行地址”处，然后再跳转到“运行地址”去执行。</li>
</ol>
<h3 id="使用连接脚本设置地址"><a href="#使用连接脚本设置地址" class="headerlink" title="使用连接脚本设置地址"></a>使用连接脚本设置地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-ld -Ttimer.lds -o timer_elf head.o init.o interrupt.o main.o</span><br></pre></td></tr></table></figure>
<p>它使用连接脚本timer.lds来设置可执行文件timer_elf的地址信息，timer.lds文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  . = 0x30000000;</span><br><span class="line">  .text             : &#123;   *(.text)    &#125;</span><br><span class="line">  .rodata ALIGN(4)  : &#123;   *(rodata)   &#125;</span><br><span class="line">  .data   ALIGN(4)  : &#123;   *(data)     &#125;</span><br><span class="line">  .bss    ALIGN(4)  : &#123;   *(bss)  *(COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析timer.lds文件之前，先讲解连接脚本的格式。连接脚本的基本命令是SECTIONS命令，它描述了输出文件的映射图：输出文件中各段、各文件怎么怎么放置。一个SECTIONS命令内部包含一个或者多个段。段（Section）是连接脚本的基本单元，它表示输入文件中的某部分怎么放置。<br>完整的连接脚本格式如下，它的核心部分是段（Section）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">secname start ALIGN(align)  (NOLOAD)  : AT(ldadr)</span><br><span class="line">  &#123; contents  &#125; &gt; region :phdr =fill</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>secname 和 contents是必需的，前者用来命名这个段。后者用来确定代码中的什么部分放在这个段中。<br>start是这个段重定位地址，也称为运行地址。如果代码中有位置无关的指令，程序在运行时，这个段必须放在这个地址上。<br>ALIGN(align)：虽然start指定了运行地址，但是仍然可以使用BLOCK（align）来指定对齐的要求—这个对齐的地址才是真正的运行地址。<br>（NOLOAD）：用来告诉加载器，在运行时不用加载这个段。显然，这个选项只有在操作系统的情况下才有意义。<br>AT（ldadr）：指定这个段在编译出来的映像文件中的地址—加载地址。如果不使用这个选项，则加载地址等于运行地址。通过这个选项，可以控制各段分别保存输出文件中不同的位置，便于把文件保存到单板上：A段放在A处，B段放在B处，运行前再把A、B段分别读出来组装成一个完整的执行程序。<br>现在开始分析下timer.lds文件：</p>
<ol>
<li>第2行表示设置“当前运行地址”为0x30000000。</li>
<li>第3行定义了一个名为“.text”的段，它的内容为“* （.text）”，表示所有输入文件的代码段。这些代码段被集合在一起，起始运行地址为0x30000000。</li>
<li>第4行定义了一个名为“.rodata”的段，在输出文件timer_elf中，它紧挨着“.text”段存放。其中“ALIGN（4）”表示起始运行地址为4字节对齐。假设前面“.text”段的地址范围是0x30000000-0x300003f1，则“.rodata”段的地址为4字节对齐后的0x300003f4。</li>
<li>第5、6行的含义与第4行类似。</li>
</ol>
<h2 id="arm-linux-objcopy选项"><a href="#arm-linux-objcopy选项" class="headerlink" title="arm-linux-objcopy选项"></a>arm-linux-objcopy选项</h2><p>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可以使用不同于源文件的格式来输出目的文件，即可以进行格式转换。<br>这本书中，常用arm-linux-objcopy来将ELF格式的可执行文件转换为二进制文件。下面讲解常用的选项：</p>
<ol>
<li>input-file、outfile<br>参数input-file和outfile分别表示输入目标文件和输出目标文件。</li>
<li>-I bfdname 或 –input-target&#x3D;bfdname<br>用来指明源文件的格式，bfdname是BFD库中描述的标准格式名。如果不指明源文件格式，arm-linux-objcopy会自己去分析源文件的格式，然后去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</li>
<li>-O bfdname 或 –output-target&#x3D;bfdname<br>使用指定的格式来输出文件，bfdname是BFD库中描述的的标准格式名。</li>
<li>-F bfdname 或 –target&#x3D;bfdname<br>同时指明源文件和目的文件的格式。将源文件的内容复制到目的文件的过程中，只进行复制而不做格式转换，源文件是什么格式，目的目标文件就是什么格式。</li>
<li>-R sectionname 或 –remove-section&#x3D;sectionname<br>从输出文件中删除掉所有名为sectionname的段。这个选项可以多次使用。</li>
<li>-S 或 –strip-all<br>不从源文件复制重定位信息和符号信息到目标文件中去。</li>
<li>-g 或 –strip-debug<br>不从源文件中复制调试符号到目标文件中去。<br>在编译bootloader、内核时，常用arm-linux-objcopy命令将ELF格式的生成结果转换为二进制文件，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-objcopy -O binary -S elf_file bin_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-objdump选项"><a href="#arm-linux-objdump选项" class="headerlink" title="arm-linux-objdump选项"></a>arm-linux-objdump选项</h2><p>arm-linux-objdump用于显示二进制文件信息，本书中常用来查看反汇编代码。下面讲解常用的选项：</p>
<ol>
<li>-b bfdname 或 –target&#x3D;bfdname<br>指定目标码格式。这不是必须的，arm-linux-objdump能自动识别许多格式。可以使用“arm-linux-objdump -i”命令查看支持的目标码格式。</li>
<li>–disassemble 或 -d<br>反汇编可执行段。</li>
<li>–disassemble 或 -D<br>反汇编所有段。</li>
<li>-EB或-EL或–endian&#x3D;{big|little}<br>指定字节序。</li>
<li>–file-headers或-f<br>显示文件的整体头部摘要信息。</li>
<li>–section-headers、–header或-h<br>显示目标文件各个段的头部摘要信息。</li>
<li>–info或-i<br>显示支持的目标文件格式和CPU架构，它们在“-b”、“-m”选项中用到。</li>
<li>–section&#x3D;name或-j name<br>仅显示指定section的信息。</li>
<li>–architecture&#x3D;machine或-m machine<br>指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候，这个选项很有用。可以用“-i”选项列出这里能够指定的架构。<br>在调试程序时，常用arm-linux-objdump命令来得到汇编代码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将ELF格式的文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D elf_file &gt; dis_file</span><br><span class="line">/*将二进制文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D -b binary -m arm bin_file &gt; dis_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="汇编代码、机器码和存储器的关系以及数据的表示"><a href="#汇编代码、机器码和存储器的关系以及数据的表示" class="headerlink" title="汇编代码、机器码和存储器的关系以及数据的表示"></a>汇编代码、机器码和存储器的关系以及数据的表示</h2><p>即使使用C&#x2F;C++或者其他高级语言编程，最后也会被编译工具转换为汇编代码，并最终作为机器码存储在内存、硬盘或者其他存储器上。在调试程序时，经常需要阅读它的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4bc:        e3a0244e: mov r2, #1308622848;</span><br><span class="line">4c0:        e3a0344e: mov r3, #1308622848;</span><br><span class="line">4c4:        e5933000: ldr r3, [r3];</span><br></pre></td></tr></table></figure>
<p>4bc、4c0、4c4是这些代码的运行地址，就是说运行前，这些指令必须位于内存中的这些地址上；e3a0244e、e3a0344e、e5933000是机器码。运行地址、机器码都是十六进制表示。CPU用到的、内存中保存的都是机器码示意如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*内存中的示意图*/</span><br><span class="line">/*地址:机器码*/</span><br><span class="line">···</span><br><span class="line">0x4bc:0xe3a0244e</span><br><span class="line">0x4c0:0xe3a0344e</span><br><span class="line">0x4c4:0xe5933000</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>“mov r2, #1308622848”、“mov r3, #1308622848”、“ldr r3, [r3]”是上述几个机器码的汇编代码。所谓汇编代码仅仅是为了方便读写而引入的，机器码和汇编代码之间也仅仅是简单的转换关系。参考CPU的数据手册，ARM的数据处指令格式为：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.jpeg" alt="img not found"><br>以机器码0xe3a0244e为例：</p>
<ol>
<li>[31:28] &#x3D; 0b1110，表示这条指令无条件执行。</li>
<li>[25] &#x3D; 0b1，表示Operand2是一个立即数。</li>
<li>[24:21] &#x3D; 0b1101，表示这是MOV指令。</li>
<li>[20] &#x3D; 0b0，表示这条指令执行时不影响状态位。</li>
<li>[15:12] &#x3D; 0b0010，表示Rd就是r2寄存器。</li>
<li>[11:0] &#x3D; 0x44e，这是一个立即数。<br>立即数占据机器码的低12位表示：最低8位的值称为immed_8，高4位称为rotate_imm。立即数的数值计算方法为：<value> &#x3D; immed_8 循环右移 （2 * rotate_imm）。对于”[11:0] &#x3D; 0x44e“，其中immed_8 &#x3D; 0x4e、rotate_imm&#x3D;0x4，所以此立即数为0x4e000000。</value></li>
</ol>
<h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>在Linux中使用Make命令来编译程序，特别是大程序；而make命令所执行的动作依赖与Makefile文件。最简单的Makefile文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello：hello.c</span><br><span class="line">  gcc -o hello hello.c</span><br><span class="line">clean:</span><br><span class="line">  rm -rf hello</span><br></pre></td></tr></table></figure>
<p>将上述4行存为Makefile文件（注意必须以Tab键来进行缩进第2、4行，不能以空格来进行缩进），执行make即可编译程序，执行make clean即可清除编译出来的结果。<br>make命令根据文件更新的时间戳来决定哪些文件需要重新编译，这使得可以避免编译已经编译过的、没有变化的程序，大大提高编译效率。</p>
<h2 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h2><p>一个简单的Makefile文件包含一系列”规则“，其样式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标（target）...：依赖（prerequiries）...</span><br><span class="line">&lt;Tab&gt;命令（command）</span><br></pre></td></tr></table></figure>
<p>目标（target）通常是要生成的文件的名称，可以是可执行文件或者OBJ文件，也可以是一个执行的动作名称，诸如”clean“。<br>依赖是用来产生目标的材料（比如源文件），一个目标通常有几个依赖。<br>命令是生成目标时的动作，一个规则可以含有几个命令，每个命令占一行。<br>通常，如果一个依赖发生了变化，就需要规则调整命令以更新或者创建目标。但是并非所有的目标都有依赖，例如，目标”clean“的作用就是清除文件，它没有依赖。<br>规则一般是用于解释怎样和何时重建目标。make首先调用命令处理依赖，进而才能创建或者更新目标。当然，一个规则也可以是用于解释怎样和何时执行一个动作，即打印提示信息。<br>一个Makefile文件可以包含规则以外的其他文本，但一个简单的Makefile文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但是格式是完全一样的。<br>对于上述Makefile，执行”make“命令时，仅当hello.c文件比hello文件新，才会执行命令”arm-linux-gcc -o hello hello.c“生成可执行文件hello；如果还没有hello文件，这个命令也会执行。<br>运行”make clean“，由于目标没有依赖项，它的命令“rm -f hello”将被强制执行。</p>
<h2 id="Makefile文件里的赋值方法"><a href="#Makefile文件里的赋值方法" class="headerlink" title="Makefile文件里的赋值方法"></a>Makefile文件里的赋值方法</h2><p>变量的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">immediate = deferred</span><br><span class="line">immediate ?= deferred</span><br><span class="line">immediate := immediate</span><br><span class="line">immediate += deferred or immediate</span><br><span class="line">define immediate</span><br><span class="line">deferred</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>在GNU make中对变量的赋值有两种方式：延时变量、立即变量。区别在于它们的定义方式和扩展时的方式不同，前者在这个变量使用时才会扩展开，意思就是当真正使用这个变量时才会确定；后者在定义时它的值就已经确定了。使用“&#x3D;”、“?&#x3D;”定义或者使用define指定定义的变量是延时变量；使用“：&#x3D;”定义的变量是立即变量。需要注意一点的的是“?&#x3D;”仅仅在变量没有定义的情况下有效，即“?&#x3D;”用来定义第一次出现的延时变量。对于附加操作符“+&#x3D;”，右边变量如果在前面使用（：&#x3D;）定义为立即变量则它也是立即变量，否则均为延时变量。</p>
<h2 id="Makefile常用函数"><a href="#Makefile常用函数" class="headerlink" title="Makefile常用函数"></a>Makefile常用函数</h2><p>函数调用的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(function arguments)</span><br></pre></td></tr></table></figure>
<p>这里“function”是函数名，“arguments”是该函数的参数。参数与函数名之间用空格或者Tab隔开，如果有多个参数，它们之间用逗号隔开。这些空格和逗号不是参数值的一部分。下面介绍一些常用的Makefile函数。</p>
<h3 id="字符串替换和分析函数"><a href="#字符串替换和分析函数" class="headerlink" title="字符串替换和分析函数"></a>字符串替换和分析函数</h3><ol>
<li>$ (subst from,to,text)<br>在文本“text”中使用“to”替换每一处“from”。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (subst ee,EE,feet on the street)</span><br><span class="line">==&gt;fEEt on the strEEt</span><br></pre></td></tr></table></figure></li>
<li>$ (patsubst pattern,replacement,text)<br>寻找“text”中符合格式“pattern”的字，用“replacement”替换它们。“pattern”和“replacement”中可以使用通配符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (patsubst %.c,%.o,x.c.c bar.c)</span><br><span class="line">==&gt;x.c.o bar.o</span><br></pre></td></tr></table></figure></li>
<li>$ (strip string)<br>去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (strip a   b c )</span><br><span class="line">==&gt;a b c</span><br></pre></td></tr></table></figure></li>
<li>$ (findstring find,in)<br>在字符串“in”中查找“find”，如果找到，则返回值是“find“，否则返回值为空。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(findstring a,a b c)</span><br><span class="line">==&gt;a</span><br><span class="line">$(findstring a,b c)</span><br><span class="line">==&gt;</span><br></pre></td></tr></table></figure></li>
<li>$(filter pattern…,text)<br>返回在”text“中由空格隔开且匹配格式”pattern…“的字，去除不符合格式”pattern…“的字。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;foo.c bar.c baz.s</span><br></pre></td></tr></table></figure></li>
<li>$(filter-out pattern…,text)<br>返回在”text“中由空格隔开并且不匹配格式”pattern…“的字，去除符合格式”pattern…“的字。它是函数filter的反函数。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;ugh.h</span><br></pre></td></tr></table></figure></li>
<li>$(sort list)<br>将”list“中的字按照字母顺序排列，并去掉重复的字。输出由单个空格隔开的字的列表。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(sort foo bar lose)</span><br><span class="line">==&gt;bar foo lose</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文件名函数"><a href="#文件名函数" class="headerlink" title="文件名函数"></a>文件名函数</h3><ol>
<li>$(dir names…)<br>抽取”names…“中每一个文件名的路径部分，文件名的路径部分包括从文件名的首字符到最后一个斜杠之前的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/ ./</span><br></pre></td></tr></table></figure></li>
<li>$(notdir names…)<br>抽取”names…“中每一个文件名的除路径之外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;foo.c hacks</span><br></pre></td></tr></table></figure></li>
<li>$(suffix names…)<br>抽取”names…“中每一个文件名的后缀。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;.c</span><br></pre></td></tr></table></figure></li>
<li>$(basename names…)<br>抽取”names…“中每一个文件名除后缀以外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/foo hacks</span><br></pre></td></tr></table></figure></li>
<li>$(addsuffix suffix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；suffix是一个后缀名。将suffix（后缀）的值附加在每一个独立文件的后面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(addsuffix .c,foo bar)</span><br><span class="line">==&gt;foo.c bar.c</span><br></pre></td></tr></table></figure></li>
<li>$(addprefix prefix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；prefix是一个前缀名。将prefix（前缀）的值附加在每一个独立文件的前面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line">==&gt;src/foo  src/bar</span><br></pre></td></tr></table></figure></li>
<li>$(wildcard pattern)<br>参数”pattern“是一个文件名格式，包含有通配符（通配符和shell的用法一样）。函数wildcard的结果是一列和格式匹配且真实存在的文件的名称，文件名之间用一个空格隔开。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_src := $(wildcard *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ol>
<li>$(foreach var,list,text)<br>前两个参数，”var“和”list“将首先扩展，最后一个参数”text“此时不扩展；接着，”list“扩展得到的每个字都赋值给”var“变量；然后，”text“引用该变量进行扩展，因此”text“每次扩展都不相同。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirs := a b c d</span><br><span class="line">files := $(foreach dir,$(dir),$(wildcard $(dir)/*))</span><br><span class="line">==&gt;</span><br><span class="line">$(wildcard a/*)</span><br><span class="line">$(wildcard b/*)</span><br><span class="line">$(wildcard c/*)</span><br><span class="line">$(wildcard d/*)</span><br></pre></td></tr></table></figure></li>
<li>$(if condition,then-part[,else-part])<br>首先把第一个参数”condition“的前导空格、结尾空格去掉，然后扩展。如果扩展为非空字符产，则条件”condition“为真，那么计算第二个参数”then-part“的值，并将之作为函数的返回值。如果condition为假，并且第三个参数存在，则计算第三个参数”else-part“的值，并将该值作为函数得返回值。如果第三个参数不存在，则返回空。</li>
<li>$(origin variable)<br>变量”variable“是一个查询变量的名称，不是对改变量的引用。所以不能采用”$“和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。函数的返回值如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined                     :变量”variable“从未被定义；</span><br><span class="line">default                       :变量”variable“是默认定义；</span><br><span class="line">environment                   :变量”variable“作为环境变量定义，选项”-e“没有打开；</span><br><span class="line">environment override          :变量”variable“作为环境变量定义，选项”-e“已打开；</span><br><span class="line">file                          :变量”variable“在Makefile中定义；</span><br><span class="line">command line                  :变量”variable“在命令行中定义；</span><br><span class="line">override                      :变量”variable“在Makefile中用override指令定义；</span><br><span class="line">automatic                     :变量”variable“是自动变量。</span><br></pre></td></tr></table></figure></li>
<li>$(shell command arguments)<br>函数shell是Makefile与外部环境通信的工具。函数shell的执行结果和在控制台上执行”command arguments“的结果相似。不过如果”command arguments“的结果含有换行符，则在函数shell的返回结果中将它们处理为单个空格，若返回结果最后是换行符或者回车符则被去掉。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_src := $(shell ls *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure>
下面以一个Makefile为例进行演示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File:Makefiel</span><br><span class="line">src :=  $(shell ls *.c)</span><br><span class="line">objs := $(patsubst  %.c,%.o,$(src))</span><br><span class="line"></span><br><span class="line">test: $(objs)</span><br><span class="line">  gcc -o  $@  $^</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">  gcc -c -o $@  $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -rf test *.o</span><br></pre></td></tr></table></figure>
上述Makefile中”$@“、”$^“、”$&lt;“称为自动变量。”$@“表示规则的目标文件名；”$^“表示所有依赖的名字，名字中间用空格隔开；”$&lt;“表示第一个依赖的文件名。<br>已知当前目录下的所有文件为Makefile、main.c、sub.c、sub.h。<br>第一行src变量的值为”main.c sub.c“。<br>第二行objs变量的值为”main.o sub.o“。<br>第四行实际上就是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test  : main.o sub.o</span><br></pre></td></tr></table></figure>
目标test的依赖项是main.o sub.o。开始时这两个文件还没有生成，在执行文件生成test的命令前先将main.o、sub.o作为目标查找合适的规则，以生成main.o、sub.o。<br>第七八行就是用来生成main.o、sub.o的规则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.o : main.c</span><br><span class="line">  gcc -c -o main.o main.c</span><br><span class="line"></span><br><span class="line">sub.o : sub.c</span><br><span class="line">  gcc -c -o sub.o sub.c</span><br></pre></td></tr></table></figure>
这样，test的依赖main.o和sub.o就生成了。</li>
</ol>
<h1 id="常用ARM汇编指令及ATPCS规则"><a href="#常用ARM汇编指令及ATPCS规则" class="headerlink" title="常用ARM汇编指令及ATPCS规则"></a>常用ARM汇编指令及ATPCS规则</h1><p>在嵌入式开发中，汇编程序常常用于非常关键的地方，比如系统启动时的初始化，进出中断时的环境保存、恢复，对性能要求非常苛刻的函数等。</p>
<ol>
<li>相对跳转指令b、bl<br>这两条指令的不同之处在于bl指令除了跳转之外，还将返回地址（bl的下一条指令的地址）保存在lr寄存器中。<br>这两条指令的可跳转范围是当前指令的前后32M。<br>它们是位置无关的指令。<br>使用示例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  b fun1</span><br><span class="line">  ...</span><br><span class="line">fun1:</span><br><span class="line">  bl fun2</span><br><span class="line">  ...</span><br><span class="line">fun2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>数据传送指令mov，地址读取伪指令ldr<br>mov指令可以把一个寄存器的值赋值给另一个寄存器赋给另一个寄存器，或者把一个常数赋值给寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*r1 = r2*/</span><br><span class="line">mov r1,r2</span><br><span class="line"></span><br><span class="line">/*r1 = 4096*/</span><br><span class="line">mov r1,#4096</span><br></pre></td></tr></table></figure>
mov传送的常数必须能用立即数来表示。<br>当不知道一个数能否用”立即数“来表示时，可以使用ldr命令来赋值。ldr是伪指令，它不是真实存在的指令，编译器会把它扩展成真正的指令：如果该常数能用”立即数“来表示，则使用mov指令；否则编译时将该常数保存在某个位置，使用内存读取指令把它读出来。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*r1 = 4097*/</span><br><span class="line">ldr r1, =4097</span><br><span class="line"></span><br><span class="line">/*r1 = label的绝对地址*/</span><br><span class="line">ldr r1, =label</span><br><span class="line">label:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>内存访问指令:ldr,str,ldm,stm<br>ldr指令从内存中读取数据到寄存器，str指令把寄存器的值存储到内存，它们操作的数据都是32位的。示例如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将地址为r2+4的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2,#4]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1,然后r2 = r2 + 4*/</span><br><span class="line">ldr r1,[r2],#4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*将r1的数据保存到地址为r2 + 4的内存单元*/</span><br><span class="line">str r1,[r2,#4]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元*/</span><br><span class="line">str r1,[r2]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元，然后r2 = r2 + 4*/</span><br><span class="line">str r1,[r2],#4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ldm和stm属于批量内存访问指令，只用一条指令就可以读写多个数据。它们的格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br><span class="line">stm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br></pre></td></tr></table></figure>
其中{cond}表示地址变化模式，有以下4种模式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ia (Increment After):事后递增模式</span><br><span class="line">ib (Increment Before):事先递增模式</span><br><span class="line">da (Decrement After):事后递减模式</span><br><span class="line">db (Decrement Before):事先递减模式</span><br></pre></td></tr></table></figure>
<rn>中保存内存的地址，如果在后面加上了感叹号，指令执行后，rn的值会更新，等于下一个内存单元的地址。<br><register list>表示寄存器列表，对于ldm指令，从<rn>所对应的内存块取出数据。写入这些寄存器；对于stm指令，把这些寄存器的值写入<rn>所对应的内存块中。<br>{^}有两种含义：如果<register list>中有PC寄存器，它表示指令执行后，spsr寄存器的值将自动复制到cpsr寄存器中—这常用于从中断处理函数返回；如果<register list>中没有pc寄存器，它表示操作的是用户模式下的寄存器，而不是当前特权模式的寄存器。<br>指令中寄存器列表和内存单元的对应关系为：编号低的寄存器对应内存中的低地址单元，编号高的寄存器对应内存中的高地址单元。</register></register></rn></rn></register></rn></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HandleIRQ:                @中断入口函数</span><br><span class="line">  sub lr,lr,#4            @计算返回地址</span><br><span class="line">  stmdb sp!,&#123;r0-r12,lr&#125;   @保存使用到的寄存器，r0-r12,lr被保存在sp表示的内存中，”!“使得指令执行后sp=sp-14*4</span><br><span class="line">  ldr lr, =int_return     @设置调用Handle_IRQ函数后的返回地址</span><br><span class="line">  ldr pc, =IRQ_Handle     @调用中断返回函数</span><br><span class="line"></span><br><span class="line">int_return:</span><br><span class="line">  ldmia sp!,&#123;r0-r12,pc&#125;^  @中断返回，”^“表示将spsr的值复制到cpsr，于是从irq模式返回被中断的工作模式。”!“使得指令执行后sp = sp + 14*4</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加减指令：add、sub<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add r1,r2,#1 /*表示r1 = r2 + 1,即寄存器r1的值等于r2的值加上1*/</span><br><span class="line">sub r1,r2,#1 /*表示r1 = r2 - 1*/</span><br></pre></td></tr></table></figure></li>
<li>程序状态字寄存器的访问指令：msr、mrs<br>ARM处理器有一个程序状态字寄存器cpsr，它用来控制处理器的工作模式、设置中断的总开关。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msr cpsr,r0 /*复制r0到cpsr中*/</span><br><span class="line">mrs r0,cpsr /*复制cpsr到r0中*/</span><br></pre></td></tr></table></figure></li>
<li>其他伪指令<br>在本书的汇编程序中，常常见到如下语句：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.extern main</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure>
”.extern“定义一个外部符号（可以是变量也可以是函数），上面的代码表示本文件中引用的main是一个外部函数。<br>”.text“表示下面的语句都属于代码段。<br>”.global“将本文件的某个程序标号定义为全局的，比如下面的代码表示_start是个全局函数。</li>
<li>汇编指令的执行条件<br>大多数ARM指令都可以条件执行，即根据cpsr寄存器中的条件标志决定执行该指令：如果条件不满足，该指令相当于一条nop指令。<br>每条ARM指令包含4位的条件域码，这表明可以定义16个执行条件。可以将这些执行条件的助记符附加在汇编指令后，如moveq，movgt等。</li>
</ol>
<table>
<thead>
<tr>
<th>条件码</th>
<th>助记符</th>
<th>含义</th>
<th>cpsr中条件标志位</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>eq</td>
<td>相等</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>0001</td>
<td>ne</td>
<td>不相等</td>
<td>Z&#x3D;0</td>
</tr>
<tr>
<td>0010</td>
<td>cs&#x2F;hs</td>
<td>无符号数大于&#x2F;等于</td>
<td>C&#x3D;1</td>
</tr>
<tr>
<td>0100</td>
<td>mi</td>
<td>负数</td>
<td>N&#x3D;1</td>
</tr>
<tr>
<td>0101</td>
<td>pl</td>
<td>非负数</td>
<td>N&#x3D;0</td>
</tr>
<tr>
<td>0110</td>
<td>vs</td>
<td>上溢出</td>
<td>V&#x3D;1</td>
</tr>
<tr>
<td>0111</td>
<td>vc</td>
<td>没有上溢出</td>
<td>V&#x3D;0</td>
</tr>
<tr>
<td>1000</td>
<td>hi</td>
<td>无符号数大于</td>
<td>C&#x3D;1 &amp;&amp; Z&#x3D;0</td>
</tr>
<tr>
<td>1001</td>
<td>ls</td>
<td>无符号数小于等于</td>
<td>C&#x3D;0</td>
</tr>
<tr>
<td>1010</td>
<td>ge</td>
<td>带符号数大于等于</td>
<td>N&#x3D;1,V&#x3D;1</td>
</tr>
<tr>
<td>1011</td>
<td>lt</td>
<td>带符号数小于</td>
<td>N&#x3D;1,V&#x3D;0</td>
</tr>
<tr>
<td>1100</td>
<td>gt</td>
<td>带符号数大于</td>
<td>Z&#x3D;0 &amp;&amp; N&#x3D;V</td>
</tr>
<tr>
<td>1101</td>
<td>le</td>
<td>带符号数小于&#x2F;等于</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>1110</td>
<td>al</td>
<td>无条件执行</td>
<td>-</td>
</tr>
<tr>
<td>1111</td>
<td>nv</td>
<td>从不执行</td>
<td>-</td>
</tr>
</tbody></table>
<p>表中的cpsr条件标志位N、Z、C、V分别表示Negative、Zero、Cary、Overflow。影响条件标志位的因素比较多，比如比较指令cmp、cnm、teq及tst等。</p>
<h2 id="ARM-THUMB子程序调用规则ATPCS"><a href="#ARM-THUMB子程序调用规则ATPCS" class="headerlink" title="ARM-THUMB子程序调用规则ATPCS"></a>ARM-THUMB子程序调用规则ATPCS</h2><p>为了使C语言程序和汇编程序之间能够相互调用，必须为子程序之间的调用制定规则，在ARM处理器中，这个规则被称为ATPCS：ARM程序和Thumb程序中子程序的调用的规则。<br>基本的ATPCS规则包括寄存器使用规则、数据栈使用规则、参数传递规则等。</p>
<h3 id="寄存器使用规则"><a href="#寄存器使用规则" class="headerlink" title="寄存器使用规则"></a>寄存器使用规则</h3><p>ARM处理器中有r0-r15共16个寄存器，它们的用途有一些约定的习惯，并依据这些这些用途定义了别名。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>别名</th>
<th>使用规则</th>
</tr>
</thead>
<tbody><tr>
<td>r15</td>
<td>pc</td>
<td>程序计数器</td>
</tr>
<tr>
<td>r14</td>
<td>lr</td>
<td>连接寄存器</td>
</tr>
<tr>
<td>r13</td>
<td>sp</td>
<td>数据栈指针</td>
</tr>
<tr>
<td>r12</td>
<td>ip</td>
<td>子程序内部调用的scratch寄存器</td>
</tr>
<tr>
<td>r11</td>
<td>v8</td>
<td>ARM状态局部变量寄存器8</td>
</tr>
<tr>
<td>r10</td>
<td>v7、sl</td>
<td>ARM状态局部变量寄存器7、在支持数据栈检查的ATPCS中为数据栈限定指针</td>
</tr>
<tr>
<td>r9</td>
<td>v6、sb</td>
<td>ARM状态局部变量寄存器6、在支持RWPI的ATPCS中为静态基址寄存器</td>
</tr>
<tr>
<td>r8</td>
<td>v5</td>
<td>ARM状态局部变量寄存器5</td>
</tr>
<tr>
<td>r7</td>
<td>v4、wr</td>
<td>ARM状态局部变量寄存器4、Thumb状态工作寄存器</td>
</tr>
<tr>
<td>r6</td>
<td>v3</td>
<td>ARM状态局部变量寄存器3</td>
</tr>
<tr>
<td>r5</td>
<td>v2</td>
<td>ARM状态局部变量寄存器2</td>
</tr>
<tr>
<td>r4</td>
<td>v1</td>
<td>ARM状态局部变量寄存器1</td>
</tr>
<tr>
<td>r3</td>
<td>a4</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器4</td>
</tr>
<tr>
<td>r2</td>
<td>a3</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器3</td>
</tr>
<tr>
<td>r1</td>
<td>a2</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器2</td>
</tr>
<tr>
<td>r0</td>
<td>a1</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器1</td>
</tr>
</tbody></table>
<p>寄存器的使用规则总结如下：</p>
<ol>
<li>子程序间通过寄存器r0-r3来传递参数，这时可以使用它们的别名a0-a3。被调用的子程序返回前无须恢复r0-r3的内容。</li>
<li>在子程序中，使用r4-r11来保存局部变量，这时可以使用它们的别名v1-v8。如果在子程序中使用了它们的某些寄存器，子程序进入时需要保存这些寄存器的值，在返回时需要恢复它们；对于子程序没有使用到的寄存器，则不必进行这些操作。在Thumb程序中，通常只能使用寄存器r4-r7来保存局部变量。</li>
<li>寄存器r12用作子程序间scratch寄存器，别名ip。</li>
<li>寄存器r13用作数据栈指针，别名sp。在子程序中寄存器r13不能用作其他用途。它的值在进入、退出子程序时必须相等。</li>
<li>寄存器r14称为连接寄存器，别名lr。它用于保存子程序的返回地址。如果在子程序中保存了返回地址（比如将lr的值保存到数据栈中），r14可以用作其他用途。</li>
<li>寄存器r15是程序计数器，别名pc。它不能用作其他用途。</li>
</ol>
<h3 id="数据栈使用规则"><a href="#数据栈使用规则" class="headerlink" title="数据栈使用规则"></a>数据栈使用规则</h3><p>数据栈有两个增长方向：向内存地址减小的方向增长时，称为DESCENDING栈；向内存增加的方向增长时，称为ASCENDING栈。<br>所谓数据栈的增长就是移动栈指针。当栈指针指向栈顶元素时，称为FULL栈；当栈指针指向栈顶元素相邻的一个空的数据单元时，称为EMPTY栈。<br>使用stmdb命令往数据栈保存内容时，先递减sp指针，再保存数据，使用ldmia命令从数据栈恢复数据时，先获得数据，再递增sp指针，sp指针总是指向栈顶元素。</p>
<h3 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h3><p>一般来说，当参数个数不超过4个时，使用r0-r3这4个寄存器来传递参数；如果参数超过4个，剩余的参数通过数据栈来传递。<br>对于一般的返回结果，通常使用a0-a3来传递。示例：<br>假设CopyCode2SDRAM函数是用C语言实现的，它的数据原型如下：<br>int CopyCode2SDRAM(unsigned char *buf,unsigned long start_addr,int size);<br>在汇编代码中，使用下面的代码调用它，并判断返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldr r0,=0x30000000</span><br><span class="line">mov r1,#0</span><br><span class="line">mov r2,#16*1024</span><br><span class="line">bl CopyCode2SDRAM</span><br><span class="line">cmp a0,#0</span><br></pre></td></tr></table></figure>
<p>第一行将r0设为0x30000000，则CopyCode2SDRAM函数执行时，它的第一个参数buf的指向的内存地址是0x30000000。<br>第二行将r1设为0，CopyCode2SDRAM函数的第二个参数start_addr等于0。<br>第三行将r2设为16x1024，CopyCode2SDRAM函数的第三个参数size等于16x1024。<br>第五行判断返回值。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第3章 嵌入式编程基础知识</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MMU</title>
    <url>/2022/08/15/MMU/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第7章总结归纳</p>
<span id="more"></span>
<h1 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h1><ol>
<li>了解虚拟地址和物理地址的关系</li>
<li>掌握如何通过设置MMU来控制虚拟地址到物理地址的转化</li>
<li>了解MMU的内存访问权限机制</li>
<li>了解TLB、Cache、Write Buffer的原理，使用时的注意事项</li>
<li>实例</li>
</ol>
<h1 id="内存管理单元MMU介绍"><a href="#内存管理单元MMU介绍" class="headerlink" title="内存管理单元MMU介绍"></a>内存管理单元MMU介绍</h1><h2 id="S3C2410-x2F-S3C2440-MMU特性"><a href="#S3C2410-x2F-S3C2440-MMU特性" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU特性"></a>S3C2410&#x2F;S3C2440 MMU特性</h2><p>内存管理单元（Memory Management Unit）简称MMU，它负责虚拟地址收到物理地址的映射，并提供硬件机制的内存访问权限检查。现代的多用户多进程操作系统通过MMU使得各个用户进程都拥有自己独立的地址空间：地址映射功能使得各进程拥有看起来一样的地址空间，而内存访问权限的检查可以保护每个进程所用的内存不会被其他破坏。</p>
<ol>
<li>与ARM V4兼容的映射长度、域、访问权限检查机制。</li>
<li>4种映射长度：段（1MB）、大页（64KB）、小页（4KB）、极小页（1KB）。</li>
<li>对每段都可以设置访问权限。</li>
<li>大页、小页的每个子页（sub-page，被映射页的1&#x2F;4）都可以设置单独的访问权限。</li>
<li>硬件实现的16个域。</li>
<li>指令TLB（含64个条目）、数据TLB（含64个条目）。</li>
<li>硬件访问页表（地址映射、权限检查有硬件自动进行）。</li>
<li>TLB条目中替换采用round-robin算法（也称cyclic算法）。</li>
<li>可以使无效整个TLB。</li>
<li>可以单独使无效某个TLB。</li>
<li>可以在TLB中锁定某个条目，指令TLB、数据TLB相互独立。<br>重点在于页表的结构与建立、映射的过程。</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-MMU地址变换过程"><a href="#S3C2410-x2F-S3C2440-MMU地址变换过程" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU地址变换过程"></a>S3C2410&#x2F;S3C2440 MMU地址变换过程</h2><h3 id="地址的分类"><a href="#地址的分类" class="headerlink" title="地址的分类"></a>地址的分类</h3><p>以前的程序是非常小的，可以全部装入内存。随着技术的发展，出现了以下两种情况：</p>
<ol>
<li>有的程序很大，它所要求的内存，超过了内存总容量，不能一次性装入内存。</li>
<li>多道系统中有很多程序需要同时执行，它们要求的内存超过了内存总容量，不能把所有程序都装入内存。<br>实际上，一个程序在运行前，没有必要全部装入内存，而仅需要将那些当前需要运行的部分先装入内存，其余部分在用到时再从磁盘调入，而当内存耗光时再将暂时不用的部分调出到磁盘。这使得一个大程序可以在较小的内存空间中运行，这也使得内存中可以同时装入更多的程序并发执行，从用户的角度看，该系统所具有的内存容量将比实际内存容量大得多，人们把这样的存储器称为虚拟存储器。<br>虚拟存储器从逻辑上对内存容量进行了扩充，用户看到的大容量只是一种感觉，是虚的，在32位的CPU系统中，这个虚拟内存地址范围为0-0xFFFFFFFF，我们把这个地址范围称为虚拟地址空间，其中某个地址称为虚拟地址。与虚拟地址空间、虚拟地址对应的是物理地址空间、物理地址，它们对应实际的内存。<br>虚拟地址空间最终需要转化为物理地址才能读写实际的数据，这通过将虚拟地址空间、物理地址空间划分为同样大小的一块块小空间（段或页），然后为这两类小空间建立映射关系。由于虚拟地址空间远大于物理空间，有可能多块虚拟地址空间映射到同一块物理地址空间，或者有些虚拟地址空间没有映射到具体的物理地址空间上去（可以使用到时再映射）。<br><img src="/2022/08/15/MMU/1.jpeg" alt="img not found"></li>
</ol>
<p>ARM CPU上的地址转换涉及3个概念：虚拟地址（Virtual Address）、变换后的虚拟地址（Modified Virtual Address）、物理地址（Physical Address）。<br>没启动MMU时，CPU核、cache、MMU、外设等所有部件使用的都是物理地址。<br>启动MMU后，CPU核对外发出虚拟地址VA；VA被转换为MVA供cache、MMU使用，再这里MVA被转换为PA；最后使用PA读写实际设备（S3C2410&#x2F;S3C2440内部寄存器或外界的设备）：</p>
<ol>
<li>CPU看到的、用到的只是虚拟地址VA，至于VA如何最终落实到物理地址PA上，CPU核是不理会的。</li>
<li>而caches和MMU也是看不到VA的，它们利用有MVA转换得到PA。</li>
<li>而实际设备看不到VA，MVA，它们读写时使用的是物理地址PA。<br>MVA是除CPU核外的其他部分看见的虚拟地址，VA与MVA之间的变化关系如图所示：<br><img src="/2022/08/15/MMU/2.jpeg" alt="img not found"><br>如果VA&lt;32M，需要使用进程标识号（PID）通过读CP15的c13获得来转换MVA。VA与MVA的转换方式如下（这是硬件自动完成的）：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (VA &lt; <span class="number">32</span>M) then</span><br><span class="line">    MVA = VA | (PID &lt;&lt; <span class="number">25</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    MVA = VA</span><br></pre></td></tr></table></figure>
利用PID生成MVA的目的是为了减少切换进程时的代价；不使用MVA而直接使用VA的话，当两个进程使用的虚拟地址空间VA有重叠时，在切换进程时为了把重叠的VA映射到不同的PA上去，需要重建页表、使无效caches和TLBS等，代价很大。使用MVA后，进程切换就省事多了：假设两个进程1、2运行时的VA都是0-32M，但是它们的MVA并不重叠，分别是0x02000000-0x03FFFFFF、0x04000000-0x05FFFFFF，这样就不必进行重建页表工作了。</li>
</ol>
<h3 id="虚拟地址到物理地址的转换过程"><a href="#虚拟地址到物理地址的转换过程" class="headerlink" title="虚拟地址到物理地址的转换过程"></a>虚拟地址到物理地址的转换过程</h3><p>将一个虚拟地址转换为物理地址，一般有两个办法：用一个确定的数学公式进行转换或用表格存储虚拟地址对应的物理地址。这类表格称为页表（Page Table），页表由一个个条目（Entry）组成；每个条目存储了一段虚拟地址对应的物理地址及其访问权限，或者下一级页表地址。<br>在AMR CPU中使用的第二种方法。S3C2410&#x2F;S3C2440最多会用到两级页表：以段（1MB）的方式进行转换时只用到一级页表，以页（Page）的方式进行转换时用到两级页表。页的大小由3种：大页（64KB）、小页（4KB）、极小页（1KB）。条目也称为”描述符“（Descriptor），有段描述符、大页描述符、小页描述符、极小页描述符–它们保存段、大页、小页或极小页的起始物理地址：粗页表描述符、细页表描述符–它们保存二级页表的物理地址。<br>大概的转换过程如下：</p>
<ol>
<li>根据给定的虚拟地址找到一级页表中的条目。</li>
<li>如果此条目是段描述符，则返回物理地址，转换结束。</li>
<li>否则如果此条目是二级页表描述符，继续利用虚拟地址在此二级页表找到下一个条目。</li>
<li>如果第二个条目是页描述符，则返回物理地址，转换结束。</li>
<li>其他情况出错。</li>
</ol>
<p><img src="/2022/08/15/MMU/3.jpeg" alt="img not found"><br>图中的“TTB base”代表一级页表的地址，将它写入协处理器CP15的寄存器C2（页表基址寄存器）即可。一级页表的地址必须是16K对应的（[14:0]为0）。<br><img src="/2022/08/15/MMU/4.jpeg" alt="img not found"><br>先介绍一级页表，32位的CPU的虚拟地址空间达到4GB，一级页表使用4096个描述符来表示这4GB空间—每个描述符对应1MB的虚拟地址，要么存储了它对应的1MB物理空间的起始地址，要么存储了下一级页表的地址。使用MVA[31:20]来索引一级页表，得到一个描述符，每个描述符占用4字节，如下图所示：<br><img src="/2022/08/15/MMU/5.jpeg" alt="img not found"><br>根据一级页表描述符的最低两位，可分为以下4种：</p>
<ol>
<li>0b00：无效。</li>
<li>0b01：粗页表（Coarse page table）<br>位[31:10]称为粗页表基址（Coarse page table base address），此描述符的低10位填充0后就是一个二级页表的物理地址。此二级页表含256个条目（所以大小为1KB），称为粗页表。其中每个条目表示大小为4KB的物理地址空间，所以一个粗页表表示1MB的物理地址空间。</li>
<li>0b10：段（Section）<br>位[31:20]称为段基址（Section Base），此描述符的低20位填充0后就是一块1MB的物理地址空间的起始地址。MVA[19:0]用来在这1MB的空间中寻址。所以，描述符的位[31:20]和MVA[19:0]就构成了这个虚拟地址MVA对应的物理地址。<br>以段的方式进行映射时，虚拟地址MVA到物理地址PA的转换过程如下：<br><img src="/2022/08/15/MMU/6.jpeg" alt="img not found"><br>①页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到段描述符。<br>②取出段描述符的位[31:20]—段基址，它和MVA[19:0]组成一个32位的物理地址–这就是MVA对应的PA。</li>
<li>0b11：细页表（Fine page table）<br>位[32：12]称为细页表基址（Fine page table base address），此描述符的低12位填充0后就是一个二级页表的物理地址。此二级页表含1024个条目（所以大小为4KB），称为细页表。其中每个条目表示大小为1KB的物理地址空间，所以一个细页表表示1MB的物理地址空间。<br>以大页（64KB）、小页（4KB）或极小页（1KB）进行地址映射时，需要用到两级页表。二级页表有粗页表、细页表两种，二级页表中描述符的格式如下：<br><img src="/2022/08/15/MMU/7.jpeg" alt="img not found"><br>根据二级描述符的最低两位，可分为以下4种情况：<br>①0b00：无效。<br>②0b01：大页描述符。<br>位[31:16]称为大页基址（Large page base address），此描述符的低16位填充0后就是一块64KB物理地址空间的起始地址。粗页表每个条目只能表示4KB的物理空间，如果大页描述符保存在粗页表中，则连续16个条目都保存同一个大页描述符。类似的，细页表中每个条目只能表示1KB的物理空间，如果大页描述符保存在细页表中，则连续64个条目都保存同一个大页描述符。<br>下面以保存在粗页表中的大页描述符为例，说明地址转换的过程：<br><img src="/2022/08/15/MMU/8.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到粗页表描述符。</span><br><span class="line">2. 取出粗页表描述符的位[31:10]--即粗页表基址，它和MVA[19:12]组成一个低两位为0的32位物理地址---据此即可找到大页描述符。</span><br><span class="line">3. 取出大页描述符的位[31:16]--即大页基址，它和MVA[15:0]组成一个32位的物理地址---这就是MVA对应的PA。</span><br><span class="line"></span><br><span class="line">上面的步骤2和3中，用于在粗页表中索引的MVA[19:12]、用于在大页内寻址的MVA[15:0]有重合的位：位[15:12]。当位[15:12]从0b0000变化到0b1111时，步骤2返回的大页描述符相同，所以粗页表中连续16个条目都保存同一个大页描述符。</span><br></pre></td></tr></table></figure>
③0b10：小页描述符<br>位[31:12]称为小页基址，此描述符的低12位填充0后就是一块4KB物理地址空间的起始地址。粗页表中每个条目表示4KB的物理空间，如果小页描述符保存在粗页表中，则只需要用一个条目来保存一个小页描述符。类似的，细页表中每个条目只能表示1KB的物理空间，如果小页表描述符保存在细页表中，则连续4个条目都保存同一个小页描述符。<br><img src="/2022/08/15/MMU/9.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到粗页表描述符。</span><br><span class="line">2. 取出粗页表描述符的位[31:10]--即粗页表基址，它和MVA[19:12]组成一个低两位为0的32位物理地址---据此即可找到小页描述符。</span><br><span class="line">3. 取出小页描述符的位[31:12]--即小页基址，它和MVA[11:0]组成一个32位的物理地址---这就是MVA对应的PA。</span><br><span class="line"></span><br><span class="line">小页描述符保存在细页表中，地址转换过程与上面类似，不在赘述。</span><br></pre></td></tr></table></figure>
④0b11：极小页描述符<br>位[31:10]被称为极小页基址，此描述符的低10位填充0后就是一块1KB的物理地址空间的起始地址。极小页描述符只能保存在细页表中，用一个条目来保存一个极小页描述符。<br><img src="/2022/08/15/MMU/10.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到细页表描述符。</span><br><span class="line">2. 取出细页表描述符的位[31:12]---即细页表基址。它和MVA[19:10]组成一个低两位为0的32位物理地址--据此即可找到极小页描述符。</span><br><span class="line">3. 取出极小页描述符的位[31:10]---即极小页基址，它和MVA[9:0]组成一个32位的物理地址---这是MVA对应的PA。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从段、大页、小页、极小页的地址转换过程可知。</p>
<ol>
<li>以段进行映射时，通过MVA[31:20]结合页表得到一段（1MB）的起始物理地址，MVA[19:0]用来在段中寻址。</li>
<li>以大页进行映射时，通过MVA[31:16]结合页表得到一个大页（64KB）的起始物理地址，MVA[15:0]用来在大页中寻址。</li>
<li>以小页进行映射时，通过MVA[31:12]结合页表得到一个小页（4KB）的起始物理地址，MVA[11:0]用来在大页中寻址。</li>
<li>以极小页进行映射时，通过MVA[31:10]结合页表得到一个极小页（1KB）的起始物理地址，MVA[9:0]用来在极小页中寻址。</li>
</ol>
<h2 id="内存的访问权限检查"><a href="#内存的访问权限检查" class="headerlink" title="内存的访问权限检查"></a>内存的访问权限检查</h2><p>内存的访问权限检查是MMU的主要功能之一，简单的说，它就是决定一块内存是否允许读、是否允许写。这由CP15寄存器C3（域访问控制）、描述符的域（Domain）、CP15寄存器C1的R&#x2F;S&#x2F;A位。描述符的AP位等联合作用。<br>CP15寄存器C1中的A位表示是否对地址进行对齐检查。所谓对齐检查就是，访问字（4字节的数据）时地址是否为4字节对齐。访问半字（2字节的数据）时地址是否2字节对齐，如果地址不对齐则产生”Alignment Fault“异常。无论MMU是否被开启，都可以进行对齐检查。CPU读取指令时不进行对齐检查，以字节为单位访问时也不进行对其检查。对其检查在MMU的权限检查，地址映射前进行。<br>内存的访问权限检查可以概括为一下两点：</p>
<ol>
<li>”域“决定是否对某块内存进行权限检查。</li>
<li>”AP“决定如何对某块内存进行权限检查。</li>
</ol>
<p>如图所示，S3C2410&#x2F;S3C2440有16个域，CP15寄存器C3中每两位对应一个域，用来表示这个域是否进行权限检查。图中表示CP15寄存器C3中哪两位对应哪个域，表中给出了CP15寄存器C3中这些”两位数据“的含义。<br><img src="/2022/08/15/MMU/11.jpeg" alt="img not found"></p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>无访问权限</td>
<td>任何访问都将导致”Domain Fault“ 异常</td>
</tr>
<tr>
<td>01</td>
<td>客户模式</td>
<td>使用段描述符、页描述符进行权限检查</td>
</tr>
<tr>
<td>10</td>
<td>保留</td>
<td>保留，目前相当于”无访问权限“</td>
</tr>
<tr>
<td>11</td>
<td>管理模式</td>
<td>运行任何访问</td>
</tr>
</tbody></table>
<p>下图中的”Domain“占4个字节，用来表示这块内存属于上面定义的16个域中哪一个。<br><img src="/2022/08/15/MMU/12.jpeg" alt="img not found"></p>
<ol>
<li>段描述符中的”Domain“为0b0000时，表示这1MB内存属于域0，如果域访问控制寄存器的位[1:0]等于0b00，则访问这1MB空间时都会产生”Domain fault“的异常，如果域访问控制器寄存器的位[1:0]等于0b11，则使用描述符中的”AP“位进行权限检查。</li>
<li>粗页表中的”Domain“为0b1111时，表示这1MB内存属于域15，如果域访问控制寄存器的位[31:30]等于0b00，则访问这1MB空间时都会产生”Domain fault“的异常，如果域访问控制寄存器的位[31:30]等于0b11时，则使用二级页表中的大页&#x2F;小页描述符中的”ap3“、”ap2“、”ap1“、”ap0“进行位权限检查。</li>
</ol>
<p>图中的”AP“、”ap3“、”ap2“、”ap1“、”ap0”结合CP15寄存器C1的R&#x2F;S位，决定如何进行访问权限检查。首先说明，段描述符中的“AP”控制整个段（1MB）的访问权限；大页描述符中的每个“apx”（x为0-3）控制一个大页（64KB）中1&#x2F;4内存的访问权限，即“ap3”对应大页高端的16KB，“ap0”对应大页低端的16KB；小页描述符与大页描述符相似，每个“apx”控制一个小页（4KB）的1&#x2F;4内存的访问权限；极小页中的“ap”就控制着整个极小页（1KB）的访问权限。<br>如下表所示，AP位、S位和R位的组合，可以产生多种访问权限。需要指出的是，ARM CPU有7种工作模式，其中6种属于特权模式，一种属于用户模式。在特权模式的用户模式下，相同的AP位、S位和R位的组合，其访问权限也不相同。</p>
<table>
<thead>
<tr>
<th>AP</th>
<th>S</th>
<th>R</th>
<th>特权模式</th>
<th>用户模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>0</td>
<td>0</td>
<td>无访问权限</td>
<td>无访问权限</td>
<td>任何访问都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>00</td>
<td>1</td>
<td>0</td>
<td>只读</td>
<td>无访问权限</td>
<td>在超级权限下进行读操作</td>
</tr>
<tr>
<td>00</td>
<td>0</td>
<td>1</td>
<td>只读</td>
<td>只读</td>
<td>任何写操作都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>00</td>
<td>1</td>
<td>1</td>
<td>保留</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>01</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>无访问权限</td>
<td>只允许在超级模式下访问</td>
</tr>
<tr>
<td>10</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>只读</td>
<td>在用户模式下进行写操作都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>11</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>读&#x2F;写</td>
<td>在任何模式下都允许访问</td>
</tr>
<tr>
<td>xx</td>
<td>1</td>
<td>1</td>
<td>保留</td>
<td>–</td>
<td>–</td>
</tr>
</tbody></table>
<h2 id="TLB的作用"><a href="#TLB的作用" class="headerlink" title="TLB的作用"></a>TLB的作用</h2><p>从虚拟地址到物理地址的转换过程可得知：使用一级页表进行地址转换时，每次读写数据时需要访问两次内存。第一次访问一级页表获取物理地址，第二次才是真正的读写数据。使用两级页表时，每次读写数据需要访问三次内存，访问两次页表（一级页表和二级页表）获得物理地址，第三次才是真正的读写数据。<br>上述地址的转换过程大大降低了CPU的性能，有没有说明办法改进呢？程序执行过程中，所用到的指令、数据的地址往往集中在一个很小的范围内，其中的地址数据经常多次使用，这称为程序访问的局部性。由此，通过使用一个高速、容量相对较小的存储器来存储近期用过的页表条目（段、大页、小页、极小页描述符），以避免每次地址转换都需要到主存去查找，这样可以大幅度的提高性能。这个存储器用来帮助快速的进行地址转换，称为“转译查找缓存（Translation Lookaside Buffers，TLB）”。<br>当CPU发出一个虚拟地址时，MMU首先访问TLB。如果TLB中含有能转换这个虚拟地址的描述符，则直接利用此描述符进行地址转换和权限检查；否则MMU访问页表找到描述符后再进行地址转化和权限检查，并将这个描述符填入TLB中（如果TLB已满，则利用round-robin算法找到一个条目，然后覆盖他），下次再使用这个虚拟地址时就可以直接使用TLB中的描述符了。<br>使用TLB需要保证TLB的内容与页表一致，在启动MMU之前，在页表中的内容发生变化后，尤其要注意这点。S3C2410&#x2F;S3C2440可以使无效（Invalidate）整个TLB，或者通过某个虚拟地址使无效TLB中某个条目。一般的做法是：在启动MMU之前使无效整个TLB，改变页表时，使无效所涉及的虚拟地址对应的TLB中的条目。</p>
<h2 id="Cache的作用"><a href="#Cache的作用" class="headerlink" title="Cache的作用"></a>Cache的作用</h2><p>同样基于程序访问的局部性，在主存和CPU通用寄存器之间设置一个高速的、容量相对较小的存储器，把正在执行的指令地址附近的一部分指令或数据从主存调入这个存储器，供CPU在一段时间内使用，这对提高程序的运行速度有很大的作用。这个介于主存和CPU之间的高速小容量存储器称作高速缓存存储器（Cache）。<br>启用Cache后，CPU读取数据时，如果Cache中有这个数据的复本则直接返回，否则从主存中读入数据，并存入Cache中，下次再使用（读&#x2F;写）这个数据时，可以直接使用Cache中的复本。<br>启用Cache后，CPU写数据时有写穿式和写回式两种方式：</p>
<ol>
<li>写穿式（Write Through）<br>任一从CPU发出的写信号送到Cache的同时，也写入主存，以保证主存的数据能同步更新。它的优点是操作简单，但是由于主存的慢速，降低了系统的写速度并占用总线时间。</li>
<li>回写式<br>为了克服写穿式每次写数据时都要访问主存，从而导致系统写速度降低并占用总线时间，尽量减少对主存的访问次数，又有了回写式。<br>它的工作方式：数据一般只写到Cache，这样有可能出现Cache中的数据得到更新而主存数据不变（数据陈旧）的情况。但此时可在Cache中设一标志及数据陈旧的信息，只有当Cache中的数据被换出或强制进行“清空”操作时，才将原更新的数据写入主存相应的单元中。这样保证了Cache和主存的数据一致性。</li>
</ol>
<p>下面介绍Cache的两个操作：</p>
<ol>
<li>“清空”（clean）：把Cache或Write Buffer中已经脏的（修改过，但是还未写入主存）数据写入主存。</li>
<li>“使无效”（Invalidate）：使之不能再使用，并不将脏的数据写入主存。</li>
</ol>
<p>S3C2410&#x2F;S3C2440内置了指令Cache（ICache）、数据Cache（DCache）、写缓存（Write Buffer）。下面的内容需要用到页表中描述符的C、B位，为了方便读者，先把这些描述符用下图表示出来。下文中，描述符的C位称为Ctt，B位称为Btt。<br><img src="/2022/08/15/MMU/13.jpeg" alt="img not found"></p>
<h3 id="指令Cache（ICache）"><a href="#指令Cache（ICache）" class="headerlink" title="指令Cache（ICache）"></a>指令Cache（ICache）</h3><p>ICache的使用比较简单。系统刚上电或复位时，ICache中的内容是无效的，并且ICache功能是关闭着的。往Icr位（即CP15写处理器中寄存器1的第12位）写1可以启动ICache，写0可以停止ICache。<br>ICache一般在MMU开启之后被使用，此时页表中描述符的C位用来表示一段内存是否可以被Cache。若C&#x3D;1，则允许Cache，否则不允许被Cache。但是，即使MMU没有开启，ICache也是可以被使用的，这时CPU读取指令（取指）时所涉及的内存都被当作是允许Cache的。<br>ICache被关闭时，CPU每次取指都是需要读取主存，性能非常低，所以需要尽早启动ICache。<br>ICache被开启后，CPU每次取指都会在ICache中查看是否能找到所要的指令，而不管C&#x3D;0还是C&#x3D;1。如果找到了，称为Cache命中，如果找不到，称为Cache缺失。ICache被开启后，CPU的取指分为如下三种情况：</p>
<ol>
<li>Cache命中且C&#x3D;1时，从ICache取出指令，返回CPU。</li>
<li>Cache缺失且C&#x3D;1时，CPU从主存读出指令。同时，一个称为“8-word linefill”的动作将发生，这个动作把该指令所处区域的8个word写进ICache的某个条目中。这有可能会覆盖某个条目。</li>
<li>C&#x3D;0时，CPU从主存读取指令。</li>
</ol>
<h3 id="数据Cache（DCache）"><a href="#数据Cache（DCache）" class="headerlink" title="数据Cache（DCache）"></a>数据Cache（DCache）</h3><p>与ICache相似，系统刚复位或者上电时，DCache中的内容也是无效的，并且DCache功能也是关闭的，而Write Buffer中的内容也是被废弃不用的。往Ccr（Cp15协处理器中寄存器1的第2位）写1可以启动DCache，写0可以停止DCache。Write Buffer与DCache紧密结合，没有专门的控制位来开启、停止它。<br>与ICache不同的是，DCache功能必须在MMU开启之后才能被使用，因为开启MMU之后，才能使用页表的描述符来定义一块内存如何使用DCache和Write Buffer。<br>DCache被关闭时，CPU每次读写数据时都会先在DCache中查看是否能找到所要的数据，而不管C&#x3D;0还是C&#x3D;1。找到了，称为Cache命中，没找到，称为Cache缺失。<br>下表描述了DCache和Write Buffer在CCr、Ctt、Btt的各种取值下如何工作。表中“Ctt and Ccr”一项的值是Ctt与Ccr进行逻辑与之后的值（Ctt &amp;&amp; Ccr）。</p>
<table>
<thead>
<tr>
<th>Ctt and Ccr</th>
<th>Btt</th>
<th>DCache、Write Buffer和主存的访问方式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>Non-Cached、Non-buffered（NCNB）；读写数据都是直接操作内存，并且可以被外设中止；写数据时不使用Write Buffer，CPU会等待操作完成；不会出现Cache命中</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Non-Cached、buffered（NCB）；读写数据都是直接操作主存，不会出现Cache命中；写数据时，数据先存入Write Buffer，随后写入主存；数据存入WriteBuffer后，CPU立立即继续执行；读数据时，可以被外设中止；写数据时，无法被外设中止</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Cached，write-through（WT，写通）mode；读数据时，如果Cache命中则从Cache中返回数据，不读取主存；读数据时，如果Cache确实则从读主存中返回数据，并导致“linefill”的动作；写数据时，数据先存入Write Buffer，并在随后写入主存；数据存入Write Buffer后，CPU立即继续执行；写数据时，如果Cache命中则新数据也写入Cache中；写数据时，无法被外设中止</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Cached，write-back（WB，写回）mode；读数据时，如果Cache命中则从Cache中返回数据，不读取主存；读数据时，如果Cache确实则从读主存中返回数据，并导致“linefill”的动作；写数据时，如果Cache缺失则将数据先存入Write Buffer，存储完毕后CPU立即继续执行，这些数据随后写入主存；写数据时，如果Cache命中则在Cache中更新数据，并设置这些数据为“脏”，但是不会写入主存；无论Cache命中与否，写数据都无法被外设中止。</td>
</tr>
</tbody></table>
<p>与TLB类似，使用Cache需要保证Cache、WriteBuffer的内容和主存保持一致，需要遵循以下两个原则：</p>
<ol>
<li>清空DCache，使得主存数据得到更新。</li>
<li>使无效ICache，使得CPU取值时重新读取主存。</li>
</ol>
<p>在实际编写程序前，需要注意以下几点：</p>
<ol>
<li>开启MMU之前，使无效ICache、DCache、WriteBuffer。</li>
<li>关闭MMU之前，清空ICache、DCache，即将“脏”数据写入主存。</li>
<li>如果代码有变，使无效ICache，这样CPU取指时会重新读取主存。</li>
<li>使用DMA操作可以被Cache的主存时：将内存的数据发送出去时，要清空Cache；将内存的数据读入时，要使无效Cache。</li>
<li>改变页表中地址映射关系时，也要慎重考虑。</li>
<li>开启ICache和DCache时，要考虑ICache或DCache中的内容是否与主存保持一致。</li>
<li>对于I&#x2F;O空间，不使用Cache和Write Buffer。所谓I&#x2F;O空间，就是对于其中的地址连续两次的写操作不能合并在一起，每次读写都必须直接访问设备，否则程序的运行结果无法预料。比如寄存器、非内存的外设（扩展串口、网卡等）。<br>S3C2410&#x2F;S3C2440提供了相关指令来操作Cache和Write buffer，可以使无效整个ICache或其中的条目，可以清空使无效整个DCache或其中的条目。</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440-MMU、TLB、Cache的控制指令"><a href="#S3C2410-x2F-S3C2440-MMU、TLB、Cache的控制指令" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU、TLB、Cache的控制指令"></a>S3C2410&#x2F;S3C2440 MMU、TLB、Cache的控制指令</h3><p>S3C2410&#x2F;S3C2440中，除了有一个ARM920T的CPU核之外，还有若干协处理器。协处理器也是一个微处理器，它被用来帮助主CPU来完成一些特殊功能，如浮点运算等。对MMU、TLB、Cache等的操作就涉及协处理器。CPU核与协处理器间传送数据时使用这两条指令：MRC和MCR，它们的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MCR | MRC&gt;&#123;cond&#125; p#,&lt;expression1&gt;,Rd,cn,cm,&#123;,&lt;expression2&gt;&#125;</span><br><span class="line">MRC             //从协处理器获得数据，传给ARM920T CPU核的寄存器</span><br><span class="line">MCR             //数据从ARM920T CPU核的寄存器传给协处理器</span><br><span class="line">&#123;cond&#125;          //执行条件  为空时表示无条件执行</span><br><span class="line">p#              //协处理器序号</span><br><span class="line">&lt;expression1&gt;  //一个常数</span><br><span class="line">Rd              //ARM920T核的寄存器</span><br><span class="line">cn和cm          //协处理器中的寄存器</span><br><span class="line">&lt;expression2&gt;   //一个常数</span><br></pre></td></tr></table></figure>
<p>其中，expression1、expression2、cn、cm仅供协处理器使用，它们的作用如何取决于具体的协处理器。</p>
<h1 id="MMU使用实例"><a href="#MMU使用实例" class="headerlink" title="MMU使用实例"></a>MMU使用实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本开发板的SDRAM的物理地址范围处于0x30000000-0x33ffffff，S3C2410&#x2F;S3C2440的寄存器地址范围都处于0x48000000-0x5FFFFFFF。在第五章中，通过往GPBCON和GPBDAT这两个寄存器的物理地址0x56000000、0x56000014写入特定的数据来驱动4个LED。<br>本章的实例将开启MMU，并将虚拟地址空间0xA0000000-0xA0100000映射到物理地址空间0x56000000-0x56100000上，这样，就可以通过操作地址0xA0000010、0xA0000014来达到驱动者4个LED的同样效果。<br>另外，将虚拟地址空间0xB0000000-0xB3FFFFFFF映射到物理地址空间0x30000000-0x33FFFFFF上，并在连接程序时将一部分代码的运行地址指定为0xB0004000，看看程序能否跳转到0xB0004000运行。<br>实例程序只是用一级页表，以段的方式进行地址映射。32位的CPU的虚拟地址空间达到4GB，一级页表中使用4096个描述符来表示这4GB（每个描述符对应1MB的虚拟地址），每个描述符占用4字节，所以一级页表占16KB。SDRAM的开始16KB来存放一级页表，所以剩下的内存开始物理地址为0xB0004000。<br>将程序代码分为两部分：第一部分的运行地址为0，它用来初始化SDRAM、复制第二部分的代码到SDRAM中（存放在0x30004000开始处），设置页表，启动MMU，最后跳转到SDRAM中（地址0xB0004000）去执行；第二部分的运行地址设为0xB0004000，它用来驱动LED。程序流程图如下：<br><img src="/2022/08/15/MMU/14.jpeg" alt="img not found"></p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="第一部分代码分析"><a href="#第一部分代码分析" class="headerlink" title="第一部分代码分析"></a>第一部分代码分析</h3><p>程序源码分3个文件：head.S、init.c、leds.c。</p>
<ol>
<li>head.S代码详解<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:head.S</span></span><br><span class="line"><span class="comment">功能：设置SDRAM，将第二部分代码复制到SDRAM，设置页表，启动MMU，然后跳到SDRAM继续执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_satrt:</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置栈指针，以下都是C函数，调用前需要设置好栈</span><br><span class="line">  bl  disable_watch_dog   @关闭WATCHDOG，否则CPU会不断重启</span><br><span class="line">  bl  memsetup            @设置控制存储器以使用SDRAM</span><br><span class="line">  bl  copy_2th_to_sdram   @将第二部分代码复制到SDRAM</span><br><span class="line">  bl  create_page_table   @设置页表</span><br><span class="line">  bl  mmu_init            @启动MMU</span><br><span class="line">  bl  sp,=<span class="number">0xB4000000</span>      @重设栈指针，指向SDRAM顶端（使用虚拟地址）</span><br><span class="line">  bl  pc,=<span class="number">0xB0004000</span>      @跳到SDRAM中继续执行第二部分代码</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">  b halt_loop</span><br></pre></td></tr></table></figure>
head.S调用的函数都在init.c中实现。<br>值得注意的是，在第15行开启MMU之后，无论是CPU取指还是CPU读写数据，使用的都是虚拟地址。<br>在第14行设置页表时，在create_page_table函数中令head.S、init.c程序所在的内存的虚拟地址和物理地址一样，这使得head.S和init.c中的代码在开启MMU后能够没有任何障碍的继续运行。</li>
<li>init.c代码详解<br>disable_watch_dog、memsetup两个接口已经在前两章讨论过，下面不再赘述。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">init.c：进行一些初始化，在Steppingstone中运行</span></span><br><span class="line"><span class="comment">它和head.S同属第一部分程序，此时MMU尚未开启，使用物理地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WATCHDOG寄存器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WTCON (*(volatile unsigned long *)0x53000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储控制器的寄存器起始地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CTL_BASE  0x48000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭WATCHAOG，否则CPU会不断重启</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_watch_dog</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  WTCON = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置存储控制器以使用SDRAM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memsetup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//SDRAM 13个寄存器的值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> mem_cfg_val[]=&#123;<span class="number">0x22011110</span>,<span class="comment">//BWSCON</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON0</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON1</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON2</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON3</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON4</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON5</span></span><br><span class="line">                                    <span class="number">0x00018005</span>,<span class="comment">//BANKCON6</span></span><br><span class="line">                                    <span class="number">0x00018005</span>,<span class="comment">//BANKCON7</span></span><br><span class="line">                                    <span class="number">0x008C07A3</span>,<span class="comment">//REFRESH</span></span><br><span class="line">                                    <span class="number">0x000000B1</span>,<span class="comment">//BANKSIZE</span></span><br><span class="line">                                    <span class="number">0x00000030</span>,<span class="comment">//MRSRB6</span></span><br><span class="line">                                    <span class="number">0x00000030</span><span class="comment">//MRSRB7</span></span><br><span class="line">                                    &#125;;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)MEM_CTL_BASE;</span><br><span class="line">  <span class="keyword">for</span>(;i &lt; <span class="number">13</span>;i++)</span><br><span class="line">    p[i] = mem_cfg_val[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
copy_2th_to_sdram函数用来将第二部分代码（即由leds.c编译得来的代码）从Steppingstone复制到SDRAM中。在连接程序时，第二部分代码的加载地址被指定为2048，重定位地址为0xB0004000。所以系统从NAND Flash启动后，第二部分代码Steppingstone中地址2048之后，需要把它复制到0x30004000处（此时尚未开启MMU，虚拟地址0xB0004000对应的物理地址在后面设为0x30004000）。Steppingstone总大小为4KB，不妨把地址2048后的所有数据复制到SDRAM中，所以源数据的结束地址为4096。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将第二部分代码复制到SDRAM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_2th_to_sdram</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *pdwSrc = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">2048</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *pdwDest = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x30004000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(pdwSrc &lt; (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">4096</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *pdwDest = *pdwSrc;</span><br><span class="line">    pdwDest++;</span><br><span class="line">    pdwSrc++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
剩下的create_page_table、mmu_init就是本章的重点了。前者用来设置页表，后者用来开启MMU。<br>先看看create_page_table函数，它用于设置3个区域的地址映射关系。<br>①将虚拟地址0-（1M-1）映射到同样的物理地址去，Steppingstone（从0地址开始的4KB内存）就处于这个范围中。使虚拟地址等于物理地址，可以让Steppingstone中的程序（head.S和init.c）在开启MMU前后不需要考虑太多的事情。<br>②GPIO寄存器的起始物理地址范围为0x56000000，将虚拟地址0xA0000000-（0xA0000000+1M-1）映射到物理地址0x56000000-（0x56000000+1M-1）。<br>③本开发板中SDRAM的物理地址范围为0x30000000-0x33fffffff，将虚拟地址0xB0000000-0xB3fffffff映射到物理地址0x30000000-0x33fffffff。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置页表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_page_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用于段描述符的一些宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_FULL_ACCESS (3 &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_DOMAIN (0 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SPECIAL (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_CACHEABLE (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_BUFFERABLE (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECTION (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | MMU_SECTION)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC_WB (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | MMU_SECTION | MMU_BUFFERABLE | MMU_CACHEABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC_SIZE (0x00100000)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> virtualaddr,physicaladdr;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *mmu_tlb_base = (<span class="type">unsigned</span> <span class="type">long</span> *)<span class="number">0x30000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Steppingstone的起始物理地址为0，第一部分程序的起始运行地址也是0，</span></span><br><span class="line"><span class="comment">  为了在开启MMU后仍能运行第一部分的程序，</span></span><br><span class="line"><span class="comment">  将0-1M的虚拟地址空间映射到同样的物理地址</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0</span>;</span><br><span class="line">  physicaladdr = <span class="number">0</span>;</span><br><span class="line">  *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  0x56000000是GPIO寄存器的起始物理地址</span></span><br><span class="line"><span class="comment">  GPBCON和GPBDAT这两个寄存器的物理地址0x56000010、0x56000014，</span></span><br><span class="line"><span class="comment">  为了在第二部分程序中能以地址0xA0000010、0xA0000014来操作GPBCON和GPBDAT这两个寄存器，</span></span><br><span class="line"><span class="comment">  把从0xA0000000开始的1MB虚拟地址空间映射到0x56000000开始的1MB物理地址空间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0xA0000000</span>;</span><br><span class="line">  physicaladdr = <span class="number">0x56000000</span>;</span><br><span class="line">  *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  SDRAM的物理地址范围是0x3000000-0x33FFFFFF，</span></span><br><span class="line"><span class="comment">  将虚拟地址0xB0000000-0xB3fffffff映射到物理地址0x30000000-0x33fffffff上</span></span><br><span class="line"><span class="comment">  总共64MB，涉及64个段描述符</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0xB0000000</span>;</span><br><span class="line">  physicaladdr = <span class="number">0x30000000</span>;</span><br><span class="line">  <span class="keyword">while</span>(virtualaddr &lt; <span class="number">0xB4000000</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line">    virtualaddr += <span class="number">0x100000</span>;</span><br><span class="line">    virtualphysicaladdraddr += <span class="number">0x100000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
mmu_tlb_base被定义为unsigned long 指针，所指向的内存为4字节，刚好是一个描述符的大小。在SDRAM的开始存放页表—第81行令mmu_tlb_base指向SDRAM的起始地址0x3000000。其中最能体现页表结构的代码是下列代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC;</span><br><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br></pre></td></tr></table></figure>
虚拟地址的位[31:20]用于索引一级页表，找到它所对应的描述符，对应于“(virtualaddr &gt;&gt; 20)”。<br>段描述符中位[31:20]中保存段的物理地址，对应于“(physicaladdr &amp; 0xFFF00000)”。<br>位[11:0]中用来设置段的访问权限，包括所属的域、AP位、C位（是否可Cache）、B位（是否使用Write buffer）—这对应“MMU_SECDESC”或“MMU_SECDESC_WB”，它们的域都被设为0，AP位被设为0b11（进行权限检查，读写操作都被允许）。“MMU_SECDESC”中C&#x2F;B位都没有设置，表示不使用Cache和Write Buffer，所以映射寄存器空间时使用“MMU_SECDESC”。“MMU_SECDESC_WB”中C&#x2F;B都设置了，表示使用Cache和Write Buffer，即所谓的回写式。在映射Steppingstone和SDRAM等内存时使用“MMU_SECDESC_WB”。<br>现在看看mmu_init函数。Create_page_table函数设置好了页表，还需要把页表地址告诉CPU，并且在开启MMU之前做好一些准备工作，比如使无效ICache、DCache，设置域访问控制寄存器等。代码的注释就可以帮助读者很好的理解mmu_init函数。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">启动MMU</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmu_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ttb <span class="number">0x30000000</span>;</span><br><span class="line"></span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;mov  r0,  #0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c7,  c7,   0\n&quot;</span>                  <span class="comment">//使无效ICache和DCache</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c7,  c10,  4\n&quot;</span>                  <span class="comment">//drain write buffer on v4</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c8,  c7,   0\n&quot;</span>                  <span class="comment">//使无效指令、数据TLB</span></span><br><span class="line">    <span class="string">&quot;mov  r4,   %0\n&quot;</span>                                     <span class="comment">//r4 = 页表基址</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r4,   c2,   c0,   0\n&quot;</span>                <span class="comment">//设置页表基址寄存器</span></span><br><span class="line">    <span class="string">&quot;mvn  r0,   #0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,   c3,   c0,   0\n&quot;</span>                <span class="comment">//域访问控制寄存器设为0xFFFFFFFFF，不进行权限检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于控制寄存器，先读出其值，在这基础上修改感兴趣的位</span></span><br><span class="line"><span class="comment">    然后再写入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">&quot;mrc  p15,  0,  r0, c1, c0, 0\n&quot;</span>                      <span class="comment">//读出控制寄存器的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    控制寄存器的低16位含义为：.RVI ..RS B... .CAM</span></span><br><span class="line"><span class="comment">    R：表示换出Cache中的条目时使用的算法，0 = Random repalcement；1 = Round robin replacement</span></span><br><span class="line"><span class="comment">    V：表示异常向量表所在的位置；0 = Low address = 0x00000000；1 = High address = 0xFFFF0000</span></span><br><span class="line"><span class="comment">    I：0 = 关闭ICache；1 = 开启ICache；</span></span><br><span class="line"><span class="comment">    R、S：用来与页表中的描述符一起确定内存的访问权限；</span></span><br><span class="line"><span class="comment">    B：0 = CPU为小字节序；1 = CPU为大字节序；</span></span><br><span class="line"><span class="comment">    C：0 = 关闭DCache；1 = 开启DCache；</span></span><br><span class="line"><span class="comment">    A：0 = 数据访问时不进行地址对齐检查；1 = 数据访问时进行地址对齐检查；</span></span><br><span class="line"><span class="comment">    M：0 = 关闭MMU；1 = 开启MMU；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    先清除不需要的位，往下若需要则重新设置它们</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*.RVI ..RS B... .CAM*/</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x3000\n&quot;</span>                             <span class="comment">//..11 .... .... .... 清除V、I位</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x0300\n&quot;</span>                             <span class="comment">//.... ..11 .... .... 清除R、S位</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x0087\n&quot;</span>                             <span class="comment">//.... .... 1... .111 清除B/C/A/M位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置需要的位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0002\n&quot;</span>                                <span class="comment">//.... .... .... ..1. 开启对齐检查</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0004\n&quot;</span>                                <span class="comment">//.... .... .... .1.. 开启DCache</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x1000\n&quot;</span>                                <span class="comment">//...1 .... .... .... 开启ICache</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0001\n&quot;</span>                                <span class="comment">//.... .... .... ...1 使能MMU</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,   c1,   c0,   0\n&quot;</span>                  <span class="comment">//将修改的值写入到控制寄存器</span></span><br><span class="line">    :<span class="comment">/*无输出*/</span></span><br><span class="line">    :<span class="string">&quot;r&quot;</span>(ttb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="第二部分代码分析"><a href="#第二部分代码分析" class="headerlink" title="第二部分代码分析"></a>第二部分代码分析</h3><p>第二部分代码leds.c中只有两个函数：wait和main。wait函数用来延时，main函数用来循环点亮4个LED。</p>
<ol>
<li>操作GPBCON、GPBDAT两个寄存器时使用虚拟地址0xA0000010、0xA0000014。在init.c中已经把虚拟地址0xA0000000-（0xA0000000 + 1M-1）映射到物理地址0x56000000-（0x56000000+1M-1）；</li>
<li>在定义wait函数时使用了一点小技巧，将它定义成“static inline”类型，原因在代码中给出：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  leds.c：循环点亮4个LED</span></span><br><span class="line"><span class="comment">  属于第二部分程序，此时MMU已开启，使用虚拟地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (* (unsigned long *) 0xA0000010)             <span class="comment">//物理地址0x56000010</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (* (unsigned long *) 0xA0000014)             <span class="comment">//物理地址0x56000014</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LED1-LED4对应GPB5、GPB6、GPB7、GPB8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">wait函数加上“static inline”是有原因的，</span></span><br><span class="line"><span class="comment">这样可以使得编译leds.c时，wait嵌入main中，编译结果只有main一个函数。</span></span><br><span class="line"><span class="comment">于是在连接时，main函数的地址就是由连接文件指定的运行地址。</span></span><br><span class="line"><span class="comment">而连接文件mmu.lds中，指定了leds.o的运行时装载地址为0xB0004000，</span></span><br><span class="line"><span class="comment">这样，head.s中的“ldr pc,=0xB0004000“就是跳去执行main函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> dly)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;dly &gt; <span class="number">0</span>;dly--)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将LED1NLED4对应的GPB5GPB8引脚设置为输出</span></span><br><span class="line">  GPBCON = GPB5out | GPB6_out | GPB7_out | GPB8_out;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">3000000</span>);</span><br><span class="line">    GPBDAT = (~(i&lt;&lt;<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span>(++i == <span class="number">16</span>)</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Makefile和连接脚本mmu-lds"><a href="#Makefile和连接脚本mmu-lds" class="headerlink" title="Makefile和连接脚本mmu.lds"></a>Makefile和连接脚本mmu.lds</h3><p>Makefile内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objs := head.o init.o leds.o</span><br><span class="line"></span><br><span class="line">mmu.bin:  $(objs)</span><br><span class="line">  arm-linux-ld -Tmmu.lds -o mmuj_elf $^</span><br><span class="line">  arm-linux-objcopy -O binary -S mmu_elf $@</span><br><span class="line">  arm-linux-objdump -D -m arm mmu_elf &gt; mmu.dis</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">  arm-linux-gcc -Wall -O2 -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">%.o:%.s</span><br><span class="line">  arm-linux-gcc -Wall -O2 -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -f mmu.bin mmu_elf mmu.lds *.o</span><br></pre></td></tr></table></figure>
<p>Makefile第4行命令用来连接程序，它使用连接脚本mmu.lds来控制连接器的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS  &#123;</span><br><span class="line">    first <span class="number">0x00000000</span>  : &#123;head.o init.o&#125;</span><br><span class="line">    second  <span class="number">0xB0004000</span>  : AT(<span class="number">2048</span>)  &#123;leds.o&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接脚本mmu.lds将程序分为两个段：first和second。前者由head.o和init.o组成，它的加载地址和运行地址都是0，所以运行前不需要重新移动代码。后者由leds.o组成，它的加载地址为2048，重定位地址为0xB0004000，这表明段second存放在编译所得映像文件地址2048处，在运行前需要将它复制到0xB0004000处，这由init.c中的copy_2th_to_sdram函数完成（此函数将代码复制到开始地址为0x30004000的内存中，这是开启MMU后虚拟地址0xB0004000对应的物理地址）。<br>实例程序涉及了代码的复制、开启MMU前使用物理地址寻址，开启MMU后使用虚拟地址寻址，相对复杂。下图更形象的演示了代码的执行。<br><img src="/2022/08/15/MMU/15.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/16.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/17.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/18.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/19.jpg" alt="img not found"></p>
<h1 id="实例测试结果"><a href="#实例测试结果" class="headerlink" title="实例测试结果"></a>实例测试结果</h1><p>程序烧入NAND Flash后，复位启动系统。可以看到4个LED被循环点亮，闪烁速度比SDRAM实验快，那是因为开启了Cache。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第7章 MMU</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>MMU</tag>
      </tags>
  </entry>
  <entry>
    <title>LCD控制器</title>
    <url>/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第13章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解LCD显示器的接口及时序</li>
<li>掌握S3C2410&#x2F;S3C2440LCD控制器的使用方法</li>
<li>了解帧缓冲区的概念，掌握如何设置帧缓冲区来显示图像</li>
</ol>
<h1 id="LCD和LCD控制器"><a href="#LCD和LCD控制器" class="headerlink" title="LCD和LCD控制器"></a>LCD和LCD控制器</h1><h2 id="LCD显示器"><a href="#LCD显示器" class="headerlink" title="LCD显示器"></a>LCD显示器</h2><h3 id="LCD的种类"><a href="#LCD的种类" class="headerlink" title="LCD的种类"></a>LCD的种类</h3><p>LCD（Liquid Crystal Display），即液晶显示器，是一种采用了液晶控制透光度技术来实现色彩的显示器。它与传统的CRT显示器相比有很多优点：轻薄、能耗低、辐射小等，市场占有率越来越大。LCD有很多种类，比如STN、TFT、LTPS TFT、OLED等，各有优缺点。<br>STN（Super Twisted Nematic，超扭曲向列），有CSTN和DSTN之分，是4种LCD屏中最低端的一种，仅有的优点就是功耗低，在色彩鲜艳度和画面亮度上相对于TFT和其他LCD屏存在明显不足，在日光下几乎不能显示，而且响应时间长达200ms左右，播放动画或视频拖影明显不足。<br>TFT（Thin Film Transistor，薄膜晶体管）可以大大缩短屏幕响应时间，其响应时间已经小于80ms，并改善了STN连续显示时屏幕闪烁模糊，有效提供了动态画面的播放力，呈现画面色彩饱和度、真实效果和对比度都很不错，完全超越STN，只是功耗稍高，是目前最为主流的液晶显示器类型。在MP3、MP4产品上大量应用，在桌面液晶显示器、笔记本电脑、手机等产品上的应用也非常普遍。<br>LTPS（Low Temperature Polycrystalline Silicon，低温多晶硅）由TFT衍生的新一代的技术产品，可以获得更高的分辨率和更丰富的色彩。LTPS LCD可以提供170°的水平和垂直可视角度，显示响应仅12ms，显示亮度达到500Cd&#x2F;m²，对比度可达500：1，这就是一些桌面液晶屏性能越来越出色的原因。虽然LTPS LCD已经出现很多年了，但由于LTPS TFT液晶屏的制造需要高于制造传统TFT屏的技术水平，目前仅有少数知名大厂能制造。<br>OLED（Organic Light Emitted Diode，有机发光二极管）各种物理特性都具备领先优势，色彩明亮、可视角度超大、非常省电，是未来发展的主流，只是目前受技术与成本限制，未能广泛普及。目前，彩色OLED比较广泛的存在中低端产品中。</p>
<h3 id="LCD的接口"><a href="#LCD的接口" class="headerlink" title="LCD的接口"></a>LCD的接口</h3><p>CPU或显卡发出的图像是TTL信号，LCD本身接收的也是TTL信号。但是由于TTL信号高速率的长距离传输性能不佳，抗干扰能力也比较差，后来又提出了多种接口，比如LVDS、TDMS、GVIF、P&amp;D、DVI和DFP等。它们实际上只是将CPU或显卡发出的TTL信号编码成各种信号以便传输，在LCD那边将接收到的信号进行解码得到TTL信号。<br>由于数字接口标准尚未统一，所以使用LCD时需要根据其手册了解具体接口定义。也是基于数字接口标准尚未统一的原因，市场上大多LCD都采用模拟接口信号，LCD先通过ADC将模拟信号转换为数字信号才能显示。<br>但是不管采用何种数字接口，本质的TTL信号是一样的。</p>
<ol>
<li><p>对于STN LCD<br>STN LCD 的数据传输方式有3种：4位单扫（4-bit single scan）、4位双扫（4-bit dual scan）、8位单扫（8-bit single scan）。所谓“单扫”是指对于一整屏的数据，从上到下、从左到右，一个一个的发送出来；“双扫”是指将一整屏的数据分为上下两部分，同时从上到下、从左到右，一个一个的发送出来。“4位”、“8位”是指发送数据时使用多少个数据线；需要注意的是，4位双扫方式也是用到8根数据线，其中4根用于上半屏数据，另外4根用于下半屏数据。<br>除数据信号外，还有其他控制信号，所有TTL信号如下表所示：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>VFRAME</td>
<td>帧同步信号</td>
</tr>
<tr>
<td>VLINE</td>
<td>行同步信号</td>
</tr>
<tr>
<td>VCLK</td>
<td>像素时钟信号</td>
</tr>
<tr>
<td>VD[7:0]</td>
<td>数据信号</td>
</tr>
<tr>
<td>VM</td>
<td>AV偏置信号</td>
</tr>
<tr>
<td>PWREN</td>
<td>电源开关信号</td>
</tr>
</tbody></table>
</li>
<li><p>对于TFT LCD<br>TFT LCD的信号与STN类似，只是其数据信号多达24根，对应像素值的每一位。</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>VSYNC</td>
<td>垂直同步信号</td>
</tr>
<tr>
<td>HSYNC</td>
<td>水平同步信号</td>
</tr>
<tr>
<td>HCLK</td>
<td>像素时钟信号</td>
</tr>
<tr>
<td>VD[23:0]</td>
<td>数据信号</td>
</tr>
<tr>
<td>LEND</td>
<td>行结束信号</td>
</tr>
<tr>
<td>PWREN</td>
<td>电源开关信号</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-LCD控制器介绍"><a href="#S3C2410-x2F-S3C2440-LCD控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 LCD控制器介绍"></a>S3C2410&#x2F;S3C2440 LCD控制器介绍</h2><h3 id="S3C2410-x2F-S3C2440-LCD控制器的特性与结构"><a href="#S3C2410-x2F-S3C2440-LCD控制器的特性与结构" class="headerlink" title="S3C2410&#x2F;S3C2440 LCD控制器的特性与结构"></a>S3C2410&#x2F;S3C2440 LCD控制器的特性与结构</h3><p>S3C2410&#x2F;S3C2440 LCD控制器被用来向LCD传输图像数据，并提供必要的控制信号，比如VFRAME、VLINE、VCLK、VM等。可以支持STN LCD、TFT LCD，其特性如下（BPP 表示bit per pixel，即每个颜色像素点用多少位来表示）。<br>STN LCD</p>
<ol>
<li>支持3种扫描方式：4位单扫，4位双扫和8位单扫</li>
<li>支持单色（1BPP）、4级灰度（2BPP）、16级灰度屏（4BPP）</li>
<li>支持256色（8BPP）和4096色（12BPP）彩色STN屏（CSTN）</li>
<li>支持分辨率为640x480、320x240、160x160以及其他规格的多种LCD</li>
<li>虚拟屏幕最大可达4MB</li>
<li>对于256色，分辨率有4094x1024、2048x2048、1024x4096等多种</li>
</ol>
<p>TFT LCD</p>
<ol>
<li>支持单色（1BPP）、4级灰度（2BPP）、16级灰度（4BPP）、256色（8BPP）的调色板显示模式</li>
<li>支持64K（16BPP）和16M（24BPP）色非调色板显示模式</li>
<li>支持分辨率为640x480、320x320及其他多种规格的LCD</li>
<li>虚拟屏幕最大可达4MB</li>
<li>对于64K色，分辨率有2048x1024等多种</li>
</ol>
<p>S3C2410&#x2F;S3C2440 LCD控制器提供了驱动STN LCD、TFT LCD所需的所有信号，另外，还特别提供额外的信号以支持SEC公司生产的TFT LCD。这3类信号中很大部分是复用的。<br>S3C2410&#x2F;S3C2440 LCD控制器的内部结构如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"><br>REGBANK是LCD控制器的寄存器组，含17个寄存器及一块256x16的调色板内存，用来设置各项参数。而LCDCDMA则是LCD控制器专用的DMA通道，可以自动地从系统总线（System Bus）上取到图像数据，这使得显示图像时不需要CPU的干涉。VIDPRCS将LCDCDMA中的数据组合成特定的格式，然后从VD[23:0]发送给LCD屏。同时TIMEGEN和LPC3600负责产生LCD屏所需要的控制时序，例如VSYNC、HSYNC、VCLK、VDEN，然后从VIDEO MUX送给LCD屏。其中LPC3600专用于SEC TFT LCD。<br>LCDCDMA中有2个FIFO：FIFOH容量为16（1个字为4个字节）个字，FIFOL容量为12个字。当使用“双扫”方式时，FIFOH、FIFIL分别用于传输上半屏、下班屏数据；当使用“单扫”方式时，只用到FIFOH。当FIFO为空或者其中的数据已经减少到设定的阈值时，LCDCDMA自动的发起DMA传输从内存中获得图像数据。</p>
<h3 id="显示器上数据的组织格式"><a href="#显示器上数据的组织格式" class="headerlink" title="显示器上数据的组织格式"></a>显示器上数据的组织格式</h3><p>一幅图像被称为一帧，每帧由多行组成，每行由多个像素组成，每个像素的颜色用若干位的数据表示。对于单色显示器，每个像素用1位来表示，称为1BPP，对于256色显示器，每个像素使用8位来表示，称为8BPP。<br>显示器从屏幕的左上方开始，一行一行的取得每个像素的数据并显示出来，当显示当一行的最右边时，跳到下一行的最左边开始显示下一行；当显示完所有行后，跳到左上方开始显示下一帧。显示器沿着“Z”字行的路线进行扫描，使用HSYNC、VSYNC信号来控制扫描路线的跳转。HSYNC表示“是时候跳到最左边了”，VSYNC表示“是时候跳到最上边了”。<br>在工作中的显示器上，可以在四周看到黑色的边框。上方的黑框是因为显示完所有行的数据时，显示器还没有扫描到最下边（VSYNC信号还未发出），这时数据已经无效。左边的黑框是因为当发出HSYNC信号时，需要经过若干像素之后第一列数据才有效；右边的黑框是因为显示完一行的数据时，显示器还每扫描到最右边（HSYNC信号还没有发出），这时数据已经无效。显示器只会依据VSYNC、HSYNC信号来取得、显示数据，并不理会该数据是否有效，何时发出有效数据由显卡决定。<br>VSYNC信号出现的频率表示1秒内能显示多少帧的图像，称为垂直频率或者场频率，这就是我们常说的“显示器的频率”；HSYNC信号出现的频率称为水平频率。<br>显示器上，一帧数据的存放位置与VSYNC、HSYNC信号的关系如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>有效数据的行数、列数即分辨率，它与VSYNC、HSYNC信号之间的“距离”等，都是可以设置的，这由显卡完成。</p>
<h3 id="TFT-LCD的操作"><a href="#TFT-LCD的操作" class="headerlink" title="TFT LCD的操作"></a>TFT LCD的操作</h3><p>目前市场上主流的LCD为TFT LCD，先了解TFT LCD的时序，这使得我们在设置各个寄存器时有个形象的概念。每个VSYNC信号表示一帧数据的开始；每个HSYNC信号表示一行数据的开始，无论这些数据是否有效；每个VCLK信号表示正在传输一个像素的数据，无论它是否有效。数据是否有效只是对CPU的LCD控制器来说的，LCD根据VSYNC、HSYNC、VCLK不停的读取总线数据、显示。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/3.jpeg" alt="img not found"></p>
<ol>
<li>VSYNC信号有效时，表示一帧数据的开始。</li>
<li>VSPW表示VSYNC信号的脉冲宽度为（VSPW + 1）个HSYNC信号周期，即（VSPW + 1）行，这（VSPW + 1）行数据无效。</li>
<li>VSYNC信号脉冲之后，还要经过（VBPD + 1）个HSYNC信号周期，有效的行数据才出现。所以在VSYNC信号有效之后，总共还要经过（VSPW + 1 + VBPD + 1）个无效的行，它对应图13.2上方的边框，第一个有效的行才出现。</li>
<li>随后即连续发出（LINEVAL + 1）行的有效数据。</li>
<li>最后是（VFPD + 1）个无效的行，它对应图13.2下方的边框，完整的一帧结束，紧接着就是下一帧的数据了（即下一个VSYNC信号）。</li>
</ol>
<p>现在深入到一行像素的传输过程。类似于行数据的传输过程。</p>
<ol>
<li>HSYNC信号有效时，表示一行数据的开始。</li>
<li>HSPW表示HSYNC信号的脉冲宽度为（HSPW + 1）个VCLK信号周期，即（HSPW + 1）个像素，这（HSPW + 1）个像素的数据无效。</li>
<li>HSYNC信号脉冲无效之后，还要经过（HBPD + 1）个VCLK信号周期，有效的像素数据才出现。所以，在HSYNC信号有效之后，总共还要经过（HSPW + 1 + HBPD + 1）个无效的像素，它对应图13.2的左边框，第一个有效像素才出现。</li>
<li>随后即连续发出（HOZVAL + 1）个像素的有效数据。</li>
<li>最后是（HFPD + 1）个无效的像素，它对应图13.2的右边框，完整的一行结束，紧接着就是下一行的数据了（即下一个HSYNC信号）。</li>
</ol>
<p>时序图中各信号的时间参数都可以在LCD控制寄存器中设置，VCLK作为时序图的基准信号，它的频率可由此计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VCLK(hz) = HCLK / [(CLKVAL + <span class="number">1</span> x <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>VSYNC信号的频率又称为帧频率、垂直频率、场频率、显示器的频率，它可以如下计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Frame Rate = <span class="number">1</span>/[&#123;(VSPW+<span class="number">1</span>)+(VBPD+<span class="number">1</span>)+(LINEVAL+<span class="number">1</span>)+(VFPD+<span class="number">1</span>)&#125; x &#123; (HSPW+<span class="number">1</span>)+(HBPD+<span class="number">1</span>)+(HFPD+<span class="number">1</span>)+(HOZVAL+<span class="number">1</span>) &#125; x &#123; <span class="number">2</span> x ( CLKVAL+<span class="number">1</span>) / (HCLK)&#125;]</span><br></pre></td></tr></table></figure>
<p>将VSYNC、HSYNC、VCLK等信号的时间参数设置好之后，并将帧内存（frame memory）的地址告诉LCD控制器，它即可自动发起DMA传输从帧内存得到图像数据，最终在上述信号的控制下出现在数据总线VD[23:0]上。用户只需要把要显示的图像数据写入帧内存中。<br>下面介绍各种图像的格式数据在内存中如何存储。<br>显示器上的每个像素的颜色都是由3个部分组成：红、绿、蓝。它们被称为三原色，这三者的混合几乎可以表示人眼所能识别到的所有颜色。比如可以根据颜色的浓烈程度将三原色都分为256个级别（0-255）。可以使用255级的红色、255级的绿色、255级的蓝色可以组成白色。0级的红色、0级的绿色、0级的蓝色可以组成黑色。<br>LCD控制器可以支持单色（1BPP）、4级灰度（2BPP）、16级灰度（8BPP）、256色（8BPP）的调色板显示模式，支持64K（16BPP）和16M（24BPP）非调色板显示模式。下面只介绍256色（8pp）、64K（16BPP）和16M（24BPP）色显示模式下，图像数据的存储格式。</p>
<ol>
<li>16M（24BPP）色<br>16M（24BPP）色的显示模式就是使用24位的数据来表示一个像素的颜色，每种原色使用8位。LCD控制器从内存中获得某个像素的24位颜色值后，直接通过VD[23:0]数据线发送给LCD。为了方便DMA传输，在内存中使用4个字节（32）位来表示一个像素，其中的3个字节从高到低分别表示红、绿、蓝，剩余的1个字节数据无效。是最低字节还是最高字节无效，这时可以选择的。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/4.jpeg" alt="img not found"></li>
<li>64K（16BPP）色<br>64K（16BPP）色的显示模式就是使用16位的数据来表示一个像素的颜色。这16位数据的格式又分为两种：5：6：5、5：5：5：1，前者使用高5位来表示红色，中间的6位来表示绿色，低5位来表示蓝色；后者的高15位从高到低分成3个5位来表示红色、绿色、蓝色，最低位表示透明度。5：5：5：1的格式也被称为RGBA（A表示Alpha，指代透明度）。<br>一个4字节可以表示两个16BPP的像素，使用高2字节还是低2字节来表示第一个像素，这也是可以选择的。<br>显示模式为16BPP时，内存数据与像素位置的关系如图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/5.jpeg" alt="img not found"><br>在5：5：5：1的格式下，VD[18]、VD[10]、VD[2]数据线上的值是一样的，都表示透明度。图中的NC表示没有连接（not connect）。</li>
<li>256（8BPP）色<br>256（8BPP）色的显示模式就是使用8位的数据来表示一个像素的颜色，但是对三种原色平均下来，每个原色只能使用不到3位的数据来表示，即每个原色最多不过8个级别，这不足以表示更丰富的颜色。<br>为了解决8BPP模式显示能力太弱的问题，需要使用调色板。每个像素对应8位数据不再用来表示RGB三原色，而是表示它在调色板中的索引值；要显示这个像素时，使用这个索引值从调色板中取得其RGB颜色值。所谓调色板就是一块内存，可以对每个索引值设置其颜色，可以使用24BPP或16BPP。S3C2410&#x2F;S3C2440中，调色板是一块256x16的内存，使用16BPP的格式来表示256色（8BPP）显示模式下各个索引值的颜色。这样即使使用256色（8BPP）的显示模式，最终在LCD数据总线上的仍是16BPP的数据。<br>一个4字节可以表示4个8BPP的像素，字节与像素的对应顺序是可以选择的，如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/6.jpeg" alt="img not found"><br>调色板中数据的存放格式与16BPP显示模式类似，也分为两种：5：6：5、5：5：5：1。调色板中数据的格式及与LCD数据线VD[23:0]的对应关系，如下表所示：</li>
</ol>
<p>5：6：5格式下调色板的数据格式</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>00H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D000400</td>
</tr>
<tr>
<td>01H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D000404</td>
</tr>
<tr>
<td>… …</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>… …</td>
</tr>
<tr>
<td>FFH</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D0007FC</td>
</tr>
<tr>
<td>VD引脚号</td>
<td>23</td>
<td>22</td>
<td>21</td>
<td>20</td>
<td>19</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>10</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td></td>
</tr>
</tbody></table>
<p>5：5：5：1格式下调色板的数据格式</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>00H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D000400</td>
</tr>
<tr>
<td>01H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D000404</td>
</tr>
<tr>
<td>… …</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>… …</td>
</tr>
<tr>
<td>FFH</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D0007FC</td>
</tr>
<tr>
<td>VD引脚号</td>
<td>23</td>
<td>22</td>
<td>21</td>
<td>20</td>
<td>19</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>注：</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>①0X4D000400是调色板的起始地址。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>②5：5：5：1格式下，VD18、VD10和VD2三个数据线中都是亮度值1，即最低位的值。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>③当LCDCCON5寄存器中的VSTATUS、HSTATUS有效时，不能读写调色板。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>各模式下用来传输红、绿、蓝三种原色的颜色值VD数据线如下表所示：</p>
<table>
<thead>
<tr>
<th>24BPP</th>
<th>16BPP&#x2F;8BPP 5：6：5格式</th>
<th>16BPP&#x2F;8BPP 5：5：5：1格式</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td>VD[23:16]</td>
<td>VD[23:19]</td>
</tr>
<tr>
<td>绿色</td>
<td>VD[15:8]</td>
<td>VD[15:10]</td>
</tr>
<tr>
<td>蓝色</td>
<td>VD[7:0]</td>
<td>VD[7:3]</td>
</tr>
</tbody></table>
<p>没有用到的数据线其电平为0，从这个观点来看，无论是24BPP模式还是16BPP、8BPP模式，24根数据线VD[23:0]都被用到了。事实上，一个TFT LCD能处理的像素位宽是固定的，即它的数据线的数目是固定的。红、绿、蓝3类信号线总是连接到各字节中的高位；软件设置24BPP、16BPP、8BPP以及调色板等，只会影响到色值的精度。</p>
<h3 id="使用TFT-LCD时LCD控制器的寄存器设置"><a href="#使用TFT-LCD时LCD控制器的寄存器设置" class="headerlink" title="使用TFT LCD时LCD控制器的寄存器设置"></a>使用TFT LCD时LCD控制器的寄存器设置</h3><p>LCD控制器中REGBANK的17个寄存器可以分为6种，如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDCON1-LCDCON5</td>
<td>用于选择LCD类型，设置各类控制信号的时间特性等</td>
</tr>
<tr>
<td>LCDSADDR1-LCDSADDR3</td>
<td>用于设置帧内存的地址</td>
</tr>
<tr>
<td>TPAL</td>
<td>临时调色板寄存器，可以快速的输出一帧单色的图像</td>
</tr>
<tr>
<td>LCDINTPND<br>LCDSRCPND<br>LCDINTMSK</td>
<td>用于LCD的中断，在一般应用中无需中断</td>
</tr>
<tr>
<td>REDLUT <br> GREENLUT <br> BLUELUT <br> DITHMODE</td>
<td>专用于STNLCD</td>
</tr>
<tr>
<td>TCONSEL</td>
<td>专用于SEC TFT LCD</td>
</tr>
</tbody></table>
<p>对于TFT LCD，一般情况下只需要设置前两种寄存器；在8BPP模式下，如果想快速的输出一帧单色图，可以借助TPAL寄存器。</p>
<ol>
<li><p>LCD控制寄存器LCDCON1<br>用于选择LCD类型、设置像素时钟、使能LCD信号的输出等，格式如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LINECNT</td>
<td>[27:18]</td>
<td>只读，每输出一个有效行其值减一，从LINEVAL减到0</td>
</tr>
<tr>
<td>CLKVAL</td>
<td>[17:8]</td>
<td>用于设置VCLK（时钟）<br> 对于TFT LCD，VCLK &#x3D; HCLK &#x2F; [(CLKVAL + 1) x 2](CLKVAL &gt;&#x3D; 0)</td>
</tr>
<tr>
<td>MMODE</td>
<td>[7]</td>
<td>设置VM信号的反转效率，用于STN LCD</td>
</tr>
<tr>
<td>PNRMODE</td>
<td>[6:5]</td>
<td>设置LCD的类型，对于TFT LCD 设为0b11</td>
</tr>
<tr>
<td>BPPMODE</td>
<td>[4:1]</td>
<td>设置BPP，对于TFT LCD：<br>0b1000 &#x3D; 1bpp <br> 0b1001 &#x3D; 2bpp <br> 0b1010 &#x3D; 4bpp <br> 0b1011 &#x3D; 8bpp <br> 0b1100 &#x3D; 16bpp <br> 0b1101 &#x3D; 24bpp</td>
</tr>
<tr>
<td>ENVID</td>
<td>[0]</td>
<td>LCD信号输出使能位，0：禁止，1：使能</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制寄存器LCDCON2<br>用于设置垂直方向各信号的时间参数，格式如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VBPD</td>
<td>[31:24]</td>
<td>VSYNC信号脉冲之后，还要经过（VBPD + 1）个HSYNC信号周期，有效的行数据才出现</td>
</tr>
<tr>
<td>LINEVAL</td>
<td>[23:14]</td>
<td>LCD的垂直宽度：（LINEVAL + 1）行</td>
</tr>
<tr>
<td>VFPD</td>
<td>[13:6]</td>
<td>一帧中的有效行数据完结后，到下一个VSYNC信号有效前的无效行数目：VFPD + 1</td>
</tr>
<tr>
<td>VSPW</td>
<td>[5:0]</td>
<td>表示VSYNC信号的脉冲宽度为（VSPW + 1）个HSYNC信号周期，即（VSPW + 1）行，这（VSPW + 1）行的数据无效</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制器LCDCON3<br>用于设置水平方向信号的时间参数，格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HBPD</td>
<td>[25:19]</td>
<td>HSYNC信号脉冲之后，还要经过（HBPD + 1）个VCLK信号周期，有效的行数据才出现</td>
</tr>
<tr>
<td>HOZVAL</td>
<td>[18:8]</td>
<td>LCD的水平宽度：（HOZVAL + 1）列（像素点）</td>
</tr>
<tr>
<td>HFPD</td>
<td>[7:0]</td>
<td>一行中的有效数据完结后，到下一个HSYNC信号有效前的无效像素数目：HFPD + 1</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制寄存器LCDCON4<br>对于TFT LCD，这个寄存器只用来设置HSYNC信号的脉冲宽度，位[7:0]的数值称为HSPW，表示脉冲宽度为（HSPW + 1）个VCLK周期。</p>
</li>
<li><p>LCD控制寄存器LCDCON5<br>用于设置各个控制信号的极性，并可以从中读到一些状态信息。如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VSTATUS</td>
<td>[16:15]</td>
<td>只读，垂直状态。<br> 00:正处于VSYNC信号脉冲期间 <br> 01:正处于VSYNC信号结束到行有效期间 <br>10:正处于行有效期间 <br>11:正处于行有效结束到下一个VSYNC之间</td>
</tr>
<tr>
<td>HSTATUS</td>
<td>[14:13]</td>
<td>只读，水平状态。<br> 00:正处于HSYNC信号脉冲期间 <br> 01:正处于HSYNC信号结束到像素有效期间 <br>10:正处于像素有效期间 <br>11:正处于像素有效结束到下一个HSYNC之间</td>
</tr>
<tr>
<td>BPP24BL</td>
<td>[12]</td>
<td>设置TFT LCD的显示模式为24BPP时，一个4字节中哪3个字节有效。<br> 0:LSB有效（低地址的3字节）；1：MSB（高地址的3字节）；</td>
</tr>
<tr>
<td>FRM565</td>
<td>[11]</td>
<td>设置TFT LCD的显示模式为16BPP时，使用的数据格式。<br> 0表示5：5：5：1格式；1表示5：6：5 格式</td>
</tr>
<tr>
<td>INVVCLK</td>
<td>[10]</td>
<td>设置VCLK信号有效沿的极性。 <br> 0：在VCLK的下降沿读取数据；1：在VCLK的上升沿读取数据。</td>
</tr>
<tr>
<td>INVVLINE</td>
<td>[9]</td>
<td>设置VLINE&#x2F;HSYNC脉冲的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVFRAME</td>
<td>[8]</td>
<td>设置VFRAME&#x2F;VSYNC脉冲的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVD</td>
<td>[7]</td>
<td>设置VD数据线表示数据（0&#x2F;1）的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVDEN</td>
<td>[6]</td>
<td>设置VDEN信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVPWREN</td>
<td>[5]</td>
<td>设置PWREN信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVLEND</td>
<td>[4]</td>
<td>设置LEND信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>PWREN</td>
<td>[3]</td>
<td>LCD_PWREN信号输出使能。<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>ENLEND</td>
<td>[2]</td>
<td>LEND信号输出使能。<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>BSWP</td>
<td>[1]</td>
<td>字节交换使能<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>HWSWP</td>
<td>[1]</td>
<td>半字（2字节）交换使能<br> 0：禁止；1：输出</td>
</tr>
</tbody></table>
</li>
<li><p>帧内存地址寄存器LCDSADDR1-LCDSADDR3<br>帧内存可以很大，而真正要显示的区域被称为视口（view point），它处于帧内存之内。这3个寄存器用于确定帧内存的起始地址，定位视口在帧内存的位置。下图给出了帧内存和视口之间的关系：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/7.jpeg" alt="img not found"><br>各寄存器格式如下表所示：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>LCDSADDR1 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDBANK</td>
<td>[29:21]</td>
<td>用来保存帧内存起始地址A[30:22]，帧内存起始地址为4MB对齐。</td>
</tr>
<tr>
<td>LCDBASEU</td>
<td>[20:0]</td>
<td>对于TFT LCD，用来保存视口（view point），所对应的内存起始地址A[21:1]，这块内存地址也称为LCD的帧缓冲区（frame buffer）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>LCDSADDR2 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDBASEL</td>
<td>[20:0]</td>
<td>对于TFT LCD，用来保存LCD的帧缓冲区结束地址A[21:1]，其值可如下计算：LCDBASEL &#x3D; LCDBASEU + （PAGEWIDTH + OFFSICE）x （LINEVAL + 1）</td>
</tr>
</tbody></table>
<p>注：可以修改LCDBASEU、LCDBASEL的值来实现图像的移动，不过不能在一帧图像的结束阶段（LCDCON1寄存器的LINECNT为0时）进行修改，因为此时LCD控制器会优先取得下一帧的数据，之后才会改变这些值，这样的话，这些数据就与新的帧缓冲区不一致。</p>
<table>
<thead>
<tr>
<th>LCDSADDR3 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OFFSIZE</td>
<td>[21:11]</td>
<td>表示上一行最后一个数据与下一行第一个数据间地址差值的一半，即以半字为单位的地址差（0表示两行数据是紧接着的，1表示它们之间相差2个字节，依次类推）</td>
</tr>
<tr>
<td>PAGEWIDTH</td>
<td>[10:0]</td>
<td>视口的宽带，以半字为单位</td>
</tr>
</tbody></table>
<p>注：OFFSIZE、PAGEWIDTH的值只能在ENVID（LCDCON1寄存器的信号输出使能）为0时修改。</p>
<ol start="7">
<li>临时调色板寄存器TPAL<br>如果要输出一帧单色的图像，可以在TPAL寄存器中设定这个颜色值，然后使能TPAL寄存器，这种方法可以避免修改整个调色板或帧缓冲区。TPAL寄存器格式如下表所示：<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TPALEN</td>
<td>[24]</td>
<td>调色板寄存器使能位。<br> 0：禁止 1：使能</td>
</tr>
<tr>
<td>TPALVAL</td>
<td>[23:0]</td>
<td>颜色值。 <br> TPALVAL[23:16]：红色 <br> TPALVAL[15:8]：绿色 <br> TPALVAL[7:0]：蓝色</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：临时调色板寄存器TPAL可以用在任何显示模式下，并非只能用在8BPP模式下。</p>
<h1 id="TFT-LCD显示实例"><a href="#TFT-LCD显示实例" class="headerlink" title="TFT LCD显示实例"></a>TFT LCD显示实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例的目的是从串口输出一个菜单，从中选择各种方法进行测试，比如画线、画圆、显示单色、使用调色板等。</p>
<h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><p>与LCD相关的文件有3个：lcddrv.c、framebuffer.c和lcdlib.c（及相应的头文件）。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/8.jpeg" alt="img not found"></p>
<ol>
<li>lcddrv.c封装了对LCD控制器、调色板的访问函数，可以设置LCD的显示模式、开启&#x2F;关闭LCD、设置调色板等。</li>
<li>framebuffer.c直接操作帧缓冲区（frame buffer），实现了画点、画线、画圆、清屏等操作。</li>
<li>lcdlib.c调用前两个文件提供的函数在LCD上进行各种操作。</li>
</ol>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(getc())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_8Bit_240320();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_16Bit_240320();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_8Bit_640480();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_16Bit_640480();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它根据串口的输入选择是以”240x320、8bpp“、”240x320、16bpp“、”640x480、8bpp“或”640x480、16bpp“的显示模式来操作LCD，所调用的4个函数都在lcdlib.c中实现。</p>
<h3 id="lcdlib-c"><a href="#lcdlib-c" class="headerlink" title="lcdlib.c"></a>lcdlib.c</h3><p>8BPP模式将用到调色板，其操作比16BPP模式稍为复杂，但是大部分仍是相似的。下面以<code>Test_Lcd_Tft_8Bit_240320()</code>为例进行说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以240x320、8bpp的显示模式测试TFT LCD</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_Lcd_Tft_8Bit_240320</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_Port_Init();                        <span class="comment">//设置LCD引脚</span></span><br><span class="line">    Tft_Lcd_Init(MODE_TFT_8BIT_240320);     <span class="comment">//初始化LCD控制器</span></span><br><span class="line">    Lcd_PowerEnable(<span class="number">0</span>,<span class="number">1</span>);                   <span class="comment">//设置LCD_PWREN有效，它用于打开LCD的电源</span></span><br><span class="line">    Lcd_EnvidOnOff(<span class="number">1</span>);                      <span class="comment">//使能LCD控制器输出信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6行所涉及的GPIO引脚用于LCD功能。<br>第7行调用Tft_Lcd_Init函数初始化LCD控制器，即设置各个控制信号的时间特性、设置LCD的显示模式、设置帧缓冲区的地址等，它是lcddrv.c中最复杂的函数，在后面会详细分析这个函数。<br>进行第6、7行的初始化之后，只要打开LCD，帧缓冲区中的数据就会被LCD控制器自动地发送到LCD上去显示。打开操作由8、9行来完成。<br>第8行发出LCD_PWREN信号。对于有电源开关控制引脚的LCD，可以使用LCD_PWREN来打开或关闭LCD。LCD_PWREN信号的极性可以设置。<br>第9行使能LCD控制器输出信号，这时，帧缓冲区中的数据就开始在LCD上显示出来了。<br>接下来就是按照设定的流程进行各类操作了，比如画线、清屏等，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Lcd_Palette8Bit_Init();                     <span class="comment">//初始化调色板</span></span><br><span class="line">ClearScr(<span class="number">0x0</span>);                              <span class="comment">//清屏</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">0</span>);                     <span class="comment">//颜色为DEMO256pal[0]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="number">1</span>);                    <span class="comment">//颜色为DEMO256pal[1]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">20</span>,<span class="number">2</span>);                    <span class="comment">//颜色为DEMO256pal[2]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">40</span>,<span class="number">4</span>);                    <span class="comment">//颜色为DEMO256pal[4]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">80</span>,<span class="number">8</span>);                    <span class="comment">//颜色为DEMO256pal[8]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">160</span>,<span class="number">16</span>);                  <span class="comment">//颜色为DEMO256pal[16]</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Mire();                                     <span class="comment">//画圆</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">ClearScr(<span class="number">128</span>);                              <span class="comment">//输出单色图像，颜色为DEMO256pal[128]</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">ClearScrWithTmpPlt(<span class="number">0x0000ff</span>);               <span class="comment">//输出单色图像，颜色为蓝色</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">DisableTmpPlt();                            <span class="comment">//关闭临时调色板寄存器</span></span><br><span class="line">ChangePalette(<span class="number">0xffff00</span>);                    <span class="comment">//改变整个调色板为黄色，输出单色图像</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Lcd_EnvidOnOff(<span class="number">0</span>);                          <span class="comment">//停止</span></span><br></pre></td></tr></table></figure>
<p>上述函数分3类：</p>
<ol>
<li>清屏函数ClearScr、画线函数DrawLine，都是通过framebuffer.c中的PutPixel函数来设置帧缓冲区中的数据，以像素为单位修改颜色来实现的。</li>
<li>Lcd_Palette8Bit_Init函数设置调色板，ChangePalette函数通过设置调色板来实现清屏功能，不涉及帧缓冲区，它在lcddrv.c中实现。</li>
<li>ClearScrWithTmpPlt函数则是通过临时调色板寄存器来快速的输出单色的图像，也不涉及帧缓冲区，它在lcddrv.c中实现。<br>lcddrv.c、framebuffer.c文件中的各个函数才是本实例的关键。可以认为lcddrv.c是对操作各寄存器的封装，framebuffer.c则是对操作图像数据的封装。先看lcddrv.c文件。</li>
</ol>
<h3 id="lcddrv-c"><a href="#lcddrv-c" class="headerlink" title="lcddrv.c"></a>lcddrv.c</h3><p>这个文件的重点在于Tft_Lcd_Init、Lcd_Palette8Bit_Init。</p>
<ol>
<li><p>Lcd_Port_Init函数<br>设置所涉及的GPIO引脚用于LCD功能。GPIO功能的设置对读者来说已经很熟悉了，不再赘述。</p>
</li>
<li><p>Tft_Lcd_Init函数<br>用于初始化LCD控制器，即设置各个控制信号的时间特性、设置LCD的显示模式、设置帧缓冲区的地址等。<br>首先是对5个控制寄存器LCDCON1-LCDCON5的设置，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化LCD控制器</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">type：显示模式</span></span><br><span class="line"><span class="comment">    MODE_TFT_8BIT_240320 : 240*320 8bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_16BIT_240320 : 240*320 16bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_8BIT_640480 : 640*480 8bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_16BIT_640480 : 640*480 16bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tft_Lcd_Init</span><span class="params">(<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MODE_TFT_8BIT_240320:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置LCD控制器的控制寄存器LCDCON1-LCDCON5</span></span><br><span class="line"><span class="comment">        1. LCDCON1</span></span><br><span class="line"><span class="comment">            设置VCLK的频率：VCLK（Hz）= HCLK/[(CLKVAL+1)x2]</span></span><br><span class="line"><span class="comment">            选择LCD类型：TFT LCD</span></span><br><span class="line"><span class="comment">            设置显示模式：8BPP</span></span><br><span class="line"><span class="comment">            先禁止LCD信号输出</span></span><br><span class="line"><span class="comment">        2. LCDCON2/3/4</span></span><br><span class="line"><span class="comment">            设置控制信号的时间参数</span></span><br><span class="line"><span class="comment">            设置分辨率，即行数及列数</span></span><br><span class="line"><span class="comment">        现在，可以根据公式计算出显示器的频率</span></span><br><span class="line"><span class="comment">        当HCLK = 100MHz时，</span></span><br><span class="line"><span class="comment">        Frame Rate = 1/[&#123;(VSPW+1)+(VBPD+1)+(LINEVAL+1)+(VFPD+1)&#125; x &#123; (HSPW+1)+(HBPD+1)+(HFPD+1)+(HOZVAL+1) &#125; x &#123; 2 x ( CLKVAL+1) / (HCLK)&#125;] = 60Hz</span></span><br><span class="line"><span class="comment">        3. LCDCON5</span></span><br><span class="line"><span class="comment">            设置显示模式为8BPP时，调色板中的数据格式为5：6：5</span></span><br><span class="line"><span class="comment">            设置HSYNC、VSYNC脉冲的极性：反转字节交换使能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        LCDCON1 = (CLKVAL_TFT_240320 &lt;&lt; <span class="number">8</span>) | (LCDTYPE_TFT &lt;&lt; <span class="number">5</span>) | (BPPMODE_8BPP &lt;&lt; <span class="number">1</span>) | (ENVID_DISABLE &lt;&lt; <span class="number">0</span>);</span><br><span class="line">        LCDCON2 = (VBPD_240320 &lt;&lt; <span class="number">24</span>) | (LINEVAL_TFT_240320 &lt;&lt; <span class="number">14</span>) | (VFPD_240320 &lt;&lt; <span class="number">6</span>) | (VSPW_240320);</span><br><span class="line">        LCDCON3 = (HBPD_240320 &lt;&lt; <span class="number">19</span>) | (HOZVAL_TFT_240320 &lt;&lt; <span class="number">8</span>) | (HFPD_240320);</span><br><span class="line">        LCDCON4 = (HSPW_240320);</span><br><span class="line">        LCDCON5 = (FORMAT8BPP_565 &lt;&lt; <span class="number">11</span>) | (HSYNC_INV &lt;&lt; <span class="number">9</span>) | (VSYNC_INV &lt;&lt; <span class="number">8</span>) | (BSWP &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的注释可以帮助读者理解这些代码，比较困难的是时间参数VSPW、VBPD、VFPD、HSPW、HBPD、HFPD、CLKVAL的设置。对于CRT显示器，当它的频率在60Hz时，人眼会感到明显的闪烁；而对于LCD，在60Hz时显示效果就很好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Frame Rate = <span class="number">1</span>/[&#123;(VSPW+<span class="number">1</span>)+(VBPD+<span class="number">1</span>)+(LINEVAL+<span class="number">1</span>)+(VFPD+<span class="number">1</span>)&#125; x &#123; (HSPW+<span class="number">1</span>)+(HBPD+<span class="number">1</span>)+(HFPD+<span class="number">1</span>)+(HOZVAL+<span class="number">1</span>) &#125; x &#123; <span class="number">2</span> x ( CLKVAL+<span class="number">1</span>) / (HCLK)&#125;];</span><br></pre></td></tr></table></figure>
<p>接下来是对地址寄存器LCDSADDR1-LCDSADDR3的设置。本程序中，帧内存与视图吻合，即图中的OFFSIZE为0，LCDBANK、LCDBASEU指向同一个地址（同一地址的不同位）。<br>需要注意的是，8BPP的显示模式要用到调色板，帧缓冲区中的数据不是像素的颜色值，而是调色板中的索引值，真正的颜色值在调色板中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置LCD控制器的地址寄存器LCDSADDR1-LCDSADDR3</span></span><br><span class="line"><span class="comment">帧内存与视口（view point）完全吻合，</span></span><br><span class="line"><span class="comment">图像数据格式如下（8BPP时，帧缓存区中的数据为调色板中的索引值）：</span></span><br><span class="line"><span class="comment">            |----width----|</span></span><br><span class="line"><span class="comment">        y/x 0   1    2   239</span></span><br><span class="line"><span class="comment">         0  idx idx  idx idx</span></span><br><span class="line"><span class="comment">         1  idx idx  idx idx</span></span><br><span class="line"><span class="comment">1. LCDSADDR1</span></span><br><span class="line"><span class="comment">    设置LCDBANK、LCDBASEU</span></span><br><span class="line"><span class="comment">2. LCDSADDR2</span></span><br><span class="line"><span class="comment">    设置LCDBASEL：帧缓冲区的结束地址A[21:1]</span></span><br><span class="line"><span class="comment">3. LCDSADDR3</span></span><br><span class="line"><span class="comment">    OFFSIZE等于0，PAGEWIDTH等于（240/2）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LCDSADDR1 = ((LCDFRAMEBUFFER &gt;&gt; <span class="number">22</span>) &lt;&lt; <span class="number">21</span>) | LOWER21BITS(LCDFRAMEBUFFER &gt;&gt; <span class="number">1</span>);</span><br><span class="line">LCDSADDR2 = LOWER21BITS((LCDFRAMEBUFFER + (LINEVAL_TFT_240320 + <span class="number">1</span>) x (HOZVAL_TFT_240320+<span class="number">1</span>) x1) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">LCDSADDR3 = (<span class="number">0</span> &lt;&lt;<span class="number">11</span> ) | (LCD_XSIZE_TFT_240320/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>第16行将帧缓冲区的起始地址写入LCDSADDR1寄存器。<br>第17行先计算帧缓冲区的结束地址，再取其位[21:1]存入LCDSADDR2中。这个地址值在本实例中即是“LCDFRAMEBUFFER + 320 x 240 x 1”,其中的“x1”表示在8BPP中一个像素使用1个字节来表示（对于16BPP，则是“x2”）。<br>在设置寄存器的最后，禁止临时调色板寄存器，现在还没有用到它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*禁止临时调色板寄存器*/</span></span><br><span class="line">TPAL = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>最后，将显示模式的主要参数记录下来，在framebuffer.c中需要用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fb_base_addr = LCDFRAMEBUFFER;</span><br><span class="line">bpp = <span class="number">8</span>;</span><br><span class="line">xsize = <span class="number">240</span>;</span><br><span class="line">ysize = <span class="number">320</span>;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，显示模式为8BPP时，LCDCON5中BSWAP位设为1，表示“字节交换使能”，这时帧缓存区中的数据与屏幕上的像素位置关系如上图13.6所示；显示模式为16BPP时，LCDCON5中HWSWAP位设为1，表示“半字交换使能”，这时帧缓冲区的数据与屏幕上的像素位置关系如图13.5所示。他们都是“低地址的数据”对应“位置靠前”的像素。</p>
</li>
<li><p>Lcd_Palette8Bit_Init函数<br>设置调色板中的数据：调试板大小为256x16，而8BPP模式中每个像素的索引值占据8位，刚好有256个索引值。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置调色板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_Palette8Bit_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *palette;</span><br><span class="line"></span><br><span class="line">    LCDCON5 |= (FORMAT8BPP_565 &lt;&lt; <span class="number">11</span>);              <span class="comment">//设置调色板中数据格式为5：6：5</span></span><br><span class="line"></span><br><span class="line">    palette = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)PALETTE;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">        *palette++ = DEMO256pal[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调色板中用16BPP的格式来表示颜色，第9行设置调色板中数据的格式为5：6：5。<br>第12、13行将数组DEMO256pal中的数据写入调色板中。</p>
</li>
<li><p>ChangePalette函数<br>以给定的颜色填充整个调色板。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改变调色板为一种颜色</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    color：颜色值，格式为0xRRGGBB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChangePalette</span><span class="params">(UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> red,green,blue;</span><br><span class="line">    UNT32 *palette;</span><br><span class="line"></span><br><span class="line">    palette = (UINT32 *)PALETTE;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        red = (color &gt;&gt; <span class="number">19</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        green = (color &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        blue = (color &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        color = (red &lt;&lt; <span class="number">11</span>) | (greee &lt;&lt; <span class="number">5</span>) | (blue);                <span class="comment">//格式5：6：5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((LCDCON5 &gt;&gt; <span class="number">16</span>) == <span class="number">2</span>);                                <span class="comment">//等待直到VSTATUS不为“有效”</span></span><br><span class="line">        *palette++ = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第15-19行从0xRRGGBB格式的变量中，提取8位红色值的高5位，8位绿色值的高6位，8位蓝色值的高5位组成5：6：5格式的16BPP颜色值。<br>第21行检测当前VSYNC信号的状态，如果它处于有效的状态，则等待。前面说过，读写调色板时，VSTATUS、HSTATUS不能处于有效状态。这里当VSTATUS不是“有效”状态时，HSTATUS也不能是“有效”状态。<br>第22行将新数据写入调色板。</p>
</li>
<li><p>Lcd_PowerEnable函数<br>用于是否控制发出LCD_PWREN信号。对于有电源开关控制引脚的LCD，可以使用LCD_PWREN来打开或关闭LCD。LCD_PWREN信号的极性可以设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置是否输出LCD电源开关信号LCD_PWREN</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    invpwren：</span></span><br><span class="line"><span class="comment">        0表示LCD_PWREN有效时为正常极性</span></span><br><span class="line"><span class="comment">        1表示LCD_PWREN有效时为反转极性</span></span><br><span class="line"><span class="comment">    pwren：</span></span><br><span class="line"><span class="comment">        0表示LCD_PWREN输出有效</span></span><br><span class="line"><span class="comment">        1表示LCD_PWREN输出无效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_PowerEnable</span><span class="params">(<span class="type">int</span> invpwren,<span class="type">int</span> pwren)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPGCON = (GPGCON &amp; (~ (<span class="number">3</span> &lt;&lt; <span class="number">8</span>))) | (<span class="number">3</span> &lt;&lt; <span class="number">8</span>);                <span class="comment">//GPG4用作LCD_PWREN</span></span><br><span class="line">    GPGUP = (GPGUP &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">4</span>))) | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);                  <span class="comment">//禁止内部上拉</span></span><br><span class="line"></span><br><span class="line">    LCDCON5 = (LCDCON5 &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">5</span>))) | (invpwrwen &lt;&lt; <span class="number">5</span>);      <span class="comment">//设置LCD_PWREN的极性：正常/反转</span></span><br><span class="line">    LCDCON5 = (LCDCON5 &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))) | (pwren &lt;&lt; <span class="number">3</span>);          <span class="comment">//设置是否输出LCD_PWREN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Lcd_EnvidOnOff函数<br>用于控制是否使能LCD控制器输出各个LCD信号，当设置如控制寄存器、地址寄存器之后，即可调用此函数输出各个LCD信号，这样，帧缓冲区中的数据即发送给LCD。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置LCD控制器是否输出信号</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">onoff：</span></span><br><span class="line"><span class="comment">    0：关闭</span></span><br><span class="line"><span class="comment">    1：打开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_EnvidOnOff</span><span class="params">(<span class="type">int</span> onoff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(onoff == <span class="number">1</span>)</span><br><span class="line">        LCDCON1 |= <span class="number">1</span>;           <span class="comment">//ENVID ON</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LCDCON1 &amp;= <span class="number">0x3fffe</span>;     <span class="comment">//ENVID OFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ClearScrWithTmpPlt、DisableTmpPlt函数<br>ClearScrWithTmpPlt函数设置颜色值并使能TPAL寄存器，这使得LCD上显示单一颜色的图像。DisableTmpPlt函数停止TPAL寄存器的功能，继续输出帧缓存区的图像。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用临时调色板寄存器输出单色图像</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    color：颜色值，格式为0xRRGGBB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearScrWithTmpPlt</span><span class="params">(UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    TPAL = (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) | ((color &amp; <span class="number">0xffffff</span>) &lt;&lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">停止使用临时调色板寄存器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisableTmpPlt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TPAL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="framebuffer-c"><a href="#framebuffer-c" class="headerlink" title="framebuffer.c"></a>framebuffer.c</h3><p>此文件中有4个函数：画点函数PutPixel、画线函数DrawLine、绘制同心圆函数Mire、清屏函数ClearScr。后3个函数都是基于PutPixel函数实现的。PutPixel函数是framebuffer.c的核心，它在缓冲区中找到给定坐标的像素的内存，然后修改它的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base_addr;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> bpp;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> xsize;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> ysize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">画点</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    x,y：像素坐标</span></span><br><span class="line"><span class="comment">    color：颜色值</span></span><br><span class="line"><span class="comment">    对于16BPP：color的格式为0xAARRGGBB  AA是透明度，0-256，需要转换为5:6:5格式</span></span><br><span class="line"><span class="comment">    对于8BPP：color为调色板的索引值，颜色取决于调色板中的数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutPixel</span><span class="params">(UINT32 x,UINT32 y,UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT8 red,green,blue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(bpp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            UINT16 *addr = (UINT16 *)fb_base_addr + (y * xsize + x);</span><br><span class="line">            red = (color &gt;&gt; <span class="number">19</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            green = (color &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            blue = (color &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">            color = (red &lt;&lt; <span class="number">11</span>) | (greee &lt;&lt; <span class="number">5</span>) | (blue);                <span class="comment">//格式5：6：5</span></span><br><span class="line">            *addr = (UINT16) color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            UINT8 *addr = (UINT8 *)fb_base_addr + (y * xsize + x);</span><br><span class="line">            *addr = (UINT8) color</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第1-4行的4个变量在lcddrv.c中的Tft_Lcd_Init函数中设置，PutPixel函数根据它们来确定给定坐标的像素在缓冲区中的地址。<br>第22、34行分别计算16BPP、8BPP模式下给定坐标的像素在帧缓冲中的地址。对于16BPP模式，每个像素占据2字节；对于8BPP模式，每个像素占据1字节。<br>对于16BPP的显示模式，第22-25行从0xAARRGGBB中提取8位红色值的高5位，8位绿色值的高6位，8位蓝色值的高5位组成5：6：5格式的16BPP颜色值。<br>最后，第28、35行将颜色值（8BPP模式下为调色板索引值）写入帧缓冲区中，这样下一次显示的时候，新颜色就可以显示出来了。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第13章 LCD控制器</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>LCD</tag>
      </tags>
  </entry>
  <entry>
    <title>构建Linux根文件系统</title>
    <url>/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统移植之构建Linux根文件系统</p>
<p>《嵌入式Linux应用完全开发手册》第3篇第17章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解Linux的文件系统层次标准（FHS）</li>
<li>了解根文件系统下各目录的作用</li>
<li>掌握构建根文件系统的的方法：移植Busybox、构造各个目录、文件等</li>
<li>掌握制作yaffs、jffs2文件系统映像的方法</li>
</ol>
<h1 id="Linux文件系统概述"><a href="#Linux文件系统概述" class="headerlink" title="Linux文件系统概述"></a>Linux文件系统概述</h1><h2 id="Linux文件系统的特点"><a href="#Linux文件系统的特点" class="headerlink" title="Linux文件系统的特点"></a>Linux文件系统的特点</h2><p>类似于Windows下的C、D、E等各个盘，Linux系统也可以将磁盘、Flash等存储设备划分为若干个分区，在不同分区存放不同类别的文件。与Windows的C盘类似，Linux一样要在一个分区上系统启动必须的文件，比如内核映像文件（在嵌入式系统中，内核一般单独存放在一个分区中）、内核启动后运行的第一个程序（init）、给用户提供操作界面的shell程序、应用程序所依赖的库等。这些必需、基本的文件合称为根文件系统。它们存放在一个分区中。Linux系统启动后首先挂载这个分区，称为挂载根文件系统。其他分区上所有目录、文件的集合，也称为文件系统。<br>Linux中没有C、D、E盘符的概念，它以树状结构管理所有目录，文件。其他分区挂载在某个目录上，这个命令称为挂载点，然后就可以通过访问这个目录来访问这个分区上的文件了。比如<code>根文件系统挂载在“/”</code>上之后，根目录下就有根文件系统的各个目录、文件：&#x2F;bin、&#x2F;sbin、&#x2F;mnt等；再将其他分区挂接到&#x2F;mnt目录上，&#x2F;mnt下目录下就有这个分区的目录、文件了。<br>在一个分区下存储文件时，需要遵循一定的格式，这种格式称为文件系统类型，比如<code>fat16</code>、<code>fat32</code>、<code>ntfs</code>、<code>ext2</code>、<code>ext3</code>、<code>jffs2</code>、<code>yaffs</code>等。除这些拥有实实在在的存储分区的文件系统类型外，Linux还有几种虚拟的文件系统类型，比如<code>proc</code>、<code>sysfs</code>等，它们的文件并不存储在实际的设备上，而是在访问它们时由内核临时生成。比如<code>proc</code>文件系统下的uptime文件，读取它时可以得到两个时间值（用来表示系统启动后运行的秒数、空闲的秒数），每次读取时都由内核即刻生成，每次读取结果都不一样。</p>
<h2 id="Linux根文件系统目录结构"><a href="#Linux根文件系统目录结构" class="headerlink" title="Linux根文件系统目录结构"></a>Linux根文件系统目录结构</h2><p><img src="/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1.jpeg" alt="img not found"></p>
<h3 id="x2F-bin-目录"><a href="#x2F-bin-目录" class="headerlink" title="&#x2F;bin 目录"></a>&#x2F;bin 目录</h3><p>该目录下存放所有用户都可以使用的、基本的命令，这些命令在挂接其他文件系统之前就可以使用，所以&#x2F;bin目录必须和根文件系统在同一个分区中。<br>&#x2F;bin目录下常用的命令有：cat、chgrp、chmod、cp、ls、sh、kill、mount、umount、mkdir、mknod、[、test等。“[”命令就是test命令，在脚本文件中“[ expr ]”等价于“test expr”。</p>
<h3 id="x2F-sbin目录"><a href="#x2F-sbin目录" class="headerlink" title="&#x2F;sbin目录"></a>&#x2F;sbin目录</h3><p>该目录下存放系统目录，即只有管理员能够使用的命令，系统命令话可以存放在&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin目录下。&#x2F;sbin目录中存放的是基本的系统命令，它们用于启动系统、修复系统等。与&#x2F;bin目录相似，在挂载其他文件系统之前就可以使用&#x2F;sbin，所以&#x2F;sbin目录必须和根文件系统在同一个分区中。<br>&#x2F;sbin下常用的命令有：shutdown、reboot、fdisk、fsck等。<br>不是急迫需要使用的系统命令存放在&#x2F;usr&#x2F;sbin目录下。本地安装的系统命令存放在&#x2F;usr&#x2F;local&#x2F;sbin目录下。</p>
<h3 id="x2F-dev目录"><a href="#x2F-dev目录" class="headerlink" title="&#x2F;dev目录"></a>&#x2F;dev目录</h3><p>该目录下存放的是设备文件。设备文件是Linux中特有的文件类型，在Linux系统下，以文件的方式访问各种外设，即通过读写某个设备文件操作某个具体硬件。比如通过“&#x2F;dev&#x2F;ttySAC0”文件可以操作串口0，通过“&#x2F;dev&#x2F;mtdblcok1”可以访问MTD设备（NAND Flash、NOR Flash等）的第2个分区。<br>设备文件有两种：字符设备和块设备。在PC上执行命令“ls &#x2F;dev&#x2F;ttySAC0 &#x2F;dev&#x2F;hda1 -l”可以看到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brwxrwxr-x  1   root    49      3,  1   Oct 9   2005 /dev/hda1</span><br><span class="line">crwxrwxr-x  1   root    root    4,  64  Sep 24  2007 /dev/ttySAC0</span><br></pre></td></tr></table></figure>
<p>其中字母“b”、“c”表示这是一个块设备文件或字符设备文件；“3，1”、“4，64”表示设备文件的主、次设备号；主设备号用来表示这是哪类设备，次设备号用来表示这是这类设备中的哪个。<br>设备文件可以使用mknod命令创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod /dev/ttySAC0 c 4 64</span><br><span class="line">mknod /dev/hda1 b 3 1</span><br></pre></td></tr></table></figure>
<p>&#x2F;dev 的创建有3种方法。</p>
<ol>
<li>手动创建<br>在制作根文件系统的时候，就在&#x2F;dev目录下创建好要使用的设备文件，比如ttySAC0等。系统挂接根文件系统后就可以使用&#x2F;dev下的设备文件了。</li>
<li>使用devfs文件系统（这种方法已经过时）<br>以前的内核中有一个配置选项CONFIG_DEVFS_FS，它用来将虚拟文件系统devfs挂接在&#x2F;dev目录上，各个驱动程序注册时会在&#x2F;dev下目录下自动生成各种设备文件。就免去了手动创建设备文件的麻烦，在制作根文件系统时，&#x2F;dev目录可以为空。<br>使用devfs比手动创建设备节点更便利，但是它仍有一些无法克服的缺点<br>①不确定的设备映射<br>比如USB接口连接两台打印机A、B。都开机的情况下以&#x2F;dev&#x2F;usb&#x2F;lp0访问A，以&#x2F;dev&#x2F;usb&#x2F;lp1访问B。但是假如A没有上电，则系统启动时会根据扫描到的设备的顺序，以&#x2F;dev&#x2F;usb&#x2F;lp0访问B。<br>②没有足够的主&#x2F;次设备号<br>主次设备号是两个8位的数字，它们不足以与日益增加的外设一一对应。<br>③命名不够灵活<br>由于devfs由内核创建设备节点，当想重新修改某个设备的名字时需要修改编译内核。<br>④devfs消耗大量内存<br>由于上述缺点，Linux在2.3.46引入devfs之后，又在Linux2.6.13后面版本移除了devfs，而使用udev机制代替。</li>
<li>udev<br>udev是个用户程序（userspace device），它能够根据系统中硬件设备的状态动态的更新设备文件，包括设备文件的创建和删除等。<br>使用udev机制也不需要在&#x2F;dev目录下创建设备节点，他需要一些用户程序的支持，并且内核要支持sysfs文件系统。它的操作相对复杂，但是灵活性很高。</li>
</ol>
<h3 id="x2F-etc-目录"><a href="#x2F-etc-目录" class="headerlink" title="&#x2F;etc 目录"></a>&#x2F;etc 目录</h3><p>如下表所示，该目录下存放各种配置文件。对于PC上的Linux系统，&#x2F;etc目录下目录、文件非常多。这些目录、文件都是可选的，它们依赖于系统中所拥有的应用程序，依赖于这些程序是否需要配置文件。在嵌入式系统中，这些内容可以大为精减。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>opt</td>
<td>用来配置&#x2F;opt下的程序 （可选）</td>
</tr>
<tr>
<td>X11</td>
<td>用来配置X Window （可选）</td>
</tr>
<tr>
<td>sgml</td>
<td>用来配置SGML （可选）</td>
</tr>
<tr>
<td>xml</td>
<td>用来配置XML （可选）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>export</td>
<td>用来配置NFS文件系统 （可选）</td>
</tr>
<tr>
<td><code>fstab</code></td>
<td>用来指明当执行“mount -a”时，需要挂接的文件系统 （可选）</td>
</tr>
<tr>
<td>mtab</td>
<td>用来显示已经加载的文件系统，通常是&#x2F;proc&#x2F;mounts的链接文件 （可选）</td>
</tr>
<tr>
<td>ftpusers</td>
<td>启动FTP服务时，用来配置用户的访问权限 （可选）</td>
</tr>
<tr>
<td>group</td>
<td>用户的组文件 （可选）</td>
</tr>
<tr>
<td>inittab</td>
<td>init进程的配置文件 （可选）</td>
</tr>
<tr>
<td>ld.so.conf</td>
<td>其他共享库的路径 （可选）</td>
</tr>
<tr>
<td>passwd</td>
<td>密码文件 （可选）</td>
</tr>
</tbody></table>
<h3 id="x2F-lib-目录"><a href="#x2F-lib-目录" class="headerlink" title="&#x2F;lib 目录"></a>&#x2F;lib 目录</h3><p>该目录下存放共享库和可加载模块（驱动程序），共享库用于启动系统、运行根文件系统中的可执行程序，比如&#x2F;bin、&#x2F;sbin目录下的程序。其他不是根文件系统所必须的库文件可以放在其他目录，比如&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;X11R6&#x2F;lib、、var&#x2F;lib等。</p>
<table>
<thead>
<tr>
<th>目录&#x2F;文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>libc.so.*</td>
<td>动态连接C库（可选）</td>
</tr>
<tr>
<td>ld*</td>
<td>连接器、加载器（可选）</td>
</tr>
<tr>
<td>modules</td>
<td>内核可加载模块存放的目录（可选）</td>
</tr>
</tbody></table>
<h3 id="x2F-home-目录"><a href="#x2F-home-目录" class="headerlink" title="&#x2F;home 目录"></a>&#x2F;home 目录</h3><p>用户目录，它是可选的。对于每个普通用户，在&#x2F;home目录下都有一个以用户命名的子目录，里面存放用户相关的配置文件。</p>
<h3 id="x2F-root-目录"><a href="#x2F-root-目录" class="headerlink" title="&#x2F;root 目录"></a>&#x2F;root 目录</h3><p>根用户（用户名为root）的目录，与此对应，普通用户的目录是&#x2F;home下的某个子目录。</p>
<h3 id="x2F-usr-目录"><a href="#x2F-usr-目录" class="headerlink" title="&#x2F;usr 目录"></a>&#x2F;usr 目录</h3><p>&#x2F;usr 目录的内容可以存放在另一个分区中，在系统启动后再挂接到根文件系统的&#x2F;usr目录下。里面存放的是共享、只读的程序和数据，这表明&#x2F;usr目录下的内容可以在多个主机间共享，这些主机也符合FHS标准，&#x2F;usr中的文件应该也是只读的，其他相关、可变的文件也应该保存在其他目录下，比如&#x2F;var。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>很多用户命令存放在这个目录下</td>
</tr>
<tr>
<td>include</td>
<td>C程序的头文件，这在PC下进行开发时才用到，在嵌入式系统中不需要</td>
</tr>
<tr>
<td>lib</td>
<td>库文件</td>
</tr>
<tr>
<td>local</td>
<td>本地目录</td>
</tr>
<tr>
<td>sbin</td>
<td>非必需的系统命令（必需的系统命令放在&#x2F;sbin目录下）</td>
</tr>
<tr>
<td>share</td>
<td>架构无关的数据</td>
</tr>
<tr>
<td>X11R6</td>
<td>XWindows系统</td>
</tr>
<tr>
<td>games</td>
<td>游戏</td>
</tr>
<tr>
<td>src</td>
<td>源代码</td>
</tr>
</tbody></table>
<h3 id="x2F-var-目录"><a href="#x2F-var-目录" class="headerlink" title="&#x2F;var 目录"></a>&#x2F;var 目录</h3><p>与&#x2F;usr目录相反，&#x2F;var目录下存放可变的数据，比如&#x2F;spool目录，log文件、临时文件。</p>
<h3 id="x2F-proc"><a href="#x2F-proc" class="headerlink" title="&#x2F;proc"></a>&#x2F;proc</h3><p>这是一个空目录，常作为proc文件系统的挂接点。proc文件系统是个虚拟的文件系统，它没有实际的存储设备，里面的目录、文件都是由内核临时生成的，用来表示系统的运行状态，也可以操作里面的文件控制系统。<br>系统启动后，使用以下命令挂接proc文件系统（常在&#x2F;etc&#x2F;fstab进行设置以自动挂接）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mount -t proc none /proc</span><br></pre></td></tr></table></figure>

<h3 id="x2F-mnt-目录"><a href="#x2F-mnt-目录" class="headerlink" title="&#x2F;mnt 目录"></a>&#x2F;mnt 目录</h3><p>用于临时挂接某个文件系统的挂接点，通常是空目录；也可以在里面创建一些空的子目录，比如&#x2F;mnt&#x2F;cdram、&#x2F;mnt&#x2F;hda1等，用来临时挂接光盘、硬盘。</p>
<h3 id="x2F-tmp-目录"><a href="#x2F-tmp-目录" class="headerlink" title="&#x2F;tmp 目录"></a>&#x2F;tmp 目录</h3><p>用于存放临时文件，通常是空目录。一些需要临时生成文件的程序要用到&#x2F;tmp目录，所以&#x2F;tmp目录必须存在并可以访问。<br>为减少对Flash的操作，当在&#x2F;tmp目录上挂接内存文件系统时，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mount -t tmpfs none /tmp</span><br></pre></td></tr></table></figure>

<h2 id="Linux-文件属性介绍"><a href="#Linux-文件属性介绍" class="headerlink" title="Linux 文件属性介绍"></a>Linux 文件属性介绍</h2><table>
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>普通文件</td>
<td>最常见的文件类型</td>
</tr>
<tr>
<td>目录文件</td>
<td>目录也是文件</td>
</tr>
<tr>
<td>字符设备文件</td>
<td>用来访问字符设备</td>
</tr>
<tr>
<td>块设备文件</td>
<td>用来访问块设备</td>
</tr>
<tr>
<td>FIFO</td>
<td>用于进程间通信，也称为命名管道</td>
</tr>
<tr>
<td>套接字</td>
<td>用于进程间的网络通信</td>
</tr>
<tr>
<td>连接文件</td>
<td>指向另一个文件，有软连接、硬连接</td>
</tr>
</tbody></table>
<p>使用“ls -lih”命令可以看到各个文件的具体信息，下面选取这几种文件，列出它们的信息。<br><img src="/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2.jpeg" alt="img not found"><br>除设备文件ttySAC0、mtdblock0外，这些信息都分为8个字段，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">228883  -rw-r--r--  2   root    root    6   Sep 27  22:10   readme.txt</span><br><span class="line">字段1       2       3     4       5      6       7           8</span><br></pre></td></tr></table></figure>
<ol>
<li>字段1：文件的索引节点inode<br>索引节点存放一个文件的上述信息，比如文件大小、属主、归属的用户组、读写权限等，并指明文件的实际数据存放的位置。</li>
<li>字段2：文件种类和权限<br>这字段共分10位，格式如下：<br>文件类型有7种，“-”表示普通文件，“d”表示目录，“c”表示字符设备，“b”表示块设备，“p”表示FIFO，“l”表示软连接，“s”表示套接字。<br>没有专门的符号来表示“硬连接”类型，硬连接也是普通文件，只不过文件的实际内容只有一个副本，连接文件、被连接文件都指向它。比如上面的ln_hard文件时是使用命令“ln readme.txt ln_hard”创建出来的到readme.txt文件的硬连接，readme.txt和ln_hard的地位完全一致，它们都指向文件系统中的同一位置，它们的“硬连接个数”都是2，表示这个文件的实际内容被引用两次，可以看到这两个文件的inode都是228883。<br>硬连接文件的引入的另一个作用是使得可以用别名来引用一个文件，避免文件被误删—只有当硬链接个数为1时，对一个文件执行删除操作时才会真正删除文件的副本。它的缺点是不能创建到目录的连接，被连接的文件和连接文件都必须在同一个文件系统中。对此，引入软连接，也称符号连接，软连接只是简单的指向一个文件（可以是目录），并不增加它的硬连接个数。比如上面的ln_soft文件就是使用命令“ln -s readme.txt ln_hard”创建出来的到readme.txt文件的软连接，它使用另一个inode。<br>剩下的9位分为3组，分别表示文件拥有者、同一个群组的用户、其他用户对这个文件的访问权限。每组权限由rwx三位组成，表示可读、可写、可执行。如果某一位被设为“-”，则表示没有相应的权限，比如“rw-”表示只有读写权限，没有可执行权限。</li>
<li>字段3：硬链接个数</li>
<li>字段4：文件拥有者</li>
<li>字段5：所属群组</li>
<li>字段6：文件或目录大小</li>
<li>字段7：最后访问或修改时间</li>
<li>字段8：文件名</li>
</ol>
<p>对于设备文件，字段6表示主设备号，字段7表示次设备号。</p>
<h1 id="移植-Busybox"><a href="#移植-Busybox" class="headerlink" title="移植 Busybox"></a>移植 Busybox</h1><p>所谓制作根文件系统，就是创建各种目录，并且在里面创建各种文件，比如在&#x2F;bin、&#x2F;sbin目录下存放各种可执行程序，在&#x2F;etc目录下存放配置文件，在&#x2F;lib目录下存放库文件。这节讲述如何使用Busybox来创建&#x2F;bin、&#x2F;sbin等目录下的可执行文件。</p>
<h2 id="Busybox-概述"><a href="#Busybox-概述" class="headerlink" title="Busybox 概述"></a>Busybox 概述</h2><p>Busybox是一个遵循GPL v2协议的开源项目。Busybox将众多的UNIX命令集合进一个很小的可执行程序中，可以用来替换GNU fileutils、shellutils等工具集。Busybox中各种命令与相应的GNU工具相比，所能提供的选项较少，但是能够满足一般应用。Busybox为各种小型的或者嵌入式系统提供了一个比较完全的工具集。<br>Busybox在编写过程中对文件大小进行优化，并考虑了系统有限的资源的情况。与一般的GNU工具集动辄几MB的体积相比，动态连接的Busybox只有几百KB，即使静态链接也只有几MB左右。Busybox按模块进行设计，可以很容易的加入、去除某些命令，或增减命令的某些选项。<br>在创建一个最小的根文件系统时，使用Busybox的话，只需要在&#x2F;dev目录下创建必要的设备节点、在&#x2F;etc目录下创建一些配置文件就可以了，如果Busybox使用动态连接，还要在&#x2F;lib目录下包含库文件。<br>Busybox支持uClibc库和glibc库，对Linux 2.2.x之后的内核支持良好。<br>Busybox的官方网站时 <code>http://www.busybox.net/</code>，源码可以从<code>http://www.busybox.net/downloads</code>下载。</p>
<h2 id="init进程介绍及用户程序启动过程"><a href="#init进程介绍及用户程序启动过程" class="headerlink" title="init进程介绍及用户程序启动过程"></a>init进程介绍及用户程序启动过程</h2><p>init进程是由内核启动的第一个用户进程，进程ID为1，它根据配置文件决定启动哪些程序，比如执行脚本、启动shell、运行用户指定的程序等。init进程是后续所有进程的发起者，比如init进程启动&#x2F;bin&#x2F;sh之后，才能够在控制台输入各种命令。<br><code>init进程的执行程序通常是/sbin/init</code>，上面讲述的init进程的作用只不过是&#x2F;sbin&#x2F;init这个程序的功能。我们完全可以编写自己的&#x2F;sbin&#x2F;init程序，或者传入命令行参数“init&#x3D;xxxxx”指定某个程序作为init进程运行。<br>一般而言，在Linux系统中有两种init程序：BSD init和System V init。BSD和System V 是两种版本的UNIX系统。这两种init程序各有优缺点，现在大多数Linux的发行版本使用System V init。但是在嵌入式领域，通常使用Busybox集成init程序。</p>
<h3 id="内核如何启动init进程"><a href="#内核如何启动init进程" class="headerlink" title="内核如何启动init进程"></a>内核如何启动init进程</h3><p>内核启动的最后一步就是启动init进程，代码在<code>init/main.c</code>文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> noinline <span class="title function_">init_post</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (sys_open((<span class="type">const</span> <span class="type">char</span> __user *) <span class="string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Warning: unable to open an initial console.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">		run_init_process(ramdisk_execute_command);</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Failed to execute %s\n&quot;</span>,</span><br><span class="line">				ramdisk_execute_command);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">		run_init_process(execute_command);</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Failed to execute %s.  Attempting &quot;</span></span><br><span class="line">					<span class="string">&quot;defaults...\n&quot;</span>, execute_command);</span><br><span class="line">	&#125;</span><br><span class="line">	run_init_process(<span class="string">&quot;/sbin/init&quot;</span>);</span><br><span class="line">	run_init_process(<span class="string">&quot;/etc/init&quot;</span>);</span><br><span class="line">	run_init_process(<span class="string">&quot;/bin/init&quot;</span>);</span><br><span class="line">	run_init_process(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">&quot;No init found.  Try passing init= option to kernel.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不复杂，其中的run_init_process函数使用它的参数所指定的程序来创建一个用户进程。需要注意，一旦run_init_process函数创建进程成功，它将不会返回。<br>内核启动init进程的过程如下：</p>
<ol>
<li>打开标准输入、标准输出、标准错误设备。<br>Linux最先打开的3个文件分别称为标准输入（stdin）、标准输出（stdout）、标准错误（stderr），它们对应的文件描述符分别为0、1、2。所谓标准输入就是在使用scanf()、fscan()获取数据时，从哪个文件（设备）读取数据；标准输出、标准错误都是输出设备，前者对应printf()、fprintf(stdout)，后者对应发fprintf(stderr)。<br>第[4]行尝试打开&#x2F;dev&#x2F;console设备文件，如果成功，它就是init进程标准输入设备。<br>第[7]、[8]行将文件描述符0复制给文件描述符1、2，所以标准输入、标准输出、标准错误都对应同一个文件（设备）。<br>在移植Linux内核时，如果发现打印出“Warning：unable to open an initial console.”，其原因大多是：根文件系统虽然被正确挂接了，但是里面的内容不正确，要么就是没有&#x2F;dev&#x2F;console这个文件，要么它没有对应的设备。</li>
<li>如果ramdisk_execute_command变量指定了要运行的程序，启动它。<br>ramdisk_execute_command的取值（代码也在init&#x2F;main.c中）分3种情况。<br>①如果命令行参数指定了“rdinit&#x3D;…”，则ramdisk_execute_command等于这个参数指定的程序。<br>②否则，如果&#x2F;init程序存在，ramdisk_execute_command就等于“&#x2F;init”。<br>③否则，ramdisk_execute_command为空。<br>本书所用的命令行没有设定“rdinit&#x3D;…”，根文件系统中也没有&#x2F;init程序，所以ramdisk_execute_command为空,所以第[11]-[13]行代码不执行。</li>
<li>如果execute_command变量指定了要运行的程序，启动它。<br>如果命令行参数中指定了“init&#x3D;…”，则execute_command等于这个参数指定的程序，否则为空。<br>本书所用的命令行没有设定“init&#x3D;…”，所以第[17]-[19]行代码不执行。</li>
<li>依次尝试执行&#x2F;sbin&#x2F;init、&#x2F;etc&#x2F;init、&#x2F;bin&#x2F;init、&#x2F;bin&#x2F;sh。<br>第[21]行执行&#x2F;sbin&#x2F;init程序，这个程序在我们的根文件系统中是存在的，所以init进程所用的程序就是&#x2F;sbin&#x2F;init。从此系统的控制器交给&#x2F;sbin&#x2F;init，不再返回init_post函数中。<br>run_init_process函数也在init&#x2F;main.c中，代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> * argv_init[MAX_INIT_ARGS+<span class="number">2</span>] = &#123; <span class="string">&quot;init&quot;</span>, <span class="literal">NULL</span>, &#125;;</span><br><span class="line"><span class="type">char</span> * envp_init[MAX_INIT_ENVS+<span class="number">2</span>] = &#123; <span class="string">&quot;HOME=/&quot;</span>, <span class="string">&quot;TERM=linux&quot;</span>, <span class="literal">NULL</span>, &#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_init_process</span><span class="params">(<span class="type">char</span> *init_filename)</span></span><br><span class="line">&#123;</span><br><span class="line">	argv_init[<span class="number">0</span>] = init_filename;</span><br><span class="line">	kernel_execve(init_filename, argv_init, envp_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以执行&#x2F;sbin&#x2F;init程序时，它的环境参数为“HOME&#x3D;&#x2F;”，“TERM&#x3D;linux”。</li>
</ol>
<h2 id="Busybox-init-进程的启动过程"><a href="#Busybox-init-进程的启动过程" class="headerlink" title="Busybox init 进程的启动过程"></a>Busybox init 进程的启动过程</h2><p>Busybox init 程序对应的代码在<code>init/init.c</code>文件中，下面以busybox-1.7.0为例进行讲解。<br>先概述其流程，再结合一个&#x2F;etc&#x2F;inittab文件讲述init进程的启动过程。</p>
<ol>
<li>Busybox init程序流程<br>流程图如下所示，其中与构建根文件系统关系密切的是控制台的初始化、对inittab文件的解释和执行。<br><img src="/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/3.jpeg" alt="img not found"><br>内核启动init进程时已经打开“dev&#x2F;console”设备作为控制台，一般情况下Busybox init 程序就使用&#x2F;dev&#x2F;console。但是如果内核启动init进程的同时设置了环境变量CONSOLE或console，则使用环境变量所指的的设备。在Busybox init 程序中，还会检查这个设备是否可以打开，如果不能打开则使用“&#x2F;dev&#x2F;null”。<br>Busybox init 只是作为其他进程的发起者和控制者，并不需要控制台与用户交互，所以init进程会把它关掉，系统启动后运行命令“ls &#x2F;proc&#x2F;1&#x2F;fd”可以看到该目录为空。init进程创建其他子进程时，如果没有在&#x2F;etc&#x2F;inittab中指明它的控制台，则使用前面确定的控制台。<br>&#x2F;etc&#x2F;inittab文件的相关文档和示例代码都在Busybox的example&#x2F;inittab文件中。<br>如果存在&#x2F;etc&#x2F;inittab文件，Busybox init程序解析它，然后按照它的指示创建各种子进程；否则使用默认的配置创建子进程。<br>&#x2F;etc&#x2F;inittab文件中每个条目用来定义一个子进程，并确定它的启动方法，格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br></pre></td></tr></table></figure>
例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ttySAC0::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure>
对于Busybox init 程序，上述字段作用如下。<br>①<id>：表示这个子进程要使用的控制台（即标准输入、标准输出、标准错误设备）。如果省略，则使用与init进程一样的控制台。<br>②<runlevels>：对于Busybox init 程序，这个字段没有意义。<br>③<action>：表示init进程如何控制这个子进程，有如下8种取值。<br>④<process>：要执行的程序，它可以是可执行程序，也可以是脚本。<br>如果<process>字段前面有“-”字符，这个程序被称为“交互的”。<table>
<thead>
<tr>
<th>action名称</th>
<th>执行条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sysinit</td>
<td>系统启动后最先执行</td>
<td>只执行一次，init进程等待它结束才继续执行其他动作</td>
</tr>
<tr>
<td>wait</td>
<td>系统执行完sysinit进程后</td>
<td>只执行一次，init进程等待它结束才继续执行其他动作</td>
</tr>
<tr>
<td>once</td>
<td>系统执行完wait进程后</td>
<td>只执行一次，init进程不等待它结束</td>
</tr>
<tr>
<td>respawn</td>
<td>启动完once进程后</td>
<td>init进程检测发现子进程退出时，重新启动它</td>
</tr>
<tr>
<td>askfirst</td>
<td>启动完respawn进程后</td>
<td>与respawn类似，不过init进程先输出“Please press Enter to activate this console.”，等用户输入回车键之后才启动子进程</td>
</tr>
<tr>
<td>shutdown</td>
<td>当系统关机时</td>
<td>即重启、关闭系统命令时</td>
</tr>
<tr>
<td>restart</td>
<td>Busybox中配置了CONFIG_FEATURE_USE_INITTAB，并且init进程接收到SIGHUP信号时</td>
<td>先重新读取、解析&#x2F;etc&#x2F;inittab文件，再执行restart程序</td>
</tr>
<tr>
<td>ctrlaltdel</td>
<td>按下Ctrl + Alt + Del组合键时</td>
<td>—</td>
</tr>
</tbody></table>
</process></process></action></runlevels></id></li>
</ol>
<p>在&#x2F;etc&#x2F;inittab文件的控制下，init进程的行为总结如下。<br>①在系统启动前期，init进程首先启动<action>为sysinit、wait、once的3类子进程。<br>②在系统正常运行期间，init进程首先启动<action>为respawn、askfirst的两类子进程，并监视他们，发现某个子进程退出时重新启动它们。<br>③在系统退出时，执行<action>为shutdown、restart、ctrlaltdel的3类子进程<br>如果根文件系统中没有&#x2F;etc&#x2F;inittab文件，Busybox init程序将使用如下默认的inittab条目。</action></action></action></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::askfirst:/bin/sh</span><br><span class="line">ttys2::askfirst:/bin/sh</span><br><span class="line">ttys3::askfirst:/bin/sh</span><br><span class="line">ttys4::askfirst:/bin/sh</span><br><span class="line">::ctrlaltdel:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>&#x2F;etc&#x2F;inittab 实例<br>仿照Busybox的example的examples&#x2F;inittab文件，创建一个inittab文件，内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/inittab</span><br><span class="line"># 这是init进程启动的第一个子进程，它是一个脚本，可以在里面指定用户想执行的操作</span><br><span class="line"># 比如挂接其他文件系统、配置网络等</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"># 启动shell，以/dev/ttySAC0作为控制台</span><br><span class="line">ttySAC0:askfirst:-/bin/sh</span><br><span class="line"></span><br><span class="line"># 按下Ctrl + Alt + Del之后执行的程序</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line"></span><br><span class="line"># 重启、关机前执行的程序</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="编译-x2F-安装-Busybox"><a href="#编译-x2F-安装-Busybox" class="headerlink" title="编译&#x2F;安装 Busybox"></a>编译&#x2F;安装 Busybox</h2><p>从<code>http://www.busybox.net/downloads</code>下载busybox-1.7.0.tar.bz2。<br>使用如下命令解压得到busubux-1.7.0目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xjf busybox-1.7.0.tar.bz2</span><br></pre></td></tr></table></figure>
<p>Busybox 集合了几百个命令，在一般系统中并不需要全部使用。可以通过配置Busybox来选择这些命令、定制某些命令的功能（选项）、指定Busybox的连接方法、指定Busybox的安装路径。</p>
<h3 id="配置-Busybox"><a href="#配置-Busybox" class="headerlink" title="配置 Busybox"></a>配置 Busybox</h3><p>在 busybox-1.7.0 目录下执行“make menuconfig”命令即可进入配置界面。Busybox将所有配置项分类存放，如下表所示：</p>
<table>
<thead>
<tr>
<th>配置项类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Busybox Settings —&gt; <br> General Configuration</td>
<td>一些通用的设置，一般不需要理会</td>
</tr>
<tr>
<td>Busybox Settings —&gt; <br> Build Options</td>
<td>连接方式、编译选项等</td>
</tr>
<tr>
<td>Busybox Settings —&gt; <br> Debugging Options</td>
<td>调试选项，使用Busybox时将打印一些调试信息，一般不选</td>
</tr>
<tr>
<td>Busybox Settings —&gt; <br> Installation Options</td>
<td>Busybox的安装路径，不需要设置，可以在命令行中指定</td>
</tr>
<tr>
<td>Busybox Settings —&gt; <br> Busybox Library Tuning</td>
<td>Busybox的性能微调，比如设置在控制台上可以输入的最大字符个数，一般使用默认值</td>
</tr>
<tr>
<td>Archival Utilities</td>
<td>各种压缩、解压缩工具，根据需要选择相关命令</td>
</tr>
<tr>
<td>Coreutils</td>
<td>核心的命令，比如ls、cp等</td>
</tr>
<tr>
<td>Console Utilities</td>
<td>控制台相关的命令，比如清屏命令clear等。</td>
</tr>
<tr>
<td>Debian Utilities</td>
<td>Debian（Linux的一种发行版本）命令</td>
</tr>
<tr>
<td>Editors</td>
<td>编辑命令，一般都选中Vi</td>
</tr>
<tr>
<td>Finding Utilities</td>
<td>查找命令</td>
</tr>
<tr>
<td>Init Utilities</td>
<td>init程序的配置选项，比如是否读取inittab文件</td>
</tr>
<tr>
<td>Login&#x2F;Password Management Utilities</td>
<td>登录、用户账号&#x2F;密码等方面的命令</td>
</tr>
<tr>
<td>Linux Ext2 FS Progs</td>
<td>Ext2文件系统的一些工具</td>
</tr>
<tr>
<td>Linux Module Utilities</td>
<td>加载&#x2F;卸载模块的命令</td>
</tr>
<tr>
<td>Linux System Utilities</td>
<td>一些系统命令，比如打印内核信息的dmesg、分区命令fdisk</td>
</tr>
<tr>
<td>Miscellaneous Utilities</td>
<td>一些不好分类的命令</td>
</tr>
<tr>
<td>Networking Utilities</td>
<td>网络方面的命令，可以选择一些方便调试的命令，比如telnetd、ping、tftp等</td>
</tr>
<tr>
<td>Process Utilities</td>
<td>进程相关的命令，如ps、free、kill、top等</td>
</tr>
<tr>
<td>Shells</td>
<td>有多种shell，比如msh、ash等，一般选择ash</td>
</tr>
<tr>
<td>System Logging Utilities</td>
<td>系统记录方面的命令</td>
</tr>
<tr>
<td>ipsvd Utilities</td>
<td>监听TCP、DPB端口</td>
</tr>
</tbody></table>
<ol>
<li>Busybox的性能微调<br>设置“TAB”键补全，如下配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Busybox Settings ---&gt;</span><br><span class="line">    Busybox Library Tuning ---&gt;</span><br><span class="line">        [*] Tab completion</span><br></pre></td></tr></table></figure></li>
<li>连接&#x2F;编译选项<br>以下选项指定是否使用静态连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Build Options ---&gt;</span><br><span class="line">    [] Build Busybox as a static binary (no shared libs)</span><br></pre></td></tr></table></figure>
使用glibc时，如果静态编译Busybox 会提示以下警告信息，表示会出现一些奇怪的问题。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># warning Static linking against glibc produces buggy executable</span><br></pre></td></tr></table></figure>
所以，本书使用动态连接的Busybox，在构造根文件系统时需要在&#x2F;lib目录下放置glibc库文件。</li>
<li>Archival Utilities 选项<br>选择tar命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Archival Utilities ---&gt;</span><br><span class="line">    [*] tar</span><br><span class="line">    [*] Enable archive creation</span><br><span class="line">    [*] Enable -j option to handle .tar.bz2 files</span><br><span class="line">    [*] Enable -X and -T options</span><br><span class="line">    [*] Enable -z option</span><br><span class="line">    [*] Enable -Z option</span><br><span class="line">    [*] Enable support for old tar  header format</span><br><span class="line">    [*] Enable support for some GNU tar extensions</span><br><span class="line">    [*] Enable long options</span><br></pre></td></tr></table></figure></li>
<li>Linux Module Utilities 选项<br>要使用可加载模块，下面的配置选上。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux Module Utilities ---&gt;</span><br><span class="line">    [*] insmode</span><br><span class="line">    [*] Module version checking</span><br><span class="line">    [*] Add module symbols to kernel symbol table</span><br><span class="line">    [*] In kernel memory optimization (uClinux only)</span><br><span class="line">    [*] Enable load map (-m) option</span><br><span class="line">    [*] Symbols in load map</span><br><span class="line">    [*] rmmod</span><br><span class="line">    [*] lsmod</span><br><span class="line">    [*] Support version 2.6.x Linux kernels</span><br></pre></td></tr></table></figure></li>
<li>Linux System Utilities 选项<br>支持mdev，这可以很方便的构造&#x2F;dev目录，并且可以支持热插拔设备。另外，为方便调试，选中mount、unmount 命令，并让mount命令支持NFS。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux System Utilities ---&gt;</span><br><span class="line">    [*] mdev</span><br><span class="line">    [*] Support /etc/mdev.conf</span><br><span class="line">    [*] Support command execution at device addtion/removal</span><br><span class="line">    [*] mount</span><br><span class="line">    [*] Suuport mounting NFS file system</span><br><span class="line">    [*] unmount</span><br><span class="line">    [*] unmount -a option</span><br></pre></td></tr></table></figure></li>
<li>Networking Utilities 选项<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux System Utilities ---&gt;</span><br><span class="line">    [*] ifconfig</span><br><span class="line">    [*] Enable status reporting output (+7k)</span><br><span class="line">    [] Enable slip-specific options &quot;keepalive&quot; and &quot;outfill&quot;</span><br><span class="line">    [] Enable options &quot;mem_start&quot;,&quot;io_addr&quot; and &quot;irq&quot;</span><br><span class="line">    [*] Enable option &quot;hw&quot; (ether only)</span><br><span class="line">    [*] Enable set the broadcast automatically</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="编译和安装-Busybox"><a href="#编译和安装-Busybox" class="headerlink" title="编译和安装 Busybox"></a>编译和安装 Busybox</h3><p>编译之前，先修改Busybox根目录的Makefile，使用交叉编译器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line">ARCH ?= $(SUBARCH)</span><br><span class="line">CROSS_COMPILE ?= </span><br><span class="line">修改后：</span><br><span class="line">ARCH ?= arm</span><br><span class="line">CROSS_COMPILE ?= arm-linux-</span><br></pre></td></tr></table></figure>
<p>然后执行“make”命令编译Busybox。<br>最后是安装，执行“make CONFIG_PREFIX&#x3D;dir_path install”就可以将Busybox安装在dir_name指定的目录下。执行以下命令在&#x2F;work&#x2F;nfs_root&#x2F;fs_mini目录下安装Busybox。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make CONFIG_PREFIX=/work/nfs_root/fs_mini install</span><br></pre></td></tr></table></figure>
<p>一切完成后，将在&#x2F;work&#x2F;nfs_root&#x2F;fs_mini目录下生成如下文件、目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x  2   book    book    4096    2008-01-22  06:56   bin </span><br><span class="line">lrwxrwxrwx  1   book    book    11      2008-01-22  06:56   linuxrc -&gt;  bin/busybox</span><br><span class="line">drwxr-xr-x  2   book    book    4096    2008-01-22  06:56   sbin </span><br><span class="line">drwxr-xr-x  4   book    book    4096    2008-01-22  06:56   usr</span><br></pre></td></tr></table></figure>
<p>其中linuxrc和上面分析的&#x2F;sbin&#x2F;init程序功能完全一样；其他目录下是各种命令，不过它们都是到&#x2F;bin&#x2F;busybox的符号链接，比如&#x2F;work&#x2F;nfs_root&#x2F;fs_mini&#x2F;sbin目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   halt -&gt;  ../bin/busybox</span><br><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   ifconfig -&gt;  ../bin/busybox</span><br><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   init -&gt;  ../bin/busybox</span><br><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   insmod -&gt;  ../bin/busybox</span><br><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   klogd -&gt;  ../bin/busybox</span><br></pre></td></tr></table></figure>
<p>除bin&#x2F;busybox外，其他文件都是到bin&#x2F;busybox的符号链接。busybox是所有命令的集合体，这些符号链接文件可以直接运行。在开发板上，运行“ls”和“busybox ls”是一样的。</p>
<h1 id="使用-glibc-库"><a href="#使用-glibc-库" class="headerlink" title="使用 glibc 库"></a>使用 glibc 库</h1><p>在制作交叉编译工具链时，已经生成了glibc库，可以直接使用它来构建根文件系统。</p>
<h2 id="glibc-库的组成"><a href="#glibc-库的组成" class="headerlink" title="glibc 库的组成"></a>glibc 库的组成</h2><p>glibc库的位置是&#x2F;work&#x2F;tools&#x2F;gcc-3.4.5-glibc-2.3.6&#x2F;arm-linux&#x2F;lib。<br>这个目录下的文件并非属于glibc库，比如crtl.o、libstdc++.a等文件是GCC工具本身生成的。本书不区分它们的来源，统一处理。<br>里面的目录、文件可以分为8类。<br>①加载器ld-2.3.6.so、ld-linux.so.2。<br>动态程序启动前，它们被用来加载动态库。<br>②目标文件(.o)<br>比如crtl.o、crti.o、crtn.o、gcrtl.o、Mcrtl.o、Scrtl.o等。在生成应用程序时，这些文件像一般的目标一样被连接。<br>③静态库文件(.a)<br>比如静态数学库libm.a、静态c++库libstdc++.a等，编译静态程序时会连接它们。<br>④动态库文件(.so，.so.[0-9]*)<br>比如动态数学库libm.so、动态c++库libstdc++.so等，它们可能是一个链接文件。编译动态库时会用到这些文件，但是不会连接它们，运行时才连接。<br>⑤libtool库文件(.a)<br>在连接库文件时，这些文件会被用到，比如它们列出了当前库文件所依赖的其他库文件。程序运行时无需这些文件。<br>⑥gconv目录<br>里面是有头字符集的动态库，比如ISO8859-l.o、GB18030.so等。<br>⑦ldscripts目录<br>里面是各种连接脚本，在编译应用程序时，它们被用于指定程序的运行地址、各段的位置等。<br>⑧其他目录及文件</p>
<h2 id="安装glibc-库"><a href="#安装glibc-库" class="headerlink" title="安装glibc 库"></a>安装glibc 库</h2><p>在开发板上只需要加载器和动态库，假设要构建的根文件系统目录为&#x2F;work&#x2F;nfs_root&#x2F;fs_mini，操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /work/nfs_root/fs_mini/lib</span><br><span class="line">cd /work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux/lib</span><br><span class="line">cp *.so* /work/nfs_root/fs_mini/lib -d</span><br></pre></td></tr></table></figure>
<p>上面复制的库文件不是每个都会用到，可以根据应用程序对库的依赖关系保留需要用到的。通过ldd命令查看一个程序会用到哪些库，主机自带的ldd命令不能查看交叉编译出来的文件。有以下两种替代方法。<br>①如果有uClibc-0.9.28的代码，可以进入utils子目录生成ldd.host工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd uClibc-0.9.28/utils</span><br><span class="line">make ldd.host</span><br></pre></td></tr></table></figure>
<p>然后将生成的ldd.host放到主机&#x2F;usr&#x2F;local&#x2F;bin目录下即可使用。<br>比如对于动态连接的Busybox，它的库的依赖关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldd.host busybox</span><br><span class="line">    libcrypto.so.1  =&gt;  /lib/libcrypto.so.1 (0x00000000)</span><br><span class="line">    libm.so.6   =&gt;  /lib/libm.so.6  (0x00000000)</span><br><span class="line">    libc.so.6   =&gt;  /lib/libc.so.6  (0x00000000)</span><br><span class="line">    /lib/ld-linux.so.2  =&gt;  /lib/ld-linux.so.2  (0x00000000)</span><br></pre></td></tr></table></figure>
<p>这表示Busybox要使用的要使用的库文件有libcrypto.so.1、libm.so.6、libc.so.6，加载器为&#x2F;lib&#x2F;ld-linux.so.2。上面的“not found”表示主机上没有这个条件，这么关系，开发板的根文件系统上有就行。<br>②可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-readelf -a &quot;your binary&quot; | grep &quot;Shared&quot;</span><br></pre></td></tr></table></figure>
<p>比如对于动态连接的Busybox，它的库依赖如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-readelf -a ./busybox | grep &quot;Shared&quot;</span><br><span class="line">0x00000001 (NEEDED)                 Shared library:[libcrypto.so.1]</span><br><span class="line">0x00000001 (NEEDED)                 Shared library:[libm.so.6]</span><br><span class="line">0x00000001 (NEEDED)                 Shared library:[libc.so.6]</span><br></pre></td></tr></table></figure>

<h1 id="构建根文件系统"><a href="#构建根文件系统" class="headerlink" title="构建根文件系统"></a>构建根文件系统</h1><p>前面在介绍了如何安装Busybox、C库，建立了bin&#x2F;、sbin&#x2F;、usr&#x2F;bin、usr&#x2F;sbin、lib&#x2F;等目录，最小根文件系统的大部分目录、文件已经建立好。</p>
<h2 id="构建etc目录"><a href="#构建etc目录" class="headerlink" title="构建etc目录"></a>构建etc目录</h2><p>init进程根据&#x2F;etc&#x2F;inittab来创建其他子进程，比如调用脚本配置文件配置IP地址、挂接其他文件分系统，最后启动shell等。<br>etc目录下的内容取决于要运行的程序，本节只需要3个文件：etc&#x2F;inittab、etc&#x2F;init.d&#x2F;rcS、etc&#x2F;fstab。</p>
<h3 id="创建etc-x2F-inittab文件"><a href="#创建etc-x2F-inittab文件" class="headerlink" title="创建etc&#x2F;inittab文件"></a>创建etc&#x2F;inittab文件</h3><p>仿照Busybox的examples&#x2F;inittab文件，在&#x2F;work&#x2F;nfs_root&#x2F;fs_mini&#x2F;etc目录下创建一个inittab文件，内容如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/inittab</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">ttySAC0::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/unmount -a -r</span><br></pre></td></tr></table></figure>

<h3 id="创建etc-x2F-init-d-x2F-rcS文件"><a href="#创建etc-x2F-init-d-x2F-rcS文件" class="headerlink" title="创建etc&#x2F;init.d&#x2F;rcS文件"></a>创建etc&#x2F;init.d&#x2F;rcS文件</h3><p>这是一个脚本文件，可以在里面添加想自动执行的命令。以下命令配置IP地址、挂接&#x2F;etc&#x2F;fstab指定的文件系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">ifconfig eth0 192.168.1.17</span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure>
<p>第一行表示这是一个脚本文件，运行时使用&#x2F;bin&#x2F;sh解析。<br>第一行用来配置IP地址。<br>第三行挂接&#x2F;etc&#x2F;fstab文件指定的所有文件系统。<br>最后还要改变它的属性，使它能够执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x etc/init.d/rcS</span><br></pre></td></tr></table></figure>

<h3 id="创建etc-x2F-fstab文件"><a href="#创建etc-x2F-fstab文件" class="headerlink" title="创建etc&#x2F;fstab文件"></a>创建etc&#x2F;fstab文件</h3><p>内容如下，表示执行“mount -a”命令后将挂接proc、tmpfs文件系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># device        mount-point        type        options      dump        fsck        order</span><br><span class="line">  proc          /proc               proc        defaults    0           0</span><br><span class="line">  tmpfs         /tmp                tmpfs       defaults    0           0</span><br></pre></td></tr></table></figure>
<p>&#x2F;etc&#x2F;fstab文件被用来定义文件系统的“静态信息”，这些信息被用来控制mount命令的行为。文件中各字段的意义如下。<br>①device：要挂接的设备<br>比如&#x2F;dev&#x2F;hda2、&#x2F;dev&#x2F;mtdblock1等设备文件；也可以是其他格式，比如对于proc文件系统这个字段没有意义，可以是任意值；对于NFS文件系统，这个字段为<code>&lt;host&gt;:&lt;dir&gt;</code>。<br>②mount-point：挂接点<br>③type：文件系统类型<br>比如proc、jffs2、yaffs、ext2、nfs等；也可以是auto，表示自动检测文件系统类型。<br>④options：挂接参数，以逗号隔开。<br>&#x2F;etc&#x2F;fstab的作用不仅仅是用来控制“mount -a”的行为，即使是一般的mount命令也受它控制，这可以从下表的参数看出。除与文件系统类型相关的参数外，常用的有以下几种取值。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>auto<br>noauto</td>
<td>决定执行“mount -a”时是否自动挂接 <br> auto：挂接 noauto：不挂接</td>
<td>auto</td>
</tr>
<tr>
<td>user<br>nouser</td>
<td>user：运行普通用户挂接设备<br>nouser：只允许root用户挂接设备</td>
<td>nouser</td>
</tr>
<tr>
<td>exec<br>noexec</td>
<td>exec：允许所挂接设备上的文件<br>noexec：不允许允许所挂接设备上的程序</td>
<td>exec</td>
</tr>
<tr>
<td>Ro</td>
<td>以只读方式挂接文件系统</td>
<td>-</td>
</tr>
<tr>
<td>Rw</td>
<td>以读写方式挂接文件系统</td>
<td>-</td>
</tr>
<tr>
<td>sync<br>async</td>
<td>sync：修改文件时，它会同步写入设备中<br>async：不会同步写入</td>
<td>sync</td>
</tr>
<tr>
<td>default</td>
<td>rw、suid、dev、exec、auto、nouser、async等的组合</td>
<td>-</td>
</tr>
</tbody></table>
<p>⑤dump和fsck order：用来决定控制dump、fsck程序的行为。<br>dump是一个用来备份文件的程序，fsck是一个用来检查磁盘的程序。<br>dump程序程序根据dump字段的值来决定这个文件系统是否需要备份，如果没有这个字段，或者其值为0，则dump忽略这个文件系统。<br>fsck程序根据fsck order字段来决定磁盘的检查顺序，一般来说对于根据根文件系统这个字段设为1，其他文件系统设为2。如果设为0，则fsck忽略这个文件系统。</p>
<h2 id="构建dev目录"><a href="#构建dev目录" class="headerlink" title="构建dev目录"></a>构建dev目录</h2><p>使用两种方式创建dev目录。</p>
<h3 id="静态创建设备文件"><a href="#静态创建设备文件" class="headerlink" title="静态创建设备文件"></a>静态创建设备文件</h3><p>为简单起见，本书先使用最原始的方法处理设备：在&#x2F;dev目录下静态创建各种节点。<br>从系统启动过程可知，涉及的设备有：&#x2F;dev&#x2F;mtdblock<em>、&#x2F;dev&#x2F;ttySAC</em>、&#x2F;dev&#x2F;console、dev&#x2F;null，只要建立以下设备就可以启动系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /work/nfs_root/fs_mini/dev</span><br><span class="line">cd /work/nfs_root/fs_mini/dev</span><br><span class="line">sudo mknod console c 5 1</span><br><span class="line">sudo mknod null c 1 3</span><br><span class="line">sudo mknod ttySAC0 c 204 64</span><br><span class="line">sudo mknod mtdblock0 b 31 0</span><br><span class="line">sudo mknod mtdblock1 b 31 1</span><br><span class="line">sudo mknod mtdblock2 b 31 2</span><br></pre></td></tr></table></figure>
<p>其他设备文件可以当系统启动后，使用“cat &#x2F;proc&#x2F;devices”命令查看内核中注册了哪些设备，然后一一创建相应的设备文件。</p>
<h3 id="使用mdev创建设备文件"><a href="#使用mdev创建设备文件" class="headerlink" title="使用mdev创建设备文件"></a>使用mdev创建设备文件</h3><p>mdev是udev的简化版本，也是通过读取内核信息来创建设备文件。<br>mdev的用途主要有两个：初始化&#x2F;dev目录、动态更新。动态更新不仅是更新&#x2F;dev目录，还支持热插拔。<br>要使用mdev，需要内核支持sysfs文件系统，为了减少对Flash的读写，还要支持tmpfs文件系统。先确保内核已经设置了CONFIG_SYSFS、CONFIG_TMPFS配置项。<br>使用mdev的命令如下，请参考它们的注释以了解其作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t tmpfs mdev /dev                    //使用内存文件系统，减少对Flash的读写</span><br><span class="line">mkdir /dev/pts                              //devpts用来支持外部网络连接的虚拟终端</span><br><span class="line">mount -t devpts devpts /dev/pts     </span><br><span class="line">mount -t sysfs sysfs /sys                   //mdev通过sysfs文件系统获得设备信息</span><br><span class="line">echo /bin/mdev&gt;/proc/sys/kernel/hotplug     //设置内核，当有设备拔插时调用/bin/mdev程序</span><br><span class="line">mdev -s                                     //在/dev目录下生成内核支持的所有设备节点</span><br></pre></td></tr></table></figure>
<p>要在内核启动时，自动运行mdev。这要修改&#x2F;work&#x2F;nfs_root&#x2F;fs_mini中的两个文件：修改etc&#x2F;fstab来自动挂载文件系统、修改etc&#x2F;init.d&#x2F;rcS加入要自动运行的命令。修改后如下所示：<br>①etc&#x2F;fstab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># device        mount-point        type        options      dump        fsck        order</span><br><span class="line">  proc          /proc               proc        defaults    0           0</span><br><span class="line">  tmpfs         /tmp                tmpfs       defaults    0           0</span><br><span class="line">  sysfs         /sys                sysfs       defaults    0           0</span><br><span class="line">  tmpfs         /dev                tmpfs       defaults    0           0</span><br></pre></td></tr></table></figure>
<p>②etc&#x2F;init.d&#x2F;rcS：加入下面几行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -a</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>
<p>需要注意的是，开发板上通过mdev生成的&#x2F;dev目录中，S3C2410、S3C2440的串口名是s3c2410_serial0、s3c2410_serial1、s3c2410_serial2，不是ttySAC0、ttySAC1、ttySAC2。需要修改etc&#x2F;inittab文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line">ttySAC0: askfirst:-/bin/sh</span><br><span class="line">修改后：</span><br><span class="line">s3c2410_serial0::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure>
<p>另外，mdev是通过init进程来启动的，在使用mdev构造&#x2F;dev目录之前，init进程至少要用到设备文件&#x2F;dev&#x2F;console、&#x2F;dev&#x2F;nul，所以要建立这两个设备文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /work/nfs_root/fs_mini/dev</span><br><span class="line">cd /work/nfd_root/fs_mini/dev</span><br><span class="line">sudo mknod console c 5 1 </span><br><span class="line">sudo mknod null c 1 3 </span><br></pre></td></tr></table></figure>

<h2 id="构建其他目录"><a href="#构建其他目录" class="headerlink" title="构建其他目录"></a>构建其他目录</h2><p>其他目录可以是空目录，比如proc、mnt、tmp、sys、root等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/nfs_root/fs_mini</span><br><span class="line">mkdir proc mnt tmp sys root</span><br></pre></td></tr></table></figure>
<p>现在，&#x2F;work&#x2F;nfs_root&#x2F;fs_mini目录下就是一个非常小的文件系统。开发板可以将它作为网络根文件系统直接启动。如果要烧入开发板，还要将它制作为一个文件，称为映像文件。</p>
<h3 id="制作-x2F-使用yaffs文件系统映像文件"><a href="#制作-x2F-使用yaffs文件系统映像文件" class="headerlink" title="制作&#x2F;使用yaffs文件系统映像文件"></a>制作&#x2F;使用yaffs文件系统映像文件</h3><p>按照前面的方法，在&#x2F;work&#x2F;nfs_root目录下构造了两个根文件系统：fs_mini、fs_mini_mdev。前者使用&#x2F;dev目录中事先建立好的设备文件，后者使用mdev机制来生成dev目录，它们的差别只在于3点：etc&#x2F;inittab文件、etc&#x2F;init.d&#x2F;rcS文件、dev&#x2F;目录。下面以&#x2F;work&#x2F;nfs_root&#x2F;fs_mini为例制作根文件系统映像。<br>所谓制作文件系统映像，就是将一个目录下的所有内容按照一定的格式存放到一个文件中，这个文件可以直接烧写到存储设备中去。当系统启动后挂接这个设备，就可以看到与原来目录一样的内容。<br>制作不同类型的文件系统映像需要使用不同的工具。</p>
<h4 id="修改制作yaffs映像文件的工具"><a href="#修改制作yaffs映像文件的工具" class="headerlink" title="修改制作yaffs映像文件的工具"></a>修改制作yaffs映像文件的工具</h4><p>在yaffs源码包有一个utils目录，里面是工具mkyaffsimage和mkyaffs2image的源代码。前者用来制作yaffs1映像文件，后者用来制作yaffs2映像文件。<br>目前mkyaffsimage工具只能生成老格式的yaffs1映像文件，需要修改才能支持新格式。<br>yaffs1新、老格式的不同在于oob区的使用发生了变化：一是ECC检验码的位置发生了变化，二是可用空间即标记（tag）的数据结构定义发生了变化。<br>另外，由于配置内核时没有设置CONFIG_YAFFS_DOES_ECC，yaffs文件系统将使用MTD设备层的ECC校验方法，制作映像文件时也使用与MTD设备层相同的函数计算ECC码。<br>①oob区中校验码的位置变化：<br>oob区中使用6个字节来存放ECC校验码，前3个字节对应上半页，后3个字节对应下半页。<br>由nand_oob_16结构可知，以前的校验码在oob区中存放的位置为8、9、10、13、14和15，现在改为0、1、2、3、6、7。<br>②oob区中可用空间的数据结构定义变化。<br>oob区中可用的空间有8个字节，它用来存放文件系统的数据，代码中这些数据被称为标记（tag）。<br>老格式的yaffs1中，这8个字节的数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//老格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> chunkId:<span class="number">20</span>;</span><br><span class="line">    <span class="type">unsigned</span> serialNumber:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> byteCount:<span class="number">10</span>;</span><br><span class="line">    <span class="type">unsigned</span> objectId:<span class="number">18</span>;</span><br><span class="line">    <span class="type">unsigned</span> ecc:<span class="number">12</span>;</span><br><span class="line">    <span class="type">unsigned</span> unusedStuff:<span class="number">2</span>;</span><br><span class="line">&#125;yaffs_Tags;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> chunkId:<span class="number">20</span>;</span><br><span class="line">    <span class="type">unsigned</span> serialNumber:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> byteCount:<span class="number">10</span>;</span><br><span class="line">    <span class="type">unsigned</span> objectId:<span class="number">18</span>;</span><br><span class="line">    <span class="type">unsigned</span> ecc:<span class="number">12</span>;</span><br><span class="line">    <span class="type">unsigned</span> deleted:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> unusedStuff:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> shouldBeff;</span><br><span class="line">&#125;yaffs_PackedTags1;</span><br></pre></td></tr></table></figure>
<p>新、老结构有细微差别：老结构中有两位没有使用（unusedStaff）；新结构中只有一位没有使用，另一位（deleted）被用来表示当前页是否已经删除。<br>③oob区中ECC码的计算<br>如果配置内核时设置了CONFIG_YAFFS_DOES_ECC，则yaffs文件系统将使用yaffs2&#x2F;yaffs_ecc.c文件中的yaffs_ECCCalculate函数来计算ECC码；否则使用drivers&#x2F;mtd&#x2F;nand&#x2F;nand_ecc.c文件中的nand_calculate_ecc函数。<br>mkyaffsimage工具原来的代码中使用yaffs_ECCCalculate函数。由于上面配置内核时，没有选择CONFIG_YAFFS_DOES_ECC，为了使映像文件与内核保持一致，要修改mkyaffsimage源码，使用nand_calculate_ecc函数。<br>对mkyaffsiamge的修改如下所示。<br>①增加头文件<br>修改文件mkyaffsimage.c，加上下面这行，里面定义了yaffs_PackedTags1结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;yaffs_packedtags1.h&quot;</span><br></pre></td></tr></table></figure>
<p>②修改mkyaffsimages.c文件的write_chunk函数<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_chunk</span><span class="params">(__u8 *data,__u32 chunkId,__u32 nBytes)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_YAFFS_9BYTE_TAGS <span class="comment">//如果要生成老格式的yaffs1映像文件，定义这个宏</span></span></span><br><span class="line"><span class="comment">/*原来的代码*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    yaffs_PachedTags pt1;</span><br><span class="line">    yaffs_ExtendedTags  etags;</span><br><span class="line">    __u8  ecc_code[<span class="number">6</span>];</span><br><span class="line">    __u8  oobbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写页数据，512个字节</span></span><br><span class="line">    error = write(outFile,data,<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span>(error &lt; <span class="number">0</span>) <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造tag</span></span><br><span class="line">    etags.chunkId = chunkId;</span><br><span class="line">    etags.serialNumber = <span class="number">0</span>;</span><br><span class="line">    etags.byteCount = nBytes;</span><br><span class="line">    etags.objectId = objId;</span><br><span class="line">    etags.chunkDeleted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定位oob区中的可用数据（称为tag）</span></span><br><span class="line">    yaffs_PackTags1(&amp;pt1,&amp;etags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算tag本身的ECC码</span></span><br><span class="line">    yaffs_CalcTagsECC((yaffs_Tags *)&amp;pt1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(oobbuf,<span class="number">0xff</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(oobbuf+<span class="number">8</span>,&amp;pt1,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用与内核MTD层相同的计算方法一页数据（5124字节）的ECC码，并把它们填入oob</span></span><br><span class="line">    nand_calculate_ecc(data,&amp;ecc_code[<span class="number">0</span>]);</span><br><span class="line">    nand_calculate_ecc(data+<span class="number">256</span>,&amp;ecc_code[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    oobbuf[<span class="number">0</span>] = ecc_code[<span class="number">0</span>];</span><br><span class="line">    oobbuf[<span class="number">1</span>] = ecc_code[<span class="number">1</span>];</span><br><span class="line">    oobbuf[<span class="number">2</span>] = ecc_code[<span class="number">2</span>];</span><br><span class="line">    oobbuf[<span class="number">3</span>] = ecc_code[<span class="number">3</span>];</span><br><span class="line">    oobbuf[<span class="number">4</span>] = ecc_code[<span class="number">4</span>];</span><br><span class="line">    oobbuf[<span class="number">6</span>] = ecc_code[<span class="number">6</span>];</span><br><span class="line">    oobbuf[<span class="number">7</span>] = ecc_code[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    nPages++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写oob数据，169字节</span></span><br><span class="line">    <span class="keyword">return</span> write(outFile,oobbuf,<span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，第20行设置新tag结构中增加的chunkDeleted成员；第32-41行将计算出来的ECC码填入新的ECC位置，它正是nand_oob_16结构的eccpos数组定义的位置。<br>其中第32、33行的nand_calculate_ecc函数是从内核源文件drivers&#x2F;mtd&#x2F;nand&#x2F;nand_ecc.c修改而来；在&#x2F;work&#x2F;system&#x2F;Development&#x2F;yaffs2&#x2F;utils目录下新建一个同名文件nand_ecc.c，把内核文件nand_ecc.c的nand_calculate_ecc函数、函数中用到的nand_ecc_precalc_table数组摘出来；并去除函数中的第一个形参“struct mtd_info *mtd”。<br>③添加文件，修改Makefile<br>第23行的yaffs_PackTags1函数在上一层目录yaffs_packedtags1.c中定义，先将这个文件复制到当前目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ../yaffs_packedtags1.c ./</span><br></pre></td></tr></table></figure>
<p>另外，nand_calculate_ecc函数是在新加的nand_ecc.c中定义的，所以要修改Makefile，把yaffs_packedtags1.c和nand_ecc.c也编译进mkyaffsimage工具中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line">MKYAFFSSOURCES = mkyaffsimage.c</span><br><span class="line">修改后：</span><br><span class="line">MKYAFFSSOURCES = mkyaffsimage.c yaffs_packedtags1.c nand_ecc.c</span><br></pre></td></tr></table></figure>
<p>现在，在&#x2F;work&#x2F;system&#x2F;Development&#x2F;yaffs2&#x2F;utils目录下执行“make”命令生成mkyaffsimage工具，将它复制到&#x2F;usr&#x2F;local&#x2F;bin目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp mkyaffsimage /usr/local/bin</span><br><span class="line">sudo chmod +x /usr/local/bin/mkyaffsimage</span><br></pre></td></tr></table></figure>

<h4 id="制作-x2F-烧写yaffs映像文件"><a href="#制作-x2F-烧写yaffs映像文件" class="headerlink" title="制作&#x2F;烧写yaffs映像文件"></a>制作&#x2F;烧写yaffs映像文件</h4><p>使用如下命令将&#x2F;work&#x2F;nfs_root&#x2F;fs_mini目录制作为fs_mini.yaffs文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/nfs_root</span><br><span class="line">mkyaffsimage fs_mini fs_mini.yaffs</span><br></pre></td></tr></table></figure>
<p>将fs_mini.yaffs放入tftp目录或nfs目录后，在U-Boot界面就可以下载、烧入NAND Flash中，操作命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tftp 0x30000000 fs_mini.yaffs 或 nfs 0x30000000 192.168.1.57:/work/nfs_root/fs_mini.yaffs</span><br><span class="line">nand erase 0xA00000 0x3600000</span><br><span class="line">nand write.yaffs 0x30000000 0xA00000 $(filesize)</span><br></pre></td></tr></table></figure>
<p>现在可以修改命令行参数以MTD2分区作为根文件系统，比如在U-Boot控制界面如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set bootargs noinitrd console=ttySAC0 root=/dev/mtdblock2 rootfstype=yaffs</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第3篇第17章 构建Linux根文件系统</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>根文件系统</tag>
        <tag>Rootfs移植</tag>
      </tags>
  </entry>
  <entry>
    <title>移植Linux内核</title>
    <url>/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统移植之移植Linux内核</p>
<p>《嵌入式Linux应用完全开发手册》第3篇第16章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解内核源码结构，了解内核启动过程</li>
<li>掌握内核配置方法</li>
<li>移植内核同时支持S3C2410、S3C2440</li>
<li>掌握MTD设备的分区方法</li>
<li>掌握YAFFS文件系统的移植方法</li>
</ol>
<h1 id="Linux-版本及特点"><a href="#Linux-版本及特点" class="headerlink" title="Linux 版本及特点"></a>Linux 版本及特点</h1><p>Linux内核的版本号可以从源代码的顶层目录下的Makefile中看到，比如下面几行它们构成了Linux的版本号：2.6.22.6。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VERSION = <span class="number">2</span></span><br><span class="line">PATCHLEVEL = <span class="number">6</span></span><br><span class="line">SUBLEVEL = <span class="number">22</span></span><br><span class="line">EXTRAVERSION = <span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p>其中的“VERSION”和“PATCHLEVEL”组成主版本号，比如2.4、2.5、2.6等，稳定版本的主版本号用偶数表示（比如2.4、2.6），每隔2-3年出现一个稳定版本。开发中的版本用技术表示（2.3、2.5），它是下一个稳定版本的前身。<br>“SUBLEVEL”称为此版本号，它不分奇偶顺序递增。每隔1-2个月发布一个稳定版本。<br>“EXTRAVERSION”称为扩展版本号，它不分奇偶，顺序递增。每周发布几次扩展版本号，修正最新的稳定版本的问题。<br>Linux内核的最初版本在1991年发布，这是Linus Torvalds为他开发的386开发的一个类Minix的操作系统。<br>Linux 1.0的官方版发行于1994年3月，包含了386的官方支持，仅支持单CPU系统。<br>Linux 1.2发行于1995年3月，它是第一个包含多平台（Alpha、Sparc、Mips等）支持的官方版本。<br>Linux 2.0发行于1996年6月，包含很多新的平台支持，但是最重要的是，它是第一个支持SMP（对称多处理器）体系的版本。<br>Linux 2.2发行于1999年1月，它带来了SMP系统性能的极大提升，同时支持更多的硬件。<br>Linux 2.2发行于2001年1月，它进一步提升了SMP系统的扩展性，同时它集成了很多用于支持桌面系统的特性：USB、PC卡（PCMCIA）的支持，内置的即插即用等。<br>Linux 2.6发行于2003年12月，在Linux 2.4的基础上作了极大的改进。2.6内核支持更多的平台，从小规模的嵌入式系统到服务器级的64位的系统；使用新的调度器，进程的切换更高效；内核可被抢占，使得用户的操作可以得到更快速的响应；I&#x2F;O子系统也经历很大的修改，使得它在各种工作负荷下都更具响应性；模块子系统、文件系统都做了大量的改进。另外，以前使用Linux的变种μClinux来支持没有MMU的处理器，现在2.6版本的Linux中已经合入了μClinux的功能，也可以支持没有MMU的处理器。</p>
<h1 id="Linux移植准备"><a href="#Linux移植准备" class="headerlink" title="Linux移植准备"></a>Linux移植准备</h1><h2 id="获取Linux内核源码"><a href="#获取Linux内核源码" class="headerlink" title="获取Linux内核源码"></a>获取Linux内核源码</h2><p>登录Linux内核的官方网站<code>http://www.kernel.org/</code>，可以看到下图所示的内容：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/1.jpeg" alt="img not found"><br>上面标明了Linux内核的最新稳定版本、正在开发的测试版本，图中间的版本号就是各种补丁的链接地址。各种标记符的意义如下表所示：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>全部代码，单击“F”即可下载全部内核代码</td>
</tr>
<tr>
<td>B</td>
<td>当前补丁基于哪个版本的内核，单击“B”可以下载这个内核</td>
</tr>
<tr>
<td>V</td>
<td>查看补丁文件的信息，修改了哪些文件</td>
</tr>
<tr>
<td>VI</td>
<td>查看与上一个扩展版本相比，修改了哪些文件</td>
</tr>
<tr>
<td>C</td>
<td>当前的修改记录</td>
</tr>
<tr>
<td>ChangeLog</td>
<td>正式的修改记录，由开发者提供</td>
</tr>
</tbody></table>
<p>一般而言，各种补丁文件都是基于内核的某个正式版本生成的，除非使用标记符“B”指明了它所基于的版本。比如有补丁文件patch-2.6.xx.1、patch-2.6.xx.2、patch-2.6.xx.3，它们都是基于内核2.6.xx生成的补丁文件。使用时可以在内核2.6.xx上直接打补丁patch-2.6.xx.3，并不需要先打上补丁文件patch-2.6.xx.1、patch-2.6.xx.2；相应的，如果已经打上了补丁文件patch-2.6.xx.2，在打补丁之前，要先去除补丁文件patch-2.6.xx.2。<br>本书在Linux2.6.22.6上进行移植开发。下载linux-2.6.22.6.tar.bz2后如下解压即可得到目录linux-2.6.22.6，里面存放了内核源码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tar xjf linux<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>.tar.bz2</span><br></pre></td></tr></table></figure>
<p>也可以先下载内核源文件linux-2.6.22.tar.bz2、补丁文件patch-2.6.22.6.bz2，然后解压、打补丁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tar xjf linux<span class="number">-2.6</span><span class="number">.22</span>.tar.bz2</span><br><span class="line">tar xjf patch<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>.bz2</span><br><span class="line">cd linux<span class="number">-2.6</span><span class="number">.22</span></span><br><span class="line">patch -p1 &lt; ../patch<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span></span><br></pre></td></tr></table></figure>

<h2 id="内核源码结构及Makefile分析"><a href="#内核源码结构及Makefile分析" class="headerlink" title="内核源码结构及Makefile分析"></a>内核源码结构及Makefile分析</h2><h3 id="内核源码结构"><a href="#内核源码结构" class="headerlink" title="内核源码结构"></a>内核源码结构</h3><p>Linux内核文件有近2万，出去其他架构CPU的相关文件，支持S3C2410、S3C2440这两款芯片的完整内核文件有1万多个。这些文件的组织结构并不复杂，它们分别位于顶层目录下的17个子目录，各个目录功能独立。下表描述各目录的功能，最后两个目录不包含代码。</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>体系结构相关的代码，对于每个架构的CPU，arch下有一个对应的子目录，比如<code>arch/arm</code>、<code>arch/i386</code>。</td>
</tr>
<tr>
<td>block</td>
<td>块设备的通用函数</td>
</tr>
<tr>
<td>crypto</td>
<td>常用的加密和散列算法（AES、SHA），还有一些压缩和CRC校验算法</td>
</tr>
<tr>
<td>drivers</td>
<td>所有的设备驱动程序，里面的每一个子目录对应一类驱动程序，比如<code>drivers/block</code>为块设备驱动程序，<code>drivers/char</code>为字符设备驱动程序，<code>drivers/mtd</code>为NOR Flash、NAND Flash等存储设备的驱动程序</td>
</tr>
<tr>
<td>fs</td>
<td>Linux支持的文件系统的代码，每一个子目录对应一种文件系统，比如<code>fs/jffs2</code>、<code>fs/ext2</code>、<code>fs/ext3</code></td>
</tr>
<tr>
<td>include</td>
<td>内核头文件，有基本头文件（存放在<code>include/linux</code>目录下）、各种驱动或功能部件的头文件（比如<code>include/media</code>、<code>include/mtd</code>、<code>include/net</code>）、各种体系相关的头文件（比如<code>include/asm-arm</code>、<code>include/asm-i386</code>）。当配置内核之后，<code>include/asm</code>是某个<code>include/asm-xxx</code>的链接</td>
</tr>
<tr>
<td>init</td>
<td>内核的初始化代码（不是系统的引导代码），其中的<code>main.c</code>文件中的<code>start_kernel</code>函数是内核引导后运行的第一个函数</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间的通信代码</td>
</tr>
<tr>
<td>Kernel</td>
<td>内核管理的核心代码，与处理器相关的代码位于<code>arch/*/kernel</code></td>
</tr>
<tr>
<td>lib</td>
<td>内核用到的一些库函数的代码，比如<code>crc32.c</code>、<code>string.c</code>，与处理器相关的库函数代码位于<code>arch/*/lib</code>目录下</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理代码，与处理器相关的内存管理代码位于<code>arch/*/mm</code>目录下</td>
</tr>
<tr>
<td>net</td>
<td>网络支持代码，每个子目录对应与网络的一个方面</td>
</tr>
<tr>
<td>security</td>
<td>安全、密钥相关的代码</td>
</tr>
<tr>
<td>sound</td>
<td>音频设备的驱动代码</td>
</tr>
<tr>
<td>usr</td>
<td>用来制作一个压缩的cpio归档文件：initrd的镜像，它可以作为内核启动后挂接的第一个文件系统</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核文档</td>
</tr>
<tr>
<td>scripts</td>
<td>用于配置、编译内核的脚本文件</td>
</tr>
</tbody></table>
<p>对于ARM架构的S3C2410、S3C2440，其体系相关的代码在<code>arch/arm</code>目录下，在后面进行Linux移植时，开始的工作正是修改这个目录下的文件。内核代码的层次结构如下图：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/2.jpeg" alt="img not found"></p>
<h3 id="Linux-Makefile-分析"><a href="#Linux-Makefile-分析" class="headerlink" title="Linux Makefile 分析"></a>Linux Makefile 分析</h3><p>内核中的哪些文件将被编译，怎样被编译，连接顺序如何确定，哪个文件在最前面，哪些文件或函数先执行。这些都是通过Makefile来管理的。</p>
<ol>
<li>决定编译哪些文件</li>
<li>怎样编译这些文件</li>
<li>怎样连接这些文件</li>
</ol>
<p>Linux内核源码中含有很多个Makefile文件，这些Makefile文件又要包含其他一些文件（比如配置信息、通用的规则等 ）。这些文件构成了Linux的Makefile体系：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>顶层Makefile</td>
<td>它是所有Makefile文件的核心，从总体上控制着内核的编译、连接</td>
</tr>
<tr>
<td>.config</td>
<td>配置文件，在配置内核时生成，所有的Makefile文件（包括顶层目录及各级子目录）都是根据.config文件来决定使用哪些文件</td>
</tr>
<tr>
<td>arch&#x2F;$(ARCH)&#x2F;Makefile</td>
<td>对应体系结构的Makefile，它用来决定哪些体系结构相关的文件参与内核的生成，并提供一些规则来生成特定格式的内核映像</td>
</tr>
<tr>
<td>scipts&#x2F;Makefile.*</td>
<td>Makefile共用的通用规则、脚本等</td>
</tr>
<tr>
<td>kbuild Makefiles</td>
<td>各级子目录下的Makefile，它们相对简单，被上一层Makefile调用来编译当前子目录下的文件</td>
</tr>
</tbody></table>
<p>内核文档<code>Documentation/kbuild/makefiles.txt</code>对内核中的Makefile作用、用法讲解的非常透彻，以下根据前面总结的Makefile的3大作用分析这5类文件。</p>
<ol>
<li>决定编译哪些文件<br>Linux 内核的编译过程从顶层Makefile开始，然后递归进入各级子目录调用它们的Makefile，分为3个步骤。<br>①顶层Makefile决定内核根目录下哪些子目录将被编进内核。<br>②<code>arch/$(ARCH)/Makefile</code>决定<code>arch/$(ARCH)</code>目录下哪些文件、哪些目录将被编进内核。<br>③各级子目录下的Makefile决定所在目录下哪些文件将被编进内核，哪些文件将被编成模块（即驱动程序），进入哪些子目录继续调用它们的Makefile。</li>
</ol>
<p>先看步骤①，在顶层Makefile中可以看到如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init-y          :   init/</span><br><span class="line">drivers-y       :   drivers/    sound/</span><br><span class="line">net-y           :   net/</span><br><span class="line">libs-y          :   lib/</span><br><span class="line">core-y          :   usr/</span><br><span class="line">...</span><br><span class="line">core-y          +=  kernerl/    mm/ fs/ ipc/    security/   crypto/ block/</span><br></pre></td></tr></table></figure>
<p>可见，顶层Makefile将这13个子目录分为5类：init-y、drivers-y、net-y、libs-y和core-y。之前上表中的17个子目录，出去<code>include</code>目录和后面两个不包含内核代码的目录外，还有一个<code>arch</code>目录没有出现在内核中。它在<code>arch/$(ARCH)/Makefile</code>中被包含进内核，在顶层Makefile中直接包含了这个Makefile，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include $(srctree)/arch/$(ARCH)/Makefile</span><br></pre></td></tr></table></figure>
<p>对于ARCH变量，可以在执行make命令时传入，比如“make ARCH&#x3D;arm …”。另外，对于非x86平台，还需要指定交叉编译工具，这也可以在执行make命令时传入，比如“make CROSS_COMPILE&#x3D;arm-linux- …”。为了方便，常在顶层Makefile中进行修改。<br>修改前：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARCH    ?= $(SUBARCH)</span><br><span class="line">CROSS_COMPILE   ?= </span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARCH    ?= arm</span><br><span class="line">CROSS_COMPILE   ?= arm-linux-</span><br></pre></td></tr></table></figure>
<p>对于步骤②的<code>arch/$(ARCH)/Makefile</code>，以ARM体系为例，在<code>arch/arm/Makefile</code>中可以看到如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">head-y  := arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o </span><br><span class="line">...</span><br><span class="line">core-y  += arch/arm/kernel/ arch/arm/mm/ arch/arm/common/</span><br><span class="line">core-y  += $(MACHINE)</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2400/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2412/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2440/</span><br><span class="line">...</span><br><span class="line">libs-y  := arch/arm/lib/    $(libs-y)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>由第1行可知，除前面的5类子目录外，又出现了另一类：<code>head-y</code>，不过它是直接以文件名出现。MMUEXT在<code>arch/arm/Makefile</code>前面定义，对于没有MMU的处理器，MMUEXT的值为-nommu，使用文件head-nommu.S；对于有MMU的处理器，MMUEXT的值为空，使用文件head.S。<br><code>arch/arm/Makefile</code>中类似第3、4、5行的代码进一步扩展了<code>core-y</code>的内容，第9行扩展了<code>libs-y</code>的内容，这些都是体系结构相关的目录。第5-7行中的CONFIG_ARCH_S3C2410在配置内核时定义，它的值有3种：y、m、空。y表示编进内核，m表示编为模块，空表示不使用。<br>编译内核时，将依次进入init-y、core-y、libs-y、drivers-y和net-y所列出的目录执行它们的Makefile，每个子目录都会生成一个build-in.o（libs-y所列目录下，有可能lib.a文件）。最后，<code>head-y</code>所表示的文件将和这些build-in.o、lib.a一起被连接成内核映像文件vmlinux。<br>最后，步骤③是如何进行的。<br>在配置内核时，生成配置文件<code>.config</code>。内核顶层Makefile使用如下语句间接包含<code>.config</code>文件，以后就根据<code>.config</code>中定义的各个变量来决定编译哪些文件。之所以说是“间接”包含，是因为包含的是<code>include/config/auto.conf</code>文件，而它只是将<code>.config</code>文件中的注释去掉，并根据顶层Makefile中定义的变量增加一些变量而已。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Read in config</span><br><span class="line">-include include/config/<span class="keyword">auto</span>.conf</span><br></pre></td></tr></table></figure>
<p><code>include/config/auto.conf</code>文件的生成过程不再描述，它与<code>.config</code>的格式相同，摘选部分内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_ARCH_SMDK2410=y</span><br><span class="line">CONFIG_ARCH_S3C2440=y</span><br><span class="line"># .config中没有下面这行，它是根据顶层Makefile中定义的内核的版本号增加的</span><br><span class="line">CONFIG_KERNELVERSION=<span class="string">&quot;2.6.22.6&quot;</span></span><br><span class="line"># .config中没有下面这行，它是根据顶层Makefile中定义的ARCH变量增加的</span><br><span class="line">CONFIG_ARCH=<span class="string">&quot;arm&quot;</span></span><br><span class="line">CONFIG_JFFS2_FS=y</span><br><span class="line">CONFIG_LEDS_S3C24XX=m</span><br></pre></td></tr></table></figure>

<p>在<code>include/config/auto.conf</code>文件中，变量的值主要有两类：“y”和“m”。各级子目录的Makefile使用这些变量来决定哪些文件被编译进内核中，哪些文件被编成模块（即驱动程序），要进入哪些下一级子目录继续编译，这通过以下4种方法来确定（obj-y、obj-m、lib-y是Makefile中的变量）。</p>
<p>①obj-y用来定义哪些文件被编进（build-in）内核。<br>obj-y中定义的.o文件由当前目录下的.c或.S文件编译生成，它们连同下级子目录的build-in.o文件一起被组合成（使用“$(LD) -r”命令）当前目录下的build-in.o文件。这个build-in.o文件将被它的上一层Makefile使用。<br>obj-y中各个.o文件的顺序是有意义的，因为内核中用<code>moudule_init</code>或<code>__initcall</code>定义的函数将按照它们的连接顺序被调用。<br><strong>例子1</strong>，当下面的CONFIG_ISDN、CONFIG_ISDN_PPP_BSDCOMP在<code>.config</code>中被定义为y时，isdn.c或isdn.S、isdn_bsdcomp.c或isdn_bsdcomp.S被编译成isdn.o、isdn_bssdcomp.o。这两个.o文件被组合进buidl-in.o文件中，最后被链接进入内核。假如isdn.o、isdn_bsdcomp.o中分别用<code>moudule_init(A)</code>、<code>moudule_init(B)</code>定义了函数A、B，则内核启动时A先被调用，然后是B。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_ISDN)      += isdn.o</span><br><span class="line">obj-$(CONFIG_ISDN_PPP_BSDCOMP)      += isdn_bsdcomp.o</span><br></pre></td></tr></table></figure>

<p>②obj-m用来定义哪些文件被编译成可加载模块（Loadable module）。<br>obj-m中定义的.o文件有当前目录下的.c或.S文件编译生成，它们不会被编进build-in.o中，而是被编成可加载模块。<br>一个模块可以由一个或多个.o文件组成。对于只有一个源文件的模块，在obj-m中直接增加它的.o文件即可。对于有多个源文件的模块，除在obj-m中增加一个.o文件外，还要定义一个<module_name>-objs变量来告诉Makefile这个.o文件由哪些文件组成。<br><strong>例子2</strong>，当下面的CONFIG_ISDN_PPP_BSDCOMP在.config文件中被定义为m时，isdn_bsdcomp.c或isdn_bsdcomp.S将被编译成isdn_bsdcomp.o文件，它最后被制作成isdn_bsdcomp.ko模块。</module_name></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#drivers/isdn/i4l/Makefile</span></span><br><span class="line">obj-$(CONFIG_ISDN_PPP_BSDCOMP)  += isdn_bsdcomp.o</span><br></pre></td></tr></table></figure>
<p><strong>例子3</strong>，当下面的CONFIG_ISDN在.config文件中被定义为m时，将会生成一个isdn.o文件，它由isdn-objs中定义的isdn-net-lib.o、isdn_v110.o、isdn_common.o等3个文件组合而成。isdn.o最后被制作成isdn.ko模块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#drivers/isdn/i4l/Makefile</span></span><br><span class="line">obj-$(CONFIG_ISDN)  += isdn.o</span><br><span class="line">isdn-objs   :=  isdn_net_lib.o isdn_v110.o isdn_common.o</span><br></pre></td></tr></table></figure>

<p>③lib-y用来定义哪些文件被编成库文件<br>lib-y中定义的.o文件由当前目录下的.c或.S文件编译生成，它们被打包成当前目录下的一个库文件：lib.a。<br>同时出现在obj-y、lib-y中的.o文件，不会被包含进lib.a中。<br>要把这个lib.a编译进入内核中，需要在顶层Makefile中libs-y变量中列出当前目录。要编成库文件的内核代码一般都在这两个目录下：<code>lib/</code>、<code>arch/$(ARCH)/lib</code>。</p>
<p>④obj-y、obj-m还可以用来指定要进入的下一级子目录。<br>Linux中一个Makefile文件只负责生成当前目录下的目标文件，子目录下的目标文件由子目录的Makefile生成。Linux的编译系统会自动进入这些子目录调用他们的Makefile，只是需要在进入之前指定这些子目录。<br>这要用到obj-y、obj-m，只要在其中增加这些子目录名即可。<br><strong>例子4</strong>，<code>fs/Makefile</code>中有如下一行，当CONFIG_JFFS2_FS被定义为y或m时，在编译时将会进入<code>jffs2</code>目录进行编译。Linu的编译系统只会根据这些信息决定是否进入下一级目录，而下一级目录的文件如何编译成build-in.o或模块由它的Makefile决定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_JFFS2_FS)      += jffs2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>怎么编译这些文件<br>即编译选项、连接选项是什么。这些选项分为3类：全局的，适用于整个内核代码树；局部的，仅适用于某个Makefile中的所有文件；个体的，仅适用于某个文件。<br>全局选项在顶层Makefile和<code>arch/$(ARCH)/Makefile</code>中定义，这些选项的名称为：CFLAGS、AFLAGS、LDFLAGS、ARFLAGS，它们分别是编译C文件的选项、编译汇编文件的选项、连接文件的选项、制作库文件的选项。<br>需要使用局部选项时，它们在各个子目录中定义，名称为：EXTRA_FLAGS、EXTRA_ALAGS、EXTRA_LDFLAGS、EXTRA_ARFLAGS，它们的用途与前述选项相同，只是适用范围比较小，它们针对当前的Makefile中的所有文件。<br>另外，如果想针对某个文件定义它的编译选项，可以使用CFLAGS_$@,AFLAGS_$@。前者用于编译某个C文件，后者用于编译某个汇编文件。$@表示某个目标文件名，比如以下代码表示编译aha152x.c时，选项中要额外加上“-DAHA152X_STAT -DAUTOCONF”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># drivers/scsi/Makefile</span></span><br><span class="line">CFLAGS_aha152x.o = -DAHA152X_STAT -DAUTOCONF</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这3类选项是一起用的，在<code>scropts/Makefile.lib</code>中可以看到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_c_flags  = $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$(basetarget).o)</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎样连接这些文件，它们的顺序如何<br>前面分析有哪些文件需要编译进入内核时，顶层Makefile和<code>arch/$(ARCH)/Makefile</code>定义了6类目录（或文件）：head-y、init-y、drivers-y、net-y、libs-y和core-y。它们的初始值如下（以ARM体系为例）：<br><code>arch/arm/Makefile</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">head-y    := arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o</span><br><span class="line">...</span><br><span class="line">core-y    := arch/arm/kernel/ arch/arm/mm/ arch/arm/common/</span><br><span class="line">core-y    := $(MACHINE)</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2400/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2412/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2440/</span><br><span class="line">...</span><br><span class="line">libs-y				:= arch/arm/lib/ $(libs-y)</span><br></pre></td></tr></table></figure>
<p>顶层Makefile中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init-y  :=  init/</span><br><span class="line">drivers :=  drivers/  sound/</span><br><span class="line">net-y   :=  net/</span><br><span class="line">libs-y  :=  lib/</span><br><span class="line">core-y  :=  usr/</span><br><span class="line">...</span><br><span class="line">core-y  +=  kernel/ mm/ fs/ ipc/  security/ crypto/ block/</span><br></pre></td></tr></table></figure>
<p>可见，除head-y之外，其余的init-y、drivers-y等都是目录名。在顶层Makefile中，这些目录名的后面直接加上build-in.o或lib.a，表示要连接进内核的文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init-y  :=  $(patsubst %/, %/build-in.o, $(init-y))</span><br><span class="line">core-y  :=  $(patsubst %/, %/build-in.o, $(core-y))</span><br><span class="line">drivers-y  :=  $(patsubst %/, %/build-in.o, $(drivers-y))</span><br><span class="line">net-y  :=  $(patsubst %/, %/lib.a, $(net-y))</span><br><span class="line">libs-y1  :=  $(patsubst %/, %/build-in.o, $(libs-y))</span><br><span class="line">libs-y2  :=  $(patsubst %/, %/build-in.o, $(libs-y))</span><br><span class="line">libs-y  :=  $(libs-y1 $(libs-y2))</span><br></pre></td></tr></table></figure>
<p>上面的patsubst是个字符串处理函数，它的用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure>
<p>表示寻找“text”中符合格式“pattern”的字，用“replacement”替换它们。比如上面的init-y初值为“init&#x2F;”，经过交换之后，“init-y”变为“init&#x2F;build-in.o”。<br>顶层Makefile中，继续往下看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vmlinux-init  :=  $(head-y) $(init-y)</span><br><span class="line">vmlinux-main  :=  $(core-y) $(libs-y) $(drivers-y)  $(net-y)</span><br><span class="line">vmlinux-all   :=  $(vmlinux-linux)  $(vmlinux-main)</span><br><span class="line">vmlinux-lds   :=  arch/$(ARCH)/kernel/vmlinux.lds</span><br></pre></td></tr></table></figure>
<p>第3行的<code>vmlinux-all</code>表示所有构成内核映像文件vmlinux的目标文件，从第1-3行可知这些目标文件的顺序为：head-y、init-y、core-y、libs-y、drivers-y、net-y，即<code>arch/arm/kernel/head.o</code>（假设有MMU，否则为head-nommu.o）、<code>arch/arm/kernel/init_task.o</code>、<code>init/build-in.o</code>、<code>usr/build-in.o</code>等。<br>第4行表示连接脚本为<code>arch/$(ARCH)/kernel/vmlinux.lds</code>。对于ARM体系，连接脚本就是<code>arch/arm/kernel/vmlinux.lds</code>，它由<code>arch/arm/kernel/vmlinux.lds.S</code>文件生成。规则在<code>scripts/Makefile.build</code>中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$(obj)/%.lds: $(src)/%.lds.S  FORCE</span><br><span class="line">      $(call if_changed_dep,cpp_lds_S)</span><br></pre></td></tr></table></figure>
<p>现将生成的<code>arch/arm/kernel/vmlinux.lds</code>摘录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	. = 0xc0000000 + 0x00008000;                  /* 代码段起始地址，这是个虚拟地址 */</span><br><span class="line"></span><br><span class="line">	.text.head : &#123;</span><br><span class="line">		_stext = .;</span><br><span class="line">		_sinittext = .;</span><br><span class="line">		*(.text.head)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.init : &#123;			                                /* 内核初始化的代码和数据 */</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	.text : &#123;			                                /* 真正的代码段 */</span><br><span class="line">		_text = .;		                              /* 代码段和只读数据段的开始地址	*/</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 只读数据 */</span><br><span class="line">  . = ALIGN((4096)); .rodata:AT(ADDR(.rodata) - 0) &#123;......&#125; . = ALIGN((4096));</span><br><span class="line"></span><br><span class="line">	_etext = .;			                              /* 代码段和只读数据段的结束地址 */</span><br><span class="line">... ...</span><br><span class="line">	.data : AT(__data_loc) &#123;                      /* 数据段 */</span><br><span class="line">		__data_start = .;	                          /* 数据段起始地址 */</span><br><span class="line">... ...</span><br><span class="line">		_edata = .;                                 /* 数据段结束地址 */</span><br><span class="line">	&#125;</span><br><span class="line">	_edata_loc = __data_loc + SIZEOF(.data);      /* 数据段结束地址 */</span><br><span class="line"></span><br><span class="line">	.bss : &#123;                                      /* BSS段，没有初始化或初值为0的全局、静态变量 */</span><br><span class="line">		__bss_start = .;	                          /* BSS段起始地址 */</span><br><span class="line">		*(.bss)</span><br><span class="line">		*(COMMON)</span><br><span class="line">		_end = .;                                   /* BSS段结束地址 */</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.stab 0 : &#123; *(.stab) &#125;                        /* 调试信息段	*/</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>下面对本节分析Makefile的结果作一下总结。</p>
</li>
<li><p>配置文件.config中定义了一系列的变量，Makefile将结合它们来决定哪些文件被编进内核、哪些文件被编成模块、涉及哪些子目录。</p>
</li>
<li><p>顶层Makefile和<code>arch/$(ARCH)/Makefile</code>决定根目录下哪些子目录、<code>arch/$(ARCH)</code>目录下哪些文件和目录将被编进内核。</p>
</li>
<li><p>最后，各级子目录下的Makefile决定所在目录下哪些文件将被编进内核，哪些文件将被编成模块（驱动程序），进入哪些子目录继续调用它们的Makefile。</p>
</li>
<li><p>顶层Makefile和<code>arch/$(ARCH)/Makefile</code>设置了可以影响所有文件的编译、连接选项：CFLAGS、AFLAGS、LDFLAGS、ARFLAGS。</p>
</li>
<li><p>各级子目录下的Makefile中可以设置能够影响当前目录下所有文件的编译、连接选项：EXTRA_CFLAGS、EXTRA_AFLAGS、EXTRA_LDFLAGS、EXTRA_ARFLAGS；还可以设置可以影响某个文件的编译选项：CFLAGS_$@，AFLAGS_$@。</p>
</li>
<li><p>顶层Makefile按照一定的顺序组织文件，根据连接脚本<code>arch/$(ARCH)/kernel/vmlinux.lds</code>生成内核映像文件vmlinux。</p>
</li>
</ol>
<h2 id="内核的Kconfig分析"><a href="#内核的Kconfig分析" class="headerlink" title="内核的Kconfig分析"></a>内核的Kconfig分析</h2><p>在内核目录下执行“make menuconfig ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-”时，就会看到一个如下图所示的菜单：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/3.jpeg" alt="img not found"><br>这就是内核的配置界面。通过配置界面，可以选择芯片类型、选择需要支持的文件系统，去除不需要的选项等，这就称为“配置内核”。注意，也有其他形式的配置界面，比如“make config”命令启动字符配置界面，对于每个选项都会依次出现一行提示信息，逐个回答；“make xconfig”命令启动X-windows图形配置界面。<br>所有配置工具都是通过读取<code>arch/$(ARCH)/Kconfig</code>文件来生成配置界面，这个文件是所有配置文件的总入口，它会包含其他目录的Kconfig文件。配置界面如上图所示。<br>内核源码的每个子目录中，都有一个Makefile文件和Kconfig文件。Makefile的作用前面已经讲述，Kconfig用于配置内核，它就是各种配置界面的源文件。内核的配置工具读取各个Kconfig文件，生成配置界面供开发人员配置内核，最后生成配置文件.config。<br>内核的配置界面以树状的菜单形式组织，主菜单下有若干子菜单，子菜单下又有子菜单或配置选项。每个子菜单或选项可以有依赖关系，这些依赖关系用来确定它们上是否显示。只有被依赖项的父项已经被选中，子项才会显示。<br>Kconfig文件的语法可以参考<code>Documentation/kbuild/kconfig-language.txt</code>文件，下面讲述几个常用的语法，并在最后介绍菜单形式的配置界面操作方法。</p>
<h3 id="Kconfig-文件的基本要素：config条目（entry）"><a href="#Kconfig-文件的基本要素：config条目（entry）" class="headerlink" title="Kconfig 文件的基本要素：config条目（entry）"></a>Kconfig 文件的基本要素：config条目（entry）</h3><p>config条目常被其他条目包含，用来生成菜单、进行多项选择等。<br>config条目用来配置一个选项，或者这么说，它用于生成一个变量，这个变量会连同它的值一起被写入配置文件.config中。比如有一个config条目用来配置CONFIG_LEDS_S3C24XX，根据用户的选择，.config文件中可能出现下面3种配置结果中的一个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_LEDS_S3C24XX=y         # 对应的文件被编进内核</span><br><span class="line">CONFIG_LEDS_S3C24XX=m         # 对应的文件被编成模块</span><br><span class="line">#CONFIG_LEDS_S3C24XX          # 对应的文件没有被使用</span><br></pre></td></tr></table></figure>
<p>以一个例子说明config条目格式，下面代码选自<code>fs/Kconfig</code>文件，它用于配置CONFIG_JFFS2_FS_POSIX_ACL选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config JFFS2_FS_POSIX_ACL</span><br><span class="line">	bool &quot;JFFS2 POSIX Access Control Lists&quot;</span><br><span class="line">	depends on JFFS2_FS_XATTR</span><br><span class="line">	default y</span><br><span class="line">	select FS_POSIX_ACL</span><br><span class="line">	help</span><br><span class="line">	  Posix Access Control Lists (ACLs) support permissions for users and</span><br><span class="line">	  groups beyond the owner/group/world scheme.</span><br><span class="line">	  </span><br><span class="line">	  To learn more about Access Control Lists, visit the Posix ACLs for</span><br><span class="line">	  Linux website &lt;http://acl.bestbits.at/&gt;.</span><br><span class="line">	  </span><br><span class="line">	  If you don&#x27;t know what Access Control Lists are, say N</span><br></pre></td></tr></table></figure>
<p>代码中包含了几乎所有的元素，下面一一说明：<br>第1行中，config是关键字，表示一个配置选项的开始；紧跟着的JFFS2_FS_POSIX_ACL是配置选项的名称，省略了前缀“CONFIG_”。<br>第2行中，boot表示变量类型，即CONFIG_JFFS2_FS_POSIX_ACL的类型。有5种类型：bool、tristate、string、hex和int，其中的tristate和string是基本的类型，其他类型是它们的变种。boot变量取值有两种：y和n；tristate变量取值有3种：y、n和m；string变量取值为字符串；hex变量取值为十六进制的数据；int变量取值为十进制的数据。<br>“boot”之后的字符串是提示信息，在配置界面中上下移动光标选中它时，就可以通过按空格或回车来设置CONFIG_JFFS2_FS_POSIX_ACL的值。提示信息的完整格式如下，如果使用“if<expr>”，则当expr为真时才显示提示信息。在实际使用时，prompt关键字可以省略。</expr></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;prompt&quot;</span> &lt;prompt&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第3行表示依赖关系，格式如下。只有JFFS2_FS_XATTR配置选项被选中时，当前配置选项中的提示信息才会出现，才能设置当前配置选项。注意，如果依赖条件不满足，则它取默认值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;depend on &quot;</span>/<span class="string">&quot;requires&quot;</span> &lt;expr&gt;</span><br></pre></td></tr></table></figure>
<p>第4行的表示默认值为y，格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;default&quot;</span> &lt;expr&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第5行表示当前配置选项JFFS2_FS_POSIX_ACL被选中时，配置选项FS_POSIX_ACL也会被自动选中，格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;select&quot;</span> &lt;symbol&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第6行表示下面几行是帮助信息，帮助信息的关键字有如下两种，它们完全一样。当遇到一行的缩进距离比第一行帮助信息的缩进距离小时，表示帮助信息已经结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;help&quot;</span> or <span class="string">&quot;---help---&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="menu-条目"><a href="#menu-条目" class="headerlink" title="menu 条目"></a>menu 条目</h3><p>menu条目用于生成菜单，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;menu&quot; &lt;prompt&gt;</span><br><span class="line">&lt;menu options&gt;</span><br><span class="line">&lt;menu block&gt;</span><br><span class="line">&quot;endmenu&quot;</span><br></pre></td></tr></table></figure>
<p>它的实际使用并不如它的标准格式那样复杂，下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu &quot;Floating point emulation&quot;</span><br><span class="line"></span><br><span class="line">config FPE_NWFPE</span><br><span class="line">      ... ...</span><br><span class="line">config FPE_NWFPE_XP</span><br><span class="line">      ... ... </span><br><span class="line">... ...</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>
<p>menu之后的字符串是菜单名，“menu”和“endmenu”之间有很多config条目。在配置界面会出现如下字样的菜单，移动光标选中它后按回车键进入，就会看到这些config条目定义的配置选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Floating point emulation  ---&gt;</span><br></pre></td></tr></table></figure>
<h3 id="choice-条目"><a href="#choice-条目" class="headerlink" title="choice 条目"></a>choice 条目</h3><p>choice条目将多个类似的配置选项组合在一起，供用户单选或多选，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;choice&quot;</span><br><span class="line">&lt;choice options&gt;</span><br><span class="line">&lt;choice block&gt;</span><br><span class="line">&quot;endchioce&quot;</span><br></pre></td></tr></table></figure>
<p>实际使用中，也是在“choice”和“endchoice”之间定义多个config条目，比如<code>arch/arm/Kconfig</code>中有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choice </span><br><span class="line">      prompt &quot;ARM system type&quot;</span><br><span class="line">      default ARCH_VERSATILE</span><br><span class="line"></span><br><span class="line">config ARCH_AAEC2000</span><br><span class="line">      ...</span><br><span class="line">config ARCH_INTEGRATOR</span><br><span class="line">      ...</span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>
<p>prompt“ARM system type”给出提示信息“ARM system type”，光标选中它之后按回车键进入，就可以看到多个config条目定义的配置选项。<br>choice条目中定义的变量类型只能有两种：bool和tristate，不能同时有这两种类型的变量。对于bool类型的choice条目，只能在多个选项中选择一个；对于tristate类型的choice条目，要么就把一个或多个选项色设为m；要么就像bool类型的choice条目一样，只能选择一个。这是可以理解的，比如对于同一个硬件，它有多个驱动程序，可以选择将其中之一编译进内核（配置选项设置为y），也可以都将它们编译成模块（配置选项设置为m）。</p>
<h3 id="comment-条目"><a href="#comment-条目" class="headerlink" title="comment 条目"></a>comment 条目</h3><p>comment条目用于定义一些帮助信息，它在配置过程中出现界面的第一行；并且这些帮助信息会出现在配置文件中，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;comment&quot; &lt;prompt&gt;</span><br><span class="line">&lt;comment options&gt;</span><br></pre></td></tr></table></figure>
<p>实际使用也很简单，比如<code>arch/arm/Kconfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu &quot;Floating point emulation&quot;</span><br><span class="line"></span><br><span class="line">comment &quot;At least one emulation must be selected&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>进入菜单“Floating point emulation —&gt;”之后，在第一行会看到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- At least one emulation must be selected</span><br></pre></td></tr></table></figure>
<p>而在.config文件中也会看到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># At least one emulation must be selected</span><br><span class="line"># </span><br></pre></td></tr></table></figure>
<h3 id="source-条目"><a href="#source-条目" class="headerlink" title="source 条目"></a>source 条目</h3><p>source 条目用于读入另一个Kconfig文件，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;source&quot; &lt;prompt&gt;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子，取自<code>arch/arm/Kconfig</code>，它读入<code>net/Kconfig</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;net/Kconfig&quot;</span><br></pre></td></tr></table></figure>

<h3 id="菜单形式的配置界面操作方法"><a href="#菜单形式的配置界面操作方法" class="headerlink" title="菜单形式的配置界面操作方法"></a>菜单形式的配置界面操作方法</h3><p>配置界面的开始几行就是它的操作方法，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/4.jpeg" alt="img not found"><br>内核<code>scripts/kconfig/mconf.c</code>文件的注释给出了更详细的操作方法，讲解如下：<br>一些特定功能的文件可以直接编译进内核中，或者编译成一个可加载模块，或者根本不使用它们。还有一些内核参数，必须给它们赋一个值：十进制数、十六进制数，或者一个字符串。<br>配置界面中，以<code>[*]</code>、<code>&lt;M&gt;</code>或<code>[]</code>开头的选项表示相应的功能被编译进内核中、被编译成一个模块，或者没有使用。尖括号<code>&lt;&gt;</code>表示相应功能的文件可以被编译成模块。<br><code>↑</code>、<code>↓</code>方向键用来高亮选中某个配置选项，如果要进入某个子菜单，先选中它，然后按回车键进入。配置选项的名字后有<code>---&gt;</code>表示它是一个子菜单。配置选项的名称中有一个高亮的字母，它被称为<code>热键(hotkey)</code>,直接输入热键就可以选中该配置选项，或者循环选中具有相同热键的配置选项。<br>可以使用翻页键<code>&lt;Page Up&gt;</code>、<code>&lt;Page Down&gt;</code>来移动配置界面中的内容。<br>要退出配置界面，使用<code>←</code>、<code>→</code>方向键选中<code>&lt;Exit&gt;</code>按钮，然后按回车键。如果没有配置选项使用后面这些按键作为热键的话，也可以按两次<code>&lt;ESC&gt;</code>或<code>&lt;E&gt;&lt;X&gt;</code>键退出。<br>按<code>&lt;TAB&gt;</code>键可以在<code>&lt;Select&gt;</code>、<code>Exit</code>、<code>Help</code>这3个按钮中循环选中它们。<br>要想阅读某个配置选项的帮助信息，选中它之后，再选中<code>&lt;Help&gt;</code>按钮，按回车键；也可以选中配置选项后，直接按<code>&lt;H&gt;</code>或<code>&lt;?&gt;</code>键。<br>对于choice条目中的多个配置选项，使用方向键高亮选中某个配置选项，按<code>&lt;S&gt;</code>或空格键选中它；也可以通过输入配置选项的首字母，按<code>&lt;S&gt;</code>或空格键选中它。<br>对于int、hex或string类型的配置选项，要输入它们的值时，先高亮选中选中它，按回车键，输入数据，再按回车键。对于十六进制数据，前缀0x可以省略掉。<br>配置界面的最下面，如下图红框所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/5.jpeg" alt="img not found"><br>前者用于加载某个配置文件，后者用于将当前的配置保存到某个配置文件中去。需要注意的是，如果不使用这两个选项，配置的加载文件、输出文件都默认为.config文件；如果加载了其他的文件（假设文件名为A），然后在它的基础上进行修改，最后退出保存时，这些变化会保存到A中去，而不是.config。<br>当然，可以先加载文件A，然后修改，最后保存到.config中去。</p>
<h2 id="Linux-内核配置选项"><a href="#Linux-内核配置选项" class="headerlink" title="Linux 内核配置选项"></a>Linux 内核配置选项</h2><p>Linux内核配置选项多达上千个，一个个的进行选择既耗费时间，对开发人员的要求也比较高（需要了解每个配置选项的作用）。一般的做法是在某个默认配置文件的基础上进行修改，比如我们可以先加载配置文件<code>arch/arm/configs/s3c2410_defconfig</code>，再增加、去除某些配置选项。</p>
<h3 id="配置界面主菜单的类别"><a href="#配置界面主菜单的类别" class="headerlink" title="配置界面主菜单的类别"></a>配置界面主菜单的类别</h3><p>下表讲解了主菜单的类别，以后读者配置内核时，可以根据自己所要设置的功能进入某个菜单，然后根据其中的各个配置选项的帮助信息进行配置。</p>
<table>
<thead>
<tr>
<th>配置界面主菜单</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Code maturity level options</td>
<td>代码成熟度选项：用于包含一些正在开发的或者不成熟的代码、驱动程序。一般不设置</td>
</tr>
<tr>
<td>Genaral setup</td>
<td>常规设置：比如增加附加的内核版本号、支持	内存交换功能、System V进程间通信等。除非很熟悉其中的内容，否则一般使用默认配置</td>
</tr>
<tr>
<td>Loadable module support</td>
<td>可加载模块支持：一般都会打开可加载模块支持（Enable loadable module support）、允许卸载已经加载到模块（Module unloading）、让内核通过运行modprobe来自动加载所需要的模块（Automatic kernel module loading）</td>
</tr>
<tr>
<td>Block layer</td>
<td>块设备层：用于设置块设备的一些总体参数，比如是否支持大于2TB的块设备、是否支持大于2TB的文件、设置I&#x2F;O调度器等。一般使用默认值即可</td>
</tr>
<tr>
<td>System Type</td>
<td>系统类型：选择CPU的架构、开发板类型等与开发板相关的配置选项</td>
</tr>
<tr>
<td>Bus support</td>
<td>PCMCIA&#x2F;CardBus总线的支持</td>
</tr>
<tr>
<td>Kernel Features</td>
<td>用于设置内核的一些参数，比如是否支持内核抢占、是否支持动态修改系统时钟等</td>
</tr>
<tr>
<td>Boot options</td>
<td>启动参数：比如设置默认的命令行参数等</td>
</tr>
<tr>
<td>Floating point emulation</td>
<td>浮点运算仿真功能：目前Linux 还不支持硬件浮点运算，所以要选择一个浮点仿真器，一般选择“NWFPE math emulation”</td>
</tr>
<tr>
<td>Userspace binary formats</td>
<td>可执行文件格式：一般都支持ELF、a.out格式</td>
</tr>
<tr>
<td>Power management options</td>
<td>电源管理选项</td>
</tr>
<tr>
<td>Networking</td>
<td>网络协议选项：一般选择“Networking support”以支持网络功能，选择“Packet socket”以支持socket接口功能，选择“TCP&#x2F;IP networking”以支持TCP&#x2F;IP网络协议。通常可以在选择“Networking support”后使用默认配置</td>
</tr>
<tr>
<td>Device Drivers</td>
<td>设备驱动程序：几乎包含了Linux的所有驱动程序</td>
</tr>
<tr>
<td>File systems</td>
<td>文件系统：可以在里面选择要支持的文件系统，比如EXT2、JFFS2等</td>
</tr>
<tr>
<td>Profiling support</td>
<td>对系统的活动进行分析，仅供内核开发者使用</td>
</tr>
<tr>
<td>Kernel hacking</td>
<td>调试内核时的各种选项</td>
</tr>
<tr>
<td>Security options</td>
<td>安全选项，一般使用默认配置</td>
</tr>
<tr>
<td>Cryptographic options</td>
<td>加密选项</td>
</tr>
<tr>
<td>Library routines</td>
<td>库子程序：比如CRC32检验函数、zlib压缩函数等。不包含在内核源码中的第三方内核模块可能需要这些库，可以全不选，内核中若有其他部分依赖它，会自动选上</td>
</tr>
</tbody></table>
<h3 id="“System-Type”-菜单：系统类型"><a href="#“System-Type”-菜单：系统类型" class="headerlink" title="“System Type” 菜单：系统类型"></a>“System Type” 菜单：系统类型</h3><p>对于arm平台（在顶层Makefile中修改“ARCH ?&#x3D; arm”）,执行“make menuconfig”后，在配置界面可以看到“System Type”字样，进入它得到另一个界面，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/6.jpeg" alt="img not found"><br>第一行“ARM system type”用来选择体系结构，进入它之后选中“Samsung S3C2410，S3C2412，S3C2413，S3C2440，S3C2442，S3C2443”，查看帮助信息可以知道它对应CONFIG_ARCH_S3C2410配置项。<br>下面几行用来设置S3C2410（包括S3C2412等）系统的特性，比如选中“S3C2410 UART to use for low-level message”后按回车键，可以输入数字，表示使用哪个串口来输入内核打印信息：选中“S3C2410 DMA support”表示支持DMA功能。<br>再往下的“S3C2410 Machine —&gt;”、“S3C2440 Machine —&gt;”表示这又是一个菜单，它们用来选择开发板类型。比如进入“S3C2410 Machine”菜单后，可以看到如下内容：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/7.jpeg" alt="img not found"><br>它们表示目前内核中支持S3C2410的8种开发板。选中某个开发板之后，它相应的文件就会被编译进内核中。比如对于开发板<code>SMDK2410/A9M2410</code>，它的配置项为CONFIG_ARCH_SMDK2410，在<code>arch/arm/mach-s3c2410/Makefile</code>中可以看到如下一行，表示如果选择支持该开发板，则<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code>文件被编进内核中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_ARCH_SMDK2410) 	+= mach-smdk2410.o</span><br></pre></td></tr></table></figure>
<p>在移植内核时，可以选中某个配置相似的开发板，然后在上面进行修改。</p>
<h3 id="“Device-Drivers”-菜单：设备驱动程序"><a href="#“Device-Drivers”-菜单：设备驱动程序" class="headerlink" title="“Device Drivers” 菜单：设备驱动程序"></a>“Device Drivers” 菜单：设备驱动程序</h3><p>执行“make menuconfig”后，在配置界面可以看到“Device Drivers”字样，进入它得到另一个界面，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/8.jpeg" alt="img not found"><br>图中的各个子菜单与内核源码<code>drivres/</code>目录下各个子目录一一对应，如下表所示，在配置过程中可以参考这个表格找到对应的配置选项，在添加新驱动时，也可以参考它来决定代码放在哪个目录下。</p>
<table>
<thead>
<tr>
<th>Device Drivers 子菜单</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Generic Driver Options</td>
<td>对应<code>divers/base</code>目录，这是设备驱动程序中一些基本和通用的配置选项</td>
</tr>
<tr>
<td>Connector - undefined userspace &lt;-&gt; kernelspace linker</td>
<td>对应<code>divers/connector</code>目录</td>
</tr>
<tr>
<td>Memory Technology Device （MTD）support</td>
<td>对应<code>divers/mtd</code>目录，用于支持各种新型的存储设备，比如NOR Flash、NAND Flash等</td>
</tr>
<tr>
<td>Parallel port support</td>
<td>对应<code>divers/parport</code>目录，用于支持各种并口设备</td>
</tr>
<tr>
<td>Plug and Play support</td>
<td>对应<code>divers/pnp</code>目录，支持各种“即插即用”设备</td>
</tr>
<tr>
<td>Block devices</td>
<td>对应<code>divers/block</code>目录，包括回环设备、RAMDISK等的驱动</td>
</tr>
<tr>
<td>ATA&#x2F;ATAPI&#x2F;MFM&#x2F;RLL support</td>
<td>对应<code>divers/ide</code>目录，它用来支持ATA&#x2F;ATAPI&#x2F;MFM&#x2F;RLL 接口的硬盘、软盘、光盘等</td>
</tr>
<tr>
<td>SCSI device support</td>
<td>对应<code>divers/scsi</code>目录，支持各种scsi接口的设备</td>
</tr>
<tr>
<td>Serial ATA（prod）and parallel ATA （experiment）drivers</td>
<td>对应<code>divers/ata</code>目录，支持SATA与PATA设备</td>
</tr>
<tr>
<td>Multi-device support （RAID and LVM）</td>
<td>对应<code>divers/md</code>目录，表示多设备支持（RAID和LVM），RAID和LVM的作用是使多个物理设备组建成一个单独的逻辑磁盘</td>
</tr>
<tr>
<td>Network device support</td>
<td>对应<code>divers/net</code>目录，用来支持各种网络设备，比如CS8900、DM9000等</td>
</tr>
<tr>
<td>ISDN subsystem</td>
<td>对应<code>divers/isdn</code>目录，用来提供综合业务数字网（Integrate Service Digital Network）的驱动程序</td>
</tr>
<tr>
<td>Input device support</td>
<td>对应<code>divers/input</code>目录，支持各类输入设备，比如键盘、鼠标等</td>
</tr>
<tr>
<td>Character devices</td>
<td>对应<code>divers/char</code>目录，它包含各种字符设备驱动程序。串口的配置也是从这个菜单调用的，但是串口的代码在<code>drivers/serial</code>下</td>
</tr>
<tr>
<td>I2C support</td>
<td>对应<code>divers/i2c</code>目录，支持各类I2C设备</td>
</tr>
<tr>
<td>SPI support</td>
<td>对应<code>divers/spi</code>目录，支持各类SPI设备</td>
</tr>
<tr>
<td>Dallas’s 1-wire bus</td>
<td>对应<code>divers/w1</code>目录，支持一线总线</td>
</tr>
<tr>
<td>Hardware Monitoring support</td>
<td>对应<code>divers/hwmon</code>目录</td>
</tr>
<tr>
<td>Misc devices</td>
<td>对应<code>divers/misc</code>目录，用来支持一些不好分类的设备，称为杂项设备</td>
</tr>
<tr>
<td>Multifuction device drivers</td>
<td>对应<code>divers/mfd</code>目录，用来支持多功能的设备，比如SM501，它既可以用于显示图像，也可以用作串口</td>
</tr>
<tr>
<td>LED devices</td>
<td>对应<code>divers/leds</code>目录，包含各种LED驱动程序</td>
</tr>
<tr>
<td>Multimedia devices</td>
<td>对应<code>divers/media</code>目录，包含多媒体驱动，比如V4L（Video for Linux），它用于向上提供统一的图像、声音接口</td>
</tr>
<tr>
<td>Graphics support</td>
<td>对应<code>divers/video</code>目录，提供图形设备&#x2F;显卡的支持</td>
</tr>
<tr>
<td>Sound</td>
<td>对应<code>sound/</code>目录（它不在drivers下），用来支持各种声卡</td>
</tr>
<tr>
<td>HID Devices</td>
<td>对应<code>divers/hid</code>目录，用来支持各种USB-HID设备，或者符合USB-HID规范的设备（蓝牙）。HID（Human Interface Device），比如各种USB接口的鼠标&#x2F;键盘&#x2F;游戏杆&#x2F;手写板等输入设备</td>
</tr>
<tr>
<td>USB support</td>
<td>对应<code>divers/usb</code>目录，包括各种USB Host和USB Device 设备</td>
</tr>
<tr>
<td>MMC&#x2F;SD card support</td>
<td>对应<code>divers/mmc</code>目录，用来支持各种MMC&#x2F;SD卡</td>
</tr>
<tr>
<td>Real Time Clock</td>
<td>对应<code>divers/rtc</code>目录，用来支持各种实时时钟设备。比如S3C24x0上就集成了RTC芯片</td>
</tr>
</tbody></table>
<h1 id="Linux-内核移植"><a href="#Linux-内核移植" class="headerlink" title="Linux 内核移植"></a>Linux 内核移植</h1><p>本节将修改Linux-2.6.22.6内核，使得它可以同时在本书使用的S3C2410、S3C2440开发板上运行，并修改相关驱动使它支持网络功能、支持JFFS2、YAFFS文件系统，同时修改MTD设备分区，使得内核可以挂接NAND Flash上的文件系统。</p>
<h2 id="Linux-内核启动过程概述"><a href="#Linux-内核启动过程概述" class="headerlink" title="Linux 内核启动过程概述"></a>Linux 内核启动过程概述</h2><p>与移植U-Boot的过程相似，在移植Linux之前，先了解它的启动过程。Linux的启动过程可以分为两部分：架构&#x2F;开发板相关的引导过程、后续的通用启动过程。下图所示是ARM架构处理器上Linux内核vmlinux的启动过程。之所以强调是vmlinux，是因为其他格式的内核在进行与vmlinux相同的流程之前会有一些独特的操作。比如对于压缩格式的内核zImage，它首先进行自解压得到vmlinux，然后执行vmlinux开始正常的启动流程。<br>引导阶段通常使用汇编语言编写，它首先检查内核是否支持当前架构的处理器，然后检查是否支持当前开发板。通过检查后，就为调用下一阶段的<code>start_kernel</code>函数准备了。主要分为如下两个步骤。</p>
<ol>
<li>连接内核时使用的虚拟地址，所以要设置页表、使能MMU。</li>
<li>调用C函数<code>start_kernel</code>之前的常规工作，包括复制数据段、清除BSS段、调用<code>start_kernel</code>函数。</li>
</ol>
<p>第二阶段的关键代码主要使用C语言编写。它进行内核初始化的全部工作，最后调用<code>rest_init</code>函数启动init过程，创建系统第一个进程：init进程。在第二阶段，仍有部分架构&#x2F;开发板相关的代码，比如下图中的<code>setup_arch</code>函数用于进行架构&#x2F;开发板相关的设置（重新设置页表、设置系统时钟、初始化串口等）。<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/9.jpeg" alt="img not found"></p>
<h2 id="修改Linux内核以支持S3C2410-x2F-S3C2440开发板"><a href="#修改Linux内核以支持S3C2410-x2F-S3C2440开发板" class="headerlink" title="修改Linux内核以支持S3C2410&#x2F;S3C2440开发板"></a>修改Linux内核以支持S3C2410&#x2F;S3C2440开发板</h2><p>首先配置、编译内核，确保内核可以正确编译。得到内核源码后，先修改顶层Makefile，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARCH 	?= $(SUBARCH)</span><br><span class="line">CROSS_COMPILR	?= </span><br><span class="line">改为</span><br><span class="line">ARCH 	?= arm</span><br><span class="line">CROSS_COMPILR	?= arm-linux- </span><br></pre></td></tr></table></figure>
<p>然后执行如下命令，使用<code>arch/arm/configs/smdk2410_defconfig</code>文件来配置内核，它生成.config配置文件，后面就可以直接使用“make menuconfig”修改配置了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make smdk2410_defconfig</span><br></pre></td></tr></table></figure>
<p>最后是编译生成内核，执行“make”命令将在顶层目录下生成内核映像文件vmlinux；执行“make uImage”除生成vmlinux外，还在<code>arch/arm/boot</code>目录下生成U-Boot格式的内核映像文件uImage。<br>对于S3C2410开发板，上面生成的uImage是可以使用的。在U-Boot控制界面中使用如下命令下载uImage并启动它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x32000000</span> uImage 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/uImage/</span><br><span class="line">bootm <span class="number">0x32000000</span></span><br></pre></td></tr></table></figure>
<p>在串口可以看到内核的启动信息，只是在最后看到如下的panic信息，这是因为没有修改MTD分区，没有增加对yaffs文件系统的支持。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VFS: Uable to mount root fs via NFS, trying flopping</span><br><span class="line">VFS: Cannot open root device <span class="string">&quot;mtdblock/2&quot;</span> or unknown-block(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">Please append a correct <span class="string">&quot;root=&quot;</span> boot option;here are the availaable partitions:</span><br><span class="line"><span class="number">1f</span>00			<span class="number">16</span> 		mtdblock0	(driver?)</span><br><span class="line"><span class="number">1f</span>01			<span class="number">2048</span> 	mtdblock1	(driver?)</span><br><span class="line"><span class="number">1f</span>02			<span class="number">4096</span> 	mtdblock2	(driver?)</span><br><span class="line"><span class="number">1f</span>03			<span class="number">2048</span> 	mtdblock3	(driver?)</span><br><span class="line"><span class="number">1f</span>04			<span class="number">4096</span> 	mtdblock4	(driver?)</span><br><span class="line"><span class="number">1f</span>05			<span class="number">10240</span> 	mtdblock5	(driver?)</span><br><span class="line"><span class="number">1f</span>06			<span class="number">24576</span> 	mtdblock6	(driver?)</span><br><span class="line"><span class="number">1f</span>07			<span class="number">16384</span> 	mtdblock7	(driver?)</span><br><span class="line">Kernel panic - not syncing: VFS: Uable to mount root fs on unkown-block(<span class="number">2</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>对于S3C2440开发板，使用同样的命令启动uImage，在打印如下信息之后（U-Boot打印），就会出现一大堆乱码：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/10.jpeg" alt="img not found"><br>所以，Linux 2.6.22.6还不支持本书所用的S3C2440开发板，这个开发板的配置与内核所支持的开发板不一致。<br>要让内核支持当前的S3C2410开发板，需要进行一些修改。</p>
<h3 id="引导阶段代码分析"><a href="#引导阶段代码分析" class="headerlink" title="引导阶段代码分析"></a>引导阶段代码分析</h3><p>由前面对内核Makefile的分析，可知<code>arch/arm/kernel/head.S</code>是内核执行的第一个文件。另外。U-Boot调用内核时，r1寄存器中存储“机器类型ID”，内核会用到它。<br>移植Linux内核时，对于<code>arch/arm/kernel/head.S</code>，只需要关注开头几条命令，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">msr cpsr_c, PSR_F_BIT | PSR_I_BIT | SVC_MODE	@确保进入管理（SVC）模式，并禁止中断</span><br><span class="line">mrc p15, 0, r9, c0, c0							@读取CPU ID，存入r9寄存器</span><br><span class="line">bl __lookup_processor_type						@调用函数，输入参数r9=cpuid，返回值r5=procinfo</span><br><span class="line">movs r10,r5										@如果不支持当前CPU，则返回值r5=0</span><br><span class="line">beq __error_p									@如果r5=0，则打印错误</span><br><span class="line">bl __lookup_machine_type						@调用函数，返回值r5=machinfo</span><br><span class="line">movs r8, r5										@如果不支持当前机器，则返回值r5=0</span><br><span class="line">beq __error_a									@如果r5=0，则打印错误</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>第2行通过设置CPSR寄存器来确保处理器进入管理（SVC）模式，并且禁止中断。<br>第3行读取协处理器CP15的寄存器C0获得CPU ID，CPU ID格式如下所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/11.jpeg" alt="img not found"></p>
<table>
<thead>
<tr>
<th>位</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[31:24]</td>
<td>厂商编号有如下值。<br>0x41 &#x3D; A，表示ARM公司 <br>0x44 &#x3D; D，表示Digital Equipment公司 <br> 0x69 &#x3D; 1，表示Intel公司</td>
</tr>
<tr>
<td>[23:20]</td>
<td>由厂商定义，当产品编号相同时，使用子编号来区分不同的产品子类，如产品中不同的高速缓存大小等</td>
</tr>
<tr>
<td>[19:16]</td>
<td>ARM体系版本号，目前取值如下。<br>0x01，表示ARM体系版本4 <br>0x02，表示ARM体系版本4T <br>0x03，表示ARM体系版本5 <br>0x04，表示ARM体系版本5 <br>0x05，表示ARM体系版本5T <br>0x06，表示ARM体系版本5TE</td>
</tr>
<tr>
<td>[15:4]</td>
<td>产品主编号</td>
</tr>
<tr>
<td>[3:0]</td>
<td>处理器版本号</td>
</tr>
</tbody></table>
<p>比如S3C2410的CPU ID为0x41129200，S3C2440的CPU ID也是0x41129200。注意，S3C2410和S3C2440称为片山系统（SOC），除CPU外，还集成了UART、USB控制器、NAND Flash控制器等设备。从它们的CPU ID可知，它们的CPU是相同的，只是片上外设不一样。<br>第4行调用<code>__lookup_processor_type</code>函数，确定内核是否支持当前CPU。如果支持，r5寄存器将会返回一个用来描述处理器的结构体的地址，否则r5的值为0。<br>第7行调用<code>__lookup_machine_type</code>函数，确定内核是否支持当前开发板。如果支持，r5寄存器将会返回一个用来描述这个开发板的结构体的地址，否则r5的值为0。<br>如果<code>__lookup_processor_type</code>、<code>__lookup_machine_type</code>这两个函数中有一个返回值为0，则内核不能启动，如果配置内核时选择了CONFIG_DEBUG_ALL，还会打印一些提示信息。<br><code>__lookup_processor_type</code>、<code>__lookup_machine_type</code>函数都是在<code>arch/arm/kernel/head-common.S</code>中定义的。<br>内核映像中，定义了若干个<code>proc_info_list</code>结构（结构体原型在include&#x2F;asm-arm&#x2F;procinfo.h中定义），表示它支持的CPU。对于ARM架构的CPU，这些结构体的源码在<code>arch/arm/mm/</code>目录下，比如<code>proc-arm920.S</code>中的如下代码，它表示arm920 CPU的proc_info_list结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section &quot;.proc.info.init&quot;, #alloc, #execinstr</span><br><span class="line"></span><br><span class="line">.type __arm920_proc_info, #object</span><br><span class="line">__arm920_proc_info:</span><br><span class="line">.long 0x41009200</span><br><span class="line">.long 0xff00fff0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>不同的<code>proc_info_list</code>结构被用来支持不同的CPU，它们都是定义在“.proc.info.init”段中。在连接内核时，这些结构体被组织在一起，开始地址为<code>__proc_info_begin</code>，结束地址为<code>__proc_info_end</code>。这可以从连接脚本<code>arch/arm/kernel/vmlinux.lds</code>中看出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__proc_info_begin = .;		//proc_info_init结构的开始地址</span><br><span class="line">*(.proc.info.init)</span><br><span class="line">__proc_info_end = .;		//proc_info_init结构的结束地址</span><br></pre></td></tr></table></figure>
<p><code>__lookup_processor_type</code>函数就是根据前面读出的CPU ID （存在r9 寄存器中），从这些<code>proc_info_init</code>结构中找出匹配的，它的代码如下（<code>arch/arm/kernel/head-common.S</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.type	__lookup_processor_type, %function</span><br><span class="line">__lookup_processor_type:</span><br><span class="line">	adr	r3, 3f							@ r3 = 最后一行代码的物理地址（3）</span><br><span class="line">	ldmda	r3, &#123;r5 - r7&#125;				@ r5 = __proc_info_begin,r6 = __proc_info_end,它们是虚拟地址。r7 = 最后一行代码的虚拟地址</span><br><span class="line">	sub	r3, r3, r7						@ r3 = r3 - r7，即物理地址和虚拟地址的差值</span><br><span class="line">	add	r5, r5, r3						@ r5 = __proc_info_begin 对应的物理地址</span><br><span class="line">	add	r6, r6, r3						@ r6 = __proc_info_end 对应的物理地址</span><br><span class="line">1:	ldmia	r5, &#123;r3, r4&#125;				@ r3、r4 = proc_info_list结构中的cpu_val、cpu_mask</span><br><span class="line">	and	r4, r4, r9						@ r4 = (r4 &amp; r9) = (cpu_mask &amp; 传入的CPU ID)</span><br><span class="line">	teq	r3, r4							@ 比较</span><br><span class="line">	beq	2f								@ 如果相等，表示找到匹配的proc_info_list结构，跳到（2）</span><br><span class="line">	add	r5, r5, #PROC_INFO_SZ			@ r5指向下一个proc_info_list结构 PROC_INFO_SZ = sizeof（proc_info_list）</span><br><span class="line">	cmp	r5, r6							@ 是否已经比较完所有的proc_info_list结构</span><br><span class="line">	blo	1b								@ 没有则继续比较</span><br><span class="line">	mov	r5, #0							@ 比较完毕，但是没有匹配的proc_info_list结构，r5 = 0</span><br><span class="line">2:	mov	pc, lr							@ 返回</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Look in include/asm-arm/procinfo.h and arch/arm/kernel/arch.[ch] for</span><br><span class="line"> * more information about the __proc_info and __arch_info structures.</span><br><span class="line"> */</span><br><span class="line">	.long	__proc_info_begin			@ proc_info_list结构的开始地址，这是连接地址，也是虚拟地址</span><br><span class="line">	.long	__proc_info_end				@ proc_info_list结构的结束地址，这是链接地址，也是虚拟地址</span><br><span class="line">3:	.long	.							@ “.”表示当前这行代码编译连接后的虚拟地址</span><br></pre></td></tr></table></figure>
<p>在调用<code>__enable_mmu</code>函数之前使用的都是物理地址，而内核却是以虚拟地址连接的。所以在访问<code>proc_info_list</code>结构前，先将它的虚拟地址转换为物理地址，第3-7行就是用来转换地址的。<br>第3行用来获得第26行代码的物理地址。adr指令基于pc寄存器计算地址值，由于这时候还没使能MMU，pc寄存器中使用的还是物理地址，所以执行“adr,r3,3f”后，r3寄存器中存放的就是第26行代码的物理地址。<br>第4行用来获得第24-26行定义的数据：__proc_info_begin、__proc_info_end和“.”。这3个数据都是在连接内核时确定，它们是虚拟地址，前两个表示<code>proc_info_list</code>结构的开始地址和结束地址，“.”表示当前行的代码在编译连接后的虚拟地址。<br>第5行计算物理地址和虚拟地址的差值，第6-7行根据这个差值计算<code>__proc_info_begin</code>、<code>__proc_info_end</code>的物理地址。<br>下面的代码依次读取每个<code>proc_info_list</code>结构前面的两个成员（cpu_val和cpu_mask），判断cpu_val是否等于(r9 &amp; cpu_mask)，r9是<code>arch/arm/kernel/head.S</code>中调用<code>__lookup_processor_type</code>时传入的CPU ID。如果比较相等，则表示当前<code>proc_info_list</code>结构适用于这个CPU，直接返回这个结构的地址（存在r5中）。如果<code>__proc_info_begin</code>、<code>__proc_info_end</code>之间的所有<code>proc_info_list</code>结构都不支持这个CPU，则返回0(r5)。<br>对于S3C2410、S3C2440开发板，它们的CPU ID都是0x41129200，而在<code>arch/arm/mm/proc-arm920.S</code>中定义的<code>__arm920_proc_info</code>结构中，cpu_val、cpu_mask等于0x41009200、0xff00fff0，刚好匹配。内核中要包含这个文件，在<code>arch/arm/mm/Makefile</code>中可以看到下面这行，它表示需要配置CONFIG_CPU_ARM920T（配置菜单中System Type-&gt;Support ARM920T procrssor）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_CPU_ARM920T)      += proc_arm920.o</span><br></pre></td></tr></table></figure>
<p>下面讲解<code>__	lookup_machine_type</code>,它和<code>__lookup_processor_type</code>函数代码相似。<br>内核中对于每种支持的开发板都会使用宏MACHINE_START、MACHINE_END来定义一个<code>machine_desc</code>结构，它定义了开发板相关的一些属性和函数。比如机器类型ID、起始I&#x2F;O物理地址，Bootloader传入的参数的地址、中断初始化函数、I&#x2F;O映射函数等。比如对于SDMK2440开发板，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MACHINE_START(S3C2440, &quot;SMDK2440&quot;)</span><br><span class="line">	/* Maintainer: Ben Dooks &lt;ben@fluff.org&gt; */</span><br><span class="line">	.phys_io	= S3C2410_PA_UART,</span><br><span class="line">	.io_pg_offst	= (((u32)S3C24XX_VA_UART) &gt;&gt; 18) &amp; 0xfffc,</span><br><span class="line">	.boot_params	= S3C2410_SDRAM_PA + 0x100,</span><br><span class="line"></span><br><span class="line">	.init_irq	= s3c24xx_init_irq,</span><br><span class="line">	.map_io		= smdk2440_map_io,</span><br><span class="line">	.init_machine	= smdk2440_machine_init,</span><br><span class="line">	.timer		= &amp;s3c24xx_timer,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure>
<p>宏<code>MACHINE_START</code>、<code>MACHINE_END</code>在<code>include/asm-arm/mach/arch.h</code>文件中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set of macros to define architecture features.  This is built into</span></span><br><span class="line"><span class="comment"> * a table by the linker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACHINE_START(_type,_name)			\</span></span><br><span class="line"><span class="meta">static const struct machine_desc __mach_desc_##_type	\</span></span><br><span class="line"><span class="meta"> __used							\</span></span><br><span class="line"><span class="meta"> __attribute__((__section__(<span class="string">&quot;.arch.info.init&quot;</span>))) = &#123;	\</span></span><br><span class="line"><span class="meta">	.nr		= MACH_TYPE_##_type,		\</span></span><br><span class="line"><span class="meta">	.name		= _name,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACHINE_END				\</span></span><br><span class="line"><span class="meta">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>所以上一段代码扩展开来就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> __<span class="title">mach_desc_S3C2440</span>	\</span></span><br><span class="line"><span class="class"> __<span class="title">used</span>							\</span></span><br><span class="line"><span class="class"> __<span class="title">attribute__</span>((__<span class="title">section__</span>(&quot;.<span class="title">arch</span>.<span class="title">info</span>.<span class="title">init</span>&quot;))) =</span> &#123;	\</span><br><span class="line">	.nr		= MACH_TYPE_S3C2440,		\</span><br><span class="line">	.name		= _name,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的MACH_TYPE_S3C2440在<code>arch/arm/tools/mach-types</code>中定义，它最后会被换成一个头文件<code>include/asm-arm/mach-types.h</code>供其他文件包含。machine_desc在<code>include/asm-arm/mach/arch.h</code>文件中定义。所有的machine_desc结构都处于“.arch.info.init”段中，在连接内核时，它们被组织在一起，开始地址为<code>__arch_info_begin</code>，结束地址为<code>__arch_info_end</code>。这可以从连接脚本文件<code>arch/arm/kernel/vmlinux.lds</code>中看出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__arch_info_begin = .;				<span class="comment">//machine_desc结构的开始地址</span></span><br><span class="line">	*(.arch.info.init)</span><br><span class="line">__arch_info_end = .;				<span class="comment">//machine_desc结构的结束地址</span></span><br></pre></td></tr></table></figure>
<p>不同的machine_desc结构用于不同的开发板，U-Boot调用内核时，会在r1寄存器中给出开发板的标记（机器类型ID）。<code>__loockup_machine_type</code>函数将这个值与machine_desc中的nr成员比较，如果两者相等则表示找到匹配的machine_desc结构，于是返回它的地址（存在r5中）。如果<code>__arch_info_begin</code>和<code>__arch_info_end</code>之间所有的machine_desc结构的nr成员都不等于r1寄存器的值，则返回0（r5）。<br>对于本书所用的S3C2410、S3C2440开发板，U-Boot传入的机器类型ID为MACH_TYPE_SMDK2410、MACH_TYPE_SMDK2440。它们对应的machine_desc结构分别在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>和<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code>中定义，所以两个文件要编进内核。在配置菜单中，选中下面两个开发板即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System Type --&gt; S3C2410 Machines --&gt; SMDK2410/A9M2410</span><br><span class="line">System Type --&gt; S3C2440 Machines --&gt; SMDK2440</span><br></pre></td></tr></table></figure>
<p><code>__lookup_machine_type</code>函数的代码如下（<code>/arch/arm/kernel/head-common.S</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3:	.long	.</span><br><span class="line">	.long	__arch_info_begin</span><br><span class="line">	.long	__arch_info_end</span><br><span class="line">...</span><br><span class="line">	.type	__lookup_machine_type, %function</span><br><span class="line">__lookup_machine_type:</span><br><span class="line">	adr	r3, 3b								@ r3 = 第1行的物理地址</span><br><span class="line">	ldmia	r3, &#123;r4, r5, r6&#125;				@ r4 = 第1行的虚拟地址	r5 = __arch_info_begin r6 = __arch_info_end 它们是虚拟地址</span><br><span class="line">	sub	r3, r3, r4							@ r3 = r3 - r4 即物理地址和虚拟地址的差值</span><br><span class="line">	add	r5, r5, r3							@ r5 = __arch_info_begin 对应的物理地址</span><br><span class="line">	add	r6, r6, r3							@ r6 = __arch_info_end 对应的物理地址</span><br><span class="line">1:	ldr	r3, [r5, #MACHINFO_TYPE]			@ r5是machine_desc 结构的地址 r3 = machine_desc 结构中定义的nr成员，即机器类型ID</span><br><span class="line">	teq	r3, r1								@ r1是Bootloader调用内核时传入的机器类型ID，测试是否相等</span><br><span class="line">	beq	2f									@ 若相等，跳到（2）</span><br><span class="line">	add	r5, r5, #SIZEOF_MACHINE_DESC		@ 否则，r5指向下一个machine_desc结构，SIZEOF_MACHINE_DESC = sizeof(machine_desc)</span><br><span class="line">	cmp	r5, r6								@ 是否比较完所有的machine_desc结构</span><br><span class="line">	blo	1b									@ 没有则继续比较</span><br><span class="line">	mov	r5, #0								@ 比较完毕，但是没有匹配的machine_desc结构，r5 = 0</span><br><span class="line">2:	mov	pc, lr								@ 返回</span><br></pre></td></tr></table></figure>
<p>如果<code>__lookup_processor_tyep</code>、<code>__lookup_machine_type</code>函数都返回成功，则后续引导程序将继续执行下去。其中的<code>__create_page_tables</code>函数用来创建一级页表以建立虚拟地址到物理地址的映射关系，它用到<code>__lookup_processor_type</code>函数返回的proc_info_list结构。在引导的最后，调用<code>start_kernel</code>函数进入内核启动的第二阶段。<code>__lookup_machine_type</code>函数确定的machine_desc结构将在第二阶段多次使用。</p>
<h3 id="start-kernel-函数部分代码分析"><a href="#start-kernel-函数部分代码分析" class="headerlink" title="start_kernel 函数部分代码分析"></a>start_kernel 函数部分代码分析</h3><p>进入<code>start_kernel</code>函数（<code>init/main.c</code>）之后，如果串口上没有看到内核的启动信息，一般而言有两个原因：Bootloader传入的命令行参数不对，或者<code>setup_arch</code>函数（<code>arch/arm/kernel/setup.c</code>）针对开发板的设置不正确。<br>在调用<code>setup_arch</code>函数之前就已经调用<code>“printk(linux_banner)”</code>了，但是这个时候printk函数只是将打印信息放在缓存区中，并没有打印到控制台上（串口、LCD屏等），因为这个时候控制台还未初始化。printk打印的内容在<code>console_init</code>函数注册、初始化控制台之后才真正输出。<br>移植U-Boot时，U-Boot传给内核的参数有两类：预先存在某个地址的tag列表和调用内核时在r1寄存器中指定的机器类型ID。后者在引导阶段的<code>__lookup_machine_type</code>函数已经用到。而tag列表将在<code>setup_arch</code>函数中进行初步处理。本节将重点介绍<code>setup_arch</code>函数、<code>console_init</code>函数、以tag列表的处理（内存tag、命令行tag）、串口控制台的初始化为主线。</p>
<h4 id="setup-arch-函数分析"><a href="#setup-arch-函数分析" class="headerlink" title="setup_arch 函数分析"></a>setup_arch 函数分析</h4><p><code>setup_arch</code>函数在<code>arch/arm/kernel/setup.c</code>中定义，其部分代码及流程图如下：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/12.jpeg" alt="img not found"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	setup_processor();											<span class="comment">//进行处理器相关的一些设置</span></span><br><span class="line">	mdesc = setup_machine(machine_arch_type);					<span class="comment">//获得开发板的machine_desc结构</span></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;boot_params)										<span class="comment">//定义了Bootloader传入参数的地址</span></span><br><span class="line">		tags = phys_to_virt(mdesc-&gt;boot_params);				<span class="comment">//这个地址就是tag列表的首地址</span></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (tags-&gt;hdr.tag == ATAG_CORE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (meminfo.nr_banks != <span class="number">0</span>)								<span class="comment">//如果已经在内核中定义了meminfo结构</span></span><br><span class="line">			squash_mem_tags(tags);								<span class="comment">//则忽略内存tag</span></span><br><span class="line">		parse_tags(tags);										<span class="comment">//解释每一个tag</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="built_in">memcpy</span>(boot_command_line, from, COMMAND_LINE_SIZE);</span><br><span class="line">	boot_command_line[COMMAND_LINE_SIZE<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	parse_cmdline(cmdline_p, from);								<span class="comment">//对命令行进行一些先期的处理</span></span><br><span class="line">	paging_init(&amp;meminfo, mdesc);								<span class="comment">//重新初始化页表</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，第[4]行的<code>setup_processor</code>函数被用来进行处理器相关的一些设置，它会调用引导阶段的<code>lookup_processor_type</code>函数以获得该处理器的proc_info_list结构。<br>接下来，第[5]行的<code>setup_machine</code>函数被用来获得开发板的machine_desc结构，这通过调用引导阶段<code>lookup_machine_type</code>函数来实现。以后就会根据开发板的machine_desc结构来进行一些开发板的相关操作，<br>第[7]-[8]行用来确定Bootloader传入的启动参数的地址，它在开发板的machine_desc结构中指定，第[8]行将它转换为虚拟地址。比如对于S3C2440开发板，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中有如下定义。启动参数的地址就是（S3C2410_SDRAM_PA + 0x100），即0x30000100。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MACHINE_START(S3C2440,<span class="string">&quot;SMDK2440&quot;</span>)</span><br><span class="line">...</span><br><span class="line">	.bootm_params = S3C2440_SDRAM_PA + <span class="number">0x100</span>,</span><br></pre></td></tr></table></figure>
<p>第[13]行处理每个tag。文件<code>arch/arm/kernel/setup.c</code>对每种tag都定义了相应的处理函数，比如对于内存tag、命令行tag，使用如下两行代码指定了它们的处理函数为<code>parse_tag_mem32、parse_tag_cmdline</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__tagtable(ATAG_MEM,parse_tag_mem32);</span><br><span class="line">__tagtable(ATAG_CMDLINE,parse_tag_cmdline);</span><br></pre></td></tr></table></figure>
<p><code>parse_tag_mem32</code>函数根据内存tag定义的内存起始地址、长度，在全局结构变量meminfo中增加内存的描述信息。以后内核就可以通过meminfo结构了解开发板的的内存信息。<br><code>parse_tag_cmdline</code>只是简单的将命令行tag的内容复制到字符串default_command_line中保存下来，后面才进一步处理。<br>第[18]行扫描命令行参数，对其中的一些参数进行先期的处理。这些参数使用“__early_param”来定义，比如<code>arch/arm/kernel/setup.c</code>中下面的一行代码，它表示如果命令行中有“mem&#x3D;…”的字样，就调用<code>early_mem</code>（在<code>include/asm-arm/setup.h</code>中定义）对它进行处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__early_param(<span class="string">&quot;mem=&quot;</span>,early_mem);</span><br></pre></td></tr></table></figure>
<p>“mem&#x3D;…”用来强制限制Linux系统所能使用的内存总量，比如“mem&#x3D;60M”使得系统只能使用60MB的内存，即使内存tag中指明了共有64MB内存。类似的参数还有“initrd&#x3D;”等。<br>此时命令行的处理还没有结束，在setup_arch函数之外还会进行一系列后续处理，比如<code>start_kernel</code>函数中调用如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setup_command_line(command_line);</span><br><span class="line">...</span><br><span class="line">parse_early_param();</span><br><span class="line">parse_args(<span class="string">&quot;Booting kernel&quot;</span>, static_command_line, __start___param,</span><br><span class="line">		   __stop___param - __start___param,</span><br><span class="line">		   &amp;unknown_bootoption);</span><br></pre></td></tr></table></figure>
<p>比如对于命令行中的“console&#x3D;ttySAC0”，它的处理过程就是第[4]行的<code>parse_args</code>函数调用第[6]行传入的<code>unknown_bootoption</code>函数，最后调用下面代码指定的处理函数<code>console_setup</code>（在<code>kernel/printk.c</code>中定义）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__setup(<span class="string">&quot;console=&quot;</span>,console_setup);</span><br></pre></td></tr></table></figure>
<p>命令行参数“console&#x3D;…”用来指定要使用的控制台的名称、序号、参数。比如对于“console&#x3D;ttySAC0,115200”，表示要使用的控制台名称为ttySAC，序号为0（第一个串口），波特率为115200。经过<code>console_setup</code>处理后，会在全局结构变量console_cmdline中保存这些信息，在后面<code>console_init</code>函数初始化控制台时会根据这些信息选择要使用的控制台。<br><code>setup_arch</code>函数后面会调用<code>paging_init</code>函数，这也是一个开发板相关的函数。</p>
<h4 id="paging-init函数分析"><a href="#paging-init函数分析" class="headerlink" title="paging_init函数分析"></a>paging_init函数分析</h4><p>这个函数在<code>setup_arch</code>函数中的调用形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">paging_init(&amp;meminfo,mdesc);</span><br></pre></td></tr></table></figure>
<p>meminfo中存放内存的信息，前面解释内存tag时确定了构建这个全局结构。<br>mdesc就是前面<code>lookup_machine_type</code>函数返回的machine_desc结构。对于S3C2440开发板，这个结构在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中有如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MACHINE_START(S3C2440, <span class="string">&quot;SMDK2440&quot;</span>)</span><br><span class="line">	<span class="comment">/* Maintainer: Ben Dooks &lt;ben@fluff.org&gt; */</span></span><br><span class="line">	.phys_io	= S3C2410_PA_UART,</span><br><span class="line">	.io_pg_offst	= (((u32)S3C24XX_VA_UART) &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0xfffc</span>,</span><br><span class="line">	.boot_params	= S3C2410_SDRAM_PA + <span class="number">0x100</span>,</span><br><span class="line"></span><br><span class="line">	.init_irq	= s3c24xx_init_irq,</span><br><span class="line">	.map_io		= smdk2440_map_io,</span><br><span class="line">	.init_machine	= smdk2440_machine_init,</span><br><span class="line">	.timer		= &amp;s3c24xx_timer,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure>
<p>上面几行代码是移植Linux必须关注的数据结构。对于S3C2410开发板，它在<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code><br><code>paging_init</code>函数在<code>arch/arm/mm/mmu.c</code>中定义，根据我们的移植目的–让内核可以在S3C2440上运行。关注如下流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paging_init -&gt; devicemaps_init -&gt; mdesc -&gt; map_io()</span><br></pre></td></tr></table></figure>
<p>对于S3C2440开发板，就是调用<code>smdk2410_map_io</code>函数，它也是<code>arch/arm/mach-s3c2440/mach-s3c2440.c</code>中定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">smdk2440_map_io</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	s3c24xx_init_io(smdk2440_iodesc, ARRAY_SIZE(smdk2440_iodesc));</span><br><span class="line">	s3c24xx_init_clocks(<span class="number">16934400</span>);</span><br><span class="line">	s3c24xx_init_uarts(smdk2440_uartcfgs, ARRAY_SIZE(smdk2440_uartcfgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述三个函数所实现的功能，从名字就可以看出，第四行中参数值表示开发板晶振的频率。当前开发板所使用的晶振频率是12MHz，不是16934400，这就是S3C2440开发板上启动uImage时串口输出乱码的原因，将它改为12000000即可。</p>
<h4 id="console-init-函数分析"><a href="#console-init-函数分析" class="headerlink" title="console_init 函数分析"></a>console_init 函数分析</h4><p>虽然上面已经找到内核无法正常输出信息的原因，但我们不该止步于此。在2.4的内核中，命令行参数常用“console&#x3D;ttyS0”来指定控制台为串口0，在2.6版本的内核中改为“console&#x3D;ssySAC0”。分析<code>console_init</code>函数的功能就可以了解这点。<br><code>console_init</code>函数被<code>start_kernel</code>函数调用，它在<code>drivers/char/tty_io.c</code>文件中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">initcall_t</span> *call;</span><br><span class="line">...</span><br><span class="line">	call = __con_initcall_start;</span><br><span class="line">	<span class="keyword">while</span> (call &lt; __con_initcall_end) &#123;</span><br><span class="line">		(*call)();</span><br><span class="line">		call++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用地址范围<code>__con_initcall_start</code>至<code>__con_initcall_end</code>之间的定义的每个函数，这些函数使用<code>console_initcall</code>宏来指定。比如<code>drivers/serial/s3c2410.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">console_initcall(s3c24xx_serial_initconsole);</span><br></pre></td></tr></table></figure>
<p><code>s3c24xx_serial_initconsole</code>函数也是在<code>drivers/serial/s3c2410.c</code>中定义，它初始化S3C24xx类SoC的串口控制台，部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_serial_initconsole</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	register_console(&amp;s3c24xx_serial_console);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s3c24xx_serial_console结构在<code>drivers/serial/s3c2410.c</code>中定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console</span> <span class="title">s3c24xx_serial_console</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">	.name		= S3C24XX_SERIAL_NAME,				<span class="comment">//即“ttySAC”</span></span><br><span class="line">	.device		= uart_console_device,				<span class="comment">//以后使用/dev/console时，用来构造设备节点</span></span><br><span class="line">	.flags		= CON_PRINTBUFFER,					<span class="comment">//控制台可用之前，printk已经在缓冲区打印了很多信息，CON_PRINTBUFFER表示注册控制台之后</span></span><br><span class="line">													<span class="comment">//打印这些“过去”的信息</span></span><br><span class="line">	.index		= <span class="number">-1</span>,								<span class="comment">//-1可以匹配任意序号。比如ttySAC0/1/2</span></span><br><span class="line">	.write		= s3c24xx_serial_console_write,		<span class="comment">//打印函数</span></span><br><span class="line">	.setup		= s3c24xx_serial_console_setup		<span class="comment">//设置函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>register_console(&amp;s3c24xx_serial_console);</code>在内核中注册控制台，就是把s3c24xx_serial_console结构链入一个全局链表console_drivers中（它在<code>kernel/printf.c</code>中定义）。并且使用其中的name和index与前面的“console&#x3D;…”指定的控制台相比较，如果相符，则以后的printk信息从这个控制台输出。<br>对于本书的情况，“console&#x3D;ttySAC0”，而s3c24xx_serial_console结构中名字为“ttySAC”，序号为-1（可取任意值），所以两者匹配，printk信息将从串口0输出。<br>现在总结一下上面分析的<code>内核启动第二阶段的函数调用过程</code>，相同的缩进表示它们是在同一个函数中被调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start_kernel -&gt;</span><br><span class="line">	setup_arch -&gt;</span><br><span class="line">		setup_processor</span><br><span class="line">		setup_machine</span><br><span class="line">		...</span><br><span class="line">		parse_tags</span><br><span class="line">		...</span><br><span class="line">		parse_cmdline</span><br><span class="line">		paging_init -&gt;</span><br><span class="line">			devicemaps_init -&gt;</span><br><span class="line">				mdesc_map_io() -&gt;</span><br><span class="line">					s3c24xx_init_io</span><br><span class="line">					s3c24xx_init_clocks</span><br><span class="line">					s3c24xx_init_uarts</span><br><span class="line">		...</span><br><span class="line">		console_init -&gt;</span><br><span class="line">			s3c24xx_serial_initconsole -&gt;</span><br><span class="line">				register_console(&amp;s3c24xx_serial_initconsole)</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<h3 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h3><p>在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中做如下修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3c24xx_init_clocks(<span class="number">16934400</span>);</span><br><span class="line">改为</span><br><span class="line">s3c24xx_init_clocks(<span class="number">12000000</span>);</span><br></pre></td></tr></table></figure>
<p>然后执行“make uImage”生成uImage。<br>对于S3C2410、S3C2440开发板，上面生成的uImage都可以使用了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x32000000</span> uImage 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/uImage</span><br><span class="line">bootm <span class="number">0x32000000</span></span><br></pre></td></tr></table></figure>
<p>可以看到内核的启动信息，最后出现panic信息（这需要修改mtd分区、增加对yaffs文件系统的支持）。</p>
<h2 id="修改-MTD-分区"><a href="#修改-MTD-分区" class="headerlink" title="修改 MTD 分区"></a>修改 MTD 分区</h2><p>MTD（Memory Technology Device），即内存技术设备，是Linux中对ROM、NOR Flash、NAND Flash等存储设备抽象出来的设备层。它向上提供统一的访问接口：读、写、擦除等；屏蔽了底层硬件的操作、各类存储设备的差别。得益于MTD设备的作用，重新划分NAND Flash的分区很简单。</p>
<h3 id="驱动对设备的识别过程"><a href="#驱动对设备的识别过程" class="headerlink" title="驱动对设备的识别过程"></a>驱动对设备的识别过程</h3><p>驱动程序识别设备时，有以下两种方法。</p>
<ol>
<li>驱动程序本身带有设备的信息，比如开始地址、中断号等；加载驱动程序时，就可以根据这些信息来识别设备。</li>
<li>驱动程序本身没有设备的信息，但是内核中已经根据其他方式确定了很多设备的信息；加载驱动程序时，将驱动程序与这些设备逐个比较，确定两者是否匹配，如果成功匹配，那么就可以通过驱动程序操作这个设备了。<br>内核常使用第二种方法来识别设备，这可以将各种设备集中在一个文件中管理，当开发板的配置改变时，便于修改代码。在内核文件<code>include/linux/paltform/device.h</code>中，定义了两个数据结构来表示这些设备和驱动程序：paltform_device结构用来描述设备的名称、ID、所占用的资源（内存地址&#x2F;大小、中断号）等；platform_driver结构用来描述各种操作函数，比如枚举函数、移除设备函数、驱动的名称等。<br>内核启动后，首先构造链表将描述设备的platform_device结构组织起来，得到一个设备的列表；当加载某个驱动程序的platform_driver结构时，使用一些匹配函数来检查驱动程序能否支持这些设备，常用的检察方式很简单：比较驱动程序和设备的名称。<br>以S3C2440开发板为例，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中定义了如下设备：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">smdk2440_devices</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">	&amp;s3c_device_usb,</span><br><span class="line">	&amp;s3c_device_lcd,</span><br><span class="line">	&amp;s3c_device_wdt,</span><br><span class="line">	&amp;s3c_device_i2c,</span><br><span class="line">	&amp;s3c_device_iis,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在<code>arch/arm/plat-s3c24xx/common-smdk.c</code>中定义了如下设备：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> __<span class="title">initdata</span> *<span class="title">smdk_devs</span>[] =</span> &#123;</span><br><span class="line">	&amp;s3c_device_nand,</span><br><span class="line">	&amp;smdk_led4,</span><br><span class="line">	&amp;smdk_led5,</span><br><span class="line">	&amp;smdk_led6,</span><br><span class="line">	&amp;smdk_led7,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这些设备在<code>smdk2410_init</code>函数或<code>smdk2440_init</code>函数中，通过<code>platform_add_devices</code>函数注册进内核中。<br>NAND Flash设备s3c_device_nand在<code>arch/arm/plat-s3c24xx/devs.c</code>中的定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">s3c_device_nand</span> =</span> &#123;</span><br><span class="line">	.name		  = <span class="string">&quot;s3c2410-nand&quot;</span>,</span><br><span class="line">	.id		  = <span class="number">-1</span>,</span><br><span class="line">	.num_resources	  = ARRAY_SIZE(s3c_nand_resource),</span><br><span class="line">	.resource	  = s3c_nand_resource,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
对于S3C2440开发板，s3c_device_nand结构的名字会在s3c24xx_map_io函数中修改为“s3c2440-nand”，这个函数在<code>arch/arm/plat-s3c24xx/s3c244x.c</code>中的定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">s3c244x_map_io</span><span class="params">(<span class="keyword">struct</span> map_desc *mach_desc, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	s3c_device_i2c.name  = <span class="string">&quot;s3c2440-i2c&quot;</span>;</span><br><span class="line">	s3c_device_nand.name = <span class="string">&quot;s3c2440-nand&quot;</span>;</span><br><span class="line">	s3c_device_usbgadget.name = <span class="string">&quot;s3c2440-usbgadget&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有了NAND Flash设备，还要有NAND Flash驱动程序，内核针对S3C2410、S3C2412、S3C2440定义了3个驱动。它们在<code>drivers/mtd/s3c2410.c</code>中的<code>s3c2410_nand_init</code>函数中注册进内核，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3c2410_nand_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;S3C24XX NAND Driver, (c) 2004 Simtec Electronics\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	platform_driver_register(&amp;s3c2412_nand_driver);</span><br><span class="line">	platform_driver_register(&amp;s3c2440_nand_driver);</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;s3c2410_nand_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中的s3c2440_nand_driver结构也是在相同的文件中定义，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">s3c2440_nand_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= s3c2440_nand_probe,</span><br><span class="line">	.remove		= s3c2410_nand_remove,</span><br><span class="line">	.suspend	= s3c24xx_nand_suspend,</span><br><span class="line">	.resume		= s3c24xx_nand_resume,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;s3c2440-nand&quot;</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
可见，s3c_device_nand结构和s3c2440_nand_driver结构中的name成员相同，都是“s3c2440-nand”。<code>platform_driver_register</code>函数就是根据这点确定它们是匹配的，所以调用<code>s3c2440_nand_probe</code>函数来枚举NAND Flash设备s3c_device_nand。<br>从<code>s3c2440_nand_probe</code>函数开始，可以一直找到对NAND Flash分区的识别，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3c2440_nand_probe(&amp;s3c_device_nand) -&gt;								<span class="comment">//这个参数是为了便于理解加上的</span></span><br><span class="line">	s3c24xx_nand_probe(&amp;s3c_device_nand, TYPE_S3C2440) -&gt;			<span class="comment">//</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">s3c2410_platform_nand</span> *<span class="title">plat</span> =</span> to_nand_plat(pdev) -&gt;	<span class="comment">//plat = &amp;smdk_nand_info</span></span><br><span class="line">		s3c2410_nand_add_partition(info, nmtd, sets); -&gt;			<span class="comment">//sets就是smdk_nand_info</span></span><br><span class="line">		add_mtd_partitions											<span class="comment">//实际的参数为smdk_default_nand_part</span></span><br></pre></td></tr></table></figure>
这些函数都在<code>drivers/mtd/nand/s3c2410.c</code>中定义，最后的<code>add_mtd_partitions</code>函数根据smdk_default_nand_part结构来确定分区。这个结构在<code>arch/arm/plat-s3c24xx/common-smdk.c</code>中定义，要改变分区时修改它即可。</li>
</ol>
<h3 id="修改-MTD-分区-1"><a href="#修改-MTD-分区-1" class="headerlink" title="修改 MTD 分区"></a>修改 MTD 分区</h3><p>如上所述，要改变分区时，修改<code>arch/arm/plat-s3c24xx/common-smdk.c</code>文件中的smdk_default_nand_part结构即可。本章节将NAND Flash划分为3个分区，前2MB用于存放内核，接下来的8MB用于存放JFFS2文件系统，剩下的用来存放YAFFS文件系统。<br>smdk_default_nand_part结构修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">smdk_default_nand_part</span>[] =</span> &#123;</span><br><span class="line">	[<span class="number">0</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;Kernel&quot;</span>,</span><br><span class="line">		.size	= SZ_2M,</span><br><span class="line">		.offset	= <span class="number">0</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[<span class="number">1</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;jffs2&quot;</span>,</span><br><span class="line">		.offset = MTDPART_OFS_APPEND,</span><br><span class="line">		.size	= SZ_8M,</span><br><span class="line">	&#125;,</span><br><span class="line">	[<span class="number">2</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;yaffs&quot;</span>,</span><br><span class="line">		.offset = MTDPART_OFS_APPEND,</span><br><span class="line">		.size	= MTDPART_SIZ_FULL,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的MTDPART_OFS_APPEND表示当前分区紧接着上一个分区，MTDPART_SIZ_FULL表示当前分区的大小为剩余的Flash空间。<br>执行“make uImage”重新生成内核映像，重新启动后可以看到内核打印出如下分区信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Creating <span class="number">3</span> MTD partitions on <span class="string">&quot;NAND 64MiB 3,3V 8-bit&quot;</span></span><br><span class="line"><span class="number">0x00000000</span><span class="number">-0x00200000</span>: <span class="string">&quot;kernel&quot;</span></span><br><span class="line"><span class="number">0x00200000</span><span class="number">-0x00a00000</span>: <span class="string">&quot;jffs2&quot;</span></span><br><span class="line"><span class="number">0x00a00000</span><span class="number">-0x04000000</span>: <span class="string">&quot;yaffs&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于目标板没有写入文件系统映像，也没有设置命令行使用网络文件系统（nfs），内核启动后还是会出现panic信息。</p>
<h2 id="移植-YAFFS-文件系统"><a href="#移植-YAFFS-文件系统" class="headerlink" title="移植 YAFFS 文件系统"></a>移植 YAFFS 文件系统</h2><h3 id="YAFFS-文件系统介绍"><a href="#YAFFS-文件系统介绍" class="headerlink" title="YAFFS 文件系统介绍"></a>YAFFS 文件系统介绍</h3><p>YAFFS（yet another flash file system）是一种类似于JFFS&#x2F;JFFS2、专门为NAND Flash 设计的嵌入式文件系统，适用于大容量的存储设备。它是日志结构的文件系统，提供了损耗平衡和掉电保护，可以有效避免意外掉电对文件系统一致性和完整性的影响。与JFFS相比，它减少了一些功能，因此速度更快，占用内存更少。<br>YAFFS充分考虑了NAND Flash的特点，根据NAND Flash以页面为单位存取的特点，将文件组织成固定大小的数据段。利用NAND Flash提供的每个页面16字节的OOB空间来存储ECC（Error Correction Code）和文件系统的组织信息，不仅能实现错误检测和坏块处理，也能够提高文件系统的加载速度。YAFFS采用了一种多策略混合的垃圾回收算法，结合了贪心策略的高效性和随机选择的平均性，达到了兼顾系统开销和损耗平衡的目的。<br>YAFFS文件系统具有很好的移植性，可以在Linux、WindowsCE、pSOS、ThreadX、DSP-BIOS等多种操作系统上工作。为NAND Flash提供了一种可靠的操作系统，并且适合于对能耗要求高的嵌入式系统。<br>YAFFS文件系统目前已经发展到第二版本：YAFFS2，它向前兼容YAFFS1，主要特点是支持每页容量大于512字节的NAND Flash。</p>
<table>
<thead>
<tr>
<th></th>
<th>比较</th>
<th>YAFFS2</th>
<th>YAFFS1</th>
</tr>
</thead>
<tbody><tr>
<td>写操作</td>
<td>快1-3倍</td>
<td>1.5MB&#x2F;s-4.5MB&#x2F;s</td>
<td>1.5MB&#x2F;s</td>
</tr>
<tr>
<td>读操作</td>
<td>快1-2倍</td>
<td>7.6MB&#x2F;s-16.7MB&#x2F;s</td>
<td>7.6MB&#x2F;s</td>
</tr>
<tr>
<td>删除操作</td>
<td>快4-34倍</td>
<td>7.8MB&#x2F;s-62.5MB&#x2F;s</td>
<td>1.8MB&#x2F;s</td>
</tr>
<tr>
<td>垃圾回收</td>
<td>快2-7倍</td>
<td>2.1MB&#x2F;s-7.7MB&#x2F;s</td>
<td>1.1MB&#x2F;s</td>
</tr>
<tr>
<td>内存消耗</td>
<td>减少25%-50%</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>一般而言，在NOR Flash上使用JFFS2文件系统，在NAND Flash上使用YAFFS文件系统。JFFS2与YAFFS的性能比较如下。<br>| 性能 | JFFS2 | YAFFS |<br>| 内存消耗 | 每个节点（node）占用16字节<br>128MB的Flash将占用4MB内存 | 每页占用2字节<br>128MB的Flash将占用512KB内存 |<br>| 第一次启动时的扫描时间 | 128MB的Flash上时间为25S | 只需要读取OOB，时间为3S |<br>| 是否压缩 | 压缩 | 不压缩 |<br>| 代码复杂度 | 复杂 | 简单 |<br>| 使用的操作系统 | Linux、eCos | 很多，容易移植 |<br>| 启动时间 | Flash容量为4MB（or 8MB）时为4S | Flash容量为30MB时为7S |</p>
<h3 id="YAFFS-文件系统移植"><a href="#YAFFS-文件系统移植" class="headerlink" title="YAFFS 文件系统移植"></a>YAFFS 文件系统移植</h3><p>从<code>http://www.aleph1.co.uk/cgi-bin/viewcvs.cgi/</code>获取源代码文件root.tar.gz。解压得到Development目录，里面有两个子目录：yaffs和yaffs2。yaffs目录不在维护，yaffs2兼容yaffs。</p>
<h4 id="将yaffs2代码加入内核"><a href="#将yaffs2代码加入内核" class="headerlink" title="将yaffs2代码加入内核"></a>将yaffs2代码加入内核</h4><p>可以通过yaffs2目录下的脚本文件patch.ker.sh来给内核打补丁，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: ./patch-ker.sh c/l kernelpath</span><br><span class="line">if c/l is c,then copy. if 1 then link</span><br></pre></td></tr></table></figure>
<p>这表明，如果“c&#x2F;l”为“c”，则yaffs2的代码会被复制到内核目录下；如果是“1”，则仅仅是在内核目录下创建一些连接文件。<br>假设下载解压后的yaffs2源码目录为<code>/work/system/Development/yaffs2</code>，内核源码目录为<code>/work/system/linux-2.6.22.6</code>，执行以下命令打补丁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/system/Development/yaffs2</span><br><span class="line">./patch-ker.sh c /work/system/linux-2.6.22.6</span><br></pre></td></tr></table></figure>
<p>上述命令完成以下3件事情。</p>
<ol>
<li>修改内核fs&#x2F;Kconfig文件，增加以下两行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Patched by YAFFS</span><br><span class="line">source &quot;fs/yaffs/Kconfig&quot;</span><br></pre></td></tr></table></figure></li>
<li>修改内核fs&#x2F;Makefile文件，增加以下两行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Patched by YAFFS</span><br><span class="line">obj-$(CONFIG_YAFFS_FS)	+= yaffs2/</span><br></pre></td></tr></table></figure></li>
<li>在内核<code>fs/</code>目录下创建yaffs2子目录，然后复制如下文件。<br>将yaffs2源码目录下得Makefile.kernel文件复制为内核<code>fs/yaffs2/Makefile</code>文件。<br>将yaffs2源码目录下的Kconfig文件复制到内核<code>fs/yaffs2</code>目录下。<br>将yaffs2源码目录下的*.c、*.h（不包括子目录下的文件）复制到内核<code>fs/yaffs2</code>目录下。</li>
</ol>
<h4 id="配置、编译内核"><a href="#配置、编译内核" class="headerlink" title="配置、编译内核"></a>配置、编译内核</h4><p>阅读<code>fs/yaffs2/Kconfig</code>文件可以了解各个配置选项的作用。</p>
<ol>
<li>CONFIG_YAFFS_FS：支持YAFFS文件系统</li>
<li>CONFIG_YAFFS_YAFFS1：支持YAFFS1文件系统<br>对于每页大小为512字节的NAND Flash，要选上这个配置项</li>
<li>CONFIG_YAFFS_YAFFS1：支持YAFFS2文件系统<br>对于每页大小为2048字节的NAND Flash，要选上这个配置项。本书所用的NAND Flash每页为512字节，这个配置项可以不选。</li>
<li>CONFIG_YAFFS_AUTO_YAFFS2：自动选择YAFFS2格式。<br>如果不设置这个配置项，必须使用“yaffs2”字样来表示YAFFS2文件系统格式；如果设置了这个配置项，则可以使用“yaffs”字样来统一表示YAFFS、YAFFS2文件系统格式，驱动程序会根据NAND Flash页的大小自动分辨是YAFFS还是YAFFS2。</li>
<li>CONFIG_YAFFS_9BYTE_TAGS<br>老的YAFFS1文件系统中，使用oob区中9个字节作为文件系统的标记（tag），比新的YAFFS1多了1个字节—“pageStatus”，它用来表示页的状态。<br>如果要使用老的YAFFS1，这个配置项要选上，另外要修改MTD设备层以使用老的oob layout结构。oob layout就是内核文件<code>drivers/mtd/nand/nand_base.c</code>中的nand_oob_16结构。<br>Linux-2.6.22.6内核使用新的oob layout，格式如下。它表示ECC码存放的位置是oob区中0、1、…、7这8个字节；剩下的空间就称为可用空间，供文件系统使用，代码中将这些数据称为标记（tag）：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_ecclayout</span> <span class="title">nand_oob_16</span> =</span> &#123;</span><br><span class="line">	.eccbytes = <span class="number">6</span>,</span><br><span class="line">	.eccpos	= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	.oobfree = &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			.offset = <span class="number">8</span>,</span><br><span class="line">			.length = <span class="number">8</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
以前的内核使用老的oob layout，格式如下，ECC码的位置不一样，标记的位置也不一样。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_ecclayout</span> <span class="title">nand_oob_16</span> =</span> &#123;</span><br><span class="line">	.eccbytes = <span class="number">6</span>,</span><br><span class="line">	.eccpos	= &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,</span><br><span class="line">	.oobavail = <span class="number">9</span>,</span><br><span class="line">	.oobfree = &#123;&#123;<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>&#125;,&#123;<span class="number">11</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如果要使用老格式的YAFFS1映像文件，定义CONFIG_YAFFS_9BYTE_TAGS配置项，并且修改nand_oob_16结构为老的格式。</li>
<li>CONFIG_YAFFS_DOES_ECC：使用YAFFS本身的ECC校验参数。<br>一般使用MTD设备层的ECC校验函数，这个配置项不用设置。<br>了解各配置项的意义后，就可以配置内核，选上对YAFFS的支持了。在内核配置界面选中“YAFFS2 file system support”即可，其他配置选项使用默认值。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File systems	---&gt;</span><br><span class="line">	Miscellaneous filesystems	---&gt;</span><br><span class="line">		&lt;*&gt;	YAFFS2 file system support </span><br></pre></td></tr></table></figure>
最后执行“make uImage”编译内核。</li>
</ol>
<h2 id="编译、烧写、启动内核"><a href="#编译、烧写、启动内核" class="headerlink" title="编译、烧写、启动内核"></a>编译、烧写、启动内核</h2><p>到目前为止，内核已经同时支持了S3C2410和S3C2440，修改了NAND Flash的分区，增加了对YAFFS文件系统的支持。另外，内核原来已经支持JFFS2文件系统。现在的内核。已经基本可用，可以将它烧入NAND Flash中。</p>
<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make uImage</span><br></pre></td></tr></table></figure>
<h3 id="烧写内核"><a href="#烧写内核" class="headerlink" title="烧写内核"></a>烧写内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tftp 0x32000000 uImage 或 nfs 0x30000000 192.168.1.57:/work/nfs_root/uImage</span><br><span class="line">nand erase 0 0x200000							//擦除NAND Flash 前2MB</span><br><span class="line">nand write.jffs2 0x32000000 0 $(filesize)		//烧写uImage</span><br></pre></td></tr></table></figure>

<h3 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nboot 0x32000000 0 0</span><br><span class="line">bootm 0x32000000</span><br></pre></td></tr></table></figure>
<p>要想开发板上电自动启动内核，可以设置bootcmd环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set bootcmd &#x27;nboot 0x32000000 0 0; bootm 0x32000000&#x27;</span><br><span class="line">setenv</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第3篇第16章 移植Linux内核</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux移植</tag>
      </tags>
  </entry>
  <entry>
    <title>移植UBoot</title>
    <url>/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统移植之移植U-Boot</p>
<p>《嵌入式Linux应用完全开发手册》第3篇第15章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解BootLoader的作用及工作流程</li>
<li>了解U-Boot的代码结构、编译过程</li>
<li>移植U-Boot</li>
<li>掌握常用的U-Boot命令</li>
</ol>
<h1 id="BootLoader简介"><a href="#BootLoader简介" class="headerlink" title="BootLoader简介"></a>BootLoader简介</h1><h2 id="BootLoader的概念"><a href="#BootLoader的概念" class="headerlink" title="BootLoader的概念"></a>BootLoader的概念</h2><h3 id="BootLoader的引入"><a href="#BootLoader的引入" class="headerlink" title="BootLoader的引入"></a>BootLoader的引入</h3><p>从前面的篇章可以知道，系统上电之后，需要一段程序来进行初始化：关闭WATCHDOG、改变系统时钟、初始化存储控制器、将更多的代码复制到内存中等。如果它能将操作系统内核复制到内存中运行，无论是从本地（Flash）还是远端（网络），那么就称这段程序为BootLoader。<br>简单来说，BootLoader就是这么一段程序，它在系统上电时运行，初始化硬件设备，准备好软件环境，最后调用操作系统内核。<br>可以增强BootLoader的功能，比如增加网络功能、从PC上通过串口或网络下载文件、烧写文件、将Flash上压缩的文件解压后再运行等，这就是一个功能更为强大的BootLoader，也称为Monitor。实际上，最终产品并不需要这些功能，它们只是为了方便开发。<br>BootLoader的实现非常依赖于具体硬件，在嵌入式系统中硬件的配置千差万别，即使CPU相同，它们的外设也可能不同，所以不可能有一个BootLoader支持所有的CPU、所有的电路板卡。即使支持CPU架构较多的U-Boot，也不是拿来就可以使用的，需要进行一些移植。</p>
<h3 id="BootLoader的启动方式"><a href="#BootLoader的启动方式" class="headerlink" title="BootLoader的启动方式"></a>BootLoader的启动方式</h3><p>CPU上电后，会从某个地址开始执行。比如MIPS架构的CPU会从0xBFC00000取第一条指令，而ARM架构的CPU则会从地址0x00000000开始。嵌入式开发板中，需要把存储器件ROM或Flash等映射到这个地址，BootLoader就存放在这个地址开始处，这样一上电就可以执行。<br>在开发时，通常需要使用各种命令操作BootLoader，一般通过串口来连接PC和开发板，可以在串口上输入各种命令、观察运行结果等。这也只是对开发人员才有意义，用户使用产品时是不需要通过串口来控制BootLoader的。BootLoader可以分为以下两种操作模式。</p>
<ol>
<li>启动加载模式（Boot loading）<br>上电后，BootLoader从板子上的某个固态存储设备上将操作相同加载到RAM中运行，整个过程没有用户的介入。产品发布时，BootLoader工作在这种模式下。</li>
<li>下载模式（Downloading）<br>在这种模式下，开发人员可以使用各种命令，通过串口连接或网络连接等通信手段从主机（Host）下载文件（内核映像、文件系统映像），将它们直接放在内存运行或是烧入Flash。<br>板子与主机间传输文件时，可以使用串口的xmodem、ymodem、zmodem协议，它们使用简单，只是速度较慢；可以使用nfs、tftp协议传输，主机需要开启nfs、tftp服务；也可以使用USB。<br>像Blob或U-Boot等这样功能强大的BootLoader通常支持者两种工作模式，而且运行用户在这两种模式之间切换。比如，U-Boot在启动时处于正常的启动加载模式，但是它会延时若干秒（可设置），等待终端用户按下任意键，而将U-Boot切换到下载模式。如果指定时间内没有用户按键，则U-Boot继续启动Linux内核。</li>
</ol>
<h2 id="BootLoader的结构和启动过程"><a href="#BootLoader的结构和启动过程" class="headerlink" title="BootLoader的结构和启动过程"></a>BootLoader的结构和启动过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在移植之前先了解BootLoader的一些通用概念，对理解它的代码会有所帮助。<br>嵌入式Linux系统从软件的角度通常可以分为以下4个层次。</p>
<ol>
<li>引导加载程序，包括固化在固件中的boot代码和BootLoader两大部分。<br>有些CPU在运行BootLoader之前先运行一段固化的程序，比如x86结构的CPU就是先运行BIOS中的固件，然后才运行硬盘的第一个分区（MBR）中的BootLoader。在大多数嵌入式系统中并没有固件，BootLoader是上电后执行的第一个程序。</li>
<li>Linux内核<br>特定于嵌入式板子的定制内核以及内核的启动参数。内核的启动参数可以是内核默认的，或是由BootLoader传递给它的。</li>
<li>文件系统<br>包括根文件系统和建立于Flash内存设备之上的文件系统。里面包含了Linux系统能够运行所必需的应用程序、库等，比如可以给用户提供操作Linux的控制界面Shell程序、动态连接的程序运行时需要的glibc或uClibc库等。</li>
<li>用户应用程序<br>特定于用户的应用程序，它们也存储在文件系统中。有时在用户应用程序和内核层之间可能还会包括一个嵌入式图形用户界面。</li>
</ol>
<p>显然，在嵌入式系统的固态存储设备上有相应的分区来存储它们，下图是一个典型的分区结构：<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/1.jpeg" alt="img not found"><br>“Boot parameter”分区中存放一些可设置的参数，比如IP地址，串口波特率、要传递给内核的命令行参数等。正常启动过程中，BootLoader首先运行，然后它将内核复制到内存中（也有些内核可以在固态存储设备上直接运行），并且在内存某个固定的地址设置好要传递给内核的参数，最后运行内核。内核启动之后，它会mount根文件系统（root filesystem），启动根文件系统中的应用程序。</p>
<h3 id="BootLoader的两个阶段"><a href="#BootLoader的两个阶段" class="headerlink" title="BootLoader的两个阶段"></a>BootLoader的两个阶段</h3><p>BootLoader的启动过程可以分为单阶段（Single Stage）、多阶段（Multi-Stage）两种。通常多阶段的BootLoader能提供更为复杂的功能以及更好的移植性。从固态存储设备上启动的BootLoader大多都是两阶段的启动过程。第一阶段使用汇编来实现，它完成一些依赖于CPU体系结构的初始化，并调用第二阶段的代码；第二阶段则通常使用C语言来实现，这样可以实现更复杂的功能，而且代码会有更好的可读性和可移植性。<br>一般而言，这两个阶段完成的功能可以如下分类。<br>BootLoader第一阶段的功能。</p>
<ol>
<li>硬件设备初始化</li>
<li>为加载BootLoader的第二阶段代码准备到RAM空间</li>
<li>复制BootLoader的第二阶段代码到RAM空间中</li>
<li>设置好栈</li>
<li>跳转到第二阶段代码的C入口点</li>
</ol>
<p>在第一阶段进行的硬件初始化一般包括：关闭WATCHDOG、关中断、设置CPU的速度和时钟频率、RAM初始化等。这些其实不是必须的，比如S3C2410&#x2F;S3C2440的开发板所使用的U-Boot中，就将CPU的速度和时钟频率的设置放在第二阶段。<br>甚至，将第二阶段的代码复制到RAM空间中也不是必须的，对于NOR Flash等存储设备，完全可以在上面直接执行代码，只不过相比在RAM中执行效率大为降低。<br>BootLoader第二阶段的功能</p>
<ol>
<li>初始化本阶段要用到的硬件设备</li>
<li>检测系统内存映射（memory map）</li>
<li>将内核映像和根文件系统映像从Flash上读到RAM空间中</li>
<li>为内核设置启动参数</li>
<li>调用内核</li>
</ol>
<p>为了方便开发，至少要初始化一个串口以便程序员与BootLoader交互。<br>所谓检测内存映射，就是确定板上使用了多少内存、它们的地址空间是什么。由于嵌入式开发中BootLoader多是针对某类板子进行编写，所以可以根据板子的情况直接设置，不需要考虑可以适用于各类情况的复杂算法。<br>Flash上的内核映像有可能是经过压缩的，在读到RAM之后，还需要进行解压。当然，如果内核带有自解压功能，不需要BootLoader来进行解压。<br>将根文件系统映像映射到RAM中，这不是必须的。这取决于是什么类型的根文件系统，以及内核访问它的方法。<br>将内核存放在适当的位置之后，直接跳到它的入口点即可调用内核。调用内核之前，下列条件要满足：</p>
<ol>
<li>CPU寄存器的设置<ol>
<li>R0 &#x3D; 0</li>
<li>R1 &#x3D; 机器类型ID；对于ARM架构的CPU，其机器类型ID可以参见linux&#x2F;arch&#x2F;arm&#x2F;tools&#x2F;mach-types</li>
<li>R2 &#x3D; 启动参数标记列表在RAM中的起始基地址</li>
</ol>
</li>
<li>CPU工作模式<ol>
<li>必须禁止中断（IRQs和FIQs）</li>
<li>CPU必须为SVC模式</li>
</ol>
</li>
<li>Cache和MMU的设置<ol>
<li>MMU必须关闭</li>
<li>指令Cache可以打开也可关闭</li>
<li>数据Cache必须关闭<br>如果用C语言，可以像下列代码一样来调用内核：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*theKernel)(<span class="type">int</span> zero,<span class="type">int</span> arch,u32 params_addr) = (<span class="type">void</span> (*)(<span class="type">int</span>,<span class="type">int</span>,u32))KERNEL_RAM_BASE;</span><br><span class="line">...</span><br><span class="line">theKernel(<span class="number">0</span>,ARCH_NUMBER,(u32)kernel_params_start);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="BootLoader与内核的交互"><a href="#BootLoader与内核的交互" class="headerlink" title="BootLoader与内核的交互"></a>BootLoader与内核的交互</h3><p>BootLoader与内核的交互是单向的，BootLoader将各类参数传给内核。由于它们不能同时运行，传递办法只有一个：BootLoader将参数放在某个约定的地方，再启动内核，内核启动后从这个地方获取参数。<br>除了约定好参数存放的地址外，还要规定参数的结构。Linux 2.4.x之后的内核都期望以标记列表（tagged list）的形式来传递启动参数。标记就是一种数据结构；标记列表，就是挨着存放的多个标记。标记列表以标记ATAG_CORE开始，以标记ATAG_NONE结束。<br>标记的数据结构为tag，它由一个tag_header结构和一个联合（union）组成。tag_header结构表示标记的类型和长度，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的联合（union），比如表示内存时使用tag_mem32，表示命令行时使用tag_cmdline。数据结构tag和tag_header定义在Linux内核源码的<code>include/asm/setup.h</code>头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">tag_header</span>  &#123;</span></span><br><span class="line">    u32 size;</span><br><span class="line">    u32 tag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">tag</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_header</span>   <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_core</span> <span class="title">core</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_mem32</span>    <span class="title">mem</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_videotext</span>    <span class="title">videotext</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_ramdisk</span>  <span class="title">ramdisk</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_initrd</span>   <span class="title">initrd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_serialnr</span>    <span class="title">serialnr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_revision</span> <span class="title">revision</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_videolfb</span> <span class="title">videolfb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_cmdline</span>  <span class="title">cmdline</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Acorn   specific</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_acorn</span>    <span class="title">acorn</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        DC21285 specific</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_memclk</span>   <span class="title">memclk</span>;</span></span><br><span class="line">    &#125;u;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面以设置内存标记、命令行标记为例说明参数的传递。</p>
<ol>
<li>设置标记ATAG_CORE<br>标记列表以标记ATAG_CORE开始，假设BootLoader与内核约定的参数存放地址为0x30000100，则可以以如下代码设置标记ATAG_CORE<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">params = (<span class="keyword">struct</span> tag *)<span class="number">0x30000100</span>;</span><br><span class="line"></span><br><span class="line">params-&gt;hdr.tag = ATAG_CORE;</span><br><span class="line">params-&gt;hdr.size = tag_size(tag_core);</span><br><span class="line">params-&gt;u.core.flags = <span class="number">0</span>;</span><br><span class="line">params-&gt;u.core.pagesize = <span class="number">0</span>;</span><br><span class="line">params-&gt;u.core.rootdev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">params = tag_next(params);</span><br></pre></td></tr></table></figure>
其中，tag_next定义如下，它指向当前标记的末尾：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tag_next(t) ((struct tag *) ((u32 *)(t) + (t)-&gt;hdr.size))</span></span><br></pre></td></tr></table></figure></li>
<li>设置内存标记<br>假设开发板使用的内存起始地址为0x30000000，大小为0x4000000，则内存标记可以加如下设置：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">params-&gt;hdr.tag = ATAG_MEM;</span><br><span class="line">params-&gt;hdr.size = tag_size(tag_mem32);</span><br><span class="line"></span><br><span class="line">params-&gt;u.mem.start = <span class="number">0x30000000</span>;</span><br><span class="line">params-&gt;u.size = <span class="number">0x4000000</span>;</span><br><span class="line"></span><br><span class="line">params = tag_next(params);</span><br></pre></td></tr></table></figure></li>
<li>设置命令行标记<br>命令行就是一个字符串，它被用来控制内核的一些行为。比如“root&#x3D;&#x2F;dev&#x2F;mtdblock 2 init&#x3D;&#x2F;linuxrc console&#x3D;ttySAC0”表示根文件系统在MTD2分区上，系统启动后执行的第一个程序为&#x2F;linuxrc，控制台为ttySAC0（即第一个串口）。<br>命令行可以在BootLoader中通过命令设置好，然后按如下构造标记传给内核。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;root=/dev/mtdblock 2 init=/linuxrc console=ttySAC0&quot;</span>;</span><br><span class="line">params-&gt;hdr.tag = ATAG_CMDLINE;</span><br><span class="line">params-&gt;hdr.size = (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tag_header) + <span class="built_in">strlen</span>(p) + <span class="number">1</span> + <span class="number">4</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(params-&gt;u.cmdline.cmdline,p);</span><br><span class="line">params = tag_next(params);</span><br></pre></td></tr></table></figure></li>
<li>设置标记ATAG_NONE<br>标记列表以标记ATAG_NONE结束，如下设置：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">params-&gt;hdr.tag = ATAG_NONE;</span><br><span class="line">params-&gt;hdr.size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用的BootLoader介绍"><a href="#常用的BootLoader介绍" class="headerlink" title="常用的BootLoader介绍"></a>常用的BootLoader介绍</h2><p>现在的BootLoader种类繁多，比如x86上有LILO、GRUB等。对于ARM架构的CPU，有U-Boot、ViVi等。它们各有特点。</p>
<table>
<thead>
<tr>
<th>BootLoader</th>
<th>Monitor</th>
<th>描述</th>
<th>X86</th>
<th>ARM</th>
<th>PowerPC</th>
</tr>
</thead>
<tbody><tr>
<td>LILO</td>
<td>否</td>
<td>Linux磁盘引导程序</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>GRUB</td>
<td>否</td>
<td>GNU的LILO替代程序</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>Loadlin</td>
<td>否</td>
<td>从DOS引导Linux</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>ROLO</td>
<td>否</td>
<td>从ROM引导Linux而不需要BIOS</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>Etherboot</td>
<td>否</td>
<td>通过以太网卡启动Linux系统的固件</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>LinuxBIOS</td>
<td>否</td>
<td>完全替代BUIS的Linux引导程序</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>BLOB</td>
<td>是</td>
<td>LART等硬件平台的引导程序</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>U-Boot</td>
<td>是</td>
<td>通用引导程序</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>RedBoot</td>
<td>是</td>
<td>基于eCos的引导程序</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Vivi</td>
<td>是</td>
<td>Mizi公司针对SAMSUNG的ARM CPU设计的引导程序</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>对于S3C2410&#x2F;S3C2440开发板，U-Boot和Vivi是两个好选择。<br>Vivi是Mizi针对SAMSUNG的ARM架构CPU专门设计的，基本上可以直接使用，命令简单方便。不过其初始版本只支持串口下载，速度较慢。在网上出现了各种改进版本：支持网络功能、USB功能、烧写YAFFS文件系统映像等。<br>U-Boot支持大多CPU，可以烧写EXT2、JFFS2文件系统映像，支持串口下载、网络下载，并提供大量的命令。相对于Vivi，它的使用更复杂，但是可以用来更方便的调试程序。</p>
<h1 id="U-Boot分析与移植"><a href="#U-Boot分析与移植" class="headerlink" title="U-Boot分析与移植"></a>U-Boot分析与移植</h1><h2 id="U-Boot工程简介"><a href="#U-Boot工程简介" class="headerlink" title="U-Boot工程简介"></a>U-Boot工程简介</h2><p>U-Boot，全称Universal Boot Loader，即通用BootLoader，是遵循GPL条款的开源代码项目。其前身是由德国DENX软件工程中心的Wolfgang Denk基于8xxROM的源码创建的PPCBOOT工程。后来整理代码结构使得非常容易增加其他类型的开发板、其他架构的CPU（之前只支持PowerPC）；增加更多的功能，比如启动Linux、下载S-Record格式的文件、通过网络启动、通过PCMCIA&#x2F;CompactFLash&#x2F;ATA disk&#x2F;SCSI等方式启动。增加ARM架构CPU及其他更多CPU的支持后，改名U-Boot。<br>它的名字“通用”有两层含义：可以引导多种操作系统、支持多种架构的CPU。它支持如下操作系统：Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS等，支持如下架构的CPU：PowerPC、MIPS、x86、ARM、NIOS、XScale等。<br>U-Boot有如下特性：</p>
<ol>
<li>开放源码</li>
<li>支持多种嵌入式操作系统内核，Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS等</li>
<li>支持多个处理器系列，PowerPC、MIPS、x86、ARM、NIOS、XScale等</li>
<li>较高的可靠性和稳定性</li>
<li>高度灵活的功能设置，适合U-Boot调试、操作系统不同引导要求、产品发布等。</li>
<li>丰富的设备驱动源码，如串口、以太网、SDRAM、Flash、LCD、NVRAM、EEPROM、RTC、键盘等</li>
<li>较为丰富的开发调试文档以及强大的网络技术支持</li>
<li>支持NFS挂载、RAMDISK（压缩或非压缩）形式的根文件系统</li>
<li>支持NFS挂载、从Flash中引导压缩或非压缩的操作系统内核</li>
<li>可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤对Linux支持最为强劲</li>
<li>支持目标板环境变量多种存储方式，如Flash、NVRAM、EEPROM</li>
<li>CRC32校验，可校验Flash中内核、RAMDISK镜像文件是否完好</li>
<li>上电自检功能：SDRAM、Flash大小自动检测、SDRAM故障检测、CPU型号</li>
<li>特殊功能：XIP内核引导</li>
</ol>
<h2 id="U-Boot源码结构"><a href="#U-Boot源码结构" class="headerlink" title="U-Boot源码结构"></a>U-Boot源码结构</h2><p>在U-Boot-1.1.6的基础上进行分析和移植，从sourceforge网站下载U-Boot-1.1.6.tar.bz2后解压得到全部源码。U-Boot-1.1.6源码根目录下共有26个子目录，可以分为4类：</p>
<ol>
<li>平台相关的或开发板相关的</li>
<li>通用的函数</li>
<li>通用的设备驱动程序</li>
<li>U-Boot工具、示例程序、文档</li>
</ol>
<table>
<thead>
<tr>
<th>目录</th>
<th>特性</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>board</td>
<td>开发板相关</td>
<td>对于不同配置的电路板（即使CPU相同），比如smdk2410、sbc2410x</td>
</tr>
<tr>
<td>cpu</td>
<td>平台相关</td>
<td>对应不同的CPU，比如arm920t、arm925t、i386等；在它们的子目录下仍可以进一步细分，比如arm920t下就有at91rm9200、s3c24x0</td>
</tr>
<tr>
<td>lib_i386等</td>
<td>平台相关</td>
<td>某一架构下的通用文件</td>
</tr>
<tr>
<td>include</td>
<td>通用的函数</td>
<td>头文件和开发板配置文件，开发板的配置文件都放在include&#x2F;configs目录下，U-Boot没有make menuconfig类似的菜单来进行可视化设置，需要手动的修改配置文件中的宏定义</td>
</tr>
<tr>
<td>lib_generic</td>
<td>通用的函数</td>
<td>通用的库函数，例如printf等</td>
</tr>
<tr>
<td>common</td>
<td>通用的函数</td>
<td>通用的函数，多是对下一层驱动程序的进一步封装</td>
</tr>
<tr>
<td>disk</td>
<td>通用的设备驱动程序</td>
<td>硬盘接口程序</td>
</tr>
<tr>
<td>drivers</td>
<td>通用的设备驱动程序</td>
<td>各类具体设备的驱动程序，基本上可以通用，它们通过宏从外面引入平台&#x2F;开发板相关的函数</td>
</tr>
<tr>
<td>dtt</td>
<td>通用的设备驱动程序</td>
<td>数字温度测量器或者传感器的驱动</td>
</tr>
<tr>
<td>fs</td>
<td>通用的设备驱动程序</td>
<td>文件系统</td>
</tr>
<tr>
<td>nand_spl</td>
<td>通用的设备驱动程序</td>
<td>U-Boot一般从ROM、NOR Flash等设备启动，现在开始支持从NAND Flash启动，但是支持的CPU种类还不多</td>
</tr>
<tr>
<td>net</td>
<td>通用的设备驱动程序</td>
<td>各种网络协议</td>
</tr>
<tr>
<td>post</td>
<td>通用的设备驱动程序</td>
<td>上电自检程序</td>
</tr>
<tr>
<td>rtc</td>
<td>通用的设备驱动程序</td>
<td>实时时钟的驱动</td>
</tr>
<tr>
<td>doc</td>
<td>文档</td>
<td>开发、使用文档</td>
</tr>
<tr>
<td>examples</td>
<td>示例程序</td>
<td>一些测试程序，可以使用U-Boot下载后运行</td>
</tr>
<tr>
<td>tools</td>
<td>工具</td>
<td>制作S-Record、U-Boot格式映像的工具，比如mkimage</td>
</tr>
</tbody></table>
<p>U-Boot各目录间的层次结构如下图所示：<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/2.jpeg" alt="img not found"></p>
<p>比如common&#x2F;cmd_nand.c文件提供了操作NAND Flash的各种命令，这些命令通过调用drivers&#x2F;nand&#x2F;nand_base.c中的擦除、读写函数来实现。这些函数针对NAND Flash的共性作了一些封装，将平台&#x2F;开发板相关的代码用宏或外部函数替代。而这些宏与外部函数，如果与平台相关，就要在下一层次的cpu&#x2F;xxx（xxx表示某型号的CPU）中实现；如果与开发板相关，就要在下一层次的board&#x2F;xxx目录（xxx表示某款开发板）中实现。本书移植的U-Boot，就是在cpu&#x2F;arm920t&#x2F;s3c24x0目录下增加一个nand_flash.c文件来实现这些函数。<br>以增加烧写yaffs文件系统映像的功能为例，即在common目录下的cmd_nand.c中增加命令。比如nand write.yaffs，这个命令要调用drivers&#x2F;nand&#x2F;nand_util.c中的相应函数，针对yaffs文件系统的特点依次调用擦除、烧写函数。而这些函数依赖于drivers&#x2F;nand&#x2F;nand_base.c、cpu&#x2F;arm920t&#x2F;s3c24x0&#x2F;nand_flash.c文件中的相关函数。<br>目前U-Boot-1.1.6支持10种架构，根目录下有10个类似lib_i386的目录；31个型号（类型）的CPU，cpu目录下有31个子目录；214种开发板，board目录下有214个子目录，很容易从中找到与自己板子相似的配置，在上面稍作修改即可使用。</p>
<h2 id="U-Boot的配置、编译、连接过程"><a href="#U-Boot的配置、编译、连接过程" class="headerlink" title="U-Boot的配置、编译、连接过程"></a>U-Boot的配置、编译、连接过程</h2><h3 id="U-Boot初体验"><a href="#U-Boot初体验" class="headerlink" title="U-Boot初体验"></a>U-Boot初体验</h3><p>U-Boot-1.1.6中有几千个文件，要想了解对于某款开发板，使用哪些文件、哪个文件首先执行，可执行文件占用内存的情况，最好的方法就是阅读它的Makefile。<br>根据顶层Readme文件的说明，可以知道如果要使用开发板board&#x2F;<board_name>，就先执行“make <board_name>_config”命令进行配置，然后执行“make all”，就可以生成如下3个文件：</board_name></board_name></p>
<ol>
<li>U-Boot.bin：二进制可执行文件，它就是可以直接烧入ROM、NOR Flash的文件。</li>
<li>U-Boot：ELF格式的可执行文件。</li>
<li>U-Boot.srec：Motorola S-Record格式的可执行文件。</li>
</ol>
<p>对于S3C2410的开发板，执行“make smdk2410_config”、“make all”后生成的U-Boot.bin可以烧入NOR Flash中运行。启动后可以看到串口输出一些信息后进入控制界面，等待用户的输入。<br>对于S3C2440的开发板，烧入上面生成的U-Boot.bin，串口无输出，需要修改代码。<br>在修改代码之前，先看看上面两个命令“make smdk2410_config”、“make all”做了什么事情，以了解程序的流程，知道要修改哪些文件。<br>另外，编译U-Boot成功之后，还会在它的tools子目录下生成一些工具，比如mkimage等。将它们复制到&#x2F;usr&#x2F;local&#x2F;bin目录下，以后就可以直接使用它们了，比如编译内核时，会使用mkimage来生成U-Boot格式的内核映像文件uImage。</p>
<h3 id="U-Boot的配置过程"><a href="#U-Boot的配置过程" class="headerlink" title="U-Boot的配置过程"></a>U-Boot的配置过程</h3><p>在顶层Makefile中可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SRCTREE     :=  $(CURDIR)</span><br><span class="line">... ...</span><br><span class="line">MKCONFIG    :=  $(SRCTREE)/mkconfig</span><br><span class="line">... ...</span><br><span class="line">smdk2410_config : unconfig</span><br><span class="line">        @$(MKCONFIG)  $(@:_config=) arm arm920t smdk2410  <span class="literal">NULL</span>  s3c24x0</span><br></pre></td></tr></table></figure>
<p>假定在U-Boot-1.1.6的根目录下编译，则其中的MKCONFIG就是根目录下的mkconfig文件。$(@:_config&#x3D;)的结果就是将“smdk2410_config”中的“_config”去掉，结果为“smdk2410”。所以“make smdk2410_config”实际上就是执行如下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./mkconfig smdk2410 arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure>
<p>再来看看mkconfig的作用，在mkconfig文件开头第6行给出了它的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Paramters: Target Architecture CPU Board [VENDOR] [SOC]</span><br></pre></td></tr></table></figure>
<p><code>这里解释一下概念，对于S3C2410、S3C2440，它们被称为SOC（System on Chip），上面除了CPU外，还集成了UART、USB控制器、NAND Flash控制器等设备（称为片内外设）。S3C2410/S3C2440中的CPU为ARM920T</code>。<br>下面分步骤分析mkconfig的作用。</p>
<ol>
<li>确定开发板名称BOARD_NAME，相关代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">APPEND=no               <span class="meta">#default: Create new config file</span></span><br><span class="line">BOARD_NAME=<span class="string">&quot;&quot;</span>           #Name to print in make output</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ $# -gt <span class="number">0</span> ] ; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;$1&quot;</span> in</span><br><span class="line">  --) shift ; <span class="keyword">break</span> ;;</span><br><span class="line">  -a) shift ; APPEND=yes ;;</span><br><span class="line">  -n) shift ; BOARD_NAME=<span class="string">&quot;$&#123;1%%_config&#125;&quot;</span> ; shift ;;</span><br><span class="line">  *)  <span class="keyword">break</span> ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[ <span class="string">&quot;$&#123;BOARD_NAME&#125;&quot;</span> ] || BOARD_NAME=<span class="string">&quot;$1&quot;</span></span><br></pre></td></tr></table></figure>
对于“.&#x2F;mkconfig smdk2410 arm arm920t smdk2410 NULL s3c24x0”命令。其中没有“–”、“-a”、“-n”等符号，所以第4-11行没做任何事情。第1、2行两个变量仍旧维持原来的值。<br>执行完第13行之后，BOARD_NAME的值等于第1个参数，即“smdk2410”。</li>
<li>创建到平台&#x2F;开发板相关的头文件的链接。<br>略过mkconfig文件中的一些没有起作用的行，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line"># Create link to architecture specific headers</span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> [ <span class="string">&quot;$SRCTREE&quot;</span> != <span class="string">&quot;$OBJTREE&quot;</span> ] ; then</span></span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd ./include</span><br><span class="line">    rm -f <span class="keyword">asm</span></span><br><span class="line">    ln -s <span class="keyword">asm</span>-$<span class="number">2</span> <span class="keyword">asm</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
第4行判断源代码目录和目标文件目录是否一样，可以选择在其他目录下编译U-Boot，这可以令源代码目录保持干净，可以同时使用不同的配置进行编译。<br>第7-9行进入include目录，删除asm文件（这时上一次配置时建立的链接文件），然后再次建立asm文件，并令它链接向asm-$2目录，即asm-arm。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rm -f <span class="keyword">asm</span>-$<span class="number">2</span>/arch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;$6&quot;</span> -o <span class="string">&quot;$6&quot;</span> = <span class="string">&quot;NULL&quot;</span> ] ; then</span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;arch-$<span class="number">3</span> <span class="keyword">asm</span>-$<span class="number">2</span>/arch</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;arch-$<span class="number">6</span> <span class="keyword">asm</span>-$<span class="number">2</span>/arch</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$2&quot;</span> = <span class="string">&quot;arm&quot;</span> ] ; then</span><br><span class="line">    rm -f <span class="keyword">asm</span>-$<span class="number">2</span>/proc</span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;proc-armv <span class="keyword">asm</span>-$<span class="number">2</span>/proc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
第1行删除asm-$2&#x2F;arch目录，即asm-arm&#x2F;arch。<br>对于“.&#x2F;mkconfig smdk2410 arm arm920t smdk2410 NULL s3c24x0”命令，$6为“s3c24x0”，不为空，也不是“NULL”，所以第3行的条件不满足，将执行else分支。<br>第6行中LNPREFIX为空，所以这个命令实际上就是“ln -s arch-$6 asm-$2&#x2F;arch”，即“ln -s arch-$6 asm-arm&#x2F;arch”。<br>第10、11行重新建立asm-arm&#x2F;arch文件，并让它链接向proc-armv目录。</li>
<li>创建顶层Makefile包含的文件include&#x2F;config.mk，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Create include file <span class="keyword">for</span> Make</span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta">echo <span class="string">&quot;ARCH = $2&quot;</span> &gt; config.mk</span></span><br><span class="line">echo <span class="string">&quot;CPU = $3&quot;</span> &gt;&gt; config.mk</span><br><span class="line">echo <span class="string">&quot;BOARD = $4&quot;</span> &gt;&gt; config.mk</span><br><span class="line"></span><br><span class="line">[ <span class="string">&quot;$5&quot;</span> ] &amp;&amp; [ <span class="string">&quot;$5&quot;</span> != <span class="string">&quot;NULL&quot;</span> ] &amp;&amp; echo <span class="string">&quot;VENDOR = $5&quot;</span> &gt;&gt; config.mk</span><br><span class="line"></span><br><span class="line">[ <span class="string">&quot;$6&quot;</span> ] &amp;&amp; [ <span class="string">&quot;$6&quot;</span> != <span class="string">&quot;NULL&quot;</span> ] &amp;&amp; echo <span class="string">&quot;SOC = $6&quot;</span> &gt;&gt; config.mk</span><br></pre></td></tr></table></figure>
对于“.&#x2F;mkconfig smdk2410 arm arm920t smdk2410 NULL s3c24x0”命令，上面几行代码创建的config.mk文件内容如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARCH = arm</span><br><span class="line">CPU = arm920t</span><br><span class="line">BOARD = smdk2410</span><br><span class="line">SOC = s3c24x0</span><br></pre></td></tr></table></figure></li>
<li>创建开发板相关的头文件<code>include/config.h</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line"># Create board specific header file</span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> [ <span class="string">&quot;$APPEND&quot;</span> = <span class="string">&quot;yes&quot;</span> ]              # Append to existing config file</span></span><br><span class="line">then</span><br><span class="line">    echo &gt;&gt; config.h</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &gt; config.h                        # Create new config file</span><br><span class="line">fi</span><br><span class="line">echo <span class="string">&quot;/* Automatically generated - do not edit */&quot;</span> &gt;&gt; config.h</span><br><span class="line">echo <span class="string">&quot;#include &lt;configs/$1.h&gt;&quot;</span> &gt;&gt; config.h</span><br></pre></td></tr></table></figure>
APPEND维持原值“no”，所以config.h被重新建立，它的内容如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Automatically generated - do not edit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;configs/smdk2410.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>现在总结一下，配置命令“make smdk2410_config”，实际的作用就是执行“.&#x2F;mkconfig smdk2410 arm arm920t smdk2410 NULL s3c24x0”命令。假设执行“.&#x2F;mkconfig $1 $2 $3 $4 $5 $6”命令，则将产生如下结果。</p>
<ol>
<li>开发板名称BOARD_NAME等于$1。</li>
<li>创建到平台&#x2F;开发板相关的头文件的链接，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ln -s <span class="keyword">asm</span>-$<span class="number">2</span> <span class="keyword">asm</span></span><br><span class="line">ln -s arch-$<span class="number">6</span> <span class="keyword">asm</span>-$<span class="number">2</span>/arch</span><br><span class="line">ln -s proc-armv <span class="keyword">asm</span>-$<span class="number">2</span>/porc           # 如果$<span class="number">2</span>不是<span class="keyword">asm</span>的话，此行没有</span><br></pre></td></tr></table></figure></li>
<li>创建顶层Makefile包含的文件include&#x2F;config.mk，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARCH = $<span class="number">2</span></span><br><span class="line">CPU = $<span class="number">3</span></span><br><span class="line">BOARD = $<span class="number">4</span></span><br><span class="line">VENDOR = $<span class="number">5</span>       # $<span class="number">5</span>为空，或者是<span class="literal">NULL</span>的话，此行没有</span><br><span class="line">SOC = $<span class="number">6</span>          # $<span class="number">6</span>为空，或者是<span class="literal">NULL</span>的话，此行没有</span><br></pre></td></tr></table></figure></li>
<li>创建开发板相关的头文件include&#x2F;config.h，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Automatically generated - do not edit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;configs/$1.h&gt;</span></span></span><br></pre></td></tr></table></figure>
从这4个结果可以知道，如果要在board目录下新建一个开发板<board_name>的目录，则在<code>include/config</code>目录下也要建立一个文件<board_name>.h，里面存放的就是开发板<board_name>的配置信息。<br>U-Boot还没有类似Linux一样的可视化配置界面（make menuconfig），需要手动修改配置文件<code>include/config/&lt;board_name&gt;.h</code>来裁剪、设置U-Boot。</board_name></board_name></board_name></li>
</ol>
<p>配置文件中有以下两类宏。</p>
<ol>
<li>一类是选项（Options），前缀为“CONFIG_”，它们用于选择CPU、SOC、开发板类型，设置系统时钟、选择设备驱动等。比如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ARM920T        1           <span class="comment">/*This is an ARM920T Core*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_S3C2410        1           <span class="comment">/*in a SAMSUNG S3C2410 SoC*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SMDK2410       1           <span class="comment">/*on a SAMSUNG SMDK2410 Board*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_CLK_FREQ   12000000    <span class="comment">/*the SMDK2410 has 12MHz input clock*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_DRVER_CS8900   1           <span class="comment">/*we have a CS8900 on-board*/</span></span></span><br></pre></td></tr></table></figure></li>
<li>另一类参数（Setting），前缀为“CFG_”，它们用于设置malloc缓冲池的大小、U-Boot的提示符、U-Boot下载文件时的默认加载地址、Flash的起始地址等。比如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_MALLOC_LEN  (CFG_ENV_SIZE + 128*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_PROMPT      <span class="string">&quot;Nibil&gt;&quot;</span>                        <span class="comment">/*控制台命令行前缀*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_LOAD_ADDR   0x33000000                      <span class="comment">/*default load address*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYS_FLASH_l    0x00000000                      <span class="comment">/*Flash Bank #1*/</span></span></span><br></pre></td></tr></table></figure>
从下面的编译、链接过程可知，U-Boot中几乎每个文件都被编译和连接，但是这些文件是否包含有效代码，则由宏开关来控制。比如对于网卡驱动cs8900.c，它的格式为：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span>                     <span class="comment">/*将包含配置文件include/config/&lt;board_name&gt;.h*/</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DRIVER_CS8900</span></span><br><span class="line"><span class="comment">/*实际的代码*/</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/*CONFIG_DRIVER_CS8900*/</span></span></span><br></pre></td></tr></table></figure>
如果定义了宏CONFIG_DRIVER_CS8900，则文件中包含有效的代码；否则，文件被注释为空。<br>可以这样认为，“CONFIG_”除了设置一些参数外，主要用来设置U-Boot的功能、选择使用文件中的哪一部分；而“CFG_”用来设置更细节的参数。</li>
</ol>
<h3 id="U-Boot的编译、连接过程"><a href="#U-Boot的编译、连接过程" class="headerlink" title="U-Boot的编译、连接过程"></a>U-Boot的编译、连接过程</h3><p>配置完后，执行“make all”即可编译，从Makefile中可以了解U-Boot使用了哪些文件、哪个文件首先执行、可执行文件占用内存的情况。<br>先确定用到哪些文件，下面所示为Makefile中与ARM相关的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include $(OBJTREE)/include/config.mk</span><br><span class="line">export ARCH CPU BOARD VENDOR SOC</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ifeq ($(ARCH),arm)</span><br><span class="line">CROSS_COMPILE = arm-linux-</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta"># load other configuration</span></span><br><span class="line">include $(TOPDIR)/config.mk</span><br></pre></td></tr></table></figure>
<p>第1行、第11行用于包含其他的config.mk文件，第1行所要包含文件的就是在上面的配置过程中制作出来的<code>include/config.mk</code>，其中定义了ARCH、CPU、BOARD、SOC等4个变量的值为arm、arm920t、smdk2410、s3c24x0。<br>第11行包含顶层目录的<code>config.mk</code>文件，它根据上面的4个变量得值确定了编译器、编译选项等。其中对我们理解编译过程有帮助的是BOARDDIR、LDFLAGS的值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOADRDIR = $(BOARD)</span><br><span class="line">...</span><br><span class="line">include $(TOPDIR)/board/$(BOARDDIR)/config.mk         <span class="meta"># <span class="keyword">include</span> board specific rules</span></span><br><span class="line">...</span><br><span class="line">LDSCRIPT  :=  $(TOPDI)/board/$(BOADRDIR)/U-Boot.lds</span><br><span class="line">...</span><br><span class="line">LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PALTFORM_LDFALGS)</span><br></pre></td></tr></table></figure>
<p>在board&#x2F;smdk2410&#x2F;config.mk中，定义了“TEXT_BASE &#x3D; 0x33F80000”。所以，最终结果如下：BOARDDIR为smdk2410；LDFLAGS中有“-T board&#x2F;smdk2410&#x2F;U-Boot.lds -Ttext 0x33F80000”字样。<br>继续往下看Makefile</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OBJS = cpu/$(CPU)/start.o</span><br><span class="line">...</span><br><span class="line">LIBS = lib_generic/libgeneric.a</span><br><span class="line">LIBS += board/$(BOARDDIR)/lib$(BOARD).a</span><br><span class="line">LIBS += cpu/$(CPU)/lib$(CPU).a</span><br><span class="line">...</span><br><span class="line">LIBS += lib_$ARCH/lib$(ARCH).a</span><br><span class="line">LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \</span><br><span class="line">fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a</span><br><span class="line">LIBS += net/libnet.a</span><br><span class="line">...</span><br><span class="line">LIB += $(BOARDLIBS)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>从第1行可知，OBJS的第一个值为“cpu&#x2F;$(CPU)&#x2F;start.o”，即“cpu&#x2F;arm920t&#x2F;start.o”。<br>第3-13行指定了LIBS变量就是平台&#x2F;开发板相关的各个目录、通用目录下相应的库，比如：lib_generic&#x2F;libgeneric.a、board&#x2F;smdk2410&#x2F;libsmdk2410.a、cpu&#x2F;arm920t&#x2F;libarm920t.a、lib_arm&#x2F;libarm.a、fs&#x2F;cramfs&#x2F;libcramfs.a、fs&#x2F;fat&#x2F;libfat.a等。<br>OBJS、LIBS所代表的.a、.o文件就是U-Boot的构成，它们通过如下命令有相应的源文件编译得到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$(OBJS):</span><br><span class="line">          $(MAKE) -C cpu/$(CPU)/ $(<span class="keyword">if</span> $(REMOTE_BUILD),$@,$(notdir $@))</span><br><span class="line"></span><br><span class="line">$(LIBS):</span><br><span class="line">          $(MAKE) -C $(dir $(subset $(obj),,$@))</span><br><span class="line"></span><br><span class="line">$(SUBDIRS):</span><br><span class="line">          $(MAKE) -C $@ all</span><br></pre></td></tr></table></figure>
<p>第1、2行的规则表示，对于OBJS中的每个成员，都将进入cpu&#x2F;$(CPU)目录（即cpu&#x2F;arm920t）编译它们。现在OBJS为cpu&#x2F;arm920t&#x2F;start.o，它将由cpu&#x2F;arm920t&#x2F;start.S编译得到。<br>第4、5行的规则表示，对于LIBS中的每个成员，都将进入相应的子目录执行“make”命令。这些子目录中的Makefile，结构相似，它们将Makefile中指定的文件编译、连接成一个库文件。<br>当所有的OBJS、LIBS表示的.o、.a文件都生成之后，就剩最后的连接了，这对应Makefile中如下几行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$(obj)U-Boot.srec:        $(obj)U-Boot</span><br><span class="line">              $(OBJCOPY)  $(OBJCFLAGS)  -O  srec  $&lt;  $@</span><br><span class="line"></span><br><span class="line">$(obj)U-Boot.bin:        $(obj)U-Boot</span><br><span class="line">              $(OBJCOPY)  $(OBJCFLAGS)  -O  binary  $&lt;  $@</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">$(obj)U-Boot：    depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)</span><br><span class="line">              UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) | sed -n -e <span class="string">&#x27;s/.*\(_u_boot_cmd_.*\)/-u\1/p&#x27;</span>|sort | uniq`;\</span><br><span class="line">              cd $(LNDIR) &amp;&amp; $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \</span><br><span class="line">              --start-group $(__LIBS) --end-group $(PLATFORM_LIBS)  \</span><br><span class="line">              -Map U-Boot.<span class="built_in">map</span> -o U-Boot</span><br></pre></td></tr></table></figure>
<p>先使用第8-12行的规则连接得到ELF格式的U-Boot，最后转换为二进制格式U-Boot.bin、S-Record格式U-Boot.srec。LDFLAGS确定了连接方式，其中的“-T board&#x2F;smdk2410&#x2F;U-Boot.lds -Ttext 0x33F80000”这样指定了程序的布局、地址。board&#x2F;smdk2410&#x2F;U-Boot.lds文件如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .text       :</span><br><span class="line">    &#123;</span><br><span class="line">      cpu/arm920t/start.o   (.text)</span><br><span class="line">      *(.text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>)</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>)</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>)</span><br><span class="line">    .got : &#123; *(.got) &#125;</span><br><span class="line"></span><br><span class="line">    . = .;</span><br><span class="line">    __u_boot_cmd_start = .;</span><br><span class="line">    .u_boot_cmd : &#123; *(.u_boot_cmd) &#125;</span><br><span class="line">    __u_boot_cmd_end = .;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>)</span><br><span class="line">    __bss_satrt = .;</span><br><span class="line">    .bss : &#123; *(.bss) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从第7行可知，cpu&#x2F;arm920t&#x2F;start.o被放在程序的最前面，所以U-Boot的入口点在cpu&#x2F;arm920t&#x2F;start.S中。<br>现在来总结一下U-Boot的编译流程。</p>
<ol>
<li>首先编译cpu&#x2F;$(CPU)&#x2F;start.S，对于不同的CPU，还可能编译cpu&#x2F;$(CPU)下其他的文件。</li>
<li>然后，对于平台&#x2F;开发板相关的每个目录、每个通用目录都使用它们各自的Makefile生成相应的库。</li>
<li>将1、2步骤生成的.o、.a文件按照board&#x2F;$(BOARDDIR)&#x2F;config.mk文件中指定的代码段起始地址、board&#x2F;$(BOARDDIR)&#x2F;U-Boot.lds连接脚本进行连接。</li>
<li>第3步得到的ELF格式的U-Boot，后面Makefile还会将它转换为二进制格式、S-Record格式。</li>
</ol>
<h2 id="U-Boot的启动过程源码分析"><a href="#U-Boot的启动过程源码分析" class="headerlink" title="U-Boot的启动过程源码分析"></a>U-Boot的启动过程源码分析</h2><p>本书使用的U-Boot从NOR Flash 启动，下面以开发板smdk2410的U-Boot为例、<br>U-Boot属于两阶段的Bootloader，第一阶段的文件为cpu&#x2F;arm920t&#x2F;start.S和board&#x2F;smdk2410&#x2F;lowlevel_init.S，前者是平台相关的，后者是开发板相关的。</p>
<h3 id="U-Boot第一阶段代码分析"><a href="#U-Boot第一阶段代码分析" class="headerlink" title="U-Boot第一阶段代码分析"></a>U-Boot第一阶段代码分析</h3><ol>
<li><p>硬件设备初始化<br>依次完成如下设置：将CPU的工作模式设为管理模式（SVC），关闭WATCHDOG，设置FCLK、HCLK、PCLK的比例（即设置CLKDIVN寄存器），关闭MMU、CACHE。<br>代码都在cpu&#x2F;arm920t&#x2F;start.S中，注释也比较完善。</p>
</li>
<li><p>为加载Bootloader的第二阶段代码准备RAM空间。<br>所谓准备RAM空间，就是初始化内存芯片，使它可用。对于S3C2410&#x2F;S3C2440，通过在start.S中调用lowlevel_init函数来设置存储控制器，使得外接的SDRAM可用。代码在board&#x2F;smdk2410&#x2F;lowlevel_init.S中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：lowlevel_init.S文件是开发板相关的，这表示如果外接的设备不一样，可以修改lowlevel_init.S文件中的宏。</span><br></pre></td></tr></table></figure>
<p>lowlevel_init函数并不复杂，只要注意这时的代码、数据都只存放在NOR Flash中，内存中还没有，所以读取数据时要变换地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_TEXT_BASE:</span><br><span class="line">.word   TEXT_BASE</span><br><span class="line"></span><br><span class="line">.global   lowlevel_init</span><br><span class="line">lowlevel_init:</span><br><span class="line">  <span class="comment">/* memory control configuration */</span></span><br><span class="line">  <span class="comment">/* make r0 relative the current location so that it */</span></span><br><span class="line">  <span class="comment">/* reads SMRDATA out of FLASH rather than memory! */</span></span><br><span class="line">  ldr r0,=SMRDATA</span><br><span class="line">  ldr r1,_TEXT_BASE</span><br><span class="line">  sub r0,r0,r1</span><br><span class="line">  ldr r1,=BWSCON<span class="comment">/*Bus Width Status Controller*/</span></span><br><span class="line">  add r2,r0,#<span class="number">13</span>*<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line">  ldr r3,[r0],#<span class="number">4</span></span><br><span class="line">  str r3,[r1],#<span class="number">4</span></span><br><span class="line">  cmp r2,r0</span><br><span class="line">  bne <span class="number">0b</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* everything is fine now */</span></span><br><span class="line">  mov pc,lr</span><br><span class="line"></span><br><span class="line">  .ltorg</span><br><span class="line">  <span class="comment">/* the literal pools origin */</span></span><br><span class="line"></span><br><span class="line">SMRDATA:</span><br><span class="line">  .word ... ...</span><br><span class="line">  .word ... ... </span><br></pre></td></tr></table></figure>
<p>第9-11行进行地址变换，因为这时候内存中没有数据，不能使用连接程序时确定的地址来读取数据。<br>第9行中SMRDATA表示这13个寄存器的值存放的开始地址（连接地址），值为0x33F8xxxx，处于内存中。<br>第10行获得代码段的起始地址，它就是第1行中的“TEXT_BASE”，其值在<code>board/smdk2410/config.mk</code>中定义为“TEXT_BASE &#x3D; 0x33F80000”。<br>第11行将0x33F8xxxx与0x33F80000相减，这就是13个寄存器值在NOR Flash上存放的开始地址。</p>
</li>
<li><p>复制Bootloader的第二阶段代码到RAM空间中<br>这里将整个U-Boot的代码（包括第一、第二阶段）都复制到SDARM中，这在<code>cpu/arm920t/start.S</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">relocate:                               <span class="comment">/*将U-Boot复制到RAM中*/</span></span><br><span class="line">  adr r0,_start                         <span class="comment">/*r0:当前代码的开始地址*/</span></span><br><span class="line">  ldr r1,_TEXT_BASE                     <span class="comment">/*r1:代码段的连接地址*/</span></span><br><span class="line">  cmp r0,r1                             <span class="comment">/*测试现在是在Flash中还是RAM中*/</span></span><br><span class="line">  beq stack_setup                       <span class="comment">/*如果已经在RAM中（通常是调试时直接下载到RAM中），则不需要复制*/</span></span><br><span class="line"></span><br><span class="line">  ldr r2,_armboot_start                 <span class="comment">/*_armboot_start在前面定义，是第一条指令的运行地址*/</span></span><br><span class="line">  ldr r3,_bss_start                     <span class="comment">/*在连接脚本U-Boot.lds中定义，是代码段的结束地址*/</span></span><br><span class="line">  sub r2,r3,r2                          <span class="comment">/*r2 = 代码段长度*/</span></span><br><span class="line">  add r2,r0,r2                          <span class="comment">/*r2 = NOR Flash 上代码段的结束地址*/</span></span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">  ldmia r0!,&#123;r3-r10&#125;                    <span class="comment">/*从地址[r0]处获得数据*/</span></span><br><span class="line">  stmia r1!,&#123;r3-r10&#125;                    <span class="comment">/*复制到地址[r1]处*/</span></span><br><span class="line">  cmp r0,r2                             <span class="comment">/*判断是否复制完毕*/</span></span><br><span class="line">  ble copy_loop                         <span class="comment">/*没复制完，则继续*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置好栈<br>栈的设置灵活性很大，只要让sp寄存器指向一段没有使用的内存即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* set up the stack */</span></span><br><span class="line">stack_setup:</span><br><span class="line">  ldr r0,_TEXT_BASE                     <span class="comment">/*_TEXT_BASE为代码段的开始地址，值为0x33F80000*/</span></span><br><span class="line">  sub r0,r0,#CFG_MALLOC_LEN             <span class="comment">/*代码段下面，留出一段内存以实现malloc*/</span></span><br><span class="line">  sub r0,r0,#CFG_GBL_DATA_SIZE          <span class="comment">/*再留出一段内存，存一些全局参数*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USE_IRQ</span></span><br><span class="line">  sub r0,r0,#(CONFIG_STACKSIZE_IRQ + CONFIG_STACKSIZE_FIQ)          <span class="comment">/*IRQ、FIQ模式的栈*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  sub sp,r0,#<span class="number">12</span>                         <span class="comment">/*最后，留出12字节的内存给abort异常，往下的内存就是栈了*/</span></span><br></pre></td></tr></table></figure>
<p>到了这一步，读者就可以知道内存的使用情况了，如下图所示，图中与上面代码的划分稍有不同，这时因为在<code>cpu/arm920t/cpu.c</code>中的cpu_init函数中才真正为IRQ、FIQ模式划分了栈。<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/3.jpeg" alt="img not found"></p>
</li>
<li><p>跳转到第二阶段代码的C入口点<br>在跳转之前，还要清除BSS段（初始值为0、无初始值的全局变量、静态变量放在BSS段），代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clear_bss:</span><br><span class="line">  ldr r0,_bss_start                      <span class="comment">/*BSS段的开始地址，它的值在连接脚本U-Boot.lds中确定*/</span></span><br><span class="line">  ldr r1,_bss_end                        <span class="comment">/*BSS段的结束地址，它的值在连接脚本U-Boot.lds中确定*/</span></span><br><span class="line">  mov r2,#<span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line">clbss_l:</span><br><span class="line">  str r2,[r0]                            <span class="comment">/*往BSS段中写入0值*/</span></span><br><span class="line">  add r0,r0,#<span class="number">4</span></span><br><span class="line">  cmp r0,r1</span><br><span class="line">  ble clbss_l</span><br></pre></td></tr></table></figure>
<p>现在，C函数的环境已经完全准备好，通过如下命令直接跳转（这之后，程序才在内存中执行），它将调用<code>lib_arm/board.c</code>中的start_arm_boot函数，这是第二阶段的入口点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  ldr pc,_start_armboot</span><br><span class="line"></span><br><span class="line">_start_armboot: .word start_armboot</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="U-Boot第二阶段代码分析"><a href="#U-Boot第二阶段代码分析" class="headerlink" title="U-Boot第二阶段代码分析"></a>U-Boot第二阶段代码分析</h3><p>U-Boot在启动内核之前可以让用户选择是否进入下载模式，即进入U-Boot的控制界面。<br>第二阶段从<code>lib_arm/board.c</code>中的start_armboot函数开始，程序流程图如下所示：<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/4.jpeg" alt="img not found"><br>移植U-Boot的主要工作在于对硬件的初始化、驱动，所以下面讲解时将重点放在硬件的操作上。</p>
<ol>
<li>初始化本阶段要使用到的硬件设备<br>最主要的的是系统时钟、初始化串口，只要设置好这两个，就可以从串口看到打印信息。<br>board_init函数设置MPLL、改变系统时钟，它是开发板相关的函数，在<code>board/smdk2410/smdk2410.c</code>中实现。值得注意的是，board_init函数中保存了机器类型ID，这将在调用内核时传给内核。代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*arch number of SMDK2410-Board*/</span></span><br><span class="line">gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410;      <span class="comment">//值为193</span></span><br></pre></td></tr></table></figure>
串口的初始化函数主要是serial_init，它设置UART控制器，是CPU相关的函数，在<code>cpu/arm920t/s3c24x0/serail.c</code>中实现。</li>
<li>检测系统内存映射（memory map）<br>对于特定的开发板，其内存的分布是明确的，所以可以直接设置。<code>board/smdk2410/smdk2410.c</code>中的dram_init函数指定了本开发板的内存起始地址为0x30000000，大小为0x4000000。代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dram_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  gd-&gt;bd-&gt;bi_dram[<span class="number">0</span>].start = PHYS_SDRAM_1;          <span class="comment">//即0x30000000；</span></span><br><span class="line">  gd-&gt;bd-&gt;bi_dram[<span class="number">0</span>].size = PHYS_SDRAM_1_SIZE;          <span class="comment">//即0x4000000；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这些参数的设置，将在后面向内核传递参数时用到。</li>
<li>U-Boot命令的格式<br>即使是内核的启动，也是通过U-Boot命令来实现的。U-Boot中每个命令都通过U_BOOT_CMD宏来定义，格式如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(name,maxargs,repeatable,command,<span class="string">&quot;usage&quot;</span>,<span class="string">&quot;help&quot;</span>)</span><br></pre></td></tr></table></figure>
各项参数意义如下：<br>①name：命令的名字，它不是一个字符串，不要用双引号括起来。<br>②maxargs：最大的参数个数<br>③repeatable：命令是否可以重复，可重复是指运行一个命令后，下次再敲回车即可再次运行<br>④command：对应的函数指针，类型为<code>(*cmd)(struct cmd_tbl_s *,int,int,char *[])</code>。<br>⑤usage：简短的使用说明，字符串。<br>⑥help：详细的使用说明，字符串。</li>
</ol>
<p>宏U_BOOT_CMD在<code>include/command.h</code>中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \</span></span><br><span class="line"><span class="meta">cmd_tbl_t __u_boot_cmd_##name Struct_Section = &#123;#name,maxargs,rep,cmd,usage,help&#125;</span></span><br></pre></td></tr></table></figure>
<p>Struct_Section也是在<code>include/command.h</code>中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Struct_Section __attribute__ ((unused,section (<span class="string">&quot;.u_boot_cmd&quot;</span>)))</span></span><br></pre></td></tr></table></figure>
<p>比如对与bootm命令，它如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">  bootm,CFG_MAXARGS,<span class="number">1</span>,do_bootm,</span><br><span class="line">  <span class="string">&quot;string1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;string2&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>宏U_BOOT_CMD扩展开后如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cmd_tbl_t</span> __u_boot_cmd_bootm __attribute__ ((unused,section (<span class="string">&quot;.u_boot_cmd&quot;</span>))) = &#123;<span class="string">&quot;bootm&quot;</span>,CFG_MAXARGS,<span class="number">1</span>,do_bootm,<span class="string">&quot;string1&quot;</span>,<span class="string">&quot;string2&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每个使用U_BOOT_CMD宏来定义的命令，其实都是在“.u_boot_cmd”段中定义一个cmd_tbl_t结构。连接脚本U-Boot.lds中有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__u_boot_cmd_start = .;</span><br><span class="line">.u_boot_cmd : &#123; *(.u_boot_cmd) &#125;</span><br><span class="line">__u_boot_cmd_end = .;</span><br></pre></td></tr></table></figure>
<p>程序中就是根据命令的名字在内存段__u_boot_cmd_start~__u_boot_cmd_end找到它的cmd_tbl_t结构，然后调用它的函数。<br>内核的复制与启动，可以通过如下命令来完成：bootm从内存、ROM、NOR Flash中启动内核，bootp则通过网络来启动，而nboot从NAND Flash启动内核。它们都是先将内核映像从各种媒介中读出，存放在指定的位置；然后设置标记列表以给内核传递参数；最后跳到内核的入口点去执行。<br>4. 为内核设置启动参数<br>U-Boot也是通过标记列表向内核传递参数。并且，在之前的小节中内存标记、命令行标记的示例代码就是取自U-Boot中的setup_memory_tags、setup_commandline_tag函数，它们都是在<code>lib_arm/armlinux.c</code>中定义。一般而言，设置这两个标记就可以了，在配置文件<code>include/configs/smdk2410.h</code>中增加如下两个配置项即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SETUP_MEMORY_TAGS  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CMDLINE_TAG  1</span></span><br></pre></td></tr></table></figure>
<p>对于ARM架构的CPU，都是通过<code>lib_arm/armlinux.c</code>中的do_bootm_linux函数来启动内核。这个函数中，设置标记列表，最后通过<code>theKernel(0,bd-&gt;bi_arch_number,bd-&gt;bi_boot_params)</code>调用内核。其中。theKernel指向内核存放的地址（对于ARM架构的CPU，通常是0x30008000），bd-&gt;bi_arch_number就是前面board_init函数设置的机器类型ID，而bd-&gt;bi_boot_params就是标记列表的开始地址。</p>
<h2 id="U-Boot的移植"><a href="#U-Boot的移植" class="headerlink" title="U-Boot的移植"></a>U-Boot的移植</h2><p>开发板smdk2410的配置适用于大多数S342410开发板，或者只需要极少的修改即可使用。但是目前的U-Boot中没有对S3C2410的支持，需要我们自己移植。<br>本书基于S342410、S342440两款开发板，它们的外接硬件相同。</p>
<ol>
<li>BANK0外界容量为1MB，位宽为8的NOR Flash芯片AM29LV800。</li>
<li>BANK3外接10M网卡芯片CS8900，位宽为16。</li>
<li>BANK6外接两片容量为32MB、位宽为16的SDRAM芯片K4S561632，组成容量为64MB、位宽为32的内存。</li>
<li>听过NAND Flash控制器外接容量为64MB，位宽为8的NAND Flash芯片K9S1208。</li>
</ol>
<p>对于NOR Flash和NAND Flash，下图划分了它们的使用区域。<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/5.jpeg" alt="img not found"><br>由于NAND Flash的“位反转”现象比较常见，为保证数据的正确，在读写数据时需要使用ECC校验。另外，NAND Flash在使用过程中、运输过程中还有可能出现坏块。所以下面使用NOR Flash保存U-Boot，NAND Flash保存内核和文件系统，并使用U-Boot烧写内核、文件系统时进行坏块检查、ECC校验。这样，即使NAND Flash出现坏块导致内核或文件系统不能使用，也可以通过NOR Flash中的U-Boot来重新烧写。<br>smdk2410开发板已经支持NOR Flash芯片AM29LV800，U-Boot本身也已经支持JFFS2文件系统映像的烧写。下面一步一步移植U-Boot，增加以下新功能。</p>
<ol>
<li>同时支持本书使用的S3C2410和S3C2440开发板。</li>
<li>支持串口xmodem协议。</li>
<li>支持网卡芯片CS8900。</li>
<li>支持NAND Flash读写。</li>
<li>支持烧写yaffs文件系统映像。</li>
</ol>
<h3 id="同时支持S3C2410和S3C2440"><a href="#同时支持S3C2410和S3C2440" class="headerlink" title="同时支持S3C2410和S3C2440"></a>同时支持S3C2410和S3C2440</h3><p>我们将在开发板smdk2410的基础上进行移植。</p>
<h4 id="新建一个开发板的相应目录和文件"><a href="#新建一个开发板的相应目录和文件" class="headerlink" title="新建一个开发板的相应目录和文件"></a>新建一个开发板的相应目录和文件</h4><p>为了不破坏原来的代码，在board目录下将smdk2410复制为<code>100ask24x0</code>目录，并将<code>board/100ask24x0/smdk2410.c</code>改名为<code>100ask2410.c</code>。<br>根据前面描述的配置过程可知，还要在<code>include/configs</code>目录下建立一个配置文件<code>100ask24x0.h</code>，可以将<code>include/configs/smdk2410.h</code>直接复制为<code>100ask24x0.h</code>。<br>还要修改两个Makefile，首先在顶层Makefile中增加两行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>ask24x0_config : unconfig</span><br><span class="line">                    @$(MKCONFIG) $(@:_config=) arm arm920t <span class="number">100</span>ask24x0 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure>
<p>在<code>board/100ask24x0/Makefile</code>中进行如下修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COBJS := smdk2410.o flash.o</span><br><span class="line">改为</span><br><span class="line">COBJS := <span class="number">100</span>ask24x0.o flash.o</span><br></pre></td></tr></table></figure>

<h4 id="修改SDRAM的设置"><a href="#修改SDRAM的设置" class="headerlink" title="修改SDRAM的设置"></a>修改SDRAM的设置</h4><p>SDRAM的初始化在U-Boot的第一阶段完成，就是在<code>board/100ask24x0/lowlevel_init.S</code>文件中设置存储寄存器。<br>检查BANK6的设置：位宽为32，宏B6_BWSON刚好为DW32（32位），无需改变；另外还需要根据HCLK设置SDRAM的刷新参数，主要是REFCNT寄存器。<br>本书所用开发板的HCLK都设为100MHz，需要根据SDRAM芯片的具体参数重新计算REFCNT寄存器的值。代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REFCNT 1113         <span class="comment">//period=15.6μs,HCLK=60MHz,(2048+1-15.6*60)</span></span></span><br><span class="line">改为</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFCNT 0x4f4         <span class="comment">//period=7.8125μs,HCLK=100MHz,(2048+1-7.8125*100)</span></span></span><br></pre></td></tr></table></figure>
<p>对于其他BANK，比如网卡芯片CS8900所在的BANK2，原来的设置刚好匹配，无需更改；而对于BANK1、BANK2、BANK4、BANK5、BANK7，在U-Boot中并没有使用到它们外接的设备，也不需要理会。</p>
<h4 id="增加对S3C2440的支持"><a href="#增加对S3C2440的支持" class="headerlink" title="增加对S3C2440的支持"></a>增加对S3C2440的支持</h4><p>S3C2440是S3C2410的改进版，它们的操作基本相似。不过在系统时间的设置、NAND Flash控制器的操作方面有一些小差别。它们的MPLL、UPLL计算公式不一样，FCLK、HCLK和PCLK的分频化设置也不一样。<br>我们的目标是令同一个二进制映像文件既能在S3C2410上运行，也可以在S3C2440上运行。首先需要在代码中自动识别芯片是S3C2440还是S3C2410，这可以通过读取GSTATUS1寄存器来分辨：0x32410000表示S3C2410，0x32410002表示S3C2410A，0x32440000表示S3C2440，0x32440001表示S3C2440A。<br>对于S3C2410开发板，将FCLK设为200MHz，分频比为FCLK：HCLK：PCLK&#x3D;1：2：4；对于S3C2440，将FCLK设为400MHz，分频比为FCLK：HCLK：PCLK&#x3D;1：4：8。还将UPLL设为48MHz，即UCLK为48MHz，以在内核中支持USB控制器。<br>首先修改<code>board/100ask24x0/100ask24x0.c</code>中的<code>board_init</code>函数，下面是修改后的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* S3C2440:</span></span><br><span class="line"><span class="comment">          MPLL = (2 * m * Fin) / (p * 2^s)</span></span><br><span class="line"><span class="comment">          UPLL = (m * Fin) / (p * 2^s)  </span></span><br><span class="line"><span class="comment">          m = M(the value for divider M) + 8</span></span><br><span class="line"><span class="comment">          p = P(the value for divider P) + 2 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_MPLL_400MHz                 ((0x5c &lt;&lt; 12) | (0x01 &lt;&lt; 4) | 0x01)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_UPLL_48MHz                  ((0x38 &lt;&lt; 12) | (0x02 &lt;&lt; 4) | 0x02)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIV                      (0x05)  <span class="comment">//FCLK:HCLK:PLCK = 1:4:8  UCLK = UPLL</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* S3C2410:</span></span><br><span class="line"><span class="comment">          MPLL = (m * Fin) / (p * 2^s)  </span></span><br><span class="line"><span class="comment">          UPLL = (m * Fin) / (p * 2^s)  </span></span><br><span class="line"><span class="comment">          m = M(the value for divider M) + 8</span></span><br><span class="line"><span class="comment">          p = P(the value for divider P) + 2 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_MPLL_200MHz                 ((0x5c &lt;&lt; 12) | (0x04 &lt;&lt; 4) | 0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_UPLL_48MHz                  ((0x28 &lt;&lt; 12) | (0x01 &lt;&lt; 4) | 0x02)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_CLKDIV                      (0x05)  <span class="comment">//FCLK:HCLK:PLCK = 1:2:8</span></span></span><br></pre></td></tr></table></figure>
<p>针对S3C2410、S3C2440分别定义了MPLL、UPLL寄存器的值。开发板输入时钟为12MHz（<code>include/configs/100ask24x0.h中的宏CONFIG_SYS_CLK_FREQ中定义</code>）。<br>下面针对S3C2410、S3C2440分别使用不同的宏设置系统时钟。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">board_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C24X0_CLOCK_POWER * <span class="type">const</span> clk_power = S3C24X0_GetBase_CLOCK_POWER();</span><br><span class="line">  S3C24X0_GPIO * <span class="type">const</span> gpio = S3C24X0_GetBase_GPIO();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*设置GPIO*/</span></span><br><span class="line">  gpio-&gt;GPACON = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  gpio-&gt;GPBCON = <span class="number">0x00044555</span>;</span><br><span class="line">  gpio-&gt;GPBUP  = <span class="number">0x000007FF</span>;</span><br><span class="line">  gpio-&gt;GPCCON = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  gpio-&gt;GPCUP  = <span class="number">0x0000FFFF</span>;</span><br><span class="line">  gpio-&gt;GPDCON = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  gpio-&gt;GPDUP  = <span class="number">0x0000FFFF</span>;</span><br><span class="line">  gpio-&gt;GPECON = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  gpio-&gt;GPEUP  = <span class="number">0x0000FFFF</span>;</span><br><span class="line">  gpio-&gt;GPFCON = <span class="number">0x000055AA</span>;</span><br><span class="line">  gpio-&gt;GPFUP  = <span class="number">0x000000FF</span>;</span><br><span class="line">  gpio-&gt;GPGCON = <span class="number">0xFF95FFBA</span>;</span><br><span class="line">  gpio-&gt;GPGUP  = <span class="number">0x0000FFFF</span>;</span><br><span class="line">  gpio-&gt;GPHCON = <span class="number">0x002AFAAA</span>;</span><br><span class="line">  gpio-&gt;GPHUP  = <span class="number">0x000007FF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*同时支持S3C2410和S3C2440*/</span></span><br><span class="line">  <span class="keyword">if</span>((gpio-&gt;GSTATUS1 == <span class="number">0x32410000</span>) || (gpio-&gt;GSTATUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*FCLK:HCLK:PCLK=1:2:4*/</span></span><br><span class="line">    clk_power-&gt;CLKDIVN = S3C2410_CLKDIV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*修改为异步总线模式*/</span></span><br><span class="line">    __asm__(<span class="string">&quot;mrc p15,0,r1,c1,c0,0 \n&quot;</span>     <span class="comment">/*read ctrl register*/</span></span><br><span class="line">            <span class="string">&quot;orr r1,r1, #0xc0000000 \n&quot;</span>   <span class="comment">/*Asynchronous*/</span></span><br><span class="line">            <span class="string">&quot;mcr p15,0,r1,c1,c0,0 \n&quot;</span>     <span class="comment">/*write ctrl register*/</span></span><br><span class="line">            :::<span class="string">&quot;r1&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置PLL锁定时间*/</span></span><br><span class="line">    clk_power-&gt;LOCKTIME = <span class="number">0xFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置MPLL*/</span></span><br><span class="line">    clk_power-&gt;MPLLCON = S3C2410_MPLL_200MHZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置MPLL后，要延时一段时间再配置UPLL*/</span></span><br><span class="line">    delay(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置UPLL*/</span></span><br><span class="line">    clk_power_UPLLCON = S3C2410_UPLL_48MHZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*再延时一会*/</span></span><br><span class="line">    delay(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*机器类型ID，这在调用Linux内核时用到*/</span></span><br><span class="line">    gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*FCLK:HCLK:PCLK=1:4:8*/</span></span><br><span class="line">    clk_power-&gt;CLKDIVN = S3C2440_CLKDIV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*修改为异步总线模式*/</span></span><br><span class="line">    __asm__(<span class="string">&quot;mrc p15,0,r1,c1,c0,0 \n&quot;</span>     <span class="comment">/*read ctrl register*/</span></span><br><span class="line">            <span class="string">&quot;orr r1,r1, #0xc0000000 \n&quot;</span>   <span class="comment">/*Asynchronous*/</span></span><br><span class="line">            <span class="string">&quot;mcr p15,0,r1,c1,c0,0 \n&quot;</span>     <span class="comment">/*write ctrl register*/</span></span><br><span class="line">            :::<span class="string">&quot;r1&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置PLL锁定时间*/</span></span><br><span class="line">    clk_power-&gt;LOCKTIME = <span class="number">0xFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置MPLL*/</span></span><br><span class="line">    clk_power-&gt;MPLLCON = S3C2440_MPLL_400MHZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置MPLL后，要延时一段时间再配置UPLL*/</span></span><br><span class="line">    delay(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置UPLL*/</span></span><br><span class="line">    clk_power_UPLLCON = S3C2440_UPLL_48MHZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*再延时一会*/</span></span><br><span class="line">    delay(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*机器类型ID，这在调用Linux内核时用到*/</span></span><br><span class="line">    gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2440;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*启动内核时，参数存放位置。这个值在构造标记列表时用到*/</span></span><br><span class="line">  gd-&gt;bd-&gt;bi_boot_params = <span class="number">0x30000100</span>;</span><br><span class="line"></span><br><span class="line">  icache_enable();</span><br><span class="line">  dcache_enable();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步：获取系统时钟的函数需要针对S3C2410、S3C2440的不同进行修改。<br>在后面设置串口波特率时需要获得系统时钟，就是在U-Boot第二阶段，<code>lib_arm/board.c</code>中<code>start_armboot</code>函数调用<code>serial_init</code>函数初始化串口时，会调用<code>get_PCLK</code>函数。它在<code>cpu/arm920t/s3c24x0/speed.c</code>中定义，与它相关的还有<code>get_HCLK</code>、<code>get_PLLCLK</code>等函数。<br>前面的<code>board_init</code>函数在识别出S3C2410或S3C2440后，设置了机器类型ID：<code>gd-&gt;bd-&gt;bi_arch_number</code>，后面的函数可以通过它分辨是S3C2410还是S3C2440。首先要在程序的开头增加如下代码，这样才可以使用<code>gd</code>变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br></pre></td></tr></table></figure>
<p>S3C2410和S3C2440的MPLL、UPLL计算公式不一样，所以<code>get_PLLCLK</code>也需要修改，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> ulong <span class="title function_">get_PLLCLK</span><span class="params">(<span class="type">int</span> pllreg)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C24X0_CLOCK_POWER * <span class="type">const</span> clk_power = S3C24X0_GetBase_CLOCK_POWER();</span><br><span class="line">  ulong r,m,p,s;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pllreg == MPLL)</span><br><span class="line">    r = clk_power-&gt;MPLLCON;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pllreg == UPLL)</span><br><span class="line">    r = clk_power-&gt;UPLLCON;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    hang();</span><br><span class="line"></span><br><span class="line">  m = ((r &amp; <span class="number">0xFF000</span>) &gt;&gt; <span class="number">12</span>) + <span class="number">8</span>;</span><br><span class="line">  p = ((r &amp; <span class="number">0x003F0</span>) &gt;&gt; <span class="number">4</span> ) + <span class="number">2</span>;</span><br><span class="line">  s = r &amp; <span class="number">0x3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*同时支持S3C2410和S3C2440*/</span></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)</span><br><span class="line">    <span class="keyword">return</span> ((CONFIG_SYS_CLK_FREQ * m) / (p &lt;&lt; s));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ((CONFIG_SYS_CLK_FREQ * m * <span class="number">2</span>) / (p &lt;&lt; s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于分频系数的设置方法也不一样，<code>get_HCLK</code>，<code>getPCLK</code>也需要修改。对于S3C2410，沿用原来的计算方法，else分支中是S3C2440的代码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* for s3c2440 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_PDIVN                     (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_MASK                (3 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_1                   (0 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_2                   (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_4_8                 (2 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_3_6                 (3 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_UCLK                      (1 &lt;&lt; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_CAMCLK_MASK               (0xf &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_CAMCLK_SEL                (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_HCLK3_HALF                (1 &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_HCLK4_HALF                (1 &lt;&lt; 9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_DVSEN                     (1 &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*return HCLK frequency*/</span></span><br><span class="line">ulong <span class="title function_">get_HCLK</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C24X0_CLOCK_POWER * <span class="type">const</span> clk_power = S3C24X0_GetBase_CLOCK_POWER();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> clkdiv;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> camdiv;</span><br><span class="line">  <span class="type">int</span> hdiv = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*同时支持S3C2410和S3C2440*/</span></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)</span><br><span class="line">    <span class="keyword">return</span> ((clk_power-&gt;CLKDIVN &amp; <span class="number">0x2</span>) ? get_FCLK() / <span class="number">2</span> : getFCLK());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    clkdiv = clk_power-&gt;CLKDIVN;</span><br><span class="line">    camdiv = clk_power-&gt;CAMDIVN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算分频比*/</span></span><br><span class="line">    <span class="keyword">switch</span>(clkdiv &amp; S3C2440_CLKDIVN_HDIVN_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_1:</span><br><span class="line">        hdiv = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_2:</span><br><span class="line">        hdiv = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_4_8:</span><br><span class="line">        hdiv = (camdiv &amp; S3C2440_CAMDIVN_HCLK4_HALF) ? <span class="number">8</span> : <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_3_6:</span><br><span class="line">        hdiv = (camdiv &amp; S3C2440_CAMDIVN_HCLK3_HALF) ? <span class="number">6</span> : <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_FCLK() / hdiv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*return PCLK frequence*/</span></span><br><span class="line">ulong <span class="title function_">getPCLK</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C24X0_CLOCK_POWER * <span class="type">const</span> clk_power = S3C24X0_GetBase_CLOCK_POWER();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> clkdiv;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> camdiv;</span><br><span class="line">  <span class="type">int</span> hdiv = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*同时支持S3C2410和S3C2440*/</span></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)</span><br><span class="line">    <span class="keyword">return</span> ((clk_power-&gt;CLKDIVN &amp; <span class="number">0x1</span>) ? get_HCLK() / <span class="number">2</span> : getHCLK());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    clkdiv = clk_power-&gt;CLKDIVN;</span><br><span class="line">    camdiv = clk_power-&gt;CAMDIVN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算分频比*/</span></span><br><span class="line">    <span class="keyword">switch</span>(clkdiv &amp; S3C2440_CLKDIVN_HDIVN_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_1:</span><br><span class="line">        hdiv = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_2:</span><br><span class="line">        hdiv = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_4_8:</span><br><span class="line">        hdiv = (camdiv &amp; S3C2440_CAMDIVN_HCLK4_HALF) ? <span class="number">8</span> : <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_3_6:</span><br><span class="line">        hdiv = (camdiv &amp; S3C2440_CAMDIVN_HCLK3_HALF) ? <span class="number">6</span> : <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_FCLK() / hdiv / ((clkdiv &amp; S3C2440_CLKDIVN_PDIVN)?<span class="number">2</span>:<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在重新执行“make 100ask24x0_config”和“make all”生成的U-Boot.bin文件既可以运行于S3C2410开发板，也可以运行于S3C2440开发板。将它烧录进入NOR Flash后启动，就可以在串口工具中看到提示信息，可以输入各种命令操作U-Boot了。</p>
<h4 id="选择NOR-Flash的型号"><a href="#选择NOR-Flash的型号" class="headerlink" title="选择NOR Flash的型号"></a>选择NOR Flash的型号</h4><p>但是，现在还无法通过U-Boot命令烧写NOR Flash。本书所用开发板中的NOR Flash型号为AM29LV800，而配置文件<code>include/configs/a00ask24x0.h</code>中的默认型号为AM29LV400。修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_AMD_LV400 1  <span class="comment">//uncomment this if you have a LV400 flash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_AMD_LV800 1  <span class="comment">//uncomment this if you have a LV800 flash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">改为</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_AMD_LV400 1  <span class="comment">//uncomment this if you have a LV400 flash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_AMD_LV800 1  <span class="comment">//uncomment this if you have a LV800 flash</span></span></span><br></pre></td></tr></table></figure>
<p>本例子中NOR Flash的操作函数在<code>board/100ask24x0/flash.c</code>中实现，它支持AM29LV400y和AM29LV800。对于其他型号的NOR Flash，如果符合CFI接口标准，则可以在使用<code>drivers/cfi_flash.c</code>中的接口函数；否则，只好自己编写了。如果要使用<code>cfi_flash.c</code>，如下修改两个文件：<br>在<code>include/configs/100ask24x0.h</code>中增加以下一行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_FLASH_CFI_DRIVER 1</span></span><br></pre></td></tr></table></figure>
<p>在<code>board/100ask24x0/Makefile</code>去掉flash.o:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COBJS :=  <span class="number">100</span>ask24x0.o flash.o</span><br><span class="line">改为</span><br><span class="line">COBJS :=  <span class="number">100</span>ask24x0.o </span><br></pre></td></tr></table></figure>
<p>修改好对NOR Flash的支持后，重新编译U-Boot：make clean、make all。运行后可以在串口中看到如下字样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Flash: <span class="number">1</span>MB</span><br></pre></td></tr></table></figure>
<p>现在可以使用loadb、loady等命令通过串口下载文件，然后使用erase、cp命令分别擦除、烧写NOR Flash了，它们的效率比JTAG高好几倍。</p>
<h3 id="支持串口xmodem协议"><a href="#支持串口xmodem协议" class="headerlink" title="支持串口xmodem协议"></a>支持串口xmodem协议</h3><p>上面的loadb命令需要配合Linux下的kermit工具来使用，loady命令通过串口ymodem协议来传输文件。Windows工具SecureCRT只支持xmodem和zmodem。现在修改代码对xmodem的支持，即增加一个命令loadx。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 支持xmodem */</span></span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">    loadx,<span class="number">3</span>,<span class="number">0</span> do_load_serial_bin,</span><br><span class="line">    <span class="string">&quot;loadx - load binary file over serial line (xmodem mode)\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[ off ] [ baud ]\n&quot;</span></span><br><span class="line">    <span class="string">&quot; -load binary file over serial line&quot;</span></span><br><span class="line">    <span class="string">&quot;with offset &#x27;off&#x27; and baudrate &#x27;baud&#x27;\n&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>其次，在<code>do_load_serial_bin</code>函数中增加对loadx命令的处理分支。也是依照loady来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*支持xmodem*/</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;loadx&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;## Ready for binary (xmodem) download to 0x%081X at %d bps...\n&quot;</span>,offset,load_baudrate);</span><br><span class="line">  addr = load_serial_xmodem(offset);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;loady&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;## Ready for binary (ymodem) download to 0x%081X at %d bps...\n&quot;</span>,offset,load_baudrate);</span><br><span class="line">  addr = load_serial_ymodem(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2-5行就是为loadx命令增加的代码。<br>第4行调用<code>load_serial_xmodem</code>函数，它是依照<code>load_serial_ymodem</code>实现的一个新函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (CONFIG_COMMANDS &amp; CFG_CMD_LOADB)</span></span><br><span class="line"><span class="comment">/*支持xmodem*/</span></span><br><span class="line"><span class="type">static</span> ulong <span class="title function_">load_serial_xmodem</span><span class="params">(ulong offset)</span>;</span><br><span class="line"><span class="type">static</span> ulong <span class="title function_">load_serial_ymodem</span><span class="params">(ulong offset)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*支持xmodem*/</span></span><br><span class="line"><span class="type">static</span> ulong <span class="title function_">load_serial_xmodem</span><span class="params">(ulong offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> xmodemBuf[<span class="number">1024</span>];               <span class="comment">//原来是ymodemBuf，这只是为了与函数名称一致</span></span><br><span class="line"></span><br><span class="line">  info.mode = xyzmodem_xmodem;        <span class="comment">//原来是xyzmodem_ymodem，对应ymodem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在开头增加<code>load_serail_xmodem</code>函数的声明，然后复制<code>load_serial_ymodem</code>函数为<code>load_serial_xmodem</code>。稍作修改：</p>
<ol>
<li>将局部数组ymodemBuf改名为xmodemBuf，并在后面使用到的地方统一修改。这只是为了与函数名称一致。</li>
<li>info.mode的值从<code>xyzModem_ymodem</code>改为<code>xyzModem_xmodem</code>。<br>重新编译、烧写U-Boot.bin后，就可以使用laodx命令下载文件了。</li>
</ol>
<h3 id="支持网卡芯片CS8900"><a href="#支持网卡芯片CS8900" class="headerlink" title="支持网卡芯片CS8900"></a>支持网卡芯片CS8900</h3><p>使用串口来传输文件的速率太低，现在增加对网卡芯片CS8900的支持。<br>本书使用开发板的网卡芯片CS8900的连接方式与smdk2410完全一样，所以现在的U-Boot中已经支持CS8900了，它的驱动程序为<code>drivers/cs8900.c</code>。只要在U-Boot控制界面中稍加配置就可以使用网络功能。使用网络之前，先设置开发板IP地址、MAC地址，服务器IP地址，比如可以在U-Boot中执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setenv ipdaar <span class="number">192.168</span><span class="number">.1</span><span class="number">.17</span></span><br><span class="line">setenv ethaddr <span class="number">08</span>:<span class="number">00</span>:<span class="number">3</span>e:<span class="number">26</span>:<span class="number">0</span>a:<span class="number">5b</span></span><br><span class="line">setenv serverip <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>然后就可以使用tftp或nfs命令下载文件了，注意：服务器上要开启tftp或nfs服务。比如可以使用如下命令将U-Boot.bin命令下载到内存0x30000000中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x30000000</span> U-Boot.bin</span><br><span class="line">或</span><br><span class="line">tftp <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/U-Boot.bin</span><br></pre></td></tr></table></figure>
<p>可以修改配置文件，让网卡的各个默认值就是上面设置的值。在此之前，先了解网卡的相关文件，这有助于移植代码以支持其他连接方式的CS8900。<br>首先，CS8900接在S3C2410、S3C2440的BANK3，位宽16，使用WAIT、nBE信号。在设置存储控制器时要设置好BANK3，代码在<code>board/100ask24x0/lowlevel_init.S</code>中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> B3_BWSCON           (DW16 + WAIT + UBLB)</span></span><br><span class="line">... ...</span><br><span class="line"><span class="comment">/* 时序参数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tacs             (0x0) <span class="comment">/*0clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tcos             (0x3) <span class="comment">/*4clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tacc             (0x7) <span class="comment">/*14clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tcoh             (0x1) <span class="comment">/*1clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tah              (0x0) <span class="comment">/*0clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tacp             (0x3) <span class="comment">/*6clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_PMC              (0x0) <span class="comment">/*normal*/</span></span></span><br></pre></td></tr></table></figure>
<p>接下来，还要确定CS8900的基地址。这在配置文件<code>include/configs/100ask24x0.h</code>中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_DRIVER_CS8900            1           <span class="comment">/* 使用CS8900 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CS8900_BASE                     0x19000300  <span class="comment">/* 基地址 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CS8900_BUS16                    1           <span class="comment">/* 位宽为16 */</span></span></span><br></pre></td></tr></table></figure>
<p>网卡CS8900的访问基址为0x1900000，之所以再偏移0x300是由它的特性决定的。<br>最后，还是在配置文件<code>include/config/100ask24x0.h</code>中定义CS8900的各个默认地址，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ETHADDR        08:00:3e:26:0a:5b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_NETMASK        255.255.255.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_IPADDR         192.168.1.17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SERVERIP       192.168.1.11 </span></span><br></pre></td></tr></table></figure>
<p>如果要增加ping命令，还可以在配置文件<code>include/configs/100ask24x0.h</code>的宏CONFIG_COMMANDS中增加CFG_CMD_PING，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_COMMANDS (CONFIG_CMD_DFL | CFG_CMD_CACHE | CFG_CMD_PING \</span></span><br><span class="line"><span class="meta">                        | ... ... \</span></span><br><span class="line"><span class="meta">                        )</span></span><br></pre></td></tr></table></figure>
<h3 id="支持NAND-Flash"><a href="#支持NAND-Flash" class="headerlink" title="支持NAND Flash"></a>支持NAND Flash</h3><p>U-Boot 1.1.6中对NAND Flash的支持有新旧两套代码，新代码在<code>drivers/nand</code>目录下，旧代码在<code>drivers/nand_legacy</code>目录下。文档<code>doc/README.md</code>对这两套代码有所说明：使用旧代码需要定义更多的宏，而新代码移植自Linux内核2.6.12，它更加智能，可以自动识别更多型号的NAND Flash。目前之所以还保留旧的代码，是因为两个目标板NETTA、NETTA_ISDN使用JFFS文件系统，它们还依赖于旧代码。当相关的功能移植到新代码之后，旧代码将从U-Boot中移除。<br>要让U-Boot支持NAND Flash，首先在配置文件<code>include/configs/100ask24x0.h</code>的宏CONFIG_COMMANDS中增加CFG_CMD_NAND，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_COMMANDS                     \</span></span><br><span class="line"><span class="meta">                        (CONFIG_CMD_DEL   | \</span></span><br><span class="line"><span class="meta">                        CFG_CMD_CACHE     | \</span></span><br><span class="line"><span class="meta">                        CFG_CMD_PING      | \</span></span><br><span class="line"><span class="meta">                        CFG_CMD_NAND      | \</span></span><br><span class="line"><span class="meta">                        ... ... )</span></span><br></pre></td></tr></table></figure>
<p>然后选择使用哪套代码：在配置文件中定义宏CFG_NAND_LEGACY则使用旧代码，否则使用新代码。<br>使用旧代码时，需要实现<code>drivers/nand_legacy/nand_legacy.c</code>中使用到的各种宏，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NAND_WAIT_READY(nand)       <span class="comment">/* 等待Nand Flash的状态为“就绪”，代码依赖于具体的开发板 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_NAND_COMMAN(d,adr)    <span class="comment">/* 写NAND Flash命令，代码依赖于具体的开发板 */</span></span></span><br></pre></td></tr></table></figure>
<p>本书使用新代码，下面讲述移植过程。<br>代码的移植没有现成的文档，可以在配置文件<code>include/configs/100ask24x0.h</code>的宏CONFIG_COMMANDS中增加CFG_CMD_NAND后就编译代码，然后一个一个的解决出现的的错误。编译结果中出现的错误和警告如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand.h: <span class="number">412</span>: error: <span class="string">&#x27;NAND_MAX_CHIPS&#x27;</span> undeclared <span class="title function_">here</span> <span class="params">(not in a function)</span></span><br><span class="line">nand.h: 35: error: &#x27;CFG_MAX_NAND_DEVICE&#x27; undeclared <span class="title function_">here</span> <span class="params">(not in a function)</span></span><br><span class="line">nand.h: 38: error: &#x27;CFG_NAND_BASE&#x27; undeclared <span class="title function_">here</span> <span class="params">(not in a function)</span></span><br><span class="line">nand.h: 35: error: storage size of &#x27;nand_info&#x27; isn&#x27;t known</span><br><span class="line">nand.h: 37: error: storage size of &#x27;nand_chip&#x27; isn&#x27;t known</span><br><span class="line">nand.h: 38: error: storage size of &#x27;base_address&#x27; isn&#x27;t known</span><br><span class="line">nand.h: 37: warning: &#x27;nand_chip&#x27; defined but not used</span><br><span class="line">nand.h: 38: warning: &#x27;base_address&#x27; defined but not used</span><br></pre></td></tr></table></figure>
<p>在配置文件<code>include/configs/100ask24x0.h</code>中增加如下3个宏就可以解决上述错误。在Flash的驱动程序中，设备是逻辑上的概念，表示一组相同结构、访问函数相同的Flash芯片。在本书所用的开发板中，只有一个NAND Flash芯片，所以设备数为1，芯片数也为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_NAND_BASE           0 <span class="comment">/* 无实际意义：基地址，这在board_nand_init中重新指定 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_MAX_NAND_DEVICE     1 <span class="comment">/* NAND Flash “设备”的数目为1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAND_MAX_CHIPS          1 <span class="comment">/* 每个NAND Flash “设备”由1个NAND Flash“芯片”组成 */</span></span></span><br></pre></td></tr></table></figure>
<p>修改配置文件后再次编译，现在只有一个错误了，“<code>board_nand_init</code>函数未定义”，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand.c:<span class="number">50</span>: undefined reference to <span class="string">&#x27;board_nand_init&#x27;</span></span><br></pre></td></tr></table></figure>
<p>调用<code>board_nand_init</code>函数的过程为：NAND Flash的初始化入口函数是<code>nand_init</code>，它在<code>lib_arm/board.c</code>的<code>start_armboot</code>函数中被调用；<code>nand_init</code>函数在<code>drivers/nand/nand.c</code>中实现，它调用相同文件中的<code>nand_init_chip</code>函数；<code>nand_init_chip</code>函数首先调用<code>board_nand_init</code>函数来初始化NAND Flash设备，最后才是统一的识别过程。<br>从<code>board_nand_init</code>函数的名称就可以知道它是平台&#x2F;开发板相关的函数，需要自己编写。本书在<code>cpu/arm920t/s3c24x0</code>目录下新建一个文件nand_flash.c，在里面针对S3C2410、S3C2440实现了统一的<code>board_nand_init</code>函数。<br>在编写<code>board_nand_init</code>函数之前，需要针对S3C2410、S3C2440 Nand Flash控制器的不同来定义一些数据结构和函数：</p>
<ol>
<li>在<code>include/s3c24x0.h</code>文件中增加S3C2440_NAND数据结构。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typdef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    S3C24X0_REG32   NFCONF;</span><br><span class="line">    S3C24X0_REG32   NFCONT;</span><br><span class="line">    S3C24X0_REG32   NFCMD;</span><br><span class="line">    S3C24X0_REG32   NFADDR;</span><br><span class="line">    S3C24X0_REG32   NFDATA;</span><br><span class="line">    S3C24X0_REG32   NFMECCD0;</span><br><span class="line">    S3C24X0_REG32   NFMECCD1;</span><br><span class="line">    S3C24X0_REG32   NFSECCD;</span><br><span class="line">    S3C24X0_REG32   NFSTAT;</span><br><span class="line">    S3C24X0_REG32   NFESTAT0;</span><br><span class="line">    S3C24X0_REG32   NFESTAT1;</span><br><span class="line">    S3C24X0_REG32   NFMECC0;</span><br><span class="line">    S3C24X0_REG32   NFMECC1;</span><br><span class="line">    S3C24X0_REG32   NFSECC;</span><br><span class="line">    S3C24X0_REG32   NFSBLK;</span><br><span class="line">    S3C24X0_REG32   NFEBLK;</span><br><span class="line">&#125;<span class="comment">/* __attribute__((__packed__)) */</span>S3C2440_NAND;</span><br></pre></td></tr></table></figure></li>
<li>在<code>include/s3c2410.h</code>文件中仿照<code>S3C2410_GetBase_NAND</code>函数定义<code>S3C2440_GetBase_NAND</code>函数。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* for s3c2440 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> S3C2440_NAND * <span class="type">const</span> <span class="title function_">S3C2440_GetBase_NAND</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (S3C2440_NAND * <span class="type">const</span>)S3C2410_NAND_BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
既然新的NAND Flash代码是从Linux 内核2.6.12中移植来的，那么<code>cpu/arm920t/s3c24x0/nand_flash.c</code>文件也可以仿照内核中对S3C2410、S3C2440的NAND Flash进行初始化的<code>drivers/mtd/nand/s3c2410.c</code>文件来编写。为了方便阅读，先把<code>cpu/arm920t/s3c24x0/nand_flash.c</code>文件的代码全部列出来，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s3c2410/s3c2440的NAND Flash控制器接口，</span></span><br><span class="line"><span class="comment">修改自Linux内核2.6.13文件 drivers/mtd/nand/s3c2410.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (CONFIG_COMMANDS &amp; CFG_CMD_NAND) &amp;&amp; !defined(CFG_NAND_LEGACY)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;s3c2410.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;nand.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_NFSTAT_READY          (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_NFCONF_nFCE           (1&lt;&lt;11)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_NFSTAT_READY          (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_NFCONF_nFCE           (1&lt;&lt;1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* S3C2410: NAND Flash 的片选函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2410_nand_select_chip</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd,<span class="type">int</span> chip)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(chip == <span class="number">-1</span>)&#123;</span><br><span class="line">    s3c2410nand-&gt;NFCONF |= S3C2410_NFCONF_nFCE;           <span class="comment">//禁止片选信号</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    s3c2410nand-&gt;NFCONF |= ~S3C2410_NFCONF_nFCE;          <span class="comment">//使能片选信号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S3C2410: 命令和控制函数</span></span><br><span class="line"><span class="comment">注意，这个函数仅仅是根据各种命令来修改“写地址”IO_ADDR_W的值（这称为tglx方法），这种方法使得平台/开发板相关的代码很简单。</span></span><br><span class="line"><span class="comment">真正发出命令是在上一层NAND Flash的统一的驱动中实现，它首先调用这个函数修改“写地址”，然后才分别发出控制、地址、数据序列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2410_nand_hwcontrol</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd,<span class="type">int</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">chip</span> =</span> mtd-&gt;priv;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETNCE:</span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_CLRNCE:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: called for NCE\n&quot;</span>,__FUNCTION__);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETCLE:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFCMD;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETALE:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFADDR;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NAND_CTL_CLRCLE */</span></span><br><span class="line">    <span class="comment">/* NAND_CTL_CLRALE */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFDATA;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S3C2410: 查询NAND Flash状态</span></span><br><span class="line"><span class="comment">返回值：0表示忙，1表示就绪</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c2410_nand_devread</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (s3c2410nand-&gt;NFSTAT &amp; S3C2410_NFSTAT_READY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* S3C2440: NAND Flash的片选函数  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2440_nand_select_chip</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd,<span class="type">int</span> chip)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(chip == <span class="number">-1</span>)&#123;</span><br><span class="line">    s3c2440nand-&gt;NFCONT |= S3C2440_NFCONT_nFCE;       <span class="comment">//禁止片选信号</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    s3c2440nand-&gt;NFCONT &amp;= ~S3C2440_NFCONT_nFCE;      <span class="comment">//使能片选信号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* S3C2440: 命令和控制函数，与s3c2440_nand_hwcontrol函数类似 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2440_nand_hwcontrol</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd,<span class="type">int</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">chip</span> =</span> mtd-&gt;priv;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETNCE:</span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_CLRNCE:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: called for NCE\n&quot;</span>,__FUNCTION__);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETCLE:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFCMD;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETALE:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFADDR;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NAND_CTL_CLRCLE */</span></span><br><span class="line">    <span class="comment">/* NAND_CTL_CLRALE */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFDATA;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S3C2440: 查询NAND Flash状态</span></span><br><span class="line"><span class="comment">返回值：0表示忙，1表示就绪</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c2440_nand_devready</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (s3c2440nand-&gt;NFSTAT &amp; S3C2440_NFSTAT_READY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NAND Flash 硬件初始化：</span></span><br><span class="line"><span class="comment">设置NAND Flash 的时序，使能NAND Flash控制器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2440_nand_inithw</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH0  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH1  2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//使能NAND Flash控制器，初始化ECC，使能片选信号，设置时序</span></span><br><span class="line">    s3c2410nand-&gt;NFCONF = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">11</span>) | (TACLS &lt;&lt; <span class="number">8</span>) | (TWRPH0 &lt;&lt; <span class="number">4</span>) | (TWRPH1 &lt;&lt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置时序</span></span><br><span class="line">    s3c2440nand-&gt;NFCONF = (TACLS &lt;&lt; <span class="number">12</span>) | (TWRPH0 &lt;&lt; <span class="number">8</span>) | (TWRPH1 &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//初始化ECC，使能NAND Flash控制器，使能片选信号</span></span><br><span class="line">    s3c2440nand-&gt;NFCONT = (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">被drivers/nand/nand.c调用，初始化NAND Flash硬件，初始化访问接口函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">board_nand_init</span><span class="params">(<span class="keyword">struct</span> nand_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  s3c24x0_nand_inithw();                                   <span class="comment">//NAND Flash  硬件初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)&#123;</span><br><span class="line">    chip-&gt;IO_ADDR_R = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFDATA;</span><br><span class="line">    chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFDATA;</span><br><span class="line">    chip-&gt;hwconrol  = s3c2410_nand_hwcontrol;</span><br><span class="line">    chip-&gt;dev_ready = s3c2410_nand_devready;</span><br><span class="line">    chip-&gt;select_chip = s3c2410_nand_select_chip;</span><br><span class="line">    chip-&gt;options = <span class="number">0</span>;<span class="comment">//设置位宽等，位宽为8</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    chip-&gt;IO_ADDR_R = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFDATA;</span><br><span class="line">    chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFDATA;</span><br><span class="line">    chip-&gt;hwconrol  = s3c2440_nand_hwcontrol;</span><br><span class="line">    chip-&gt;dev_ready = s3c2440_nand_devready;</span><br><span class="line">    chip-&gt;select_chip = s3c2440_nand_select_chip;</span><br><span class="line">    chip-&gt;options = <span class="number">0</span>;<span class="comment">//设置位宽等，位宽为8</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chip-&gt;eccmode =  NAND_ECC_SOFT;                           <span class="comment">//ECC校验方式：软件ECC</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
文件中分别针对S3C2410、S3C2440实现了NAND Flash最底层访问函数，并进行了一些硬件的设置（比如时序、使能NAND Flash控制器等）。新的代码对NAND Flash的封装做的很好，只要向上提供底层初始化函数<code>board_nand_init</code>来设置好平台&#x2F;开发板的相关的初始化、提供底层接口即可。<br>最后，只要将新建的nand_flash.c文件编入U-Boot中就可以擦除、读写NAND Flash了。如下修改<code>cpu/arm920t/s3c24x0/Makefile</code>文件即可。<br>修改前：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COBJS = i2c.o interrupts.o serial.o speed.o \</span><br><span class="line">        usb_ohci.o</span><br></pre></td></tr></table></figure>
修改后：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COBJS = i2c.o interrupts.o serial.o speed.o \</span><br><span class="line">        usb_ohci.o  nand_flash.o</span><br></pre></td></tr></table></figure>
现在，可以使用新编译的U-Boot.bin烧写内核映像到NAND Flash中去了。</li>
</ol>
<h3 id="支持烧写yaffs文件系统映像"><a href="#支持烧写yaffs文件系统映像" class="headerlink" title="支持烧写yaffs文件系统映像"></a>支持烧写yaffs文件系统映像</h3><p>在实际生产中，可以通过烧片器等手段将内核、文件系统映像烧入固态存储设备中，Bootloader不需要具备烧写功能。但为了方便开发，通常在Bootloader中增加烧写内核、文件系统映像文件的功能。<br>增加了NAND Flash功能的U-Boot 1.1.6已经可以通过“nand write …”、“nand write.jffs2…”等命令来烧写内核，烧写cramfs、jffs2文件系统映像文件。但是在NAND Flash上，yaffs文件系统的性能更佳，下面增加“nand write.yaffs…”命令以烧写yaffs文件系统映像文件。<br>“nand write.yaffs…”字样的命令中，“nand”是具体命令，“write.yaffs…”是参数。nand命令在<code>common/cmd_nand.c</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(nand,<span class="number">5</span>,<span class="number">1</span>,do_nand,</span><br><span class="line">          <span class="string">&quot;nand - NAND sub-system\n&quot;</span>,</span><br><span class="line">          <span class="string">&quot;info                 -show available NAND devices\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand device [dev]    -show or set current device\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand read[.jffs2]    -addr off|partition size \n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand write[.jffs2]   -addr off|partition size - read/write &#x27;size&#x27; bytes starting\n&quot;</span></span><br><span class="line">          <span class="string">&quot;at offset &#x27;off&#x27; to/from memory address &#x27;addr&#x27;\n&quot;</span></span><br><span class="line">          ...</span><br><span class="line">          )</span><br></pre></td></tr></table></figure>
<p>先在其中增加“nand write.yaffs…”的使用说明，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(nand,<span class="number">5</span>,<span class="number">1</span>,do_nand,</span><br><span class="line">          <span class="string">&quot;nand - NAND sub-system\n&quot;</span>,</span><br><span class="line">          <span class="string">&quot;info                 -show available NAND devices\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand device [dev]    -show or set current device\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand read[.jffs2]    -addr off|partition size \n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand write[.jffs2]   -addr off|partition size - read/write &#x27;size&#x27; bytes starting\n&quot;</span></span><br><span class="line">          <span class="string">&quot;at offset &#x27;off&#x27; to/from memory address &#x27;addr&#x27;\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand read.yaffs addr off size - read the &#x27;size&#x27; byte yaffs image starting\n&quot;</span></span><br><span class="line">          <span class="string">&quot;at offset &#x27;off&#x27; to memory address &#x27;addr&#x27;\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand write.yaffs addr off size - write the &#x27;size&#x27; byte yaffs image starting\n&quot;</span></span><br><span class="line">          <span class="string">&quot;at offset &#x27;off&#x27; from memory address &#x27;addr&#x27;\n&quot;</span></span><br><span class="line">          ...</span><br><span class="line">          )</span><br></pre></td></tr></table></figure>
<p>然后，在nand命令的处理函数<code>do_nand</code>中增加对“write.yaffs…”的支持。<code>do_nand</code>函数仍在<code>common/cmd_nand.c</code>中实现，代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">strcmp</span>(s,<span class="string">&quot;.yaffs&quot;</span>))&#123;</span><br><span class="line">  <span class="keyword">if</span>(read)&#123;</span><br><span class="line">    <span class="comment">/*read*/</span></span><br><span class="line">    <span class="type">nand_read_options_t</span> opts;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;opts,<span class="number">0</span>,<span class="keyword">sizeof</span>(opts));</span><br><span class="line">    opts.buffer = (u_char *)addr;</span><br><span class="line">    opts.length = size;</span><br><span class="line">    opts.offset = off;</span><br><span class="line">    opts.readoob = <span class="number">1</span>;</span><br><span class="line">    opts.quiet = quiet;</span><br><span class="line">    ret = nand_read_opts(nand,&amp;opts);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">/*write*/</span></span><br><span class="line">    <span class="type">nand_write_options_t</span> opts;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;opts,<span class="number">0</span>,<span class="keyword">sizeof</span>(opts));</span><br><span class="line">    opts.buffer = (u_char *)addr; <span class="comment">//yaffs 文件系统映像存放的地址</span></span><br><span class="line">    opts.length = size;           <span class="comment">//长度</span></span><br><span class="line">    opts.offset = off;            <span class="comment">//要烧写到的NAND Flash的偏移地址</span></span><br><span class="line">    <span class="comment">/* opts.foreceyaffs = 1 */</span>    <span class="comment">//计算ECC码的方法，没有使用</span></span><br><span class="line">    opts.noecc = <span class="number">1</span>;               <span class="comment">//不需要计算ECC，yaffs映像中有OOB数据</span></span><br><span class="line">    opts.writeoob = <span class="number">1</span>;            <span class="comment">//写OOB区</span></span><br><span class="line">    opts.blockalign = <span class="number">1</span>;          <span class="comment">//每个“逻辑块”大小为1个“物理块”</span></span><br><span class="line">    opts.quiet = quiet;           <span class="comment">//是否打印提示信息</span></span><br><span class="line">    opts.skipfirstblk = <span class="number">1</span>;        <span class="comment">//跳过第一个可用块</span></span><br><span class="line">    ret = nand_write_opts(nand,&amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始分析这段代码，即“nand write.yaffs…”命令的实现。<br>NAND Flash 每一页大小为（512 + 16）字节（还有其他格式的NAND Flash，比如每页大小为（256 + 8）、（2048 + 64）等），其中的512字节就是一般存储数据的区域，16字节称为OOB（Out Of Band）区。通常在OOB区存放坏块标记、前面512字节的ECC校验码等。<br>cramfs、jffs2文件系统映像文件中没有OOB区的内容，如果将它们烧入NOR Flash中，则是简单的“平铺”关系；如果将它们烧入NAND Flash中，则NAND Flash的驱动程序首先根据OOB的标记略过坏块，然后将一页数据（512字节）写入后，还会计算这512字节的ECC校验码，最会将它写入OOB区，如此循环。cramfs、jffs2文件系统映像文件的大小通常是512的整数倍。<br>而yaffs文件系统映像文件的格式则跟它们不同，文件本身就包含了OOB区的数据（里面有坏块标记、ECC校验码、其他yaffs相关的信息）。所以烧写时，不需要再计算ECC值，首先检查是否坏块（是则跳过），然后写入512字节的数据，最后写入16字节的OOB数据，如此循环。yaffs文件系统映像文件的大小是（512 + 16）的整数倍。<br>第16-18行设置源地址、目的地址、长度。烧写yaffs文件系统映像之前，一般通过网络将它下载到内存的某个地址处，比如0x30000000，然后通过类似“nand write.yaffs 0x30000000 0x00A00000 $(filesize)”的命令烧到NAND Flash的偏移地址0x00A00000处。对于这个命令，第16行中的“opts.buffer &#x3D; 0x30000000”，第17行中的“opts.length &#x3D; $(filesize)”，就是前面下载文件的大小，第18行中的“opts.offset &#x3D; 0x00A00000”。<br>这里列出不使用的第19行，是因为“opts.forceyaffs”这个名字，很有欺骗性，它其实是指计算ECC校验码的一种方法。烧写yaffsw文件系统映像时，不需要计算ECC校验码。<br>第20-21行指定烧写数据时不计算ECC校验码，而是烧入文件中的OOB数据。<br>第22行指定“逻辑块”的大小，“逻辑块”可以由多个“物理块”组成，在yaffs文件系统映像中，它们是1：1的关系。<br>第24行的“opts.skipfirstblk”是新加的项，<code>nand_write_options_t</code>结构中没有<code>skipfirstblk</code>成员。它表示烧写时跳过第一个可以的逻辑块，这是由yaffs系统的特性决定的。<br>既然<code>skipfirstblk</code>是在<code>nand_write_options_t</code>结构中新加的项，那么就要重新定义<code>nand_write_options_t</code>结构，并在下面调用的<code>nand_write_opts</code>函数中对它进行处理。<br>首先在<code>include/nand.h</code>中进行如下修改，增加<code>skipfirstblk</code>成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nand_write_options</span> &#123;</span></span><br><span class="line">       u_char *buffer;              <span class="comment">//memory block containing image to write</span></span><br><span class="line">       ulong length;                <span class="comment">//number of bytes to write</span></span><br><span class="line">       ulong offset;                <span class="comment">//start address in NAND</span></span><br><span class="line">       <span class="type">int</span> quiet;                   <span class="comment">//dont display progress message</span></span><br><span class="line">       <span class="type">int</span> autopalce;               <span class="comment">//if true use auto oob layout</span></span><br><span class="line">       <span class="type">int</span> forcejffs2;              <span class="comment">//force jffs2 oob layout</span></span><br><span class="line">       <span class="type">int</span> forceyaffs;              <span class="comment">//force yaffs oob layout</span></span><br><span class="line">       <span class="type">int</span> noecc;                   <span class="comment">//write without ecc</span></span><br><span class="line">       <span class="type">int</span> writeoob;                <span class="comment">//image contain oob data</span></span><br><span class="line">       <span class="type">int</span> pad;                     <span class="comment">//pad to page size</span></span><br><span class="line">       <span class="type">int</span> blockalign;              <span class="comment">//1 | 2 | 4 set multiple of eraseblocks to align to </span></span><br><span class="line">       <span class="type">int</span> skipfirstblk;            <span class="comment">//新加，烧写时跳过第一个可用的逻辑块</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_write_options</span> <span class="title">nand_write_options_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>然后，修改<code>nand_write_opts</code>函数，增加对skipfirstblk成员的支持。它在<code>drivers/nand/nand_utils.c</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nand_write_opts</span><span class="params">(<span class="type">nand_info_t</span> *meminfo,<span class="type">const</span> <span class="type">nand_write_options_t</span> *opts)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="type">int</span> skipfirstblk = opts-&gt;skipfirstblk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(blockstart != (mtdoffset &amp; (~erasesize_blockalign + <span class="number">1</span>)))&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(baderaseblcok)&#123;</span><br><span class="line">      mtdoffset = blockstart + erasesize_blockalign;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行上面的移植之后，U-Boot已经支持烧写yaffs文件系统映像了。由于前面设置“opts.noecc &#x3D; 1”不使用ECC校验码，在烧写过程中会出现很多的提示信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Writing data without ECC to NAND-FLASH is not recommended</span><br></pre></td></tr></table></figure>
<p>修改前：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> NAND_ECC_NONE:</span><br><span class="line">printk(KERNEL_WARING<span class="string">&quot;Writing data without ECC to NAND-FLASH is not recommended\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> NAND_ECC_NONE:</span><br><span class="line"><span class="comment">// printk(KERNEL_WARING&quot;Writing data without ECC to NAND-FLASH is not recommended\n&quot;);</span></span><br></pre></td></tr></table></figure>
<h3 id="修改默认配置参数以方便使用"><a href="#修改默认配置参数以方便使用" class="headerlink" title="修改默认配置参数以方便使用"></a>修改默认配置参数以方便使用</h3><p>前面移植网卡芯片CS8900时，已经设置过默认IP地址等。为了使用U-Boot时减少一些设置，现在修改配置文件<code>include/configs/100ask24x0.h</code>，增加默认配置参数，其中一些在移植过程中已经增加的选项这里也再次说明。</p>
<ol>
<li>Linux启动参数<br>增加如下3个宏：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SETUP_MEMORY_TAGS        1       <span class="comment">//向内核传递内存分布信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CMDLINE_TAG              1       <span class="comment">//向内核传递命令行参数</span></span></span><br><span class="line"><span class="comment">//默认命令行参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTTAGS                 <span class="string">&quot;noinited root=/dev/mtdblack 2 init=/linuxrc console=ttySAC0&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>自动启动命令<br>增加如下2个宏：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动启动前延时3s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTDELAY        3</span></span><br><span class="line"><span class="comment">//自动启动的命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND      <span class="string">&quot;nboot 0x32000000 0 0; bootm 0x32000000&quot;</span></span></span><br></pre></td></tr></table></figure>
自动启动时（开机3s内无输入），首先执行“nboot 0x32000000 0 0”命令将第0个NAND Flash的偏移地址0上的映像文件复制到内存0x32000000中；然后执行“bootm 0x32000000”命令启动内存中的映像。</li>
<li>默认网络设置<br>根据具体网络环境增加、修改下面4个宏<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ETHADDR  08:00:3e:26:0a:5b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_NETMASK  255.255.255.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_IPADDR   192.168.1.17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SERVERIP 192.168.1.11</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="U-Boot的常用命令"><a href="#U-Boot的常用命令" class="headerlink" title="U-Boot的常用命令"></a>U-Boot的常用命令</h2><h3 id="U-Boot的常用命令的用法"><a href="#U-Boot的常用命令的用法" class="headerlink" title="U-Boot的常用命令的用法"></a>U-Boot的常用命令的用法</h3><p>进入U-Boot的控制界面之后，可以运行各种命令，比如下载文件到内存，擦除、读写Flash，运行内存、NOR Flash、NAND Flash中的程序，查看、修改、比较内存中的数据等。<br>使用各种命令时，可以使用其开头的若干字母代替它。比如tftpboot命令，可以使用t、tf、tft、tftp等代替，只要其他命令不以这些字母开头即可。<br>当运行一个命令之后，如果它是可重复执行的（代码中使用U_BOOT_CMD定义这个命令时，第3个参数是1），若想再次运行可以直接输入回车。<br>U-Boot接受的数据都是十六进制，输入时可以省略前缀0x、0X。<br>下面介绍常用的命令：</p>
<ol>
<li><p>帮助命令help<br>运行help命令可以看到U-Boot中所有命令的作用，如果要查看某个命令的使用方法，运行“help 命令名”，比如“help bootm”。<br>可以使用“?”来代替help，比如直接输入“?”、“?bootm”。</p>
</li>
<li><p>下载命令<br>U-Boot支持串口下载、网络下载，相关命令有：loadb、loads、loadx、loady和tftpboot、nfs。<br>前几个串口下载命令使用方法相似，以loadx命令为例，它的用法为“loadx [off] [baud]”。“[]”表示里面的参数可以省略，off表示文件下载后存放的内存地址，baud表示使用的波特率。如果baud参数省略，则使用当前的波特率；如果off参数省略，存放的地址为配置文件中定义的宏CFG_LOAD_ADDR。<br>tftpboot命令使用TFTP协议从服务器下载文件，服务器的IP地址为环境变量serverip。用法为“tftpboot [loadAddress] [bootfilename]”，loadAddress表示文件下载后存放的内存地址，bootfilename表示要下载的文件的名称。如果loadAddress省略，存放的地址为配置文件中定义的宏CFG_LOAD_ADDR；如果bootfilename省略，则使用开发板的IP地址构造一个文件名，比如开发板IP为192.168.1.17，则默认的文件名为C0A80711.img。<br>nfs命令使用NFS协议下载文件，用法为“nfs [loadAddress] [host ip addr:bootfilename]”。“loadAddress、bootfilename”的意义与tftpboot命令一样，“host ip addr”表示服务器的IP地址，默认为环境变量serverip。<br>下载文件成功后，U-Boot会自动创建或更新环境变量filesize，它表示下载的文件的长度，可以在后续命令中使用”$(filesize)“来引用它。</p>
</li>
<li><p>内存操作命令<br>常用的命令有：查看内存命令md、修改内存命令mm、填充内存命令mw、复制命令cp。这些命令都可以带上后缀“.b”、“.w”或“.l”，表示以字节、字（2个字节）、双字（4个字节）为单位进行操作。比如“cp.l 30000000 31000000 2”将从开始地址0x3000000处，复制2个双字到开始地址为0x31000000的地方。<br>md命令用法为“md[.b,.w,.l] address [count]”，表示以字节、字或双字（默认为双字）为单位，显示地址address开始的内存数据，显示的数据个数为count。<br>mm命令用法为“mm[.b,.w,.l] address ”，表示以字节、字或双字（默认为双字）为单位，从地址address处开始修改内存数据。执行命令mm后，输入新数据后回车，地址会自动增加，按“Ctrl + C”键退出。<br>mw命令用法为“mw[.b,.w,.l] address value [count]”，表示以字节、字或双字（默认为双字）为单位，往开始地址为address的内存中填充count个数据，数据值为value。<br>cp命令用法为“cp[.b,.w,.l] source target count”，表示以字节、字或双字（默认为双字）为单位，往源地址source的内存复制count个数据到目的地址的内存。</p>
</li>
<li><p>NOR Flash操作命令<br>常用的命令有查看Flash信息的info命令、加&#x2F;解写保护命令protect、擦除命令erase。由于NOR Flash的接口与一般内存相似，所以一些内存命令可以在NOR Flash上使用，比如读NOR Flash时可以使用md、cp命令，写NOR Flash时可以使用cp命令（cp根据地址分辨出是NOR Flash，从而调用NOR Flash驱动完成写操作）。<br>直接运行“flinfo”即可看到NOR Flash的信息，有NOR Flash的型号、容量、各扇区的开始地址、是否只读等信息。比如对于本书基于的开发板，flinfo命令的结果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Bank # <span class="number">1</span>: AMD: <span class="number">1</span>x <span class="title function_">Amd29LV800BB</span><span class="params">(<span class="number">8</span>Mbit)</span></span><br><span class="line">Size: 1 MB in 19 Sectors</span><br><span class="line">Sector Start Address:</span><br><span class="line">00000000 <span class="params">(RO)</span> 00004000 <span class="params">(RO)</span> 00006000 <span class="params">(RO)</span> 00008000 <span class="params">(RO)</span> 00010000 <span class="params">(RO)</span></span><br><span class="line">00020000 <span class="params">(RO)</span> 00030000      00040000      00050000      00060000</span><br><span class="line">00070000      00080000      00090000      000A0000      000B0000</span><br><span class="line">000C0000      000D0000      000E0000      000<span class="title function_">F0000</span> <span class="params">(RO)</span></span><br></pre></td></tr></table></figure>
<p>其中的RO表示该扇区处于写保护状态，只读。<br>对于只读的扇区，在擦除、烧写它之前，要先接触写保护。最简单的命令为“protect off all”，解除所有的NOR Flash的写保护。<br>erase命令常用的格式为“erase start end”，擦除的地址范围为start<del>end；“erase start + len”，擦除的地址范围为start</del>（start + len - 1）；“erase all”，表示擦除所有NOR Flash。</p>
</li>
<li><p>NAND Flash操作命令<br>NAND Flash操作命令只有一个：nand，它根据不同的参数进行不同操作，比如擦除、读取、烧写等。<br>“nand info”查看NAND Flash信息。<br>“nand erase [clean] [off size]”擦除NAND Flash。加上“clean”时，表示在每个块的第一个扇区的OOB区写入清除标记；off、size表示要擦除的开始偏移地址的长度，如果省略off和size，表示要擦除整个NAND Flash。<br>“nand read [.jffs2] addr off size”从NAND Flash偏移地址off处读出size个字节的数据存放到开始地址为addr的内存中。是否加后缀“.jffs”的差别只是读操作时的ECC校验方法不同。<br>“nand write [.jffs2] addr off size”把开始地址为addr的内存中的size个字节数据写到NAND Flash的偏移地址off处。是否加后缀“.jffs”的差别只是写操作时的ECC校验方法不同。<br>“nand read.yaffs addr off size”从NAND Flash偏移地址off处读出size个字节的数据（包括OOB区域），存放到开始地址为addr的内存中。<br>“nand write.yaffs addr off size”把开始地址为addr的内存中的size个字节数据（其中有要写入OOB区域的数据）写到NAND Flash的偏移地址off处。<br>“nand dump off”将NAND Flash偏移地址off的一个扇区的数据打印出来，包括OOB数据。</p>
</li>
<li><p>环境变量命令<br>“printenv”命令打印全部环境变量，“printenv name1 name2……”打印名字为name1、name2、…的环境变量。<br>“setenv name value”设置名字为name的环境变量的值为value。<br>“setenv name”删除名字为name的环境变量。<br>上面的设置、删除操作只是在内存中进行，“saveenv”将更改后的所有环境变量写入NOR Flash中。</p>
</li>
<li><p>启动命令<br>不带参数的“boot”、“bootm”命令都是执行环境变量bootcmd所指定的命令。<br>“bootm [addr [arg…]]”命令启动存放在地址addr处的U-Boot格式的映像文件（使用U-Boot目录tools下的mkimage制作工具得到），[arg…]表示参数。如果addr参数省略，映像文件所在地址为配置文件中定义的宏CFG_LOAD_ADDR。<br>“go addr [arg…]”与bootm命令类似，启动存放在地址addr处的二进制文件，[arg…]表示参数。<br>“nboot [[[loadAddr]dev]offset]”命令将NAND Flash设备dev上偏移地址off处的映像文件复制到内存loadAddr处，然后，如果环境变量autostart的值为“yes”，就启动这个映像。如果loadAddr参数省略，存放地址为配置文件中定义的宏CFG_LOAD_ADDR；如果dev参数省略，则它的取值为环境变量bootdevice的值；如果offset参数省略，则默认为0。</p>
</li>
</ol>
<h3 id="U-Boot命令使用实例"><a href="#U-Boot命令使用实例" class="headerlink" title="U-Boot命令使用实例"></a>U-Boot命令使用实例</h3><p>下面通过一个例子来演示如何使用各种命令烧写内核映像文件，yaffs映像文件，并启动系统。</p>
<ol>
<li><p>制作内核映像文件<br>对于本书使用的Linux2.6.22.6版本，编译内核时可以直接生成U-Boot格式的映像文件uImage。<br>对于不能直接生成uImage的内核，制作方法在U-Boot根目录下的README文件中有说明，假设已经编译好的内核文件为vmlimux，它是ELF格式的。mkimage是U-Boot命令tools下的工具，它在编译U-Boot是自动生成。执行以下3个命令将内核文件vmlinux制作为U-Boot格式的映像文件uImage，它们首先将vmlinux转换为二进制格式，然后压缩，最后构造头部信息（里面包含文件名称、大小、类型、CRC校验码等），如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arm-linux-objcopy -O binary -R .note -R .comment -S vmlinux linux.bin</span><br><span class="line">gzip <span class="number">-9</span> linux.bin</span><br><span class="line">mkimage -A arm -O linux -T kernel -C gzip -a <span class="number">0x30008000</span> -e <span class="number">0x30008000</span> -n <span class="string">&quot;Linux Kernel Image&quot;</span> -d linux.bin.gz uImage</span><br></pre></td></tr></table></figure></li>
<li><p>烧写内核映像文件uImage<br>首先将uImage放在主机上的tftp或nfs目录下，确保已经开启tftp或nfs服务。<br>然后运行如下命令下载文件，擦除、烧写NAND Flash，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x30000000</span> uImage 或nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/uImage</span><br><span class="line">nand erase <span class="number">0x0</span> <span class="number">0x00200000</span></span><br><span class="line">nand write.jffs2 <span class="number">0x30000000</span> <span class="number">0x0</span> $(filesize)</span><br></pre></td></tr></table></figure>
<p>第3条命令之所以使用“nand write.jffs2”而不是“nand write”，是因为前者不要求文件的长度是页对齐的（512字节对齐）。也可以使用“nand write”，但是需要将命令中的长度参数改为$(filesize)向上进行512取整（513向上取整得1024）。比如uImage的大小为1540883，向上进行取整为1541120（0x178400），可以使用命令“nand write 0x30000000 0x0 0x178400”进行烧写。</p>
</li>
<li><p>烧写yaffs文件系统映像<br>假设yaffs文件系统映像的文件名为yaffs.img，首先将它放在主机上的tftp或nfs目录下，确保已经开启或nfs服务；然后执行如下命令下载、擦除、烧写，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x30000000</span> yaffs.img 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/yaffs.img</span><br><span class="line">nand erase <span class="number">0xA00000</span> <span class="number">0x3600000</span></span><br><span class="line">nand write.yaffs <span class="number">0x30000000</span> <span class="number">0xA00000</span> $(filesize)</span><br></pre></td></tr></table></figure>
<p>这时，重启系统，在U-Boot倒数3s之后，就会自动启动Linux系统。</p>
</li>
<li><p>烧写jffs2文件系统映像<br>假设jffs2文件系统映像的文件名为jffs2.img，首先将它放在主机上的tftp或nfs目录下，确保已经开启tftp或nfs服务；然后执行如下命令下载、擦除、烧写，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x30000000</span> jffs2.img 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>/work/nfs_root/jffs2.img</span><br><span class="line">nand erase <span class="number">0x200000</span> <span class="number">0x800000</span></span><br><span class="line">nand write.jffs2 <span class="number">0x30000000</span> <span class="number">0x200000</span> $(filesize)</span><br></pre></td></tr></table></figure>
<p>系统启动后，就可以使用“mount -t jffs2 &#x2F;dev&#x2F;mtdblock1 &#x2F;mnt”挂载jffs2文件系统。</p>
</li>
</ol>
<h2 id="使用U-Boot来执行程序"><a href="#使用U-Boot来执行程序" class="headerlink" title="使用U-Boot来执行程序"></a>使用U-Boot来执行程序</h2><p>之前章节的实例使用JTAG烧写程序到NAND Flash，烧写过程十分缓慢。如果使用U-Boot来烧写NAND Flash，效率会高很多。烧写二进制文件到NAND Flash中所使用的命令与上面烧写内核映像文件uImage的过程类似，只是不需要将二进制文件制作成U-Boot格式。<br>另外，可以将程序下载到内存中，然后使用go命令执行它。假设有一个程序的二进制可执行文件test.bin，连接地址为0x30000000。首先将它放在主机上的tftp和nfs目录下，确保已经开启tftp或nfs服务；然后将它下载到内存0x30000000处，最后使用go命令执行它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x3000000</span> test.bin 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/test.bin</span><br><span class="line">go <span class="number">0x30000000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第3篇第15章 移植U-Boot</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>U-Boot移植</tag>
      </tags>
  </entry>
</search>
