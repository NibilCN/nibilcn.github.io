<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇博客</title>
    <url>/2022/07/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这里是Nibil建立博客后的第一篇文章。</p>
<span id="more"></span>
<p>历时两个工作日，我采用了<a href="https://hexo.io/">Hexo博客框架</a>和Github Pages网页部署工具。在广大网友的帮助下，踩过一些坑，终于成功搭建并部署Nibil的博客。博客采用了<a href="https://github.com/next-theme/hexo-theme-next">Next</a>主题模板,在仿照<a href="https://carlyleliu.github.io/">CarlyleLiu</a>的博客模板的基础上，附带了我本人的一些个性化设置。于是，Nibil的私人博客诞生了，希望不要马上去世~~~<br>我建立博客的初衷是为了督促自己能抽出时间来学习，复习自己从事的嵌入式行业的专业知识，并分享在博客上，以此来达到温故而知新的目的，从而提高自己的行业竞争力。我暂时将博客大纲定性为四块，工作，学习，生活，杂项。工作包含自己在公司做项目过程中遇到的问题以及解决的问题，避免自己重复踩坑。学习包含自己主动去提升尚未掌握但是以后工作中会用到的领域的知识，避免一问三不知。生活属于是自己日常生活中的一些分享，毕竟这是一个博客。杂项就是我个人的一些感想，领悟啥的，属于是发牢骚。<br>暂时就写这么多，希望我的这第一篇文章不会成为我的最后一篇文章！</p>
]]></content>
      <categories>
        <category>杂</category>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>何谓硬解码和软解码</title>
    <url>/2022/08/05/%E4%BD%95%E8%B0%93%E7%A1%AC%E8%A7%A3%E7%A0%81%E5%92%8C%E8%BD%AF%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>关于“硬解码”与“软解码”。</p>
<span id="more"></span>
<p>软解码和硬解码的区别：</p>
<ol>
<li>软解码使用CPU进行解码。</li>
<li>硬解码使用非CPU进行解码，如GPU、专用的DSP、FPGA、ASIC等芯片。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>何谓硬解码和软解码</category>
      </categories>
      <tags>
        <tag>多媒体编解码</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Linux开发概述</title>
    <url>/2022/08/04/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第1章总结归纳</p>
<span id="more"></span>
<h1 id="嵌入式系统介绍"><a href="#嵌入式系统介绍" class="headerlink" title="嵌入式系统介绍"></a>嵌入式系统介绍</h1><h2 id="嵌入式系统的定义和特点"><a href="#嵌入式系统的定义和特点" class="headerlink" title="嵌入式系统的定义和特点"></a>嵌入式系统的定义和特点</h2><h3 id="嵌入式系统的定义"><a href="#嵌入式系统的定义" class="headerlink" title="嵌入式系统的定义"></a>嵌入式系统的定义</h3><p>嵌入式系统的定义为：以应用为中心，以计算机技术为基础、软硬件可裁剪、适用于应用系统，对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。它的主要特点是嵌入，专用。<br>含有嵌入式系统的设备成为嵌入式设备，这在生活中随处可见：电子表、手机、MP3播放器、遥控器等。涵盖了生产、工业控制、通信、网络、消费电子、汽车电子、军工等领域。从通俗，广义的角度来说，除电脑，超级计算机等具备比较强大计算能力及系统资源（比如内存，存储器等）的电子系统之外，凡具备计算能力的设备都可称为嵌入式设备。</p>
<h3 id="嵌入式设备的特点"><a href="#嵌入式设备的特点" class="headerlink" title="嵌入式设备的特点"></a>嵌入式设备的特点</h3><ol>
<li>软硬件可裁剪</li>
<li>对功能、可靠性、成本、体积、功耗严格要求</li>
</ol>
<h2 id="嵌入式技术的发展史"><a href="#嵌入式技术的发展史" class="headerlink" title="嵌入式技术的发展史"></a>嵌入式技术的发展史</h2><p>通用计算机和嵌入式计算机是两条不同的道路。通用计算机系统的技术要求是高速海量的数值计算；技术发展方向是总线速度的无限提升，存储容量的无限扩大。而嵌入式计算机系统的技术要求是对象的智能化控制能力；技术发展方向则是与对象系统密切相关的嵌入性能、控制能力与控制的可靠性。<br>嵌入式技术发展日新月异，经历了单片机（SCM）、微控制器（MCU）、系统级芯片（SOC）3个阶段。</p>
<h3 id="SCM（Single-Chip-Microcomputer）"><a href="#SCM（Single-Chip-Microcomputer）" class="headerlink" title="SCM（Single Chip Microcomputer）"></a>SCM（Single Chip Microcomputer）</h3><p>又称单片微型计算机，简称单片机，随着大规模集成电路的出现以及发展，计算机的CPU、RAM、ROM、定时计数器和多种I&#x2F;O接口集成在一片芯片上，形成芯片级计算机。<br>这个阶段主要寻求单片形态嵌入式系统的最佳体系结构。</p>
<h3 id="MCU（Micro-Controller-Unit）"><a href="#MCU（Micro-Controller-Unit）" class="headerlink" title="MCU（Micro Controller Unit）"></a>MCU（Micro Controller Unit）</h3><p>MCU即微型控制器的特征是：满足各类嵌入式应用，根据对象系统扩展各类外围电路和接口电路，突显其对象的智能化控制能力。它所涉及的领域都与对象系统有关。<br>实际上，SCM和MCU在日常工作中并不严格区分，很多时候一概以单片机称呼。随着能够运行更复杂软件（操作系统）的SOC的出现，单片机通常是指不允许操作系统，功能相对单一的嵌入式系统。但这也不是绝对的，比如8051上就可以运行RTX51实时操作系统，它的大小只有6KB，相比于嵌入式Linux，Windows CE等操作系统而言比较简单。</p>
<h3 id="SoC（System-on-a-Chip）"><a href="#SoC（System-on-a-Chip）" class="headerlink" title="SoC（System on a Chip）"></a>SoC（System on a Chip）</h3><p>随着设计与制造技术的发展，集成电路设计从晶体管的集成发展到逻辑门的集成，现在又发展到IP的集成，即SOC设计技术。Soc可以有效降低电子&#x2F;信息系统产品的开发成本，缩短开发周期，提高产品的竞争力，是未来工业界将采用的最主要的产品开发方式。<br>Soc的特征：</p>
<ol>
<li>实现复杂系统功能的VLSI；</li>
<li>采用超深亚微米工艺技术；</li>
<li>使用一个以上嵌入式CPU&#x2F;数字信号处理器DSP；</li>
<li>外部可以对芯片进行编程；</li>
<li>主要采用第三方IP进行设计。<br>从上述SoC特征来看，SoC中包含了微处理器、微控制器、存储器以及其他专用功能逻辑，但是并不包含微处理器、微控制器、存储器以及其他专用功能的芯片就是SoC。8051就集成了微处理器、存储器等部件，它不属于SoC。SoC的主要价值在于—缩短了产品的上市周期。<br>因此SoC更合理的定义：SoC是在一个芯片上由于广泛使用预定制模块IP（Intellectual Property）而得以快速开发的集成电路。<br>本书介绍的S3C2410&#x2F;S3C2440就属于SoC，它们集成了处理器、MMU、NAND Flash控制器等部件，而处理器的IP是基于ARM公司的。<br>以前写的单片机软件，通常是在main函数当中定义一个无限循环，然后在里面查询各类输入事件，并做相应处理，它直接操作硬件；而基于SoC的软件多是在操作系统上面运行，通过驱动程序操作硬件。</li>
</ol>
<h1 id="基于ARM处理器的嵌入式Linux系统"><a href="#基于ARM处理器的嵌入式Linux系统" class="headerlink" title="基于ARM处理器的嵌入式Linux系统"></a>基于ARM处理器的嵌入式Linux系统</h1><h2 id="ARM处理器介绍"><a href="#ARM处理器介绍" class="headerlink" title="ARM处理器介绍"></a>ARM处理器介绍</h2><h3 id="ARM处理器的概念"><a href="#ARM处理器的概念" class="headerlink" title="ARM处理器的概念"></a>ARM处理器的概念</h3><p>嵌入式处理器的种类繁多，又ARM、MIPS、PPC等多种架构。ARM的文档丰富，各类嵌入式软件大多选择ARM。在掌握ARM架构之后，上手其他处理器架构也会很快。<br>ARM(Advanced RISC Machine),既是一家公司的名字，也可以是一类处理器的统称，还可以认为是一种技术的名字。<br>ARM公司并不生产芯片，而是出售芯片授权。基于ARM的处理器以其高速度、低功耗、价格低等优点得到非常广泛的应用，它可以应用于以下领域：</p>
<ol>
<li>为无线通信、消费电子、成像设备等产品提供可运行复杂操作系统的开放应用平台；</li>
<li>在海量存储、汽车电子、工业控制和网络应用等领域提供实时嵌入式应用；</li>
<li>安全系统，比如SIM卡、信用卡等。</li>
</ol>
<h3 id="ARM体系架构的版本"><a href="#ARM体系架构的版本" class="headerlink" title="ARM体系架构的版本"></a>ARM体系架构的版本</h3><p>ARM体系架构的版本就是它所使用的指令集的版本。ARM公司支持32位的ARM指令集和16位的Thumb指令集，后者使得代码的存储空间大大减小。<br>还在使用的ARM指令集（ISA，Instruction Set Architecture）有以下版本：</p>
<ol>
<li>ARMv4<br>这是当前市场上最老的版本，ARMv4只支持32位的指令集，支持32位的地址空间。一些ARM7系列的处理器和Intel公司的StrongARM处理器采用ARMv4指令集。</li>
<li>ARMv4T<br>增加了16位的Thumb指令集，它可以产生更紧凑的代码，与相同功能的ARM代码相比，可以节省超过35%的存储空间，同时具备32位代码的所有优点。</li>
<li>ARMv5TE<br>1999年，ARMv5TE版本改进了Thumb指令集，增加了一些“增强型DSP指令”，简称E指令集。<br>这些指令用于增强处理器对于一些典型的DSP算法的处理性能，是的音频DSP应用可以提升70%的性能。许多系统在使用微控制器来进行各类控制的时候，还要具备数据处理能力，传统的做法要么是使用更高级的处理器，这会使得成本增加，要么是使用多个处理器，这会使得系统复杂度增高。通过E指令集可以在一个普通CPU中增加DSP的功能，这在成本、性能、简化设计等方面都有优势。</li>
<li>ARMv5TEJ<br>增加Jazelle技术用于提供Java加速功能。</li>
<li>ARMv6<br>2001年，ARMv6问世。它在很多方面都有改进：存储系统、异常处理，最重要的是增加了对多媒体功能的支持。ARMv6包含了一些媒体指令以支持SIMD媒体功能扩展。SIMD媒体功能扩展为音视频的处理提供了优化功能，可以使得音视频的处理性能提高4倍。<br>ARMv6中还引入了Thumb-2和TrustZone技术，这是两个可选的技术。之前的版本中，ARM指令和Thumb分别运行于不同的处理器状态下，执行不同的指令集的指令前需要进行切换。Thumb-2技术增加了混合模式的功能，定义了新的32位指令集，可以运行32位指令和16位指令的混合代码。这能够提供”ARM指令级别的性能“和”Thumb指令级别的代码密度“。TrustZone技术在硬件上提供了两个隔离的地址空间：安全域和非安全域，给系统提供了一个安全机制。</li>
<li>ARMv7<br>ARMv7架构使用Thumb-2技术，还使用了NEON技术，将DSP和媒体处理能力提高了近4倍，并支持改良的浮点运算，满足下一代3D图形、游戏物理应用以及传统嵌入式控制应用的需求。</li>
</ol>
<h3 id="ARM处理器系列"><a href="#ARM处理器系列" class="headerlink" title="ARM处理器系列"></a>ARM处理器系列</h3><p>在相同的指令集下，搭配不同的部件就可以组装出具有不同功能的处理器，比如有无内存管理单元，有无调试功能等。它们可以分为8个系列，系列名有7个后缀，这些后缀可以组合：<br>T：表示支持Thumb指令集。<br>D：表示支持片上调试（Debug）。<br>M：表示内嵌乘法器（Multiplier）。<br>I：支持片上断点和调试点。<br>E：表示支持增强型DSP功能。<br>J：表示支持Jazelle技术，即Java加速器。<br>S：表示全合成式（full synthesizable）。</p>
<ol>
<li>ARM7<br>ARM7系列处理器是低功耗32位RISC微处理器，它主要用于对成本、功耗特别敏感的产品。最高可达到130MIPS（Million Instructions Percent Second），支持Thumb16位指令集和ARM32位指令集。ARM7系列微处理器包括如下几种类型的核：ARM7TDMI、ARM7TDMI-S、ARM720T、ARM7EJ-S。其中。ARM7TMDI是目前使用最广泛的32位嵌入式RISC处理器，属于低端ARM处理器核。ARM7不带MMU。</li>
<li>ARM9<br>与ARM7相比，ARM9最大的差别在于：有MMU和Cach。它的指令执行效率较ARM7有较大提高，最高可达300MIPS。ARM9系列微处理器有ARM920T和ARM922T两种类型。</li>
<li>ARM9E<br>ARM9E系列微处理器在单一的处理器内核上提供了微控制器、DSP、Java应用系统的解决方案，极大的减少了芯片的面积和系统的复杂度。ARM9E系列微处理器提供了增强的DSP处理能力，适合于那些需要同时使用DSP和微控制器的应用场合。<br>ARM9E系列微处理器有ARM926EJ-S、ARM946E-S、ARM966E-S、ARM968E-S和ARM996HS共五种类型。</li>
<li>ARM10E<br>ARM10E微处理器具有更加杰出的高性能、低功耗特点，由于使用了新的体系结构，它拥有ARM系列中最高的主频。ARM10E系列微处理器采用了一种新的省电模式，支持”64 bit load-store micro-architecture“，含浮点运算协处理器。<br>ARM10E系列微处理器有ARM1020E、ARM1022E和ARM1026EJ-S三种类型。</li>
<li>ARM11<br>ARM11系列微处理器是ARM公司近年来推出的新一代RISC处理器，它是ARM新指令架构—ARMv6的第一代设计实现。ARM11的媒体处理能力和低功耗特点特别适用于无线和消费类电子产品，其高数据吞吐量和高性能的结合非常适合网络处理应用。另外在实时性能和浮点处理等方面ARM11可以满足汽车电子的应用需求。<br>ARM11系列微处理器有这4种类型：ARM11 MPCore、ARM1136J(F)-S、ARM1156T2(F)-S和ARM1176JZ(F)-S。</li>
<li>Cortex<br>Cortex基于ARMv7架构，分为Cortex-A、Cortex-R、Cortex-M三类。Cortex-A为传统的、基于虚拟内存的操作系统和应用程序而设计，支持ARM、Thumb、和Thumb-2指令集；Cortex-R针对实时系统设计，支持ARM、Thumb、和Thumb-2指令集；Cortex-M为对价格敏感的产品设计，只支持Thumb-2指令集。</li>
<li>SecureCore<br>SecureCore系列微处理器专为安全需要设计，提供了完善的32位RISC技术的安全解决方案，因此，SecureCore系列微处理器除了具有ARM体系结构的低功耗、高性能特点外，还具有其独特的优势，即提供了对安全解决方案的支持。<br>SecureCore系列微处理器有如下类型：SecureCoreSC100、SecureCoreSC200。</li>
<li>OptimoDE Data Engines<br>这是一个新的IP核，针对高性能的嵌入式信号处理应用而设计。<br>另外，Intel公司的StrongARM、Xscale系列处理器也属于ARM架构。Intel StrongARM处理器是便携式通信产品和消费电子产品的理想选择，已成功应用于多家公司的掌上电脑系列产品。Xscale处理器是基于ARMv5TE体系结构的解决方案，是一款全性能、高性价比、低功耗的处理器。它支持16位的Thumb指令和DSP指令集。</li>
</ol>
<h2 id="选择嵌入式Linux的理由"><a href="#选择嵌入式Linux的理由" class="headerlink" title="选择嵌入式Linux的理由"></a>选择嵌入式Linux的理由</h2><p>在嵌入式领域可以选择的操作系统有很多，比如：嵌入式Linux、VxWorks、Windows CE、μC&#x2F;OS-Ⅱ等。<br>VxWorks是美国WindRiver公司开发的嵌入式实时操作系统。但就性能而言，它是非常优秀的操作系统，具有可裁剪的微内核结构、高效的任务管理、灵活的任务间通信、微秒级的中断处理，支持POSIX 1003.1b实时扩展标准，支持多种物理介质及标准、完整的TCP&#x2F;IP网络协议等。缺点是它支持的硬件相对较少，源代码不开放，需要专门的技术人员进行维护，授权费用高。<br>Windows CE是微软公司针对嵌入式设备开发的32位、多任务、多线程的操作系统。它支持x86、ARM、MIPS、SH等架构的CPU，硬件驱动丰富，支持WiFi、USB2.0等新型设备，并且具有强大的多媒体功能；可以灵活裁剪以减少系统体积；与PC上的Windows操作系统相通，开发、调试工具使用方便。应用程序的开发流程与PC上的Windows程序开发流程类似。就开发的便利性而言，Windows CE是最好的。但是，它的源代码没有开放，开发人员难以进行更细致的定制，占用内存较多，整个相同相对庞大，版权许可费也比较高。<br>μC&#x2F;OS-Ⅱ是Micrium公司开发的操作系统，可用于8位、16位、32位处理器。可裁剪，对硬件要求低；可运行最多64个任务；任务调度方式位抢占式调度，总是运行最高优先级的就绪任务。用户可以获取μC&#x2F;OS-Ⅱ的全部代码，但是它不是完全免费的。用于商业目的，需要购买商业授权。μC&#x2F;OS-Ⅱ采用一次性收费的方式，价格低廉。μC&#x2F;OS-Ⅱ仅是一个实时内核，用户需要完成其他更多的工作，比如编写硬件驱动程序，实现文件操作等。<br>Linux是遵循GPL协议的开放源代码的操作系统，使用时无需缴纳许可费。内核可以任意裁剪，几乎支持所有的32位、62位CPU；内核中支持的硬件种类繁多，几乎可以从网络上找到所有的硬件驱动程序；支持几乎所有的网络协议；有大量的应用程序可以使用，从编译工具，调试工具到GUI程序，几乎都遵循GPL协议的相关版本；有庞大的开发人员群体，有数量众多的技术论坛，大多数问题可以得到快速而且免费的解答。<br>Linux的缺点在于实时性，虽然在2.6版本的Linux在实时性上有了较大的改进，但是仍然无法称作实时操作系统。不过正是因为Linux开放源代码、易于移植、资源丰富、免费等优点，使得它在嵌入式领域越来越流行。更重要的一点，由于嵌入式Linux与PC Linux基于同样的内核代码，只是裁剪的程度不一样，这使得很多为PC开发的软件再次编译后，可以直接在嵌入式设备上面运行，这使得软件资源极大丰富，比如各类使用的函数库等。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第1章 嵌入式Linux开发概述</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO接口</title>
    <url>/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第5章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>掌握嵌入式开发的步骤：编程、编译、烧写程序、运行</li>
<li>通过GPIO口的操作了解软件如何控制硬件</li>
</ol>
<h1 id="GPIO硬件介绍"><a href="#GPIO硬件介绍" class="headerlink" title="GPIO硬件介绍"></a>GPIO硬件介绍</h1><p>GPIO（Genaral Purpose I&#x2F;O Ports）意思是通过通用输入&#x2F;输出端口，通俗的说，就是一些引脚，可以通过它们输出高低电平或者通过它们读入引脚的状态—是高电平还是低电平。<br>S3C2410有117个I&#x2F;O端口，共分为A-H 8组，GPA、GPB、……、GPH。S3C2440有130个I&#x2F;O端口，共分为A-H 9组，GPA、GPB、……、GPJ。可以通过设置寄存器来确定某个引脚用于输入、输出还是其他特殊功能。比如可以设置GPH6作为一般的输入、输出引脚，或者用于串口。<br>GPIO的操作是所有硬件操作的基础，由此扩展开来可以了解所有硬件的操作，这是底层开发人员必须掌握的。</p>
<h2 id="通过寄存器来操作GPIO引脚"><a href="#通过寄存器来操作GPIO引脚" class="headerlink" title="通过寄存器来操作GPIO引脚"></a>通过寄存器来操作GPIO引脚</h2><p>既然一个引脚可以用于输入、输出或其他功能，那么一定有寄存器用来选择这些功能；对于输入，一定可以通过读取某个寄存器来确定引脚的电平是高还是低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电平还是低电平；对于其他特殊功能，则有另外的寄存器来控制它。<br>对于这几组GPIO引脚，它们的寄存器是相似的；GPxCON用于选择引脚功能。GPxDAT用于读写引脚数据。GPxUP用于确定是否使用内部上拉电阻。</p>
<h3 id="GPxCON寄存器"><a href="#GPxCON寄存器" class="headerlink" title="GPxCON寄存器"></a>GPxCON寄存器</h3><p>从寄存器的名字可以看出，它用于配置（Configure）—选择引脚的功能。<br>PORT A与PORT B-PORT H&#x2F;J在功能选择方面有所不同，GPACON中每一位对应一根引脚（共23根引脚）。当某位被设置为0时，相应引脚为输出引脚，此时我们可以在GPADAT中的相应位写入0或1让此引脚输出高电平或者低电平。当某位被设置为1时，相应的引脚为地址线，或用于地址控制。此时的GPADAT无用。通常而言GPACON全被设置为1，以便访问外部存储器件。<br>PORT B-PORT H&#x2F;J 在寄存器操作方面完全相同。GPxCON中每两位控制一根引脚，00表示输入、01表示输出、10表示特殊功能、11保留。</p>
<h3 id="GPxDAT寄存器"><a href="#GPxDAT寄存器" class="headerlink" title="GPxDAT寄存器"></a>GPxDAT寄存器</h3><p>GPxDAT用于读&#x2F;写引脚；当引脚被设置为输入时，读此寄存器可知相应引脚的电平状态是高还是低；当引脚被设置为输出时，写此寄存器相应位可令此引脚输出高电平或者低电平。</p>
<h3 id="GPxUP"><a href="#GPxUP" class="headerlink" title="GPxUP"></a>GPxUP</h3><p>某位为1时，相应引脚无内部上拉电阻；为0时，相应引脚使用内部上拉电阻。<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/1.jpeg" alt="img not found"><br>上拉、下拉电阻的作用在于，当GPIO引脚处于第三态（既不是输出高电平，也不是输出低电平，而是呈高阻态）时，它的电平状态由上拉、下拉电阻决定。</p>
<h2 id="怎样使用软件来访问硬件"><a href="#怎样使用软件来访问硬件" class="headerlink" title="怎样使用软件来访问硬件"></a>怎样使用软件来访问硬件</h2><h3 id="访问单个引脚"><a href="#访问单个引脚" class="headerlink" title="访问单个引脚"></a>访问单个引脚</h3><p>单个引脚的操作无外乎3种：输出高低电平、检测引脚状态、中断。对某个引脚的操作一般通过读写寄存器来完成。<br>比如对于图5.2所示的电路，可以设置GPBCON寄存器将GPB5、GPB6、GPB7和GPB8设为输出功能，然会写GPBDAT的寄存器使得这四个引脚输出高电平或低电平。输出高电平时，相应的LED灯熄灭，输出低电平时，相应的LED灯点亮。<br>还可以设置GPFCON寄存器将GPF0、GPF2、GPF3和GPF11设为输入功能，然后通过读出GPFDAT&#x2F;GPGDAT寄存器并判断相应位是0还是1来确定各个按键是否被按下。某个按键按下时，相应引脚电平为低，GPFDAT&#x2F;GPGDAT寄存器相应位为0，否则为1。<br>那么怎么访问这些寄存器呢，通过软件，读写它们的地址。比如，GPBCON和GPBDAT寄存器的地址都是0x56000010、0x56000014，可以通过如下的指令让GPB5输出低电平，点亮LED1。<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/2.jpeg" alt="img not found"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (*(volatile unsigned long *)0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (*(volatile unsigned long *)0x56000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line">GPBCON = GPB5_out;<span class="comment">//GPB5引脚设置为输出</span></span><br><span class="line">GPBDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//GPB5输出低电平</span></span><br></pre></td></tr></table></figure>
<h3 id="以总线方式访问硬件"><a href="#以总线方式访问硬件" class="headerlink" title="以总线方式访问硬件"></a>以总线方式访问硬件</h3><p>并非只能通过寄存器才能发出硬件信号，实际上，通过访问总线的方式控制硬件更常见。以NOR Flash的访问为例：<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/3.jpeg" alt="img not found"><br>图中，缓冲器的作用是为了提高驱动力、隔离前后级信号。NOR Flash AM29LV800BB的片选信号使用S3C2410&#x2F;S3C2440的nGCS0信号，当CPU发出的地址信号处于0x00000000-0x07FFFFFF之间时，nGCS0信号有效，于是NOR Flash被选中。这时，CPU发出的地址信号传到NOR Flash；进行写操作时，nWE信号为低，数据信号从CPU发出给NOR Flash；进行读操作时，nWE信号为高，数据信号从NOR Flash发给CPU。上图所示的硬件连线决定了读写操作都是以16位为单位的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址对齐的16位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> wVal;</span><br><span class="line">wVal = *pwAddr;</span><br></pre></td></tr></table></figure>
<p>上述代码就会向NOR Flash发起读操作：CPU发出的读地址为0x2，则地址总线ADDR1-ADDR20、A0-A19的信号都是1、0、…、0（CPU的ADDR0为0，不过ADDR0没有接到NOR Flash上）。NOR Flash接收到的地址就是0x1，NOR Flash在稍后的时间里将此址上的16位数据取出，并通过数据总线D0-D15发给CPU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址不对齐的16位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> wVal;</span><br><span class="line">wVal = *pwAddr;</span><br></pre></td></tr></table></figure>
<p>由于地址位0x1；不是2对齐的，但是BANK0的位宽被设为16，这将导致异常。我们可以设置异常处理函数来处理这种情况。在异常处理函数中，使用0x0、0x2发起两次读操作，然后将两个结果组合起来。使用地址0x0读到两字节数据D0、D1，再使用地址0x2读到D2、D3。最后D1、D2组合成一个16位的数返回给wVal。如果没有设置地址不对齐异常处理函数，那么上述代码将出错。如果某个BANK位宽被设置为n，访问此BANK时，在总线上永远只会看到地址对齐的n位操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*8位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *pucAddr = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">0x6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucVal;</span><br><span class="line">ucVal = *pucAddr;</span><br></pre></td></tr></table></figure>
<p>CPU首先使用地址0x6对NOR Flash发起16位的读操作，得到两字节的数据，假设位D1、D0，然后将D0取出赋值给uvVal。在读操作期间，地址总线ADDR1-ADDR20、A0-A19的信号都是1、1、1、…、0。CPU会自动丢弃D1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*32位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *pdwAddr = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwVal;</span><br><span class="line">dwVal = *pdwAddr;</span><br></pre></td></tr></table></figure>
<p>CPU首先使用地址0x6对NOR Flash发起16位的读操作，得到两字节的数据，假设为D0，D1；再使用地址0x8发起读操作，得到两字节的数据D2，D3，最后将这4个字节的数据组合后再赋值给变量dwVal。<br>由于NOR Flash的特性，使得对NOR Flash的写操作比较复杂—比如要先发出特定的地址信号通知NOR Flash准备接受数据，然后才发出数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*16位写操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x6</span>;</span><br><span class="line">*pwAddr = <span class="number">0x1234</span>;</span><br></pre></td></tr></table></figure>
<p>CPU发起一次对NOR Flash的写操作，地址总线ADDR1-ADDR20、A0-A19的信号都时1、1、…、0；数据线DATA0-DATA15、D0-D15的信号为0、0、1、0、1、1、0、0、0、1、0、0、1、0、0、0。<br>由此可见，CPU使用某个地址进行访问时，这个32位的地址值和ADDR0-ADDR31一一对应，外接的设备可以以8位、16位、32位进行操作—取决于硬件设计。如果以8位进行操作，那么数据出现在数据信号DATA0-DATA7上，如果以16位进行操作，则数值出现在数据线DATA0-DATA15上；如果以32位进行操作，则数值出现在DATA0-DATA31上。</p>
<h1 id="GPIO操作实例"><a href="#GPIO操作实例" class="headerlink" title="GPIO操作实例"></a>GPIO操作实例</h1><p>LED和按键与处理器的电路连接基于图5.2。程序基于裸机开发，不带操作系统。</p>
<h2 id="纯汇编实现点亮一个LED"><a href="#纯汇编实现点亮一个LED" class="headerlink" title="纯汇编实现点亮一个LED"></a>纯汇编实现点亮一个LED</h2><p>汇编程序实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    ldr r0,=0x56000010      @r0设置为GPBCON寄存器，用于配置GPIOB系列引脚。</span><br><span class="line">    mov r1,#0x00000400      @r1赋值立即数0x00000400</span><br><span class="line">    str r1,[r0]             @GPBCON写入0x00000400，设置GPB5为输出口，位[10:9]=0b01</span><br><span class="line">    ldr r0,=0x56000014      @r0设置为GPBDAT寄存器，用于读写GPIOB系列引脚的数据。</span><br><span class="line">    mov r1,#0x00000020      @r1赋值立即数0x00000020</span><br><span class="line">    str r1,[r0]             @点亮LED1</span><br><span class="line">main_loop:</span><br><span class="line">    b main_lopp             @死循环</span><br></pre></td></tr></table></figure>
<p>编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o led_on.o led_on.S                        @编译</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf        @链接</span><br><span class="line">arm-linux-objcopy -O binary -S led_on_elf led_on.bin            @将elf格式的可执行文件转换位二进制格式</span><br></pre></td></tr></table></figure>

<h2 id="C代码实现点亮一个LED"><a href="#C代码实现点亮一个LED" class="headerlink" title="C代码实现点亮一个LED"></a>C代码实现点亮一个LED</h2><p>C语言执行的第一条指令并不在main函数中。生成一个C程序的可执行文件时，编译器通常会在我们的代码中加上几个被称为启动文件的代码—crtl.o、crti.o、crtend.o、crtn.o等，它们是标准库文件。这些代码设置C程序的堆栈等，然后调用main函数。它们依赖于操作系统，在裸板上这些代码无法执行，所以需要自己写一个。<br>这段代码很简单，只有6条指令，自己编写的crt0.S文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:crt0.S</span></span><br><span class="line"><span class="comment">通过它转入C程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    ldr r0,=<span class="number">0x56000010</span>      @watchdog地址寄存器</span><br><span class="line">    mov r1,#<span class="number">0x0</span>             @</span><br><span class="line">    str r1,[r0]             @写入<span class="number">0</span>，禁止watchdog，否则CPU会不断重启</span><br><span class="line">    ldr sp,=<span class="number">1024</span>*<span class="number">4</span>          @设置堆栈，注意不能大于<span class="number">4</span>KB，因为当前可以内存只有<span class="number">4</span>KB</span><br><span class="line">                            @NAND Flash中的代码会在复位后移到内部RAM（只有<span class="number">4</span>KB）</span><br><span class="line">    bl main                 @调用C程序中的main函数</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">    b halt_loop</span><br></pre></td></tr></table></figure>
<p>设置好堆栈指针后，就可以调用C函数main了。C函数执行前，必须设置栈。<br>所以现在可以写出控制LED的C程序了。main函数在led_on_c.c中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (*(volatile unsigned long *)0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (*(volatile unsigned long *)0x56000014)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    GPBCON = <span class="number">0x00000040</span>;    <span class="comment">//设置GPB5为输出端口，位[10:9]=0b01</span></span><br><span class="line">    GPBDAT = <span class="number">0x00000000</span>;    <span class="comment">//GPB5输出0，LED1点亮</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o crt0.o crt0.S</span><br><span class="line">arm-linux-gcc -g -c -o led_on_c.0 led_on_c.c</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 -g crt0.o led_on_c.o -o led_on_c_elf</span><br><span class="line">arm-linux-objcopy -O binary -S led_on_c_elf led_on_c.bin</span><br><span class="line">arm-linux-objdump -D -m arm led_on_c_elf &gt; led_on_c.dis</span><br></pre></td></tr></table></figure>
<p>先分别编译crt0.S和led_on_c.c(不连接)。然后将编译的结果连接起来。然后把得到的ELF格式的文件led_on_c_elf转换成二进制的bin文件。最后将结果转换为汇编代码以供查看。</p>
<h2 id="按键来控制LED"><a href="#按键来控制LED" class="headerlink" title="按键来控制LED"></a>按键来控制LED</h2><p>当K1-K4某个按键按下时，点亮LED1-LED4中相应的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:key_led.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (* (unsigned long *) 0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (* (unsigned long *) 0x56000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFCON (* (unsigned long *) 0x56000050)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFDAT (* (unsigned long *) 0x56000054)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPGCON (* (unsigned long *) 0x56000060)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPGDAT (* (unsigned long *) 0x56000064)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LED1-LED4对应GPB5、GPB6、GPB7、GPB8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">K1-K4对应GPG11、GPG3、GPF2、GPF0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPG11_in ~(3&lt;&lt;(11*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPG3_in ~(3&lt;&lt;(3*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPF2_in ~(3&lt;&lt;(2*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPF0_in ~(3&lt;&lt;(0*2))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dwDat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LED1-LED4对应的4根引脚设置为输出</span></span><br><span class="line">    GPBCON = GPB5_out | GPB6_out | GPB7_out | GPB8_out ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//K1-K2对应的两根引脚设为输入</span></span><br><span class="line">    GPGCON = GPG11_in &amp; GPG3_in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwDat = GPGDAT;             <span class="comment">//读取GPG管脚电平状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>))       <span class="comment">//K1没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>);    <span class="comment">//LED1熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);   <span class="comment">//LED1点亮</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))        <span class="comment">//K2没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">6</span>);    <span class="comment">//LED2熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);   <span class="comment">//LED2点亮</span></span><br><span class="line"></span><br><span class="line">        dwDat = GPFDAT;             <span class="comment">//读取GPF管脚电平状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>))        <span class="comment">//K3没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);    <span class="comment">//LED3熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);   <span class="comment">//LED3点亮</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>))        <span class="comment">//K4没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">//LED4熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);   <span class="comment">//LED4点亮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码先将LED1-LED4对应的引脚GPB5-GPB8设为输出引脚。<br>然后将K1、K2对应的引脚GPG11、GPG3设为输入引脚，K3、K4对应的引脚GPF2、GPF0设为输入引脚。<br>然后就是一个无穷循环，读取GPGDAT、GPFDAT寄存器，从中判断K1、K2、K3、K4是否按下。若按下则点亮相应的LED，否则熄灭相应的LED。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第5章 GPIO接口</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>裸机</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之工厂模式</title>
    <url>/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之工厂模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>在工厂模式中，我们创建对象时不会对客户暴露逻辑并且是通过一个共同的接口来指向新创建的对象。工厂模式作为一种创建模式，一般在创建复杂对象时，考虑使用；创建简单对象时，建议直接new完成一个实例对象的创建。</p>
<h1 id="简单工厂模式"><a href="#简单工厂模式" class="headerlink" title="简单工厂模式"></a>简单工厂模式</h1><p>主要特点是需要在工厂类中做判断，从而创建相应的产品，当增加新的产品时，需要修改工厂类。使用简单工厂模式，我们只需要知道具体的产品型号就可以创建一个产品。<br>缺点：工厂类中集中了所有产品的创建逻辑，如果产品量过大，会使工程类变得臃肿。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//产品种类</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">enum</span></span><br><span class="line">&#123;</span><br><span class="line">    Clothes_Min = <span class="number">-1</span>,</span><br><span class="line">    Clothes_pants,</span><br><span class="line">    Clothes_jeans,</span><br><span class="line">    Clothes_Max,</span><br><span class="line">&#125;Clothes_t;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Pants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Jeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Jeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Clothes *<span class="title">MakeClothes</span><span class="params">(Clothes_t clothes_type)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">switch</span>(clothes_type)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> Clothes_pants:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Pants</span>();</span><br><span class="line">            <span class="keyword">case</span> Clothes_jeans:</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Jeans</span>();</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory fac;</span><br><span class="line"></span><br><span class="line">    Clothes *pants = fac.<span class="built_in">MakeClothes</span>(Clothes_pants);</span><br><span class="line">    pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    Clothes *jeans = fac.<span class="built_in">MakeClothes</span>(Clothes_jeans);</span><br><span class="line">    jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pants;</span><br><span class="line">    pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> jeans;</span><br><span class="line">    jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
<h1 id="工厂方法模式"><a href="#工厂方法模式" class="headerlink" title="工厂方法模式"></a>工厂方法模式</h1><p>定义一个创建对象的接口，其子类去具体实现这个接口已完成具体的创建工作。如果需要增加新的产品类，只需要扩展一个相应的工厂类即可。<br>缺点：产品类数据较多时，需要实现大量的工厂类，这无疑增加了代码量。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Clothes</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Pants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Pants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体产品类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span> : <span class="keyword">public</span> Clothes</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Jeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;Jeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Clothes* <span class="title">MakeClothes</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">PantsFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">Clothes* <span class="title">MakeClothes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Pants</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//具体工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">JeansFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function">Clothes* <span class="title">MakeClothes</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Jeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *pants_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Clothes *pants_clo = <span class="literal">nullptr</span>;</span><br><span class="line">    </span><br><span class="line">    pants_fac = <span class="keyword">new</span> <span class="built_in">PantsFactory</span>();</span><br><span class="line">    pants_clo = pants_fac-&gt;<span class="built_in">MakeClothes</span>();</span><br><span class="line">    pants_clo-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> pants_fac;</span><br><span class="line">    pants_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> pants_clo;</span><br><span class="line">    pants_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Factory *jeans_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Clothes *jeans_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    jeans_fac = <span class="keyword">new</span> <span class="built_in">JeansFactory</span>();</span><br><span class="line">    jeans_clo = jeans_fac-&gt;<span class="built_in">MakeClothes</span>();</span><br><span class="line">    jeans_clo-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> jeans_fac;</span><br><span class="line">    jeans_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> jeans_clo;</span><br><span class="line">    jeans_clo = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/2.jpeg" alt="img not found"></p>
<h1 id="抽象工厂模式"><a href="#抽象工厂模式" class="headerlink" title="抽象工厂模式"></a>抽象工厂模式</h1><p>抽象工厂模式提供创建一系列相关或者相互依赖对象的接口，而无需指定他们具体的类。<br>当存在多个产品系列，而客户端只使用一格系列的产品时，可以考虑使用抽象工厂模式<br>缺点：当增加一个新系列的产品时，不仅需要实现具体的产品类，还需要增加一个新的创建接口，扩展相对困难。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Pants</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhitePants</span> : <span class="keyword">public</span> Pants</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WhitePants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;WhitePants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色裤子类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackPants</span> : <span class="keyword">public</span> Pants</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlackPants</span>():<span class="built_in">m_type</span>(<span class="string">&quot;BlackPants&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Jeans</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhiteJeans</span> : <span class="keyword">public</span> Jeans</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">WhiteJeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;WhiteJeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色牛仔裤类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackJeans</span> : <span class="keyword">public</span> Jeans</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BlackJeans</span>():<span class="built_in">m_type</span>(<span class="string">&quot;BlackJeans&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">const</span> string&amp; <span class="title">type</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout &lt;&lt; m_type &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> m_type;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    string m_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//抽象工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Factory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Pants* <span class="title">MakePants</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> Jeans* <span class="title">MakeJeans</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//白色工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">WhiteFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pants* <span class="title">MakePants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WhitePants</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Jeans* <span class="title">MakeJeans</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">WhiteJeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//黑色工厂类</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">BlackFactory</span> : <span class="keyword">public</span> Factory</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">Pants* <span class="title">MakePants</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BlackPants</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">Jeans* <span class="title">MakeJeans</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BlackJeans</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Factory *white_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Pants* white_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    Jeans* white_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    white_fac = <span class="keyword">new</span> <span class="built_in">WhiteFactory</span>();</span><br><span class="line">    white_pants = white_fac-&gt;<span class="built_in">MakePants</span>();</span><br><span class="line">    white_pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    white_jeans = white_fac-&gt;<span class="built_in">MakeJeans</span>();</span><br><span class="line">    white_jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> white_fac;</span><br><span class="line">    white_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> white_pants;</span><br><span class="line">    white_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> white_jeans;</span><br><span class="line">    white_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    Factory *black_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    Pants* black_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    Jeans* black_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    black_fac = <span class="keyword">new</span> <span class="built_in">BlackFactory</span>();</span><br><span class="line">    black_pants = black_fac-&gt;<span class="built_in">MakePants</span>();</span><br><span class="line">    black_pants-&gt;<span class="built_in">type</span>();</span><br><span class="line">    black_jeans = black_fac-&gt;<span class="built_in">MakeJeans</span>();</span><br><span class="line">    black_jeans-&gt;<span class="built_in">type</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">delete</span> black_fac;</span><br><span class="line">    black_fac = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> black_pants;</span><br><span class="line">    black_pants = <span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">delete</span> black_jeans;</span><br><span class="line">    black_jeans = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/16/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/3.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>工厂模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
        <tag>应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之单例模式</title>
    <url>/2022/08/17/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之单例模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>单例模式顾名思义，保证一个类在内存中仅有一个实例化对象，并提供一个可以访问它的全局化接口。实现单例模式必须注意以下几点：</p>
<ol>
<li>单例类只能有一个实例化对象。</li>
<li>单例类必须自己提供一个实例化对象。</li>
<li>单例类必须提供一个可以访问唯一实例化对象的接口。<br>单例模式分为懒汉式和饿汉式两种实现方式。</li>
</ol>
<h1 id="懒汉单例模式"><a href="#懒汉单例模式" class="headerlink" title="懒汉单例模式"></a>懒汉单例模式</h1><p>懒汉，顾名思义，不到万不得已就不会去实例化类，也就是说第一次用到类实例的时候才会去实例化一个对象。在访问量较小，甚至可能不会去访问的情况下，采用懒汉实现，以时间换空间。</p>
<h2 id="非线程安全的懒汉单例模式"><a href="#非线程安全的懒汉单例模式" class="headerlink" title="非线程安全的懒汉单例模式"></a>非线程安全的懒汉单例模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    关键代码：构造函数私有，不能通过赋值运算，拷贝构造等方法实例化对象</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//懒汉式一般实现：非线程安全，getInstance返回的实例指针需要delete</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">SingleMan</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line">&#125;;</span><br><span class="line">SingleMan *SingleMan::m_singleMan = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan *<span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_m_singleMan;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="非线程安全的懒汉单例模式-1"><a href="#非线程安全的懒汉单例模式-1" class="headerlink" title="非线程安全的懒汉单例模式"></a>非线程安全的懒汉单例模式</h2><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan *<span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line">    ~<span class="built_in">SingleMan</span>()&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line"></span><br><span class="line">    std::mutex m_lock;</span><br><span class="line">&#125;;</span><br><span class="line">SingleMan *SingleMan::m_singleMan = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan *<span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        m_lock.<span class="built_in">lock</span>();</span><br><span class="line">        <span class="keyword">if</span>(m_singleMan == <span class="literal">nullptr</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        m_lock.<span class="built_in">unlock</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m_m_singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="返回一个reference指向local-static对象"><a href="#返回一个reference指向local-static对象" class="headerlink" title="返回一个reference指向local static对象"></a>返回一个reference指向local static对象</h2><p>这种单例模式实现方式多线程可能存在不确定性：任何一种non-const static 对象，不论它是local还是non-local，在多线程环境下”等待某事发生“都会有麻烦。<br>解决办法：在程序的单线程启动阶段手工调用所有reference-returing函数。<br>下面这种实现方式的好处就是你不需要去关心实例的释放，因为static修饰的变量生命周期和程序一样长。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan&amp; <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">SingleMan&amp; <span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">static</span> SingleMan singleMan;</span><br><span class="line">    <span class="keyword">return</span> singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="饿汉单例模式"><a href="#饿汉单例模式" class="headerlink" title="饿汉单例模式"></a>饿汉单例模式</h1><p>饿汉模式，在访问量较大，或者访问线程较多时，采用饿汉实现，可以实现更好的性能。这是一种空间换时间的策略。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//饿汉式：线程安全，注意一定要在合适的地方去delete它</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SingleMan</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">static</span> SingleMan* <span class="title">getInstance</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">SingleMan</span>()&#123;&#125;                                           <span class="comment">//不允许类外实例化</span></span><br><span class="line">    <span class="built_in">SingleMan</span>(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;               <span class="comment">//不允许拷贝构造</span></span><br><span class="line">    SingleMan&amp; <span class="keyword">operator</span>=(<span class="type">const</span> SingleMan&amp; man) = <span class="keyword">delete</span>;    <span class="comment">//不允许赋值</span></span><br><span class="line">​</span><br><span class="line">    <span class="type">static</span> SingleMan* m_singleMan;</span><br><span class="line">&#125;;</span><br><span class="line">​</span><br><span class="line">SingleMan* SingleMan::m_singleMan = <span class="keyword">new</span> <span class="built_in">SingleMan</span>();</span><br><span class="line">​</span><br><span class="line"><span class="function">SingleMan* <span class="title">SingleMan::getInstance</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> m_singleMan;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>UML类图：<br><img src="/2022/08/17/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>单例模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
        <tag>应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>Cpp设计模式之策略模式</title>
    <url>/2022/08/22/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>C++常用设计模式之策略模式</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><p>策略模式是指定义一系列的算法，把它们一个个的封装起来，并且使它们可以互相替换。本模式可以使得算法独立于它的客户而变化。也就是说这些算法完成的功能一样，对外的接口一样，只是各自实现实现上存在差异。用策略模式来封装算法，效果比较好。<br>下面以高速缓存（Cache）的替换算法为例，实现策略模式。<br>所谓Cache的替换算法，就是当Cache发生缺失时，Cache控制器必须选择Cache中的一行并用欲获得的数据替换它。所采用的选择策略就是Cache的替换算法。相应的UML类图如下：<br><img src="/2022/08/22/Cpp%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/1.jpeg" alt="img not found"></p>
<h1 id="算法定义"><a href="#算法定义" class="headerlink" title="算法定义"></a>算法定义</h1><p>这里首先给出算法的定义。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">ReplaceAlgorithm</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> <span class="type">void</span> <span class="title">replace</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRU_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Least Recently Used replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FIFO_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;First in First out replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Random_ReplaceAlgorithm</span> : <span class="keyword">public</span> ReplaceAlgorithm</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">repace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;Random replace algorithm&quot;</span>&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="实现方式1"><a href="#实现方式1" class="headerlink" title="实现方式1"></a>实现方式1</h1><p>接着给出Cache的定义，这里很关键，Cache的实现方式直接影响了客户的使用方式，其关键在于怎么指定替换算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cache</span>(ReplaceAlgorithm *ra)</span><br><span class="line">    &#123;</span><br><span class="line">        m_ra = ra;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Cache</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> m_ra;</span><br><span class="line">        m_ra = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ra-&gt;<span class="built_in">replace</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    ReplaceAlgorithm *m_ra;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Cache <span class="title">cache</span><span class="params">(<span class="keyword">new</span> LRU_ReplaceAlgorithm())</span></span>; <span class="comment">//暴露了算法的定义  </span></span><br><span class="line">    cache.<span class="built_in">Replace</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这种方式暴露给了客户具体的算法的定义。</p>
<h1 id="实现方式2"><a href="#实现方式2" class="headerlink" title="实现方式2"></a>实现方式2</h1><figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cache需要用到替换算法  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">enum</span> <span class="title class_">RA</span> &#123;LRU, FIFO, RANDOM&#125;; <span class="comment">//标签  </span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span>  </span><br><span class="line">&#123;  </span><br><span class="line"><span class="keyword">private</span>:  </span><br><span class="line">    ReplaceAlgorithm *m_ra;  </span><br><span class="line"><span class="keyword">public</span>:  </span><br><span class="line">    <span class="built_in">Cache</span>(<span class="keyword">enum</span> RA ra)   </span><br><span class="line">    &#123;   </span><br><span class="line">        <span class="keyword">if</span>(ra == LRU)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">LRU_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ra == FIFO)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">FIFO_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(ra == RANDOM)  </span><br><span class="line">            m_ra = <span class="keyword">new</span> <span class="built_in">Random_ReplaceAlgorithm</span>();  </span><br><span class="line">        <span class="keyword">else</span>   </span><br><span class="line">            m_ra = <span class="literal">NULL</span>;  </span><br><span class="line">    &#125;  </span><br><span class="line">    ~<span class="built_in">Cache</span>() &#123; <span class="keyword">delete</span> m_ra; &#125;  </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span> </span>&#123; m_ra-&gt;<span class="built_in">Replace</span>(); &#125;  </span><br><span class="line">&#125;; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span>  </span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="function">Cache <span class="title">cache</span><span class="params">(LRU)</span></span>; <span class="comment">//指定标签即可  </span></span><br><span class="line">    cache.<span class="built_in">Replace</span>();  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;  </span><br><span class="line">&#125;  </span><br></pre></td></tr></table></figure>
<p>这种方式也是通过参数指定，不过不是传入指针，而是传入算法的枚举。这样客户就不需要知道算法的具体定义，只需要知道算法的标签即可。</p>
<h1 id="实现方式3"><a href="#实现方式3" class="headerlink" title="实现方式3"></a>实现方式3</h1><p>以上两种实现方式都需要构造函数传参才能实现，是否可以不需要构造函数传参的方式来实现？<br>利用模板来实现。算法通过模板的实参指定，虽然还是使用了参数，但是不是构造函数的参数。在策略模式中，参数的传递难以避免，客户必须指定某种算法。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="comment">//Cache需要用到的替换算法</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">RA</span>&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Cache</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    RA m_ra;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Cache</span>()&#123;&#125;</span><br><span class="line">    ~<span class="built_in">Cache</span>()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Replace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        m_ra.<span class="built_in">repalce</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">(<span class="type">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Cache &lt;Random_ReplaceAlgorithm&gt; cache;<span class="comment">//模板实参</span></span><br><span class="line">    cache.<span class="built_in">replace</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>C++设计模式</category>
        <category>策略模式</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>面向对象编程</tag>
        <tag>设计模式</tag>
        <tag>应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>通用异步收发器UART</title>
    <url>/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第11章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解UART的原理</li>
<li>掌握S3C2410&#x2F;S3C2440中UART的使用</li>
</ol>
<h1 id="UART原理以及UART部件使用方法"><a href="#UART原理以及UART部件使用方法" class="headerlink" title="UART原理以及UART部件使用方法"></a>UART原理以及UART部件使用方法</h1><h2 id="UART原理说明"><a href="#UART原理说明" class="headerlink" title="UART原理说明"></a>UART原理说明</h2><p>通用异步收发器简称UART（Universal Asynchronous Reciver Transmitter），它用来传输串行数据。发送数据时，CPU将并行数据写入UART，UART按照一定的格式在一根电线上发出；接收数据时，UART检测另一根电线上的信号，将串行收集放在缓冲区中，CPU即可读取UART获得这些数据。UART之间以全双工方式传输数据，最精简的连线方法只有三根电线，TxD用于发送数据，RxD用于接收数据，GnD用于给双方提供参考电平。<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/1.jpeg" alt="img not found"><br>UART使用标准的TTL&#x2F;CMOS逻辑电平（0-5V、0-3.3V、0-2.5V、0-1.8V）来表示数据，高电平表示1，低电平表示0。为了增强数据的抗干扰能力、提高传输长度，通常将TTL&#x2F;CMOS逻辑电平转换为RS-232逻辑电平，3<del>12V表示0，-3</del>-12V表示1。<br>TxD、RxD数据线以“位”为最小单位传输数据。帧（Frame）由具有完整意义、不可分割的若干位组成，它包含开始位、数据位、校验位（需要的话）和停止位。发送数据之前，UART之间要约定好数据的传输速率（即每位所占据的时间，其倒数称为波特率）、数据的传输格式（即有多少个数据位、是否使用校验位、奇校验还是偶校验、有多少个停止位）。<br>数据传输流程如下：</p>
<ol>
<li>平时数据线处于空闭状态（1状态）。</li>
<li>当要发送数据时，UART改变TxD数据线的状态（变为0状态），并维持1位的时间，这样接收方检测到开始位之后，再等待1.5位的时间就开始一位一位检测数据线的状态得到所传输的数据。</li>
<li>UART一帧中可以有5、6、7或8位得数据，发送方一位一位地改变数据线的状态将它们发送出去，首先发送最低位。</li>
<li>如果使用校验功能，UART在发送完数据位之后，还要发送一个校验位。有两种校验方法：奇校验、偶校验—数据位连同校验位中“1”的数目等于奇数还是偶数。</li>
<li>最后，发送停止位，数据线恢复到空闭状态（1状态）。停止位的长度有3种：1位、1.5位、2位。</li>
</ol>
<p>下图演示了UART使用7个数据位、偶校验、2个停止位的格式传输字符’A‘（二进制格式为0b1000001）时，TTL&#x2F;CMOS逻辑电平、RS232逻辑电平对应的波形。<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/2.jpeg" alt="img not found"></p>
<h2 id="S3C2410-x2F-S3C2440-UART的特性"><a href="#S3C2410-x2F-S3C2440-UART的特性" class="headerlink" title="S3C2410&#x2F;S3C2440 UART的特性"></a>S3C2410&#x2F;S3C2440 UART的特性</h2><p>S3C2410&#x2F;S3C2440 中UART的特性相似，有3个独立的通道，每个通道都可以工作于中断模式或DMA模式，即UART可以发出中断或DMA请求以便在CPU、UART之间传输数据。S3C2410&#x2F;S3C2440 UART由波特率发生器、发送器、接收器和控制逻辑组成。<br>使用系统时钟时，S3C2410的UART波特率可以达到230.4Kbit&#x2F;s，S3C2440则可以达到115.2Kbit&#x2F;s；如果使用UEXTCLK引脚提供的外部时钟，则可以达到更高的波特率。波特率可以通过编程控制。<br>S3C2410 UART的每个控制通道都有16字节的发送FIFO和16字节的接收FIFO，S3C2440 UART的FIFO深度为64。发送数据时，CPU先将数据写入发送FIFO中，然后UART控制器会自动将FIFO中的数据复制到“发送移位器（Transmit Shifter）”中，发送移位器将数据一位一位的发送到TxD数据线上。接收数据时，“接收移位器（Receive Shifter）”，将RxD数据线上的数据一位一位的接收进来，然后复制到接收FIFO中，CPU即可从中读取数据。<br>S3C2410&#x2F;S3C2440 UART的每个通道支持的停止位有1位、2位，数据位有5、6、7或8位，支持校验功能，另外还有红外发送&#x2F;接收功能。<br>S3C2410&#x2F;S3C2440 UART结构如下图所示：<br><img src="/2022/08/24/%E9%80%9A%E7%94%A8%E5%BC%82%E6%AD%A5%E6%94%B6%E5%8F%91%E5%99%A8UART/3.jpeg" alt="img not found"></p>
<h2 id="S3C2410-x2F-S3C2440-UART的使用"><a href="#S3C2410-x2F-S3C2440-UART的使用" class="headerlink" title="S3C2410&#x2F;S3C2440 UART的使用"></a>S3C2410&#x2F;S3C2440 UART的使用</h2><p>在使用UART之前需要设置波特率、传输格式；对于S3C2410&#x2F;S3C2440，还要选择所涉及管脚为UART功能，选择UART通道的工作模式为中断模式还是DMA模式。设置好之后，往某个寄存器写入数据即可发送。可以通过查询状态寄存器或设置中断来获知数据是否已经发送完毕、是否已经接收到数据。</p>
<h3 id="将所涉及的UART通道管脚设为UART功能"><a href="#将所涉及的UART通道管脚设为UART功能" class="headerlink" title="将所涉及的UART通道管脚设为UART功能"></a>将所涉及的UART通道管脚设为UART功能</h3><p>比如UART通道0中，GPH2、GPH3分别用作TXD0、RXD0，要使用UART通道0时，先设置GPHCON寄存器将GPH2、GPH3引脚的功能设为TXD0、RXD0。</p>
<h3 id="UBRDIVn寄存器（UART-BAUD-RATE-DIVISOR）：设置波特率"><a href="#UBRDIVn寄存器（UART-BAUD-RATE-DIVISOR）：设置波特率" class="headerlink" title="UBRDIVn寄存器（UART BAUD RATE DIVISOR）：设置波特率"></a>UBRDIVn寄存器（UART BAUD RATE DIVISOR）：设置波特率</h3><p>S3C2410 UART的时钟源有两种选择：PCLK、UEXTCLK；S3C2440的时钟源有三种选择：PCLK、UEXTCLK、FCLK&#x2F;n，其中n通过UCON0<del>UCON2联合设置。<br>根据给定的波特率、所选择的时钟源的频率，可以通过以下公式计算UBRDIVn寄存器（n为0</del>2，对应3个UART通道）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">UBRDIVn = (<span class="type">int</span>)(UART clock/(baud rate x <span class="number">16</span>)) - <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>上述公式计算出来的UBRDIVn寄存器值不一定是整数，只要误差在1.87%之内即可。误差计算公式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tUPCLK = (UBRDIVn + <span class="number">1</span>) x <span class="number">16</span> x <span class="number">1F</span>rame / (UART clock)     <span class="comment">//tUPCLK 实际的UART时钟</span></span><br><span class="line">tUEXACT = <span class="number">1F</span>rame / baud rate                            <span class="comment">//tUEXACT 理论的UART时钟</span></span><br><span class="line">UART error = (tUPCLK - tUEXACT) / tUEXACT x <span class="number">100</span>%        <span class="comment">//误差</span></span><br></pre></td></tr></table></figure>

<h3 id="ULCONn寄存器（UART-LINE-CONTROL）：设置传输格式"><a href="#ULCONn寄存器（UART-LINE-CONTROL）：设置传输格式" class="headerlink" title="ULCONn寄存器（UART LINE CONTROL）：设置传输格式"></a>ULCONn寄存器（UART LINE CONTROL）：设置传输格式</h3><p>ULCONn寄存器（n为0~2）格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>数据位宽度</td>
<td>[1:0]</td>
<td>0b00：5位<br> 0b01：6位<br> 0b10：7位<br> 0b11：8位</td>
</tr>
<tr>
<td>停止位宽度</td>
<td>[2]</td>
<td>0：一帧中有一个停止位 <br>1：一帧中有两个停止位</td>
</tr>
<tr>
<td>校验模式</td>
<td>[5:3]</td>
<td>设置校验位的产生方法、检验方法: <br> 0b0xx：无校验 <br>0b100：奇校验<br>0b101：偶校验<br>0b110：发送数据时强制设为1，接收数据时检查是否为1<br>0b111：发送数据时强制设为0，接收数据时检查是否为0</td>
</tr>
<tr>
<td>红外模式</td>
<td>[6]</td>
<td>0：正常模式<br>1：红外模式</td>
</tr>
</tbody></table>
<p>UART通道被设为红外模式时，其串行数据的波形与正常模式稍有不同。</p>
<h3 id="ULCONn寄存器（UART-CONTROL）"><a href="#ULCONn寄存器（UART-CONTROL）" class="headerlink" title="ULCONn寄存器（UART CONTROL）"></a>ULCONn寄存器（UART CONTROL）</h3><p>ULCONn寄存器用于选择UART时钟源、设置UART中断方式等。S3C2410 UART的时钟源有两种选择：PCLK、UEXTCLK；S3C2440的时钟源有三种选择：PCLK、UEXTCLK、FCLK&#x2F;n。所以在时钟源的选择与设置方面稍有不同。<br>S3C2410的ULCONn寄存器格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>接收模式</td>
<td>[1:0]</td>
<td>选择如何从UART接收缓冲区中读取数据。<br>0b00：禁止接收数据 <br>0b01：中断方式或者查询方式 <br>0b10：DMA0请求（UART0） DMA3请求（UART2）<br>0b11：DMA1请求（UART1）</td>
</tr>
<tr>
<td>发送模式</td>
<td>[3:2]</td>
<td>选择如何将数据发送到UART发送缓存区。<br>0b00：禁止发送数据 <br>0b01：中断方式或者查询方式 <br>0b10：DMA0请求（UART0） DMA3请求（UART2）<br>0b11：DMA1请求（UART1）</td>
</tr>
<tr>
<td>自环模式</td>
<td>[5]</td>
<td>自环模式就是将TxDn和RxDn在内部相连，用于自发自收。<br>0：正常模式 1：自环模式</td>
</tr>
<tr>
<td>接收错误状态中断使能</td>
<td>[6]</td>
<td>用于使能当发生错误时（帧错误、溢出）时，产生中断。<br> 0：出错时不产生中断 <br>1：出错时产生中断</td>
</tr>
<tr>
<td>接收超时使能</td>
<td>[7]</td>
<td>当使用UART FIFO时，用于使能&#x2F;禁止接收超时的中断。 <br>0&#x3D;禁止 1&#x3D;使能</td>
</tr>
<tr>
<td>接收中断方式</td>
<td>[8]</td>
<td>如下情况发生时，将产生接收中断。<br> 不使用FIFO时，接收到一个数据；<br>使用FIFO时，FIFO中的数据达到RxFIFO的触发阈值。<br>中断方式如下设置。<br>0：脉冲 <br>1：电平</td>
</tr>
<tr>
<td>发送中断方式</td>
<td>[9]</td>
<td>如下情况发生时，将产生发送中断。<br> 不使用FIFO时，发送缓冲区变空；<br>使用FIFO时，FIFO中的数据达到TxFIFO的触发阈值。<br>中断方式如下设置。<br>0：脉冲 <br>1：电平</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[10]</td>
<td>选择UART时钟源。<br>0：PCLK <br>UEXTCLK</td>
</tr>
</tbody></table>
<p>S3C2440的UCONn寄存器在UART时钟的选择方面与S3C2410有所不同，从位[10]往上的位含义不一样，并且原来的位[4]用于选择是否发出“break”信号，这些位的含义如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>“break”信号</td>
<td>[4]</td>
<td>设置此位时，UART会在一帧的时间内发出一个“break”信号。<br>0：正常发送  1：发出“break”信号</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[11:10]</td>
<td>选择UART时钟源。<br>0b00&#x2F;0b10：PCLK <br> 0b01：UEXTVLK <br> 0b11：FCLK&#x2F;n</td>
</tr>
<tr>
<td>FCLK分频率系数</td>
<td>[15:12]</td>
<td>用来设置“FCLK&#x2F;n”中的n值</td>
</tr>
</tbody></table>
<p>ULCON0、ULCON1、ULCON2这3个寄存器的位[15:12]一起用来确定n值，它们的意义如下。</p>
<ol>
<li>ULCON2[15]：“FCLK&#x2F;n”使能位。<br>它等于0时，禁止使用“FCLK&#x2F;n”作为UART时钟源；等于1时，可以用作UART时钟源。</li>
<li>n值的设置。<br>ULCON0[15:12]、ULCON1[15:12]、ULCON2[14:12]三者用于设置n值，当其中一个被设置为非0值时，其他两个必须为0。<ol>
<li>n值处于7~12时，UART时钟&#x3D;FCLK&#x2F;（divider + 6），divider为ULCON0[15:12]的值，大于0。</li>
<li>n值处于22~36时，UART时钟&#x3D;FCLK&#x2F;（divider + 21），divider为ULCON1[15:12]的值，大于0。</li>
<li>n值处于37~43时，UART时钟&#x3D;FCLK&#x2F;（divider + 36），divider为ULCON2[14:12]的值，大于0。</li>
<li>ULCON0[15:12]、ULCON1[15:12]、ULCON2[14:12]都等于0时，UART时钟：FCLK&#x2F;44。</li>
</ol>
</li>
</ol>
<h3 id="UFCONn寄存器（UART-FIFO-CONTROL）、UFSTATn寄存器（UART-FIFO-STATUS）"><a href="#UFCONn寄存器（UART-FIFO-CONTROL）、UFSTATn寄存器（UART-FIFO-STATUS）" class="headerlink" title="UFCONn寄存器（UART FIFO CONTROL）、UFSTATn寄存器（UART FIFO STATUS）"></a>UFCONn寄存器（UART FIFO CONTROL）、UFSTATn寄存器（UART FIFO STATUS）</h3><p>UFCONn寄存器用于设置是否使用FIFO，设置各FIFO的触发阈值，即发送FIFO中有多少个数据产生中断、接收FIFO中有多少个数据产生中断。并可以通过设置UFCONn寄存器来复位各个FIFO。<br>读取UFSTATn寄存器可以知道各个FIFO是否已经满、其中有多少个数据。<br>不适用FIFO时，可以认为FIFO的深度是1，使用FIFO时，S3C2410的FIFO深度是16，S3C2440的深度是64。</p>
<h3 id="UMCONn寄存器（UART-MODEM-CONTROL）、UMSTATn寄存器（UART-MODEM-STATUS）"><a href="#UMCONn寄存器（UART-MODEM-CONTROL）、UMSTATn寄存器（UART-MODEM-STATUS）" class="headerlink" title="UMCONn寄存器（UART MODEM CONTROL）、UMSTATn寄存器（UART MODEM STATUS）"></a>UMCONn寄存器（UART MODEM CONTROL）、UMSTATn寄存器（UART MODEM STATUS）</h3><p>这两类寄存器用于流量控制。</p>
<h3 id="UTRSTATn寄存器（UART-TX-x2F-RX-STATUS）"><a href="#UTRSTATn寄存器（UART-TX-x2F-RX-STATUS）" class="headerlink" title="UTRSTATn寄存器（UART TX&#x2F;RX STATUS）"></a>UTRSTATn寄存器（UART TX&#x2F;RX STATUS）</h3><p>UTRSTATn寄存器用来表明数据是否已经发送完毕、是否已经接收到数据。格式如下表所示。缓冲区其实就是FIFO，只不过不适用FIFO时，FIFO的深度为1。</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>接收缓冲区数据就绪</td>
<td>[0]</td>
<td>当接收到数据时，此位被自动设为1</td>
</tr>
<tr>
<td>发送缓冲区空</td>
<td>[1]</td>
<td>当发送缓冲区没有数据时，此位被自动设为1</td>
</tr>
<tr>
<td>发送器空</td>
<td>[2]</td>
<td>当发送缓冲区中没有数据，并且最后一个数据也已经发送出去，此位被自动设为1</td>
</tr>
</tbody></table>
<h3 id="UERSTATn寄存器（UART-ERROR-STATUS）"><a href="#UERSTATn寄存器（UART-ERROR-STATUS）" class="headerlink" title="UERSTATn寄存器（UART ERROR STATUS）"></a>UERSTATn寄存器（UART ERROR STATUS）</h3><p>用来表示各种错误是否发生，位[0]~位[3]为1时分别表示溢出错误、校验错误、帧错误、检测到“break”信号。读取这个寄存器时，它会自动清0。<br>需要注意的是，接收数据时如果使用FIFO，则UART内部会使用一个“错误FIFO”来表明接收FIFO中哪个数据在接收过程中发生了错误。CPU只有在读出这个错误的数据时，才会察觉到发生了错误。要想清除“错误FIFO”，则必须读出错误的数据，并读出UERSTATn寄存器。</p>
<h3 id="UTXHn寄存器（UART-TRANSMIT-BUFFER-REGISTER）"><a href="#UTXHn寄存器（UART-TRANSMIT-BUFFER-REGISTER）" class="headerlink" title="UTXHn寄存器（UART TRANSMIT BUFFER REGISTER）"></a>UTXHn寄存器（UART TRANSMIT BUFFER REGISTER）</h3><p>CPU将数据写入这个寄存器，UART即会将它保存到缓冲区，并自动发送出去。</p>
<h3 id="URXHn寄存器（UART-RECEIVER-BUFFER-REGISTER）"><a href="#URXHn寄存器（UART-RECEIVER-BUFFER-REGISTER）" class="headerlink" title="URXHn寄存器（UART RECEIVER BUFFER REGISTER）"></a>URXHn寄存器（UART RECEIVER BUFFER REGISTER）</h3><p>当UART接收到数据，CPU读取这个寄存器，即可获得数据。</p>
<h1 id="UART操作实例"><a href="#UART操作实例" class="headerlink" title="UART操作实例"></a>UART操作实例</h1><h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>本示例代码的目的是在串口上输出一串字符，单板接收到后将它的ASCII码加1后从串口输出。<br>首先设置MPLL提高系统时钟，令PCLK为50MHz，UART将选择PCLK为时钟源。将代码复制到SDRAM中之后，调用main函数。重点在于UART0的初始化、收发数据，这由3个函数来实现：uart0_init、getc和putc。</p>
<h3 id="UART初始化"><a href="#UART初始化" class="headerlink" title="UART初始化"></a>UART初始化</h3><p>uart0_init函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> PCLK                        50000000            <span class="comment">//init.c中的clock_init函数设置PCLK为50MHz</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_CLK                    PCLK                <span class="comment">//UART0的时钟源设置为PCLK</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BAUD_RATE              115200              <span class="comment">//波特率</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> UART_BRD                    ((UART_CLK / (UART_BAUD_RATE * 16 )) - 1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化UART0</span></span><br><span class="line"><span class="comment">115200 8N1 无流控</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">uart0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPHCON |= <span class="number">0xa0</span>;                     <span class="comment">//GPH2、GPH3用作TXD0、RXD0</span></span><br><span class="line">    GPHUP   = <span class="number">0x0c</span>;                     <span class="comment">//GPH2、GPH3内部上拉</span></span><br><span class="line"></span><br><span class="line">    ULCON0  = <span class="number">0x03</span>;                     <span class="comment">//波特率为115200，数据格式为：8个数据位、没有流控、1个停止位</span></span><br><span class="line">    UCON0   = <span class="number">0x05</span>;                     <span class="comment">//查询方式，UART时钟源位PLCK</span></span><br><span class="line">    UFCON0  = <span class="number">0x00</span>;                     <span class="comment">//不使用FIFO</span></span><br><span class="line">    UMCON0  = <span class="number">0x00</span>;                     <span class="comment">//不使用流控</span></span><br><span class="line">    UBRDIV0 = UART_BRD;                 <span class="comment">//波特率位115200</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="发送字符的函数"><a href="#发送字符的函数" class="headerlink" title="发送字符的函数"></a>发送字符的函数</h3><p>本实例不使用FIFO，发送字符前，首先判断上一个字符是否已经被发送出去。如果没有，则不断查询UTRSTAT0寄存器的位[2]，当它为1时表示已经发送完毕。于是，即可向UTXH0寄存器中写入当前要发送的字符。代码如下（宏TXD0READY被定义为（1 &lt;&lt; 2））:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">发送一个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">putc</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待，直到发送缓区中的数据已经全部发送出去</span></span><br><span class="line">    <span class="keyword">while</span>(!(UTRSTAT0 &amp; TXD0READY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//向UTXH0寄存器中写入数据，UART即自动将它发送出去</span></span><br><span class="line">    UTXH0 = c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收字符的函数"><a href="#接收字符的函数" class="headerlink" title="接收字符的函数"></a>接收字符的函数</h3><p>试图读取数据前，先查询UTRSTAT0寄存器的位[1]，当它为1时表示接收缓冲区有数据，于是，即可读取URXH0得到数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">接收一个字符</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> <span class="title function_">getc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//等待，直到接收缓存区有数据</span></span><br><span class="line">    <span class="keyword">while</span>(!(UTRSTAT0 &amp; RXD0READY));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接读取URXH0寄存器，即可获得接收到的数据</span></span><br><span class="line">    <span class="keyword">return</span> URXH0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>在main函数中，初始化UART0之后，即不断读取串口数据，并判断它是否为数字或字母。如果是的话，就将它加1后从串口输出。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;serial.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> c;</span><br><span class="line"></span><br><span class="line">    uart0_init();               <span class="comment">//波特率115200，8N1（8个数据位，无校验位，1个停止位）</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//从串口接收到数据之后，判断其是否为数字或字母，若是则加1后输出</span></span><br><span class="line">        c = getc();</span><br><span class="line">        <span class="keyword">if</span>(isDigital(c) || isLetter(c))</span><br><span class="line">            putc(c+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="测试方式"><a href="#测试方式" class="headerlink" title="测试方式"></a>测试方式</h2><p>首先使用串口将开发板的COM0和PC的串口相连，打开PC上的串口工具（推荐使用SecureCRT），设置其波特率为115200、8N1（8个数据位，无校验位，1个停止位）。然后将编译生成的uart.bin文件烧入NAND Flash后上电运行。最后在PC上的串口工具中输入数字或者字母，可以看到输出另一个字符（加1）；如果输入其他字符，则无输出。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第11章 通用异步收发器UART</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>UART总线</tag>
      </tags>
  </entry>
  <entry>
    <title>Oops信息解析</title>
    <url>/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>内核的Oops信息对于做嵌入式Linux开发的来说非常常见，在此单独划作一章。</p>
<span id="more"></span>

<h1 id="Oops信息及栈回溯"><a href="#Oops信息及栈回溯" class="headerlink" title="Oops信息及栈回溯"></a>Oops信息及栈回溯</h1><h2 id="Oops信息来源及格式"><a href="#Oops信息来源及格式" class="headerlink" title="Oops信息来源及格式"></a>Oops信息来源及格式</h2><p>Oops这个单词含义为“惊讶”，当内核出错时（比如访问非法地址）打印出来的信息被称为Oops信息。<br>Oops信息包含以下几部分内容。</p>
<ol>
<li>一段文本描述信息<br>比如类似<code>“Unable to handle kernel NULL pointer dereference at virtual address 00000000”</code>的信息，它说明了发生的是哪类错误。</li>
<li>Oops信息的序号。<br>比如是第1次、第2次等。这些信息与下面类似，中括号内的数据表示序号。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Internal error: Oops:805 [#1]</span><br></pre></td></tr></table></figure></li>
<li>内核中加载的模块名称，也可能没有，以下面字样开头。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Modules linked in:</span><br></pre></td></tr></table></figure></li>
<li>发生错误的CPU序号，对于单处理器的系统，序号为0，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CPU: 0 Not tainted (2.6.22.6 #36)</span><br></pre></td></tr></table></figure></li>
<li>发生错误时CPU的各个寄存器的值。</li>
<li>当前进程的名字及进程ID，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Process swapper (pid:1,stack limit = 0xc0480258)</span><br></pre></td></tr></table></figure>
并不是说发生错误的是这个进程，而是表示发生错误时，当前进程是它。错误可能发生在内核代码、驱动程序，也可能就是这个进程的错误。</li>
<li>栈信息</li>
<li>栈回溯信息，可以从中看出函数调用关系，形式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Backstrace:</span><br><span class="line">[&lt;c001a6f4&gt;] (s3c2410fb_probe + 0x0/0x560) from [&lt;c01bf4e8&gt;] (platform_drv_probe + 0x20/0x24)</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li>
<li>出错指令附近的指令的机器码，比如（出错指令在小括号里）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Code : e24cb004 e24dd010 e59f34e0 e3a07000 (e5873000)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="配置内核使Oops信息的栈回溯信息更直观"><a href="#配置内核使Oops信息的栈回溯信息更直观" class="headerlink" title="配置内核使Oops信息的栈回溯信息更直观"></a>配置内核使Oops信息的栈回溯信息更直观</h2><p>Linux 2.6.22自身具备的调试功能，可以使得打印出的Oops信息更直观。通过Oops信息中PC寄存器的值可以知道出错指令的地址，通过栈回溯信息可以知道出错时的函数调用关系，根据这两点可以快速定位错误。<br>要让内核出错时能够快速打印栈回溯信息，<code>编译内核要增加“-fno-omit-frame-pointer”选项</code>，这可以通过<code>配置CONFIG_FRAME_POINTER</code>来实现。查看内核目录下的配置文件.config，确保CONFIG_FRAME_POINTER已经被定义，如果没有，执行“make menuconfig”命令重新配置内核。CONFIG_FRAME_POINTER有可能已经被其他配置项自动选上。</p>
<h2 id="使用Oops信息调试内核的实例"><a href="#使用Oops信息调试内核的实例" class="headerlink" title="使用Oops信息调试内核的实例"></a>使用Oops信息调试内核的实例</h2><h3 id="获得Oops信息"><a href="#获得Oops信息" class="headerlink" title="获得Oops信息"></a>获得Oops信息</h3><p>刻意修改LCD驱动程序<code>drivers/video/s3c2410fb.c</code>，加入错误代码：在<code>s3c2410fb_probe</code>函数开头增加如下两行代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int *ptest = NULL;</span><br><span class="line">*ptest = 0x1234;</span><br></pre></td></tr></table></figure>
<p>重新编译内核，启动后会出错并打印如下Oops信息：<br><img src="/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/1.jpeg" alt="img not found"><br><img src="/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/2.jpeg" alt="img not found"></p>
<h3 id="分析Oops信息"><a href="#分析Oops信息" class="headerlink" title="分析Oops信息"></a>分析Oops信息</h3><ol>
<li><p>明确出错原因<br>由出错信息<code>“Unable to handle kernel NULL pointer dereference at virtual address 00000000”</code>可知内核是因为<code>非法地址访问出错，使用了空指针</code>。</p>
</li>
<li><p>根据栈回溯信息找出函数调用关系<br>内核崩溃时，可以从pc寄存器得知崩溃发生时的函数、出错指令。但是很多情况下，错误有可能是它的调用者引入的，所以找出函数的调用关系也很重要。<br>部分栈回溯信息如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;c001a6f4&gt;] (s3c2410fb_probe + 0x0/0x560) from [&lt;c01bf4e8&gt;] (platform_drv_probe + 0x20/0x24)</span><br></pre></td></tr></table></figure>
<p>这行信息分为两部分，表示后面的<code>platform_drv_probe</code>函数调用了前面的<code>s3c2410fb_probe</code>函数。<br>前半部分含义为：“c001a6f4”是<code>s3c2410fb_probe</code>函数首地址偏移0的地址，这个函数大小为0x560。<br>后半部分含义为：“c01bf4e8”是<code>paltform_drv_probe</code>函数首地址偏移0x20的地址，这个函数大小为0x24。<br>另外，后半部的“[<c01bf4e8>]”表示<code>s3c2410fb_probe</code>执行后的返回地址。<br>对于类似下面的栈回溯信息，其中r8-r4表示<code>driver_probe_device</code>函数刚被调用时这些寄存器的值。</c01bf4e8></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[&lt;c01bd4c0&gt;] (driver_probe_device + 0x0/0x18c) from [&lt;c01bd788&gt;] (__driver_attach + 0x80/0xe0)</span><br><span class="line">r8:00000000 r7:c0389a3c r6:c01bd708 r5:c036256c r4:c0362644</span><br></pre></td></tr></table></figure>
<p>从上面的栈回溯信息可以知道内核出错时的函数调用关系如下，最后在<code>s3c2410fb_probe</code>函数内部崩溃。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">do_exit -&gt;</span><br><span class="line">    kernel_init -&gt;</span><br><span class="line">        s3c2410fb_init -&gt;</span><br><span class="line">            platform_driver_register -&gt;</span><br><span class="line">                driver_register -&gt;</span><br><span class="line">                    bus_add_driver -&gt;</span><br><span class="line">                        driver_attch -&gt;</span><br><span class="line">                            bus_for_each_dev -&gt;</span><br><span class="line">                                __driver_attach -&gt;</span><br><span class="line">                                    driver_probe_device -&gt;</span><br><span class="line">                                        platform_drv_probe -&gt;</span><br><span class="line">                                            s3c2410fb_probe</span><br></pre></td></tr></table></figure></li>
<li><p>根据pc寄存器的值确定出错位置<br>上述Oops信息中出错时的寄存器值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">PC is at s3c2410fb_probe+0x18/0x560</span><br><span class="line">LR is at platform_drv_probe+0x20/0x24</span><br><span class="line">pc : [&lt;c001a70c&gt;] lr : [&lt;c01bf4e8&gt;] psr : a0000013</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p><code>“PC is at s3c2410fb_probe+0x18/0x560”表示出错指令为s3c2410fb_probe函数中偏移为0x18的指令。</code><br>“pc : [<c001a70c>]”表示出错指令的地址为c001a70c（十六进制）。</c001a70c></p>
</li>
<li><p>结合内核源代码和反汇编代码定位问题<br>先生成内核的反汇编代码<code>vmlinux.dis</code>，执行以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/system/linux-2.6.22.6</span><br><span class="line">arm-linux-objdump -D vmlinux &gt; vmlinux.dis</span><br></pre></td></tr></table></figure>
<p>出错地址c001a70c附近的部分汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c001a6f4: &lt;s3c2410fb_probe&gt;:</span><br><span class="line">c001a6f4: e1a0c00d  mov ip, sp</span><br><span class="line">c001a6f8: e92ddff0  stmdb sp!, &#123;r4,r5,r6,r7,r8,r9,sl,fp,ip,lr,pc&#125;</span><br><span class="line">c001a6fc: e24cb004  sub fp, ip, #4; 0x4</span><br><span class="line">c001a700: e24dd010  sub sp, sp, #16; 0x10</span><br><span class="line">c001a704: e59f34e0  ldr r3, [pc, #1248]; c001abec&lt;.init + 0x1284c&gt;</span><br><span class="line">c001a708: e3a07000  mov r7, #0; 0x0</span><br><span class="line">c001a70c: e5873000  str r3, [r7] &lt;=========出错指令</span><br><span class="line">c001a710: e59030fc  ldr r3, [r0, #252]</span><br></pre></td></tr></table></figure>
<p>出错指令为<code>“str r3, [r7]”</code>，它把r3寄存器的值放到内存中，内存地址为r7寄存器的值。根据Oops信息中的寄存器值可知：<code>r3为0x00001234，r7为0。0地址不可访问，所以出错</code>。<br><code>s3c2410fb_probe</code>函数的部分c代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">static int __init s3c2410fb_probe(struct platform_device *pdev)</span><br><span class="line">&#123;</span><br><span class="line">    struct s3c2410fb_info *info;</span><br><span class="line">    struct fb_info  *fb_info;</span><br><span class="line">    struct s3c2410fb_hw *mregs;</span><br><span class="line">    int ret;</span><br><span class="line">    int irq;</span><br><span class="line">    int i;</span><br><span class="line">    u32 lcdcon1;</span><br><span class="line"></span><br><span class="line">    int *ptest = NULL;</span><br><span class="line">    *ptest = 0x1234;</span><br><span class="line"></span><br><span class="line">    mach_info = pdev-&gt;dev.paltform_data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>结合反汇编代码，很容易知道是“*ptest &#x3D; 0x1234;”导致错误，其中的ptest为空。<br>对于大多数情况，从反汇编代码定位到C代码并不容易，这需要较强的汇编程序阅读能力。通过栈回溯信息知道函数的调用关系，这已经可以帮助定位很多问题了。</p>
</li>
</ol>
<h2 id="使用Oops的栈信息手工进行栈回溯"><a href="#使用Oops的栈信息手工进行栈回溯" class="headerlink" title="使用Oops的栈信息手工进行栈回溯"></a>使用Oops的栈信息手工进行栈回溯</h2><p>前面说过，从Oops信息的pc寄存器值可得知崩溃发生时的函数、出错指令。但是错误有可能是它的调用者引入的，所以还是要找出函数的调用关系。<br>由于内核配置了CONFIG_FRAME_POINTER，当出现Oops信息时，会打印栈回溯信息。如果内核没有配置CONFIG_FRAME_POINTER，这时可以自己分析栈信息，找到函数的调用关系。</p>
<h3 id="栈的作用"><a href="#栈的作用" class="headerlink" title="栈的作用"></a>栈的作用</h3><p>一个程序包含代码段、数据段、BSS段、堆、栈；其中数据段用来存储初始值不为0的全局数据，BSS段用来存储初始值为0的全局数据，堆用于动态内存分配，栈用于实现函数调用、存储局部变量。<br>被调用函数在执行之前，它会将一些寄存器的值保存在栈中,其中包括返回地址寄存器lr。如果知道了所保存的lr寄存器的值，那就可以知道它的调用者是谁。在栈信息中，一个函数一个函数地往上找出所有保存的lr值，就可以知道各个调用函数，这就是栈回溯的原理。</p>
<h3 id="栈回溯实例分析"><a href="#栈回溯实例分析" class="headerlink" title="栈回溯实例分析"></a>栈回溯实例分析</h3><p>仍以前面的LCD驱动程序为例，使用上面的Oops信息的栈信息进行分析，栈信息如下：<br><img src="/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/3.jpeg" alt="img not found"></p>
<ol>
<li>根据pc寄存器值找到第一个函数，确定它的栈大小，确定调用函数。<br>从Oops信息可知pc值为c001a70c，使用它在内核反汇编程序<code>vmlinux.dis</code>中可以知道它位于<code>s3c2410fb_probe</code>函数内。<br>根据这个函数开始部分的汇编代码可以在知道栈的大小、lr返回值在栈中保存的位置，代码如下：<br><img src="/2022/09/22/Oops%E4%BF%A1%E6%81%AF%E8%A7%A3%E6%9E%90/4.jpeg" alt="img not found"><br>{r4,r5,r6,r7,r8,r9,sl,fp,ip,lr,pc}这11个寄存器都保存在栈中，指令“sub sp, sp, #16”又使得栈向下扩展了16字节，所以本函数的大小为（11 x 4 + 16）字节，即15个双字。<br>栈信息开始部分的15个数据就是本函数的栈内容，下面列出了它们所保存的寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1e60:           c02b1f70  00000020  c03625d4  c036256c  c036256c  00000000  c0389a3c</span><br><span class="line">                                                        r4        r5        r6</span><br><span class="line">1e80: c0389a3c  c03c420c  c0024864  00000000  c0481eac  c0481ea0  c01bf4e8  c001a704</span><br><span class="line">      r7        r8        r9        sl        fp        ip        lr        pc</span><br></pre></td></tr></table></figure>
其中lr值为c01bf4e8，表示函数s3c2410fb_probe执行完后的返回地址，它是调用函数中的地址。下面使用lr值再次重复本步骤的回溯过程。</li>
<li>根据lr寄存器值找到调用函数，确定它的栈大小，确定上一级调用函数。<br>根据上步得到的lr值（c01bf4e8）， 在内核反汇编程序vmlinux.dis中可以知道它位于<code>platform_drv_probe</code>函数内。<br>根据这个函数开始部分的反汇编代码可以知道栈的大小、lr返回值在栈中保存的位置。代码如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c01bf4c8  &lt;platform_drv_probe&gt;:</span><br><span class="line">c01bf4c8:   e1a0c00d    mov ip, sp</span><br><span class="line">c01bf4cc:   e92dd800    stmdb sp!,  &#123;fp,ip,lr,pc&#125;</span><br><span class="line">...   </span><br><span class="line">c01bf4e8:   e89da800    ldmia sp!,  &#123;fp,sp,pc&#125;      //lr值（c01bf4e8）对应的指令</span><br></pre></td></tr></table></figure>
{fp,ip,lr,pc}这4个寄存器都保存在栈中，本函数的栈大小为4个双字。Oops栈信息中，前一个函数s3c2410fb_probe的栈下面的4个数据就是函数platform_drv_probe的栈内容，如下所示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lea0:   c0481ed0  c0481eb0  c01bd5a8  c01bf4d8</span><br><span class="line">        fp        ip        lr        pc  </span><br></pre></td></tr></table></figure>
其中lr值为c01bd5a8，表示函数<code>platform_drv_probe</code>执行完后的返回地址，它是上一级调用函数中的地址。使用lr值，重复本步骤的查找过程，知道栈信息分析完毕或者再也无法分析，这样就可以找出所有的函数调用关系。<br>有些函数很简单，没有使用栈（sp在这个函数中没有吧变化），或者没有在栈中保存lr值。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>DEBUG</category>
        <category>Linux Kernel</category>
        <category>Oops信息解析</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>bug定位</tag>
      </tags>
  </entry>
  <entry>
    <title>设备与模块</title>
    <url>/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《Linux内核设计与实现》第17章总结归纳</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><ol>
<li>设备类型：在所有Unix系统中为了统一普通设备的操作所采用的分类</li>
<li>模块：Linux内核中用于按需加载和卸载目标码的机制</li>
<li>内核对象：内核数据结构支持面向对象的简单操作，还支持维护父子对象之间的关系</li>
<li>sysfs：表示系统中设备树的一个文件系统</li>
</ol>
<h1 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h1><p>在Linux以及所有的Unix中，设备被分为三种类型；</p>
<ol>
<li>块设备<br> 通常缩写为blkdev，块设备是可寻址的，寻址以块为单位。块设备通常支持重定位操作，即对数据的随机访问。常见的块设备有硬盘，光碟，Flash。块设备通常会被挂载为文件系统。</li>
<li>字符设备<br> 通常缩写为cdev，字符设备是不可寻址的，仅提供数据的流式访问（即一个一个字符或者一个一个字节）。常见的字符设备有键盘，鼠标，打印机等，还有大部分伪设备。应用程序可以直接访问字符设备节点与字符设备交互。</li>
<li>网络设备<br> 一般以Ethernet Device来称呼，它提供了对网络的访问，通过一种物理适配器（如网卡）和一种特定的协议（如IP）进行的。它不是通过文件节点来访问的，而是通过套接字来这样的特殊接口来访问。</li>
<li>伪设备<br> 并不是所有设备驱动都表示物理设备。有些设备驱动时虚拟的，仅仅提供访问访问内核功能而已，称之为伪设备。例如内核随机数发生器（&#x2F;dev&#x2F;null）,空设备（&#x2F;dev&#x2F;zero）,零设备（&#x2F;dev&#x2F;urandom），满设备（&#x2F;dev&#x2F;full），内存设备（&#x2F;dev&#x2F;mem）。</li>
</ol>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>Linux是单块内核的操作系统，即整个系统都运行与一个单独的保护域中，但是Linux内核却是模块化的。它允许内核在运行期间动态的向其中插入或删除代码。这些代码（相关的子例程，数据，函数出口，函数入口）被存放在一个单独的二进制镜像中，称之为模块。支持模块的好处就是基本的内核镜像能尽可能的小，因为可选的功能和驱动程序都可以以模块的形式再提供。当热插拔新设备时，可以重新载入新的驱动程序。</p>
<h2 id="一个最简单模块"><a href="#一个最简单模块" class="headerlink" title="一个最简单模块"></a>一个最简单模块</h2><p>虽然编写“Hello World”程序属于陈词滥调，但是它就是那么合适，下面就是属于内核模块的“Hello World”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello.c Hello World 我们的第一个内核模块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello_init--初始化函数，模块装载时被调用，如果成功装载，返回0，否则返回非零值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;hello init.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello_exit--退出函数，模块卸载时被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;hello exit.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LISENCE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Nibil&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A Hello World Module&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>hello_init()</code>函数是模块的入口点，它通过<code>module_init()</code>例程注册到系统中，在内核装载时被调用。<code>module_init()</code>是一个宏。<br>模块的所有初始化函数必须符合下面的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>因为它不会被外部调用，所以可以加上static修饰。在实际的模块初始化函数中，往往会注册资源，初始化硬件，分配数据结构等。如果这个文件被静态编译进入内核镜像，那么这个模块将会在内核启动时运行。<br><code>hello_exit()</code>函数是模块的出口函数，他由<code>module_exit()</code>例程注册到系统。在模块从内核中卸载时，便会调用<code>hello_exit()</code>。简单来说，该函数负责对模块生命周期内所做的一切事情的撤销工作，在<code>hello_exit()</code>返回后，模块就被卸载了。<br>退出函数必须符合下面的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>与init函数一样，你也可以用static修饰它。<br><code>MODULE_LISENCE()</code>用于指定模块的版权；<code>MODULE_AUTHOR()</code>和<code>MODULE_DESCRIPTION()</code>用于指定作者和模块的简要描述，他们完全是用作信息记录目的。</p>
<h2 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h2><p>在2.6的内核中采用了“KBuild”构建系统，现在构建模块相比从前更加容易。构建过程的第一步是决定在哪里管理模块代码。你可以把模块源码加入到内核源代码树上，或者是作为一个补丁，最终把你的代码合并到正式的内核代码树上；另一种可行的方法就是在内核源代码树之外维护和构建你的模块代码。</p>
<h3 id="放在内核源代码树上"><a href="#放在内核源代码树上" class="headerlink" title="放在内核源代码树上"></a>放在内核源代码树上</h3><p>当你决定了把你的模块放在内核源代码树上，下一步就要清楚放在内核源代码树的何处。设备驱动程序位于&#x2F;drivers的子目录下，在其内部，设备驱动程序被进一步按照类别，类型或者特殊驱动程序等更有序的组织起来。如字符设备存放于&#x2F;drivers&#x2F;char目录下，块设备存放于&#x2F;drivers&#x2F;block目录下，USB设备存放于&#x2F;drivers&#x2F;usb目录下。文件的具体组织规则并不是墨守成规，不容打破，很多USB设备也属于字符设备。不管怎样，这些组织关系对我们来说相当容易理解，而且也很准确。<br>假定你有一个字符设备，而且你希望将它存放于&#x2F;drivers&#x2F;char目录下，建议建立你自己代码的子目录。你的驱动程序是一个钓鱼竿和计算机的接口，那么你需要在&#x2F;drivers&#x2F;char下面建立一个fishing的子目录。接下来需要向&#x2F;drivers&#x2F;char下的Makefile文件添加一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-m += fishing/</span><br></pre></td></tr></table></figure>
<p>这行代码告诉模块构建系统，在模块编译时需要进入fishing&#x2F;子目录中。更有可能发生的是，你的驱动程序的编译取决于一个特殊配置选项；比如，可能的CONFIG_FISHING_POLE。那么，你可能需要用下面的指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing/</span><br></pre></td></tr></table></figure>
<p>最后，在&#x2F;drivers&#x2F;char&#x2F;fishing&#x2F;下，添加一个新的Makefile文件，其中需要有下面这行指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing.o</span><br></pre></td></tr></table></figure>
<p>以后，假如你的钓鱼竿程序需要更加智能化–它需要可以增加自动检测钓鱼线的功能。那么你的源程序就不止一个C文件了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing.o</span><br><span class="line">fishing-objs := fish-main.o fish-line.o</span><br></pre></td></tr></table></figure>
<p>每当设置了CONFIG_FISHING_POLE，fishing-main.c和fishing-line.c就会被一起编译链接到fishin.ko中去。最后需要注意的是，构建文件时你可能需要额外的编译标记，你只需要在Makefile中添加如下命令，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS += -DTITANIUM_POLE</span><br></pre></td></tr></table></figure>
<p>然后就开始编译吧！</p>
<h3 id="放在内核代码外"><a href="#放在内核代码外" class="headerlink" title="放在内核代码外"></a>放在内核代码外</h3><p>模块在内核内和在内核外的构建的区别在于构建过程。当模块在内核源码树外时，你必须告诉make如何找到内核源代码文件和Makefile文件，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make -C /kernel/source/location SUBDIRS=$PWD modules</span><br></pre></td></tr></table></figure>
<p>在这个例子中，&#x2F;kernel&#x2F;source&#x2F;location是你自己配置的内核源码树。</p>
<h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>编译后的模块将被装入到目录&#x2F;lib&#x2F;modules&#x2F;version&#x2F;kernel下，在将kernel&#x2F;目录下的每一个目录都对应着内核源码树中的模块位置。如果使用的是2.6.34的内核，而且将你的模块源代码直接放在&#x2F;drivers&#x2F;char下，那么编译后的钓鱼杆驱动程序的存放路径将是:&#x2F;lib&#x2F;modules&#x2F;2.6.34&#x2F;kernel&#x2F;drivers&#x2F;char&#x2F;fishing.ko。<br>下面的构建命令用来安装编译的模块到合适的目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<h2 id="产生模块依赖性"><a href="#产生模块依赖性" class="headerlink" title="产生模块依赖性"></a>产生模块依赖性</h2><p>Linux模块之间存在依赖性，也就是说钓鱼模块依赖于鱼饵模块，那么当你载入钓鱼模块时，鱼饵模块会自动被载入。你可以使用如下命令获取内核模块之间的依赖信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depmod</span><br><span class="line">depmod -A #模块依赖关系存放于/lib/modules/version/modules.dep中。</span><br></pre></td></tr></table></figure>

<h2 id="载入模块"><a href="#载入模块" class="headerlink" title="载入模块"></a>载入模块</h2><p>载入模块最简单的方法就是通过insmod命令，它的功能就是请求内核载入指定的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insmod module.ko</span><br><span class="line">rmmod module #卸载一个模块</span><br></pre></td></tr></table></figure>
<h2 id="管理配置选项"><a href="#管理配置选项" class="headerlink" title="管理配置选项"></a>管理配置选项</h2><p>这里我们继续以钓鱼竿驱动程序为例，看看一个新的配置选项如何加入。<br>由于2.6内核新引入了“Kbuild”系统，你所需要做的就是想Kconfig文件中添加一项，用以对应内核源码树。对驱动程序而言，kconfig通常和源代码处于同一目录。如果钓鱼杆驱动程序位于&#x2F;drivers&#x2F;char下，那么&#x2F;drivers&#x2F;char&#x2F;kconfig也会存在。<br>如果你新引入了一个子目录fishing&#x2F;，那么你必须在一个已经存在的kconfig文件中将它引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;drivers/char/fishing/kconfig&quot;</span><br></pre></td></tr></table></figure>
<p>请看kconfig中钓鱼竿模块的选项，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config FISHING_POLE</span><br><span class="line">    tristate &quot;Fish Mater 3000 support&quot;</span><br><span class="line">    default n</span><br><span class="line">    help </span><br><span class="line">        you can say N(no),M(Module),Y(yes) here,if unsure say N</span><br></pre></td></tr></table></figure>
<p>第一行定义了该选项所代表的配置目标，注意CONFIG_前缀并不需要带上。<br>第二行声明类型为tristate，也就是说可以编译进内核（Y），也可以作为模块编译（M），或者干脆不编译它（N）。如果配置选项代表的是一个系统功能，而不是一个模块，那么编译选项将用bool代替tristate，说明它不允许被编译成模块。<br>第三行指定默认编译选项，驱动程序一般默认不编译进入内核（N）。<br>help指令为该选项提供帮助文档。<br>除了上述选项外，还存在其他选项。比如depends指令指定了在该选项设置前，首先需要设置的选项。假设你加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depends on FISH_TANK</span><br></pre></td></tr></table></figure>
<p>到配置选项中，那么就意味着在CONFIG_FISH_TANK被选择前，我们的钓鱼竿模块是不能被使用的（Y或者M）。<br>select指令和depends类似，它们只有一点不同之处—那就是select指定了谁，它就会将被指定的选项强制打开，所以要慎重使用select</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select BAIT</span><br></pre></td></tr></table></figure>
<p>意味着当CONFIG_FISHING_POLE被激活时，配置选项CONFIG_BAIT必然被一起激活。<br>如果select和depends同时指定多个选项，那就需要通过&amp;&amp;指令来进行多选。使用的depends时，你还可以利用叹号前缀来指明禁止某个选项。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depends on EXAMPLE_DIRVERS &amp;&amp; !NO_FISHING_ALLOWED</span><br></pre></td></tr></table></figure>
<p>这行指令就指定驱动程序安装要求打开CONFIG_EXAMPLE_DIRVERS选项，同时禁止CONFIG_NO_FISHING_ALLOWED选项。<br>tristate和bool选项往往会结合if指令一起使用，这表示某个选项取决于另一个配置选项。如果条件不满足，配置选项不但会被禁止，甚至不会显示在配置工具中。比如，要求配置系统只有在CONFIG_x86配置选项时才显示某选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool &quot;x86 only&quot; if x86</span><br></pre></td></tr></table></figure>
<h2 id="导出符号表"><a href="#导出符号表" class="headerlink" title="导出符号表"></a>导出符号表</h2><p>模块被载入后，就会被动态的连接到内核。注意，它与用户空间的动态链接库类似，只有被显式导出后的外部函数，才可以被动态库调用。在内核中，导出内核函数需要使用特殊的指令<code>EXPORT_SYMBOL()</code>和<code>EXPORT_SYMBOL_GPL()</code>。<br>导出的内核函数可以被模块调用，而未导出的函数模块则无法被调用。函数代码的链接和调用规则相比核心内核镜像的的代码而言，要更加严格。核心代码在内核中可以调用任意非静态接口，因为所有的核心源代码文件被链接成了同一个镜像。当然，被导出的符号表所含的函数必然也要是非静态的。<br>导出的内核符号被看作导出的内核接口，甚至被称为内核API。导出符号相当简单，在声明函数后，紧跟上<code>EXPORT_SYMBOL()</code>指令就搞定了。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    返回当前priate胡须的颜色</span><br><span class="line">*/</span><br><span class="line">int get_priate_beard_color(struct priate *p)</span><br><span class="line">&#123;</span><br><span class="line">    return p-&gt;beard.color;</span><br><span class="line">&#125;</span><br><span class="line">EXPROT_SYMBOL(get_priate_beard_color)</span><br></pre></td></tr></table></figure>
<p>如果你希望先前的函数仅对标记为GPL协议的模块可见，那么你就需要用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPROT_SYMBOL_GPL(get_priate_beard_color)</span><br></pre></td></tr></table></figure>
<p>如果你的代码被配置为模块，那么你就必须确保它被编译为模块时，它所用的全部接口都已经被导出，否则就会出现连接错误（而且模块不能编译成功）。</p>
<h1 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h1><p>2.6的内核增加了一个引人注目的新特性—-统一设备模型（device model）。设备模型提供了一个独立的机制专门来表示设备，并描述其在系统中的拓扑结构，从而使得系统具有以下优点：</p>
<ol>
<li>代码重复最小化；</li>
<li>提供诸如引用计数这样的统一机制；</li>
<li>可以列举系统中的所有设备，观察他们的形态，并且查看他们连接的总线；</li>
<li>可以将系统中的全部设备结构以树的形式完整，有效的展示出来—-包括总线和所有的内部连接；</li>
<li>可以将设备和其对应的驱动联系起来，反之亦然；</li>
<li>可以将设备按照类型分类，比如分为输入设备，而无需理解物理设备的拓扑结构；</li>
<li>可以沿这设备树的叶子向其根节点的方向遍历，以保证能以正确的顺序关闭各个设备的电源。<br>内核无疑需要一棵设备树。</li>
</ol>
<h2 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h2><p>设备模型的核心部分就是kobject（kernel object），它由struct kobject结构体表示，定义域头文件<code>&lt;linux/kobject.h&gt;</code>中。它提供了诸如引用计数，名称，父指针等字段，可以创建对象的层次结构。具体结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject&#123;</span><br><span class="line">    const char          *name;</span><br><span class="line">    struct list_head    entry;</span><br><span class="line">    struct kobject      *parent;</span><br><span class="line">    struct kset         *kset;</span><br><span class="line">    struct kobi_type    *ktype;</span><br><span class="line">    struct sysfs_dirent *sd;</span><br><span class="line">    struct kref         kref;</span><br><span class="line">    unsigned int        state_initialized:1;</span><br><span class="line">    unsigned int        state_in_sysfs:1;</span><br><span class="line">    unsigned int        state_add_uevent_sent:1;</span><br><span class="line">    unsigned int        state_remove_uevent_sent:1;</span><br><span class="line">    unsigned int        uevent_suppress:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>name 指针指向该kobject的名称。<br>parent 指针指向kobject的父对象，这样一来，kobject就会在内核中构造一个对象层次结构，并且可以将多个对象间的关系表现出来。这便是sysfs的真面目：一个用户空间的文件系统，用来表示内核中kobject对象的层次结构。<br>sd 指针指向sysfs_dirent结构体，它在sysfs中表示的就是这个kobject。<br>kref 提供引用计数。ktype和kset对kobject进行描述和分类。<br>kobject通常是嵌入到其他结构中，其单独存在的意义不大。比如定义在<code>&lt;linux/cdev.h&gt;</code>下的struct cdev中才真正用到了kobj结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    该对象代表一个字符设备</span><br><span class="line">*/</span><br><span class="line">struct cdev&#123;</span><br><span class="line">    struct kobject          kobj;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当konject被嵌入到其他结构中时，该结构便拥有了kobject提供的标准功能。更重要的一点是，嵌入kobject的结构体可以成为对象层次架构中的一部分。比如cdev就可以通过其父指针cdev-&gt;kobj.parent 和链表 cdev-&gt;kobj.entry 插入到对象层次结构中。</p>
<h2 id="ktype"><a href="#ktype" class="headerlink" title="ktype"></a>ktype</h2><p>kobject对象被关联到一种特殊的类型，即ktype（kernel object type）。ktype由kobj_type结构体表示，定义于头文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strcut kobj_type&#123;</span><br><span class="line">    void (*release)(struct kobject *);</span><br><span class="line">    const struct sysfs_ops *sysfs_ops;</span><br><span class="line">    struct attribute       **defalut_attrs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ktype的存在就是为了描述一族kobject的普遍特性。如此一来，不需要每一个kobject都分别定义自己的特性，而是将这些普遍的特性在ktype中一次定义，然后所有的同类“kobject”都能共享一样的特性。<br>release函数指针指向kobject引用计数为零时要被调用的析构函数。该函数负责释放所有kobject使用的内存和其他相关清理工作。<br>sysyfs_ops变量指向sysfs_ops结构体。该结构体描述了sysfs文件读写时的特性。<br>default_attrs指向了一个attribute结构体数组。这些结构体定义了该kobject相关的默认属性。属性描述了给定对象的特征，如果该kobject导出到sysyfs，那么这些属性都将相应的作为文件而导出，数组的最后一项必须为NULL。</p>
<h2 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h2><p>kset是kobject对象的集合体。可以把它看作是一个容器，可将所有相关的kobject对象，比如”全部的块设备“置于同一位置。kset和ktype最大的区别就是：具有相同ktype的kobject可以被分组到不同的kset。也就是说，在Linux内核中，只有少数一些的ktype，却有多个kset。<br>kobject的kset指针指向相应的kset集合。kset集合由kset结构体表示，定义于头文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kset&#123;</span><br><span class="line">    struct list_head        list;</span><br><span class="line">    spinlock_t              list_lock;</span><br><span class="line">    struct kobject          kobj;</span><br><span class="line">    struct kset_uevent_ops  *uevenet_ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个结构中，其中list连接该集合中所有的kobject对象，list_lock是保护这个链表对象的自旋锁，kobj指向的konject对象代表了该集合的基类。uevent_ops指向了一个结构体—用于处理集合中kobject对象的热插拔操作。<code>uevent就是用户事件（user event）的缩写</code>，提供了与用户空间热插拔信息进行通信的机制。</p>
<h2 id="kobject、ktype、kset的相互关系"><a href="#kobject、ktype、kset的相互关系" class="headerlink" title="kobject、ktype、kset的相互关系"></a>kobject、ktype、kset的相互关系</h2><p><img src="/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/1.jpeg" alt="img not found"></p>
<h2 id="管理和操作kobject"><a href="#管理和操作kobject" class="headerlink" title="管理和操作kobject"></a>管理和操作kobject</h2><p>当了解了kobject的内部基本细节后，我们来看管理和操作他的外部接口了。<br>使用kobject的第一步需要先进行声明和初始化。kobject通过函数<code>kobject_init()</code>进行初始化，该函数定义在文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_init(struct kobject *kobj,struct kobj_type *ktype);</span><br></pre></td></tr></table></figure>
<p>该函数第一个参数就是需要初始化kobject对象，在调用初始化之前，kobject必须清空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memset(kobj,0,sizeof(*kobj));</span><br></pre></td></tr></table></figure>
<p>只有在初始化之后就可以安全的初始化parent和kset字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">kobj = kmalloc(sizeof(*kobj),GFP_KERNEL);</span><br><span class="line">if(!kobj)</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">memset(kobj,0,sizeof(*kobj));</span><br><span class="line">kobj-&gt;kset = my_kset;</span><br><span class="line">kobject_init(kobj,my_ktype);</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">kobj = kobject_create();</span><br><span class="line">if(!kobj)</span><br><span class="line">    return -ENOMEM;</span><br></pre></td></tr></table></figure>
<p>大多数情况下，应该调用<code>kobject_create()</code>而不是直接操作这个结构体。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>kobject的主要功能之一就是为我们提供了一个统一的引用计数系统。初始化后，koject的引用计数设置为1。只要引用计数不为零，那么该对象就会继续保留在内存中。任何包含对象引用的代码首先要增加该对象的引用计数，当代码结束后就减少它的引用计数。当引用计数跌为零时，对象便可以撤销，相关内存也都被释放。</p>
<h3 id="增加和递减引用计数"><a href="#增加和递减引用计数" class="headerlink" title="增加和递减引用计数"></a>增加和递减引用计数</h3><p>增加一个引用计数可通过<code>kobject_get()</code>函数完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_get(struct kobject *kobj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数正常情况下将返回一个指向kobject的指针，如果失败则返回NULL。<br>减少引用计数通过<code>kobject_put()</code>完成，这个函数也声明在<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_put(struct kobject *kobj);</span><br></pre></td></tr></table></figure>
<p>如果对应的kobject的引用计数减少到零，那么与该kobject关联的ktype中的析构函数将会被调用。</p>
<h3 id="kref"><a href="#kref" class="headerlink" title="kref"></a>kref</h3><p>kobject的引用计数是通过kref结构体实现的。该结构体定义在<code>&lt;linux/kref.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kref&#123;</span><br><span class="line">    atomic_t refcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中唯一的字段是用来存放引用计数的原子变量。那么为什么采用结构体，这是为了便于进行类型检测。在使用kref前，你必须通过<code>kref_init()</code>来初始化它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_init(strcut kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">    atomic_set(&amp;kref-&gt;refcount,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数简单的将原子变量置1，所以fref一旦被初始化，它所表示的引用计数便固定为1。<br>要获得对kref的引用，需要调用<code>kref_get()</code>函数，该函数增加引用计数值，没有返回值，这个函数在<code>&lt;linux/kref.h&gt;</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_get(strcut kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(!atomic_read(&amp;kref-&gt;refcount));</span><br><span class="line">    atomic_inc(&amp;kref-&gt;refcount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少对kref的引用，这个函数在<code>&lt;linux/kref.h&gt;</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_put(strcut kref *kref,void (*release) (strcut kref *kref))</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(release == NULL);</span><br><span class="line">    WARN_ON(release == (void (*release) (strcut kref *)) kfree);</span><br><span class="line"></span><br><span class="line">    if(atomic_dec_and_test(&amp;kref-&gt;refcount))&#123;</span><br><span class="line">        release(kref);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述所有函数定义和声明分别在<code>lib/kref.c</code>和<code>&lt;linux/kref.h&gt;</code>中。</p>
<h1 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h1><p>sysfs文件系统是一个处于内存中的虚拟文件系统，它为我们提供了kobject对象层次结构的视图。帮助用户能以一个简单文件系统的方式来视察系统中各种设备的拓扑结构。借助属性对象，kobject可以用导出文件的方式，将内核变量提供给用户读取或者写入。<br>虽然设备模型的初衷是为了方便电源管理而提出的一种设备拓扑结构，但是sysfs是颇为意外的收获。为了方便调试，设备模型的开发者决定将设备结构树导出为一个文件系统。今天所有的2.6内核的系统都拥有sysfs文件系统，而且几乎都将其挂载在<code>sys/</code>下。<br>sysfs的诀窍就是吧kobject对象和目录项（directory entries）紧密联系在一起，这点是通过kobject对象中的dentry字段实现的。dentry结构体表示目录项，通过连接kobject到指定的目录项上，无疑方便的将kobject映射到该目录上。从此，把kobject导出形成文件系统就变得跟在内存中构建目录项一样简单。kobject其实已经形成了一棵树—就是我们心爱的对象体系模型。由于kobject映射到目录项，同时对象层次结构也已经在内存中形成了一棵树，因此sysfs的生成便水到渠成般的简单了。<br><img src="/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/2.jpeg" alt="img not found"><br>sysfs的根目录下至少包含了十个目录：block、bus、class、dev、devices、firmware、fs、kernel、module和power。</p>
<ol>
<li>block下每个子目录都对应着系统中已注册的块设备。反过来，每个目录下又都包含了该块设备的所有分区。</li>
<li>bus目录提供了一个系统总线试图。</li>
<li>class目录包含了以高层功能逻辑组织起来的系统设备视图。</li>
<li>dev目录是已注册的设备节点的视图。</li>
<li>devices目录是系统中的设备拓扑结构视图，它直接映射了内核中设备结构体的组织层次。</li>
<li>firmware目录包含了一些诸如ACPI、EDD、EFI等低层子系统的特殊树。</li>
<li>fs目录是已注册的文件系统的视图。</li>
<li>kernel目录包含内核配置项和状态信息。</li>
<li>module目录则包含系统已加载模块的信息。</li>
<li>power目录包含系统范围的电源去管理数据。<br>其中最重要的目录是devices，该目录将设备模型导出到用户空间。目录结构就是系统中的实际的设备拓扑。其他目录中的很多数据都是将devices目录下的数据加以转换加工得来的。比如，<code>/sys/class/net/</code>目录是以注册网络接口这一高层概念来组织设备关系的，在这个目录中可能会有目录<code>eth0</code>，它里面包含的devices文件其实就是一个指回到devices下实际设备目录的符号链接。<br>随便看看你可以访问到的任何Linux系统的sys目录，这种系统设备视图相当准确和漂亮，而且可以看到class中高层概念与devices中的低层物理设备，以及bus中的实际驱动程序之间互相联络是非常广泛的。当你认识到这种数据是开放的，换句话说，这种内核中维持系统的很好表示方式时，整个经历都是弥足珍贵的。</li>
</ol>
<h2 id="sysfs中添加和删除kobject"><a href="#sysfs中添加和删除kobject" class="headerlink" title="sysfs中添加和删除kobject"></a>sysfs中添加和删除kobject</h2><p>仅仅初始化kobject是不能将其导入到sysfs中去的，想要将kobject导入sysfs，你需要用到<code>kobject_add()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kobject_add(struct kobject *kobj,struct kobject *parent,const char *fmt,...);</span><br></pre></td></tr></table></figure>
<p>kobject在sysfs的位置取决于kobject在对象层次结构中的位置。如果kobject的父指针被设置，那么在sysfs中kobject将被映射为其父目录下的子目录；如果parent没有被设置，那么kobject将被映射为kset-&gt;kobj中的子目录。如果给定的kobject中parent或kset字段都没有被设置，那么就认为kobject没有父对象，所以就会被映射成sysfs下的根级目录。这往往不是你所需要的，所以在调用<code>kobject_add()</code>之前，parent或者kset应该被适当的设置。sysfs中代表kobject的目录名字是由fmt指定的，它也接受<code>printf()</code>样式的格式化字符串。<br>辅助函数<code>kobject_create_and_add()</code>把<code>koject_create()</code>和<code>kobject_add()</code>所做的工作放在一个函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_create_and_add(const char *name,struct kobject *parent);</span><br></pre></td></tr></table></figure>
<p>从sysfs中删除一个kobject对应文件目录，需要使用函数<code>kobject_del()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_del(struct kobject *kobj);</span><br></pre></td></tr></table></figure>
<p>上述函数都定义于文件<code>lib/kobject.c</code>中，声明位于头文件<code>&lt;linux/kobject.h&gt;</code>中。</p>
<h2 id="向sysfs中添加文件"><a href="#向sysfs中添加文件" class="headerlink" title="向sysfs中添加文件"></a>向sysfs中添加文件</h2><p>我们已经看到kobject被映射为文件目录了，而且所有的对象层次结构都优雅的，一个不少的映射成sys下的目录结构。但是里面的文件是什么，sysfs仅仅是一个漂亮的树，但是没有提供实际数据的文件。</p>
<h3 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h3><p>默认的文件集合是通过kobject和kset中的ktype提供的。因此所有具有相同类型的kobject在它们对应的sysfs目录下都拥有相同默认文件集合。kobject_type字段含有一个字段—default_attrs，它是一个attribute结构体数组。这些属性负责将内核数据映射成sysfs中的文件。<br>attribute结构体定义在文件<code>&lt;linux/sysfs.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">attribute 结构体 - 内核数据映射成sysfs中的文件</span><br><span class="line">*/</span><br><span class="line">struct attribute&#123;</span><br><span class="line">    const char      *name;      /*属性名称*/</span><br><span class="line">    struct module   *owner;     /*所属模块，如果存在*/</span><br><span class="line">    mode_t          mode;       /*权限*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中名称字段提供了该属性的名称，最终出现在sysfs中的文件名就是它。owner字段在存在所属模块的情况下指向其所属的module结构体。如果一个模块没有该属性，那么该字段为NULL。mode 字段类型为mode_t，它表示了sysfs中该文件的权限。对于只读属性而言，如果是所有人都可以读它，则该字段设置为S_IRUGO;如果只限于所有者可读，则该字段被设置为S_IRUSR。同样对于可写属性，可能会设置该字段为S_IRUGO | S_IWUSR。sysfs中的所有文件和目录的uid与gid标志均为0。<br>虽然default_attr列出了默认的属性，sysfs_ops字段则描述了如何使用他们。sysfs_ops字段指向了一个定义于文件<code>&lt;linux/sysfs.h&gt;</code>的同名的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sysfs_ops&#123;</span><br><span class="line">    /*在读sysfs时被调用*/</span><br><span class="line">    ssize_t (*show) (struct kobject *kobj,struct attribute *attr,char *buffer);</span><br><span class="line">    /*在写sysfs时被调用*/</span><br><span class="line">    ssize_t (*store) (struct kobject *kobj,struct attribute *attr,char *buffer,size_t size);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当从用户空间读取sysfs的项时调用<code>show()</code>方法。它会拷贝由attr提供的属性值到buffer指定的缓冲区中，缓冲区大小为PAGE_SIZE字节；<br><code>store()</code>方法在写操作时调用，它会从buffer中读取size大小的字节，并将其存放入attr表示的属性结构体变量中。</p>
<h3 id="创建新属性"><a href="#创建新属性" class="headerlink" title="创建新属性"></a>创建新属性</h3><p>内核为能在默认集合上，再添加新属性而提供了<code>sysfs_create_file()</code>接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sysfs_create_file(struct kobject *kobj,const struct attribute *attr);</span><br></pre></td></tr></table></figure>
<p>注意，kobject中的ktype所对应的sysfs_ops操作将负责处理新属性。现有的<code>show()</code>和<code>store()</code>方法必须能够处理新属性。<br>除了添加文件外，还有可能需要创建符号链接。再sysf中创建一个符号链接很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sysyfs_create_link(struct kobject *kobj,struct kobject *target,char *name);</span><br></pre></td></tr></table></figure>
<p>该函数创建的符号链接名由name决定，连接则由kobj对应的目录映射到target指定的目录。如果成功该函数返回零，如果失败返回负的错误码。</p>
<h3 id="删除新属性"><a href="#删除新属性" class="headerlink" title="删除新属性"></a>删除新属性</h3><p>删除一个属性需要通过函数<code>sysfs_remove_file()</code>完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sysfs_remove_file(struct kobject *kobj,const struct attribute *attr);</span><br></pre></td></tr></table></figure>
<p>一但调用返回，给定的属性将不再存在于给定的kobject目录中。另外由<code>sysfs_create_link()</code>创建的符号链接可通过函数<code>sysfs_remove_link()</code>删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sysfs_remove_link(struct kobject *kobj,char *name);</span><br></pre></td></tr></table></figure>
<p>调用一旦返回，在kobj对应目录中的名为name的符号链接将不复存在。<br>上述四个函数在文件<code>&lt;linux/kobject.h&gt;</code>中声明；<code>sysfs_create_file()</code>和<code>sysfs_remove_file()</code>定义于文件<code>fs/sysfs/file.c</code>。<code>sysyfs_create_link()</code>和<code>sysfs_remove_link()</code>定义于文件<code>fs/sysfs/symlink.c</code>中。</p>
<h2 id="内核事件层"><a href="#内核事件层" class="headerlink" title="内核事件层"></a>内核事件层</h2><p>内核事件层实现了内核到用户的消息通知系统，就是建立在上文一直讨论的kobject基础之上。在2.6.0版本之后，显而易见，系统确实需要一种机制来帮助事件传出内核输入到用户空间，特别是对于桌面系统来说吗，因为他需要更完整和异步的系统。为此就要让内核将其事件压倒堆栈：硬盘满了，CPU过热了，分区挂载了。<br>早期的事件层没有采用kobject和sysfs，他们如过眼云烟，没有存在多久。现在的事件层借助kobject和sysfs实现以证明相当理想。内核事件层把事件模拟册成信号—从明确的kobject对象发出，所以每个事件源都是一个sysfs路径。如果请求的事件与你的第一个硬盘相关，那么<code>sys/block/had</code>便是源树。实质上，在内核中我们认为事件都是从幕后的kobject对象产生的。<br>每个事件都被赋予了一个动词或者动作字符串表示信号。该字符串会以“被修改过”或者“未挂载”等词语来描述事件。<br>最后。每个事件都有一个可选的负载（payload）。相比传递任意一个标识负载的字符串到用户空间而言，内核事件层使用sysfs属性代表负载。<br>从内部实现来讲，内核事件由内核空间传递到用户空间需要经过netlink。netlink是一个用于传送网络信息的多点传送套接字。使用netlink就意味着从用户空间获取内核事件就如同在套接字上堵塞一样易如反掌。方法就是用户空间实现一个系统后台服务用于监听套接字，处理任何读到的信息，并将事件传送到系统栈里面。对于这种用户后台服务来说，一个潜在的目的就是将事件融入D-BUS系统。D-BUS系统已经实现了一套系统范围的消息总线，这种总线可帮助内核如同系统中其他组件一样地发出信号。<br>在内核代码中向用户空间发送信号使用函数<code>kobject_uevent()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kobject_uevent(struct kobject* kobj,enum kobject_action action);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定发送该信号的对象。实际的内核事件将包含该kobject映射到sysfs的路径。<br>第二个参数指定了该信号的“动作”或者“动词”。实际的内核事件将包含一个映射成枚举类型kobject_action的字符串。该函数不是直接提供一个字符串，而是利用一个枚举变量来提高可重用性和保证类型安全，而且也消除了打字错误或者其他错误。该枚举变量定义于文件<code>&lt;linux/kobject_uevent.c&gt;</code>中，其形式为kOBJ_foo。当前值包含kOBJ_MOUNT、kOBJ_UNMOUNT、kOBJ_ADD、kOBJ_REOMOVE、kOBJ_CHNAGE等。这些值分别映射为字符串“mount”、“unmount”、“add”、“remove”、“change”等。当现有的这些值不够用时，允许添加新动作。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中涉及到的内核功能有设备驱动的实现、设备树的管理、包括模块、kobject、kset、ktype和sysfs。这些功能对于设备驱动程序的开发者来说是至关重要的。因为它能让我们写出更加模块化、更为高级的驱动程序。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第17章 设备与模块</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>设备驱动</tag>
      </tags>
  </entry>
  <entry>
    <title>存储控制器</title>
    <url>/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第6章总结归纳<br>总线的使用是嵌入式底层开发的基础，了解它之后，再根据外设的具体特性，就可以驱动该外设了。</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440地址空间的布局</li>
<li>掌握如何通过总线形式访问扩展的外设，比如内存、NOR Flash、网卡等。</li>
</ol>
<h1 id="使用存储控制器访问外设的原理"><a href="#使用存储控制器访问外设的原理" class="headerlink" title="使用存储控制器访问外设的原理"></a>使用存储控制器访问外设的原理</h1><h2 id="S3C2410-x2F-S3C2440的地址空间"><a href="#S3C2410-x2F-S3C2440的地址空间" class="headerlink" title="S3C2410&#x2F;S3C2440的地址空间"></a>S3C2410&#x2F;S3C2440的地址空间</h2><p>S3C2410&#x2F;S3C2440的”存储控制器“提供了访问外部设备所需的信号，它有如下特性：</p>
<ol>
<li>支持小字节序、大字节序（通过软件选择）；</li>
<li>每个BANK的地址空间为128MB，共1GB（8BANKs）；</li>
<li>可编程控制的范围总线位宽（8&#x2F;16&#x2F;32bit），不过BANK0只能选择两种位宽（16&#x2F;32bit）；</li>
<li>总共8个BANK，BANK0-BANK5可以支持外接ROM、SRAM等。BANK6-BANK7除了可以支持ROM、SRAM外，还支持SDRAM等；</li>
<li>BANK0-BANK7共7个BANK的起始地址是固定的；</li>
<li>BANK7的起始地址可编程选择；</li>
<li>BANK6、BANK7的地址空间大小是可编程控制的；</li>
<li>每个BANK的访问周期均可编程控制；</li>
<li>可以通过外部的”wait“信号延长总线的访问周期；</li>
<li>在外接SDRAM时，支持自刷新（self-refresh）和省电模式（power down mode）<br>S3C2410&#x2F;S3C2440对外引出的27根地址线ADDR0-ADDR26的访问范围只有128MB，那么如何达到上面所说的1GB的访问空间呢？CPU对外引出了8根片选信号nGCS0-nGCS7，对应于BANK0-BANK7，当访问BANKx的地址空间时，nGCSx的引脚输出低电平，用来选中外接的设备。这样，每个nGCSx对应的128MB空间，8个nGCSx信号总共就对应了1GB的地址空间。这8个BANK的地址空间如图所示：<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"><br>如图所示，左边对应不使用NAND Flash作为启动设备（单板上不接NAND BOOT跳线）时的地址空间布局，右边对应使用NAND Flash作为启动设备（单板上接NAND BOOT跳线）时的地址空间布局。<br>S3C2410&#x2F;S3C2440作为32位的CPU，可以使用的地址范围理论上达到4GB。除去上述用于连接外设的1GB地址空间外，还有一部分是CPU内部寄存器的地址，剩下的地址空间没有使用。<br>S3C2410&#x2F;S3C2440的寄存器地址范围都处于0x4800000-0x5fffffff，各功能部件的寄存器大体相同。（”-表示相同。”无“表示不含该功能部件。）<table>
<thead>
<tr>
<th>功能部件</th>
<th>S3C2410起始地址</th>
<th>S3C2410结束地址</th>
<th>S3C2440起始地址</th>
<th>S3C2440结束地址</th>
</tr>
</thead>
<tbody><tr>
<td>存储控制器</td>
<td>0x48000000</td>
<td>0x48000030</td>
<td>0x48000000</td>
<td>0x48000030</td>
</tr>
<tr>
<td>USB Host控制器</td>
<td>0x49000000</td>
<td>0x49000058</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>中断控制器</td>
<td>0x4A000000</td>
<td>0x4A00001C</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>DMA</td>
<td>0x4B000000</td>
<td>0x4B0000E0</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>时钟和电源管理</td>
<td>0x4C000000</td>
<td>0x4C000014</td>
<td>-</td>
<td>0x4C000018</td>
</tr>
<tr>
<td>LCD控制器</td>
<td>0x4D000000</td>
<td>0x4D000060</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>NAND Flash控制器</td>
<td>0x4E000000</td>
<td>0x4E000014</td>
<td>-</td>
<td>0x4E00003C</td>
</tr>
<tr>
<td>摄像头接口</td>
<td>无</td>
<td>无</td>
<td>0x4F000000</td>
<td>0x4F0000A0</td>
</tr>
<tr>
<td>UART</td>
<td>0x50000000</td>
<td>0x50008028</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>脉宽调制计时器</td>
<td>0x51000000</td>
<td>0x51000040</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>USB设备</td>
<td>0x52000140</td>
<td>0x5200026F</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>看门狗计时器</td>
<td>0x53000000</td>
<td>0x53000008</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>IIC控制器</td>
<td>0x54000000</td>
<td>0x5400000C</td>
<td>-</td>
<td>0x54000010</td>
</tr>
<tr>
<td>IIS控制器</td>
<td>0x55000000</td>
<td>0x55000012</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>I&#x2F;O端口</td>
<td>0x56000000</td>
<td>0x560000B0</td>
<td>-</td>
<td>0x560000CC</td>
</tr>
<tr>
<td>RTC</td>
<td>0x57000000</td>
<td>0x5700008B</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>A&#x2F;D转换器</td>
<td>0x58000000</td>
<td>0x58000010</td>
<td>-</td>
<td>0x58000014</td>
</tr>
<tr>
<td>SPI</td>
<td>0x59000000</td>
<td>0x59000034</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>SD接口</td>
<td>0x5A000000</td>
<td>0x5A000040</td>
<td>-</td>
<td>0x5A000043</td>
</tr>
<tr>
<td>AC97音频编码接口</td>
<td>无</td>
<td>无</td>
<td>0x5B000000</td>
<td>0x5B00001C</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="存储控制器与外设的关系"><a href="#存储控制器与外设的关系" class="headerlink" title="存储控制器与外设的关系"></a>存储控制器与外设的关系</h2><p>本书所用的开发板使用了存储控制器的BANK0-BANK6，分别接如下设备：NOR Flash、IDE接口、10M网卡 CS8900A、100M网卡DM9000、扩展串口芯片16C2550、SDRAM。连线方式如下图所示：<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>根据图6.1可以知道各个BANK的起始地址，但是还需要结合图6.2中用到的地址线才能确定相关外设的访问地址。这些地址线所确定的地址值，再加上这个BANK的起始地址，就是这个外设的访问地址。<br>选择一个复杂的BANK—扩展串口作为例子。</p>
<ol>
<li>它使用nGCS5，起始地址作为0x28000000；</li>
<li>nCSA&#x3D;ADDR24 || nGCS5，nCSB&#x3D;!ADDR24 || nGCS5。当ADDR24和nGCS5均为低电平时选中扩展串口A；当ADDR24为高电平、nGCS5为低电平时选中扩展串口B。</li>
<li>CPU的ADDR0-ADDR2连接到扩展串口的A0-A2。所以访问空间有8字节。<br>综上所述，扩展串口A的访问空间为：0x28000000-0x28000007；扩展串口B的访问空间为：0x29000000-0x29000007。</li>
</ol>
<p>BANK0-BANK5的连接方式都是相似的，BANK6连接SDRAM时复杂一点，CPU提供了一组用于SDRAM的信号。</p>
<ol>
<li>SDRAM时钟有效信号SCKE；</li>
<li>SDRAM时钟信号SCLK0&#x2F;SCLK1；</li>
<li>数据掩码信号DQM0、DQM1、DQM2、DQM3；</li>
<li>SDRAM片选信号nSCS0（它与nGCS6是同一个引脚的两个功能）；</li>
<li>SDRAM行地址选通脉冲信号nSRAS；</li>
<li>SDRAM列地址选通脉冲信号nSCAS；</li>
<li>写允许信号mWE（它不是专用于SDRAM的）。<br>SDRAM的内部是一个存储阵列，阵列就如同表格一样，把数据填进去，和表格的检索原理一样，先指定一个行（Row），再指定一个列（Column），就可以找到所需的单元格，这就是SDRAM的寻址的基本原理。这个单元格称为存储单元，这个表格就是逻辑BANK（L-BANK），SDRAM一般含有4个L-BANK。<br>对SDRAM的访问可以分为如下4个步骤：</li>
<li>CPU发出片选信号，nSCS0有效，它选中SDRAM芯片。</li>
<li>SDRAM中有4个L-BANK,需要两个地址线来选择其中一个，从图6.2可知使用ADDR24、ADDR25作为L-BANK的选择信号。</li>
<li>对被选中的芯片进行统一的行&#x2F;列（存储单元）寻址。<br>根据SDRAM芯片的列地址线数目选择CPU的相关寄存器后，CPU就会从32位的地址中自动分出L-BANK选择信号，行地址信号，列地址信号，然后发出行地址信号、列地址信号。L-BANK选择信号在发出行地址信号的同时发出，并维持到列地址信号结束。<br>在图6.2中，行地址、列地址公用地址线ADDR2-ADDR14（BANK6位宽位32，ADDR0&#x2F;1没有使用），使用nSRAS、nSCAS两个信号来区分它们。比如本开发板中，使用两根地址线ADDR24、ADDR25作为L-BANK的选择信号；SDRAM芯片K4S561632的行地址数位13，列地址数为9，所以当nSRAS信号有效时，ADDR2-ADDR14上发出的是行地址信号，它对应32位地址空间的bit[23::11]；当nSCAs信号有效时，ADDR2-ADDR10上发出的是列地址信号，它对应32位地址空间的bit[10:2]；由于图6.2中BANK6以32位的宽度外接SDRAM，ADDR0、ADDR1恒为0，不参与译码。</li>
<li>找到存储单元后，被选中的芯片就要进行统一的数据传输了。<br>开发板中使用两片16位的SDRAM芯片并联组成32位的位宽，与CPU的32根数据线（DATA0-DATA31）相连。<br>BANK6的起始地址为0x30000000，所以SDRAM的访问地址为0x30000000-0x33ffffff，共64M。<br>对6.2图中连接的外设，它们的访问地址（物理地址）如下表所示：<table>
<thead>
<tr>
<th>BANKx</th>
<th>外设名称</th>
<th>起始地址</th>
<th>结束地址</th>
<th>大小（字节）</th>
<th>位宽</th>
</tr>
</thead>
<tbody><tr>
<td>BANK0</td>
<td>NOR Flash</td>
<td>0x00000000</td>
<td>0x001FFFFF</td>
<td>2M</td>
<td>16</td>
</tr>
<tr>
<td>BANK1</td>
<td>IDE 接口命令块寄存器</td>
<td>0x08000000</td>
<td>0x0800000F</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>BANK2</td>
<td>IDE 接口控制块寄存器</td>
<td>0x10000000</td>
<td>0x1000000F</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>BANK3</td>
<td>10M网卡CS8900A</td>
<td>0x19000000</td>
<td>0x190FFFFF</td>
<td>1M</td>
<td>16</td>
</tr>
<tr>
<td>BANK4</td>
<td>10&#x2F;100M网卡DM9000</td>
<td>只有两个地址 0x20000000 和 0x20000004</td>
<td></td>
<td>2M</td>
<td>16</td>
</tr>
<tr>
<td>BANK5</td>
<td>扩展串口A</td>
<td>0x28000000</td>
<td>0x28000007</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>BANK6</td>
<td>扩展串口B</td>
<td>0x29000000</td>
<td>0x29000007</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>BANK7</td>
<td>SDRAM</td>
<td>0x30000000</td>
<td>0x33FFFFFF</td>
<td>64M</td>
<td>32</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：10M网卡CS8900A使用nIOR、nIOW作为读&#x2F;写使能信号时，ADDR24必须为1。</p>
<h2 id="存储控制器的寄存器使用方法"><a href="#存储控制器的寄存器使用方法" class="headerlink" title="存储控制器的寄存器使用方法"></a>存储控制器的寄存器使用方法</h2><p>存储控制器共有13个寄存器，BANK0-BANK5只需要设置BWSCON和BANKCONx（x为0-5）两个寄存器，BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</p>
<ol>
<li>位宽和等待控制寄存器BWSCON（BUS WIDTH &amp; WAIT CONTROL REGISTER）<br>BWSCON中每4位控制一个BANK。最高4位对应BANK7、接下来4位对应BANK6、依此类推。<br>STx：启动&#x2F;禁止SDRAM的数据掩码引脚，对于SDRAM，此位为0；对于SRAM此位为1。<br>DWx：使用两位来设置相应BANK的位宽。0b00对应8位，0b01对应16位，0b10对应32位，0b11保留。<br>WSx：是否使用存储器的WAIT信号，通常设为0。<br>比较特殊的是BANK0，他没有ST0和WS0，DW0（[2:1]）只读，0b01表示16位，0b10表示32位，BANK0只支持16、32两种位宽。</li>
<li>BANK控制寄存器BANKCONx（BANK CONTROL REGISTER x为0-5）<br>这几个寄存器控制BANK0-BANK5外接设备的访问时序。</li>
<li>BANK控制寄存器BANKCONx（BANK CONTROL REGISTER x为6-7）<br>在8个BANK中，只有BANK6和BANK7可以外接SRAM或者SDRAM，所以BANKCON6-BANKCON7与BANKCON0-BANKCON5有点不同。<br>MT[16:15]：用于设置本BANK外接的是ROM&#x2F;SRAM还是SDRAM。SRAM-0b00，SDRAM-0b11。当MT&#x3D;0b00时，此寄存器与BANKCON0-BANKCON5类似，当MT&#x3D;0b11时，此寄存器其他值如下设置：<br>Trcd[3:2]：RAS to CAS delay，设为推荐值，0b01。<br>SCAN[1:0]：SDRAM的列地址位数，对于本开发板使用的SDRAM K4S561632，列地址位数为9，所以SCAN&#x3D;0b01。如果使用其他型号的SDRAM，需要查看其数据手册来决定SCAN的取值。0b00表示8位，0b01表示9位，0b10表示10位。</li>
<li>刷新控制寄存器REFRESH（REFRESH CONTROL RFEGISTER）：设为0x008C0000 + R_CNT<br>REFEN[23]：0&#x3D;禁止SDRAM的刷新功能，1&#x3D;开启SDRAM的刷新功能。<br>TREFMD[22]：SDRAM的刷新模式，0&#x3D;CBR&#x2F;ATUO Refresh，1&#x3D;Self Refresh（一般在系统休眠时使用）。<br>Trp[21:20]设为0即可。<br>Tsrc[19:18]：设为默认值0b11即可。<br>Refresh Counter[10:0]：即上述的R_CNT。可如下计算（SDRFAM的时钟频率就是HCLK）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R_CNT = 2^11 + 1 - SDRAM时钟频率(MHZ) + SDRAM刷新周期（uS）</span><br></pre></td></tr></table></figure>
SDRAM的刷新周期在SDRAM的数据手册上有标明，在本开发板上使用的SDRAM K4S561632的数据手册上，可以看见这么一行”64ms refresh period （8K Cycle）“。所以，刷新周期&#x3D;64ms&#x2F;8192 &#x3D; 7.8125 us。<br>在未使用PLL时，SDRAM的时钟频率等于晶振频率，12MHz。现在可以计算：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R_CNT = 2^11 + 1 - 12 * 7.8125 = 1955</span><br></pre></td></tr></table></figure>
所以在未使用PLL时，REFRESH &#x3D; 0x008C0000 + 1955 &#x3D; 0x008C07A3。</li>
<li>BANKSIZE寄存器REFRESH （BANKSIZE REGISTER）<br>BURST_EN[7]：0&#x3D; ARM核禁止突发传输，1&#x3D;ARM核支持突发传输。<br>SCKE_EN[5]：0&#x3D;不使用SCKE信号令SDRAM进入省电模式，1&#x3D;使用SCKE信号令SDRAM进入省电模式。<br>SCLK_EN[4]：0&#x3D;时刻发出SCLK信号，1&#x3D;仅在访问SDRAM期间发出SCLK信号（推荐）。<br>BK76MAP[2:0]：设置BANK6&#x2F;7的大小。<br>BANK6&#x2F;7对应的地址空间与BANK0-5不同，BANK0-5的地址空间大小都是固定的128MB，地址范围是（x * 128M）到（x + 1）* 128M-1，x表示0到5。BANK6&#x2F;7的大小是可变的，以保持这两个空间的地址连续，即BANK7的起始地址会随他们的大小而变化。  BK76MAP的取值意义如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0b010 = 128MB/128MB,0b001 = 64MB/64MB,0b000 = 32MB/32MB,</span><br><span class="line">0b111 = 16MB/16MB,0b110 = 8MB/8MB,0b101 = 4M/4M,0b100 = 2M/2M</span><br></pre></td></tr></table></figure>
本开发板BANK6外接64MB的SDRAM，令[2:0]&#x3D;0b001，表示BANK6&#x2F;7的容量都是64MB，虽然BANK7未使用。</li>
<li>SDRAM模式设置寄存器MRSRBx（SDRAM MODE REGISTER SET REGISTER，x为6-7）<br>能修改的只有为CL[6:4]，这是SDRAM时序的一个时间参数：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[work]0b000 = 1 clock,0b010  = 2 clocks,0b011 = 3 clocks</span><br></pre></td></tr></table></figure>
SDRAM K4S561632不支持CL&#x3D;1的情况，所以位[6:4]取值为0b010(CL &#x3D; 2)或0b011(CL &#x3D; 3)。</li>
</ol>
<h1 id="存储控制器操作实例：使用SDRAM"><a href="#存储控制器操作实例：使用SDRAM" class="headerlink" title="存储控制器操作实例：使用SDRAM"></a>存储控制器操作实例：使用SDRAM</h1><h2 id="代码详解及程序的复制、跳转过程"><a href="#代码详解及程序的复制、跳转过程" class="headerlink" title="代码详解及程序的复制、跳转过程"></a>代码详解及程序的复制、跳转过程</h2><p>从NAND Flash启动CPU时，CPU会通过内部的硬件将NAND Flash开始的4KB数据复制到称为”Steppingstone“的4KB的内部RAM中（起始地址为0），然后跳到地址0开始执行。<br>本实例先使用汇编语言设置好存储控制器，使外接的SDRAM可用：然后把程序本身从Steppingstone复制到SDRAM处，最后跳到SDRAM中执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:head.S</span></span><br><span class="line"><span class="comment">功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDARM执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">.equ    MEM_CTL_BASE,       <span class="number">0x48000000</span></span><br><span class="line">.equ    SDRAM_BASE,         <span class="number">0x30000000</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    bl  disable_watch_dog                       @关闭看门狗，否则CPU会一直重启</span><br><span class="line">    bl  memsetup                                @设置存储控制器</span><br><span class="line">    bl  copy_steppingstone_to_sdram             @复制代码到SDRAM中</span><br><span class="line">    ldr pc,=on_sdram                            @跳到SDRAM中执行</span><br><span class="line">on_sdram:</span><br><span class="line">    ldr sp,=<span class="number">0x34000000</span>                          @设置栈</span><br><span class="line">    bl  main</span><br><span class="line">    </span><br><span class="line">halt_loop:</span><br><span class="line">    b   halt_loop</span><br><span class="line"></span><br><span class="line">disable_watch_dog:</span><br><span class="line">    mov r1,#<span class="number">0x53000000</span>                          @看门狗寄存器</span><br><span class="line">    mov r2,#<span class="number">0x0</span>                                 @往里写<span class="number">0</span></span><br><span class="line">    str r2,[r1]</span><br><span class="line">    mov pc,lr                                   @返回</span><br><span class="line"></span><br><span class="line">copy_steppingstone_to_sdram:</span><br><span class="line">                                                @将Steppingstone的<span class="number">4</span>KB数据全部复制到SDRAM中去。</span><br><span class="line">                                                @Steppingstone起始地址为<span class="number">0x00000000</span>，SDRAM中起始地址为<span class="number">0x30000000</span></span><br><span class="line">    mov r1,#<span class="number">0</span>                                   </span><br><span class="line">    ldr r2,=SDARM_BASE</span><br><span class="line">    mov r3,#<span class="number">4</span>*<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    ldr r4,[r1],#<span class="number">4</span>                              @从Steppingstone读取<span class="number">4</span>字节的数据，并让源地址加<span class="number">4</span></span><br><span class="line">    str r4,[r2],#<span class="number">4</span>                              @将此<span class="number">4</span>字节的数据复制到SDRAM中，并让目的地址加<span class="number">4</span></span><br><span class="line">    cmp r1,r3                                   @判断是否完成：源地址等于Steppingstone的末地址</span><br><span class="line">    bne lb                                      @若没有复制完，继续</span><br><span class="line">    mov pc, lr                                  @返回</span><br><span class="line"></span><br><span class="line">memsetup:</span><br><span class="line">                                                @设置存储控制器以便使用SDRAM外设</span><br><span class="line">    mov r1,#MEM_CTL_BASE                        @存储控制器的<span class="number">13</span>个寄存器的开始地址</span><br><span class="line">    adrl    r2,mem_cfg_val                      @这<span class="number">13</span>个值的起始存储地址</span><br><span class="line">    add r3,r1,#<span class="number">52</span>                               @<span class="number">13</span>*<span class="number">4</span> = <span class="number">52</span></span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    ldr r4,[r2],#<span class="number">4</span>                              @读取设置值，并让r2加<span class="number">4</span></span><br><span class="line">    str r4,[r1],#<span class="number">4</span>                              @将此值写入寄存器，并让r1加<span class="number">4</span></span><br><span class="line">    cmp r1,r3                                   @判断是否设置完所有<span class="number">13</span>个寄存器</span><br><span class="line">    bne lb                                      @若没有完成，继续</span><br><span class="line">    mov pc,lr                                   @返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">mem_cfg_val:</span><br><span class="line">                                                @存储控制器<span class="number">13</span>个寄存器的设置值</span><br><span class="line">    .<span class="type">long</span> <span class="number">0x22011110</span>    </span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00018005</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00018005</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x008C07A3</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x000000B1</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000030</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000030</span></span><br></pre></td></tr></table></figure>
<p>12-18行是程序的主题，为了使得程序结构明了，主要使用了函数调用的方式。<br>第12行禁止看门狗，否则看门狗会不断重启系统，往看门狗寄存器（0x53000000）里写0即可禁止看门狗。<br>第13行设置存储控制器的13个寄存器，以便使用SDRAM。<br>第14行将Steppingstone中的代码复制到SDRAM中（起始地址为0x30000000）。<br>第15行向pc寄存器直接赋值跳到SDRAM中执行下一条指令”ldr sp，&#x3D;0x34000000“。、<br>第17行设置栈，调用c函数之前必须设置好栈。<br>第18行调用C函数main。<br>程序是如何从Steppingstone跳到SDRAM中去执行的呢？<br>这是通过第15行的”ldr pc,&#x3D;on_sdram“指令完成的。程序标号”on_stream“这个地址值在连接程序时被确定为0x30000010（这是SDRAM的地址），执行”ldr pc,&#x3D;on_sdram“后，程序一下子就跳到SDRAM中去了。<br>”on_sdram“这个地址值为什么等于0x30000010？<br>Makefile中连接程序的命令为”arm-linux-ld -Ttext 0x30000000 head.o sdram.o -o sdram_elf“，意思就是代码段的起始地址为0x30000000，即程序的第一条指令（第12行）的连接地址为0x30000000，第二条指令（第13行）的连接地址是0x30000004，…,第五条指令（第17行）的连接地址为0x300000010，其程序标号”on_sdram“的值即为0x300000010。<br>虽然第12-14行指令的连接地址都在SDRAM中，但是由于它们都是位置无关的相对跳转指令，所以可以在Steppingstone里执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o head.o head.S</span><br><span class="line">arm-linux-gcc -g -c -o leds.o leds.c</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 -g head.o leds.o -o sdram_elf</span><br><span class="line">arm-linux-objcopy -O binary -S sdram_elf sdram_elf.bin</span><br><span class="line">arm-linux-objdump -D -m arm sdram_elf &gt; sdram_elf.dis</span><br></pre></td></tr></table></figure>
<p>下图所示程序从Steppingstone 到SDRAM 的执行过程。<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/4.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/5.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/6.png" alt="img not found"></p>
<h2 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h2><p>生成的sdram.bin下载到板子上运行之后，可以发现与leds程序相比，LED灯闪烁的更慢，原因是外部的SDRAM的性能比内部SRAM差一些。<br>把程序从性能更好的内部SRAM移到外部SDRAM中去，是否多此一举？内部的SRAM只有4KB大小，如果程序大于4KB，那么就不指望完全利用内部SRAM来运行了，就得想办法把存储在NAND Flash中的代码复制到SDRAM中去。对于NAND Flash的前4KB，芯片自动把它复制到内部SRAM中，可以很轻松的再把它复制到SDRAM中（实验代码中的函数copy_steppingstone_to_sdram就有此功能），要复制4KB后面的代码需要使用NAND Flash控制器来读取NAND Flash。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第6章 存储控制器</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>存储控制器</tag>
      </tags>
  </entry>
  <entry>
    <title>NAND_Flash控制器</title>
    <url>/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第8章总结归纳</p>
<span id="more"></span>
<h1 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h1><ol>
<li>了解NAND Flash芯片的接口</li>
<li>掌握通过NAND Flash控制器访问NAND Flash的方法</li>
</ol>
<h1 id="NAND-Flash介绍和NAND-Flash控制器使用"><a href="#NAND-Flash介绍和NAND-Flash控制器使用" class="headerlink" title="NAND Flash介绍和NAND Flash控制器使用"></a>NAND Flash介绍和NAND Flash控制器使用</h1><p>NAND Flash在嵌入式系统中地位与PC中的硬盘类似，用于保存系统运行所必须的操作系统、应用程序、用户数据、运行过程中产生的各类数据。与内存掉电后数据丢失不同，NAND Flash中的数据在掉电后仍可永久保存。</p>
<h2 id="Flash介绍"><a href="#Flash介绍" class="headerlink" title="Flash介绍"></a>Flash介绍</h2><p>常用的Flash类型有NOR Flash和NAND Flash两种。NOR Flash由Intel公司在1988年发明，以替代当时在市场上占据主要地位的EPROM和EEPROM。NAND Flash由Toshiba公司在1989年发明。两者主要差别如下表所示：</p>
<table>
<thead>
<tr>
<th>项目</th>
<th>NOR</th>
<th>NAND</th>
</tr>
</thead>
<tbody><tr>
<td>容量</td>
<td>1MB-32MB</td>
<td>16MB-512MB</td>
</tr>
<tr>
<td>XIP</td>
<td>YES</td>
<td>NO</td>
</tr>
<tr>
<td>擦除性能</td>
<td>非常慢（5S）</td>
<td>（快）3ms</td>
</tr>
<tr>
<td>写性能</td>
<td>慢</td>
<td>快</td>
</tr>
<tr>
<td>读性能</td>
<td>快</td>
<td>快</td>
</tr>
<tr>
<td>可靠性</td>
<td>比较高，位反转的比例小于NAND Flash的10%</td>
<td>比较低，位反转比较常见，必须有校验措施。比如TNR必须有坏块管理措施</td>
</tr>
<tr>
<td>可擦除次数</td>
<td>10000-100000</td>
<td>100000-1000000</td>
</tr>
<tr>
<td>生命周期</td>
<td>低于NAND Flash的10%</td>
<td>是NOR Flash的10倍以上</td>
</tr>
<tr>
<td>接口</td>
<td>与RAM接口相同</td>
<td>I&#x2F;O接口</td>
</tr>
<tr>
<td>访问方法</td>
<td>随机访问</td>
<td>顺序访问</td>
</tr>
<tr>
<td>易用性</td>
<td>容易</td>
<td>复杂</td>
</tr>
<tr>
<td>主要用途</td>
<td>用于保存代码和关键数据</td>
<td>用于保存数据</td>
</tr>
<tr>
<td>价格</td>
<td>高</td>
<td>低</td>
</tr>
</tbody></table>
<p>NOR Flash支持XIP，即代码可以直接在NOR上运行，无须复制到内存中。这是由于NOR的接口与RAM完全相同，可以随机访问任意地址的数据。在NOR上进行读数据的效率非常高，但是擦除和写的效率很低。而且NOR的容量一般比较小。NAND Flash进行擦除和写操作的效率更高，并且容量更大。一般而言，NOR Flash用于存储程序，NAND Flash用于存储数据。基于NAND Flash的设备通常也要搭配NOR以存储程序。<br>Flash存储器件由擦除单元（块）组成，当要写某个块时，需要确保这个块已经被擦除。NOR Flash的块大小范围为64KB-128KB；NAND Flash的块大小为8KB-64KB。擦&#x2F;写一个NOR Flash块需要4S，而擦&#x2F;写一个NAND Flash块仅需2ms。NOR Flash的块太大，不仅增加了擦写时间，对于给定的操作，NOR Flash也需要更多的擦除操作–特别是小文件。比如一个文件只有1KB，但是为了保存它却需要擦除大小为64KB-128KB的NOR Flash块。<br>NOR Flash的接口与RAM完全相同，可以随意访问任意地址的数据。而NAND Flash的接口仅仅包含几个I&#x2F;O引脚，需要串行访问。NAND Flash一般以512字节为单位进行读写。这使得NOR Flash更适合运行程序，NAND Flash更适合存储数据。<br>容量相同的情况下，NAND Flash的体积更小，对于空间有严格要求的系统，NAND Flash可以节省更多空间。市场上NOR Flash的容量通常为1MB-4MB(也有32MB的NOR Flash)。NAND Flash的容量为8MB-512MB。容量的差别也使得NOR Flash多用于存储程序，NAND Flash多用于存储数据。<br>基于Flash存储器件的可靠性需要考虑3点：位反转、坏块和可擦除次数。所有Flash器件都遭遇位反转问题：由于Flash固有的电气特性，在读写数据的过程中，偶尔会产生一位或几位数据错误，而NAND Flash出现的概率远大于NOR Flash。当位反转发生在关键的代码、数据时，有可能导致系统崩溃。当仅仅是报告位反转，重新读取即可；如果确实发生了位反转，则必须有相应的错误检测&#x2F;恢复措施。在NAND Flash上发生位反转的概率更高，推荐使用EDC&#x2F;ECC进行错误检测和恢复。NAND Flash上面会有坏块随机分布，在使用前需要将坏块扫描出来，确保不在使用它们，否则会使产品含有严重的故障。NAND Flash每块的可擦除次数通常在100000次左右。是NOR Flash的10倍。另外，因为NAND Flash的块大小通常是NOR Flash的1&#x2F;8，所以NAND Flash的寿命远远超过NOR Flash。<br>嵌入式Linux对NOR、NAND Flash的软件支持都很成熟。在NOR Flash上常用jffs2文件系统，而在NAND Flash常用yaffs文件系统。在更底层，有MTD驱动程序实现对它们的读、写、擦除操作，它也实现了EDC&#x2F;ECC校验。</p>
<h2 id="NAND-Flash的物理结构"><a href="#NAND-Flash的物理结构" class="headerlink" title="NAND Flash的物理结构"></a>NAND Flash的物理结构</h2><p>以NAND Flash K9F1208U0M为例，K9F1208U0M是Samsung公司生产的容量为64MB的NAND Flash，常用于手持设备等消费电子产品。它的封装下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"></p>
<p>外部引脚如下表所示：</p>
<table>
<thead>
<tr>
<th>引脚名称</th>
<th>引脚功能</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O0-I&#x2F;O7</td>
<td>数据输入&#x2F;输出</td>
</tr>
<tr>
<td>CLE</td>
<td>命令锁存使能</td>
</tr>
<tr>
<td>ALE</td>
<td>地址锁存使能</td>
</tr>
<tr>
<td>CE</td>
<td>芯片使能</td>
</tr>
<tr>
<td>RE</td>
<td>读使能</td>
</tr>
<tr>
<td>WE</td>
<td>写使能</td>
</tr>
<tr>
<td>WP</td>
<td>写保护</td>
</tr>
<tr>
<td>R&#x2F;B</td>
<td>就绪&#x2F;忙输出信号</td>
</tr>
<tr>
<td>Vcc</td>
<td>电源</td>
</tr>
<tr>
<td>Vss</td>
<td>地</td>
</tr>
<tr>
<td>N.C</td>
<td>不接</td>
</tr>
</tbody></table>
<p>K9F1208U0M的功能结构图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>K9F1208U0M的内部结构包含10个功能部件：</p>
<ol>
<li>X-Buffers Latche &amp; Decoders：用于行地址。</li>
<li>Y-Buffers Latche &amp; Decoders：用于列地址。</li>
<li>Command Register：用于命令字。</li>
<li>Control Logic &amp; High Voltage Generator：控制逻辑及产生Flash所需高压。</li>
<li>Nand Flash Array：存储部件。</li>
<li>Page Register &amp; S&#x2F;A：页寄存器，当读、写某页时，会将数据先读入&#x2F;写入此寄存器，大小为528字节。</li>
<li>Y-Gating。</li>
<li>I&#x2F;O Buffers &amp; Latches。</li>
<li>Global Buffers。</li>
<li>Output Drivers。</li>
</ol>
<p>Nand Flash 存储单元组织结构如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/3.jpeg" alt="img not found"><br>K9F1208U0M容量为528Mbit，分为131072行（页）、528列。每一页大小为512字节，外加16字节的额外空间，这16字节额外空间的列地址为512-527。<br>命令、地址、数据都通过8个I&#x2F;O口输入&#x2F;输出，这种形式减少了芯片的引脚个数，并使得系统很容易升级到更大的容量。写入命令、地址或数据时，都需要将WE、CE信号同时拉低。<br>数据在WE信号的上升沿被NAND Flash锁存。命令锁存信号CLE、地址锁存信号ALE用来分辨、锁存命令或地址。K9F1208U0M的64MB存储空间需要26位地址，因此以字节为单位访问Flash时需要4个地址序列：列地址、行地址的低位部分，行地址的高位部分。读&#x2F;写页发出命令之后，需要4个地址序列，而擦除块在发出擦除命令后仅需要3个地址序列。</p>
<h2 id="Nand-Flash的访问方法"><a href="#Nand-Flash的访问方法" class="headerlink" title="Nand Flash的访问方法"></a>Nand Flash的访问方法</h2><h3 id="硬件连接"><a href="#硬件连接" class="headerlink" title="硬件连接"></a>硬件连接</h3><p>NAND Flash和S3C2410&#x2F;S3C2440的硬件连接图如下所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/4.jpeg" alt="img not found"><br>NAND Flash和S3C2410&#x2F;S3C2440的连线较少：8个I&#x2F;O引脚（I&#x2F;O0-I&#x2F;O7），5个使能信号（nWE、ALE、CLE、nCE、nRE）、1个状态引脚（RDY&#x2F;B）、1个写保护引脚（nWP）。地址、数据、命令都是在这些使能信号的配合下，通过8个I&#x2F;O引脚的传输。写地址、数据、命令时，nCE、nWE信号必须为低电平，它们在nWE信号的上升沿被锁存。命令锁存使能信号CLE和地址锁存信号ALE用来区分I&#x2F;O引脚上传输的是命令还是地址。</p>
<h3 id="命令字及操作方法"><a href="#命令字及操作方法" class="headerlink" title="命令字及操作方法"></a>命令字及操作方法</h3><p>操作NAND Flash时，先传输命令，然后传输地址，最后读写数据。期间要检查Flash的状态。对于K9F1208U0M，它的容量是64MB，需要一个26位的地址。发出命令后，后面要紧跟着4个地址序列。比如读Flash时，发出读命令和4个地址序列后，后续的读操作就可以得到这个地址及器后续地址的数据。相应的命令字和地址序列如下表所示：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>第1个访问周期</th>
<th>第2个访问周期</th>
<th>第3个访问周期</th>
</tr>
</thead>
<tbody><tr>
<td>Read1（读）</td>
<td>00h&#x2F;01h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read2（读）</td>
<td>50h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read ID（读芯片ID）</td>
<td>90h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Page Program（写页）</td>
<td>80h</td>
<td>10h</td>
<td>-</td>
</tr>
<tr>
<td>Block Erase（擦除块）</td>
<td>60h</td>
<td>D0h</td>
<td>-</td>
</tr>
<tr>
<td>Read Status（读状态）</td>
<td>70h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Read Multi-Plane Status（读多层的状态）</td>
<td>71h</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Reset（复位）</td>
<td>FFh</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Page Program（Dummy）</td>
<td>80h</td>
<td>11h</td>
<td>-</td>
</tr>
<tr>
<td>Copy-Back Program（True）</td>
<td>00h</td>
<td>8Ah</td>
<td>10H</td>
</tr>
<tr>
<td>Copy-Back Program（Dummy）</td>
<td>03h</td>
<td>8Ah</td>
<td>11H</td>
</tr>
<tr>
<td>Multi-Plane Block Erase</td>
<td>60h-60h</td>
<td>D0h</td>
<td>-</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>&#x2F;</th>
<th>I&#x2F;O0</th>
<th>I&#x2F;O1</th>
<th>I&#x2F;O2</th>
<th>I&#x2F;O3</th>
<th>I&#x2F;O4</th>
<th>I&#x2F;O5</th>
<th>I&#x2F;O6</th>
<th>I&#x2F;O7</th>
<th>备注</th>
</tr>
</thead>
<tbody><tr>
<td>第1个地址序列</td>
<td>A0</td>
<td>A1</td>
<td>A2</td>
<td>A3</td>
<td>A4</td>
<td>A5</td>
<td>A6</td>
<td>A7</td>
<td>列地址</td>
</tr>
<tr>
<td>第2个地址序列</td>
<td>A9</td>
<td>A10</td>
<td>A11</td>
<td>A12</td>
<td>A13</td>
<td>A14</td>
<td>A15</td>
<td>A16</td>
<td>行地址（页地址）</td>
</tr>
<tr>
<td>第3个地址序列</td>
<td>A17</td>
<td>A18</td>
<td>A19</td>
<td>A20</td>
<td>A21</td>
<td>A22</td>
<td>A23</td>
<td>A24</td>
<td>行地址（页地址）</td>
</tr>
<tr>
<td>第4个地址序列</td>
<td>A25</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>L</td>
<td>行地址（页地址）</td>
</tr>
</tbody></table>
<p>注：<br>①K9F1208U0M一页大小为512字节，分两部分：上半部、下半部。<br>②列地址用来在半页（256字节）中寻址。<br>③当发出读命令00h时，表示列地址将在上半部寻址。当发出写命令01h时，表示列地址将在下半部寻址。<br>④A8被读命令00h设为低电平，被01h设为高电平。<br>⑤L表示低电平。</p>
<p>K9F1208U0M一页大小为508字节，而列地址A0-A7可以寻址的范围是256字节，所以必须辅以其他手段才能完全寻址着528字节。将一页分为A、B、C三个区：A区为0-255字节，B区为256-511字节，C区为512-527字节。访问某页时，需要选定特定的区，这称为“使地址指针指向特定的区”。这通过3个命令来实现：命令00h让地址指针指向A区、命令01h让地址指针指向B区、命令50h让地址指针指向C区。命令00h和命令50h会使得访问Flash的地址指针一直从A区或C区开始，除非发出了其他的修改地址指针的命令。命令01h的效果只能维持一次，当前的读、写、擦除、复位或者上电操作完成后，地址指针重新指向A区。写A区或C区的数据时，必须在发出命令80h之前发出命令00h或50h；写B区的数据时，发出命令01h后必须紧接着发出命令80h。下图形象的描述了这个过程：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/5.jpeg" alt="img not found"></p>
<ol>
<li>Read 1：命令字为00h或01h<br>在发出命令00h或者01h后，就选定了读操作是从A区还是B区开始。列地址A0-A7可以寻址的范围是256字节，命令00h和01h使得可以在512字节大小的页内任意寻址–这相当于A8被命令00h设为0，而命令01h设为1。<br>发出命令字后，随后发出4个地址序列，然后就可以检测R&#x2F;nB引脚以确定Flash是否准备好。如果准备好了，就可以发起读操作一次读出数据。</li>
<li>Read 2：命令字为50h<br>与Read 1类似，不过读取的是C区数据，操作序列为：发出命令字50h、发出4个地址序列、等待R&#x2F;nB引脚为高，最后读取数据。不同的是，地址序列中A0-A3用于设定C区（16字节）要读取的起始地址，A4-A7被忽略。</li>
<li>Read ID：命令字90h。<br>发出命令字90h，发出4个地址序列（都设为0），然后就可以连续读入5个数据，分别表示：厂商代码（Samsung格式为Ech）、设备代码（K9F1208U0M为76h）、保留的字节（K9F1208U0M为A5h）、多层操作代码（C0h表示支持多层操作）。</li>
<li>Reset：命令字为FFh<br>发出命令字FFh即可复位NAND Flash芯片。如果芯片正处于读、写、擦除状态，复位命令会终止这些命令。</li>
<li>Page Program（True）：命令字分两阶段，80h和10h<br>它的操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/6.jpeg" alt="img not found"><br>NAND Flash的写操作一般是以页为单位的，但是可以只写一页中的一部分。发出命令字80h后，紧接着的是4个地址序列，然后向Flash发送数据（最大可达528字节），然后发送命令字10h启动写操作，此时Flash内部会自动完成写、校验操作。一旦发出命令字10h后，就可以通过读状态命令70h获知当前写操作是否完成、是否成功。</li>
<li>Page Program（Dummy）：命令字分为两阶段，80h和11h。<br>NAND Flash K9F1208U0M分为4个128Mbit的存储层（plane），每个存储层包含1024个block和528字节的寄存器。这使得可以同时写多个页（page）或者同时擦除多个块（block）。块的地址经过精心安排，可以在4个连续的块内同时进行写或者擦除操作。下图为K9F1208U0M的块组织图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/7.jpeg" alt="img not found"><br>命令Page Program（Dummy）正是在这种结构下对命令Page Program（True）的扩展，后者仅能对一页进行写操作，前者可以同时写4页。操作序列如下图：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/8.jpeg" alt="img not found"><br>发出命令字80h、4个地址序列及最多528字节的数据之后，发出命令字11h（11h称为“Dummy Page Program command”，相对的，10h称为“True Page Program Command”）；接着对相邻层（plane）上的页进行同样的操作。仅在第4页的最后使用10h替代11h，这样即可启动Flash内部的写操作。此时可以通过命令71h获知这些写操作是否完成、是否成功。</li>
<li>Copy-Back Program（True）：命令字分3阶段，00h、08h、10h。<br>此命令用于将一页复制到同一层（plane）内的另一页，它省略了读出源数据、将数据重新载入Flash，这使得效率大卫提高。此命令有两个限制：源页、目的页必须在同一层（plane）中，并且将源地址、目的地址的A14、A15必须相同。<br>操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/9.jpeg" alt="img not found"><br>首先发出命令Read 1（00h）、4个源地址序列，此时源页的528字节数据很快就被全部读入内部寄存器中；接着发出命令字8Ah（Page-Copy Data-input command）,随之发出4个目的地址序列；最后发出命令字10h启动对目的页的写操作。此后可以使用命令70h来查看此操作是否完成、是否成功。</li>
<li>Copy-Back Program（Dummy）：命令字分3个阶段，03h、8Ah、11h。<br>与命令Page Program（Dummy）类似，Copy-Back Program（Dummy）可以同时启动对多达4个连续plane内的Copy-Back Program操作。操作序列如下所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/10.jpeg" alt="img not found"><br>从图中可得知，首先发出命令字00h、源页地址，这使得源页的528字节数据被读入所在plane的寄存器；对于随后的其他plane的源页，发出命令字03h和相应的源页地址将数据读入该plane的寄存器；按照前述说明读出最多4页的数据到寄存器后，发出命令字8Ah、目的地址、命令字11h，在发出最后一页地址后，用10h代替11h启动写操作。</li>
<li>Block Erase：命令字分3阶段，60h、D0h。<br>此命令用于擦除NAND Flash块（block，大小为16KB）。发出命令字后，发出block地址—仅需要3个地址序列，并且A9-A13被忽略，操作序列如下图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/11.jpeg" alt="img not found"></li>
<li>Multi-Plane Block Erase：60h—-60h D0h。<br>此命令用于擦除不同的plane中的块，发出命令字60h后，紧接着发出block地址序列，如此最多可以发出4个block地址，最后发出命令字D0h启动擦除操作。操作序列如图所示：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/12.jpeg" alt="img not found"></li>
<li>读状态命令字有如下两种：<br>①Read Status：命令字为70h。<br>②Read Multi-Plane Status：命令字为71h。<br>Falsh中有状态寄存器，发出命令字70h或71h后，启动读操作即可读入此寄存器。状态寄存器中各位的含义如下表所示：<table>
<thead>
<tr>
<th>I&#x2F;O引脚</th>
<th>所标识的状态</th>
<th>命令70h对应的定义</th>
<th>命令71h对应的定义</th>
</tr>
</thead>
<tbody><tr>
<td>I&#x2F;O0</td>
<td>总标记：成功&#x2F;失败</td>
<td>成功：0 失败：1</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O1</td>
<td>Plane0的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O2</td>
<td>Plane1的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O3</td>
<td>Plane2的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O4</td>
<td>Plane3的标记：成功&#x2F;失败</td>
<td>忽略</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O5</td>
<td>保留</td>
<td>忽略</td>
<td>忽略</td>
</tr>
<tr>
<td>I&#x2F;O6</td>
<td>设备状态</td>
<td>忙：0 就绪：1</td>
<td>成功：0 失败：1</td>
</tr>
<tr>
<td>I&#x2F;O7</td>
<td>写保护状态</td>
<td>保护：0 没有保护：1</td>
<td>保护：0 没有保护：1</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：<br>①I&#x2F;O0是所有Plane的“总标记”，只要有一个Plane的操作是失败的，I&#x2F;O0就会被设为“失败”。<br>②I&#x2F;O0-I&#x2F;O4引脚只部件它对应的Plane。</p>
<h2 id="S3C2410-x2F-S3C2440-NAND-Flash控制器介绍"><a href="#S3C2410-x2F-S3C2440-NAND-Flash控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 NAND Flash控制器介绍"></a>S3C2410&#x2F;S3C2440 NAND Flash控制器介绍</h2><p>NAND Flash控制器提供几个寄存器来简化对NAND Flash的操作。比如要发出读命令时，只需要往NFCMD寄存器中写入0即可，NAND Flash控制器会自动发出各种控制信号。</p>
<h3 id="操作方法概述"><a href="#操作方法概述" class="headerlink" title="操作方法概述"></a>操作方法概述</h3><p>访问NAND Flash时需要先发出命令，然后发出地址序列，最后读写数据。需要使用各个使能信号来分辨是命令、地址还是数据。S3C2410的NAND Flash控制器提供了NFCONF、NFCMD、NFADDR、NFDATA、NFSTAT和NFECC等6个寄存器来简化这些操作。S3C2440的NAND Flash控制器则提供了NFCONF、NFCONT、NFCMMD、NFADDR、NFDATA、NFSTAT和其他与ECC有关的寄存器。对NAND Flash控制器的操作，S3C2410与S3C2440有一点小差别，有的寄存器地址不一样，有的寄存器内容不一样。<br>NAND Flash的读写操作次序如下：</p>
<ol>
<li>设置NFCONF（对于S3C2440，还要设置NFCONT）寄存器，配置NAND Flash。</li>
<li>向NFCMD寄存器写入命令。</li>
<li>向NFADDR写入地址。</li>
<li>读&#x2F;写数据，通过寄存器NFSTAT检测NAND Flash的状态，在启动某个操作之后，应该检测R&#x2F;nB信号以确定该操作是否完成、是否成功。</li>
</ol>
<h3 id="寄存器介绍"><a href="#寄存器介绍" class="headerlink" title="寄存器介绍"></a>寄存器介绍</h3><ol>
<li>NFCONF：NAND Flash配置寄存器<br>这个寄存器在S3C2410、S3C2440上功能有所不同。<br>S3C2410上的NFCONF寄存器，被用来使能&#x2F;禁止NAND Flash控制器，使能&#x2F;禁止控制引脚信号nFCE、初始化ECC、设置NAND Flash的时序参数等。TACLS、TWRPH0和TWRPH1这3个参数控制的是NAND Flash信号线CLE&#x2F;ALE与写控制信号nWE的时序关系。<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/13.jpeg" alt="img not found"><br>S3C2440的NFCONF寄存器，被用来设置NAND Flash的时序参数TACLS、TWRPH0、TWRPH1，设置数据位宽；还有一些只读位，用来指示是否支持其他大小的页（256&#x2F;512&#x2F;1024&#x2F;2048字节）。<br>它没有实现S3C2410的NFCONF寄存器的控制功能，这些功能在S3C2440的NFCONT寄存器里实现。</li>
<li>NFCONT：NAND Flash控制寄存器，S3C2410没有这个寄存器。<br>被用来使能&#x2F;禁止NAND Flash控制器、使能&#x2F;禁止控制引脚信号nFCE、初始化ECC。它还有其他功能，在一般的应用中用不到，比如锁定NAND Flash。</li>
<li>NFCMD：NAND Flash命令寄存器<br>对于不同型号的Flash，操作命令一般不一样。</li>
<li>NFADDR：NAND Flash地址寄存器。<br>当写这个寄存器时，它将对Flash发出地址信号。</li>
<li>NFDATA：NAND Flash数据寄存器。<br>只用到低8位，读写此寄存器将启动对NAND Flash的读数据、写数据操作。</li>
<li>NFSTAT：NAND Flash状态寄存器<br>只用到位0。0：busy，1：ready。</li>
</ol>
<h1 id="NAND-Flash控制器操作实例：读Flash"><a href="#NAND-Flash控制器操作实例：读Flash" class="headerlink" title="NAND Flash控制器操作实例：读Flash"></a>NAND Flash控制器操作实例：读Flash</h1><p>本实例讲述如何读取NAND Flash，擦除、写Flash的操作与读Flash类似，读者可以自行编写程序程序。</p>
<h2 id="读NAND-Flash的步骤"><a href="#读NAND-Flash的步骤" class="headerlink" title="读NAND Flash的步骤"></a>读NAND Flash的步骤</h2><p>下面讲述如何从NAND Flash中读出数据，假设读地址为addr。</p>
<h3 id="1-设置NFCONF（对于S3C2440，还要设置NFCONT）"><a href="#1-设置NFCONF（对于S3C2440，还要设置NFCONT）" class="headerlink" title="1.设置NFCONF（对于S3C2440，还要设置NFCONT）"></a>1.设置NFCONF（对于S3C2440，还要设置NFCONT）</h3><ol>
<li><p>对于S3C2410<br>实例中此寄存器设为0x9830—使能NAND Flash控制器、初始化ECC、NAND Flash片选信号nFCE&#x3D;1（inactive，真正使用时再让它等于0），设置TACLS&#x3D;0，TWRPH0&#x3D;3，TWRPH1&#x3D;0。这些时序参数的含义为：TACLS&#x3D;1个HCLK时钟，TWRPH0&#x3D;4个HCLK时钟，TWRPH1&#x3D;1个HCLK时钟。<br>K9F1208U0M的时间特性如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CLE setup Time = 0 ns,CLE Hold Time = 10 ns,</span><br><span class="line">ALE setup Time = 0 ns,ALE Hold Time = 10 ns,</span><br><span class="line">WE Pulse Width 25 ns</span><br></pre></td></tr></table></figure>
<p>参考上图：即使在HCLK&#x3D;100MHZ的情况下，TACLS+TWRPH0+TWRPH1&#x3D;6&#x2F;100μs&#x3D;60ns，也是可以满足NAND Flash K9F1208U0M的时序要求的。</p>
</li>
<li><p>对于S3C2440<br>时间参数也设为：TACLS&#x3D;0，TWRPH0&#x3D;3，TWRPH1&#x3D;0。NFCONF寄存器的值如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF = 0x300</span><br></pre></td></tr></table></figure>
<p>NFCONT寄存器的取指如下，表示使能NAND Flash控制器、禁止控制引脚信号nFCE、初始化ECC。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT = (1&lt;&lt;4) | (1&lt;&lt;1) | (1&lt;&lt;0)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="2-在第一次操作NAND-Flash前，通常复位一下NAND-Flash"><a href="#2-在第一次操作NAND-Flash前，通常复位一下NAND-Flash" class="headerlink" title="2.在第一次操作NAND Flash前，通常复位一下NAND Flash"></a>2.在第一次操作NAND Flash前，通常复位一下NAND Flash</h3><ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF &amp;= ~(1&lt;&lt;11)  (发出片选信号)</span><br><span class="line">NFCMD   = 0xff      (reset命令)</span><br></pre></td></tr></table></figure>
然后循环查询NFSTAT位0，直到它等于1。<br>最后禁止片选信号，在实际使用NAND Flash时再使能。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF  |=  (1&lt;&lt;11) (禁止NAND Flash)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  &amp;=  ~(1&lt;&lt;11)    (发出片选信号)</span><br><span class="line">NFCMD    =  0xff        (reset命令)</span><br></pre></td></tr></table></figure>
然后循环查询NFSTAT位0，知道它等于1。<br>最后禁止片选信号，在实际使用NAND Flash时再使能。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  |=  0x2         (禁止NAND Flash)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="3-发出读命令"><a href="#3-发出读命令" class="headerlink" title="3.发出读命令"></a>3.发出读命令</h3><p>先使能NAND Flash，然后发出读命令。</p>
<ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF &amp;=   ~(1&lt;&lt;11)        (发出片选信号)</span><br><span class="line">NFCMD   =   0               (读命令)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  &amp;=  ~(1&lt;&lt;11)        (发出片选信号)</span><br><span class="line">NFCND    =  0               (读命令)</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="4-发出地址信号"><a href="#4-发出地址信号" class="headerlink" title="4.发出地址信号"></a>4.发出地址信号</h3><p>这步请注意，表8.3列出了在地址操作的4个步骤对应的地址线，没用到A8（它由读命令设置，当读命令为0时，A8&#x3D;0；当读命令为1时，A8&#x3D;1），如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFADDR  = addr &amp; 0xff</span><br><span class="line">NFADDR  = (addr &gt;&gt; 9)   &amp;   0xff    (左移9位，不是8位)</span><br><span class="line">NFADDR  = (addr &gt;&gt; 17)  &amp;   0xff    (左移17位，不是16位)</span><br><span class="line">NFADDR  = (addr &gt;&gt; 25)  &amp;   0xff    (左移25位，不是24位)</span><br></pre></td></tr></table></figure>
<h3 id="5-循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了"><a href="#5-循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了" class="headerlink" title="5.循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了"></a>5.循环查询NFSTAT位0，直到等于1，这时候就可以读取数据了</h3><h3 id="6-连续读取NFDATA寄存器512次，得到一页数据（512字节）"><a href="#6-连续读取NFDATA寄存器512次，得到一页数据（512字节）" class="headerlink" title="6.连续读取NFDATA寄存器512次，得到一页数据（512字节）"></a>6.连续读取NFDATA寄存器512次，得到一页数据（512字节）</h3><p>循环执行第3、4、5、6这四个步骤，直到读出所要求的所有数据。</p>
<h3 id="7-最后禁止NAND-Flash的片选信号"><a href="#7-最后禁止NAND-Flash的片选信号" class="headerlink" title="7.最后禁止NAND Flash的片选信号"></a>7.最后禁止NAND Flash的片选信号</h3><ol>
<li>对于S3C2410<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONF |= (1&lt;&lt;11)</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2440<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">NFCONT  |=  (1&lt;&lt;1)</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>源文件为head.S、init.c和main.c。本实例的目的是把一部分代码存放在NAND Flash地址4096后，当程序启动NAND Flash控制器将它们读出来、执行。以前的代码都小于4096字节，开发板启动后它们被自动复制进“Steppingstone”中。<br>连接脚本nand.lds把它们分为两部分，nand.lds代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    first   0x00000000  ：&#123;head.o init.o nand.o&#125;</span><br><span class="line">    second  0x30000000  :   AT(4096)    &#123;main.o&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2行表示head.o、init.o、nand.o这3个文件的运行地址为0，它们在生成的映像文件中的偏移地址也为0（从0开始存放）。<br>第3行表示main.o的运行地址为0x30000000，它在生成的映像文件中的偏移地址为4096。<br>head.S调用init.c中的函数来关WATCH DOG、初始化SDRAM；调用nand.c中的函数来初始化NAND Flash，然后将main.c中的代码从NAND Flash地址4096开始处复制到SDRAM中；最后跳到main.c中的main函数继续执行。<br>由于S3C2410、S3C2440的NAND Flash控制器并非完全一样，这个程序要既能处理S3C2410，也能处理S3C2440，首先需要分辨是S3C2410还是S3C2440，然后使用不同的函数进行处理。读取GSTATUS1寄存器，如果它的值为0x32410000或0x32410002，就表示处理器是S3C2410，否则就是S3C2440。<br>nand.c向外引出两个函数：用来初始化NAND Flash的nand_init函数，用来将数据从NAND Flash读到SDRAM的nand_read函数。</p>
<h3 id="nand-init-函数分析"><a href="#nand-init-函数分析" class="headerlink" title="nand_init 函数分析"></a>nand_init 函数分析</h3><p>代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化NAND Flash</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">nand_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH0  3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH1  0</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*判断是S3C2410还是S3C2440*/</span></span><br><span class="line">    <span class="keyword">if</span>((GSTATUS1 == <span class="number">0x32410000</span>) || (GSTATAUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        nand_chip.nand_reset            =   s3c2410_nand_reset;</span><br><span class="line">        nand_chip.wait_idle             =   s3c2410_wait_idle;</span><br><span class="line">        nand_chip.nand_select_chip      =   s3c2410_nand_select_chip;</span><br><span class="line">        nand_chip.nand_deselect_chip    =   s3c2410_nand_deselect_chip;</span><br><span class="line">        nand_chip.write_cmd             =   s3c2410_write_cmd;</span><br><span class="line">        nand_chip.write_addr            =   s3c2410_write_addr;</span><br><span class="line">        nand_chip.read_data             =   s3c2410_read_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*使能NAND Flash控制器，初始化ECC，禁止片选，设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (<span class="number">1</span>&lt;&lt;<span class="number">15</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">12</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">11</span>) | (TACLS&lt;&lt;<span class="number">8</span>) | (TWRPH0&lt;&lt;<span class="number">4</span>) | (TWRPH1&lt;&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        nand_chip.nand_reset            =   s3c2440_nand_reset;</span><br><span class="line">        nand_chip.wait_idle             =   s3c2440_wait_idle;</span><br><span class="line">        nand_chip.nand_select_chip      =   s3c2440_nand_select_chip;</span><br><span class="line">        nand_chip.nand_deselect_chip    =   s3c2440_nand_deselect_chip;</span><br><span class="line">        nand_chip.write_cmd             =   s3c2440_write_cmd;</span><br><span class="line">        nand_chip.write_addr            =   s3c2440_write_addr;</span><br><span class="line">        nand_chip.read_data             =   s3c2440_read_data;</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (TACLS&lt;&lt;<span class="number">12</span>) | (TWRPH0&lt;&lt;<span class="number">8</span>) | (TWRPH1&lt;&lt;<span class="number">4</span>);</span><br><span class="line">        <span class="comment">/*使能NAND Flash控制器，初始化ECC，禁止片选，设置时序*/</span></span><br><span class="line">        s3c2410nand-&gt;NFCONF =   (<span class="number">1</span>&lt;&lt;<span class="number">4</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">1</span>) | (<span class="number">1</span>&lt;&lt;<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">/*复位NAND Flash*/</span></span><br><span class="line">    nand_reset();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第12行读取GSTATUS1寄存器来判断为S3C2410还是S3C2440，然后分别处理：S3C2410、S3C2440的NAND Flash控制器中，有一些寄存器的功能是相同的，但是它们的地址是不一样的；有一些寄存器的功能已经发生变化。所以使用两套函数来进行处理。<br>第14-20行设置S3C2410的NAND Flash处理函数，第27-33行设置S3C2440的NAND Flash处理函数，把这些函数赋值给nand_chip结构，以后通过这个结构来调用。<br>如果处理器是S3C2410，则调用第23行的代码设置NFCONF寄存器；使能NAND Flash控制器，初始化ECC，禁止片选，设置时序。如果处理器是S3C2440，则使用第36、38两行代码来进行相同的设置。<br>最后第41行调用nand_reset函数复位NAND Flash。在第一次使用前通常复位一下。其中涉及的各个函数都只有几行，主要是读写寄存器。</p>
<h3 id="nand-read-函数分析"><a href="#nand-read-函数分析" class="headerlink" title="nand_read 函数分析"></a>nand_read 函数分析</h3><p>它的原型如下，表示从NAND Flash位置satrt_addr开始，将数据复制到SDRAM地址buf处，共复制size字节。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">unsigned</span> <span class="type">long</span> start_addr,<span class="type">int</span> size)</span></span><br></pre></td></tr></table></figure>
<p>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">nand_read</span> <span class="params">(<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">unsigned</span> <span class="type">long</span> start_addr,<span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>((start_addr &amp; NAND_BLOCK_MASK) || (size &amp; NAND_BLOCK_MASK))&#123;</span><br><span class="line">        <span class="keyword">return</span>;<span class="comment">/*地址或长度不对齐*/</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*选中芯片*/</span></span><br><span class="line">    nand_select_chip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = start_addr;i &lt; start_addr + size;)&#123;</span><br><span class="line">        <span class="comment">/*发出READ0命令*/</span></span><br><span class="line">        write_cmd(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">        <span class="comment">/*Write Address*/</span></span><br><span class="line">        write_addr(i);</span><br><span class="line">        wait_idle();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;i &lt; NAND_SECTOR_SIZE;j++,i++)&#123;</span><br><span class="line">            *buf = read_data();</span><br><span class="line">            buf++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*取消片选信号*/</span></span><br><span class="line">    nand_deselect_chip();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以看到，读NAND Flash的操作分为6步。</p>
<ol>
<li>选择芯片——nand_select_chip()；</li>
<li>发出读命令——write_cmd()；</li>
<li>发出地址——write_addr()；</li>
<li>等待数据就绪——wait_idle()；</li>
<li>读取数据——read_data()；</li>
<li>结束后，取消片选信号；</li>
</ol>
<p>流程图如下：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/14.jpeg" alt="img not found"><br>从NAND Flash复制代码到SDRAM并运行的过程：<br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/15.jpeg" alt="img not found"><br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/16.jpeg" alt="img not found"><br><img src="/2022/08/18/NAND-Flash%E6%8E%A7%E5%88%B6%E5%99%A8/17.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第8章 NAND Flash控制器</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Flash</tag>
      </tags>
  </entry>
  <entry>
    <title>中断体系结构</title>
    <url>/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第9章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解ARM系统CPU的7中工作模式</li>
<li>了解S3C2410&#x2F;S3C2440中断体系结构</li>
<li>掌握S3C2410&#x2F;S3C2440的中断服务程序的编写方法</li>
</ol>
<h1 id="S3C2410-x2F-S3C2440中断体系结构"><a href="#S3C2410-x2F-S3C2440中断体系结构" class="headerlink" title="S3C2410&#x2F;S3C2440中断体系结构"></a>S3C2410&#x2F;S3C2440中断体系结构</h1><h2 id="ARM体系CPU的7种工作模式"><a href="#ARM体系CPU的7种工作模式" class="headerlink" title="ARM体系CPU的7种工作模式"></a>ARM体系CPU的7种工作模式</h2><ol>
<li>用户模式（usr）：ARM处理器正常的程序执行状态。</li>
<li>快速中断模式（fiq）：用于高速数据传输或通道处理。</li>
<li>中断模式（irq）：用于通用的中断处理。</li>
<li>管理模式（svc）：操作系统使用的保护模式。</li>
<li>数据访问终止模式（abt）：当数据或指令预取终止时进入该模式，可用于虚拟存储及存储保护。</li>
<li>系统模式（sys）：运行具有特权的操作系统任务。</li>
<li>未定义指令中止模式（und）：当未定义的指令执行时进入该模式，可用于支持硬件协处理器的软件仿真。</li>
</ol>
<p>可以通过软件来进行模式切换，或者发生各类中断、异常时CPU自动进入相应的模式。除用户模式外，其他6种模式都属于特权模式。大多数程序运行于用户模式，进入特权模式是为了处理中断、异常，或者访问被保护的系统资源。<br>另外，ARM体系的CPU有以下两种工作状态。<br>ARM状态：此时处理器执行32位的字对齐的ARM指令。<br>Thumb状态：此时处理器执行16位的、半字对齐的Thumb指令。<br>实际上，本书所有的程序都是在ARM状态下运行的，而CPU一上电就处于ARM状态，所以无需关心CPU的工作状态。<br>ARM920T有31个通用的32位寄存器和6个程序状态寄存器。这37个寄存器分为7组，进入某个工作模式是就使用它的那组寄存器。有些寄存器，不同的工作模式有自己的副本，当切换到另一个工作模式时，那个工作模式的寄存器副本将被使用：这些寄存器被称为备份寄存器。<br>在ARM状态下，每种工作模式都有16个通用寄存器和1个（或2个，取决于工作模式）程序状态寄存器。下图列出了ARM状态下不同工作模式所使用的寄存器：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1.jpeg" alt="img not found"><br>图中R0-R15可以直接访问，这些寄存器除R15之外都是通用寄存器。即它们既可以保存数据也可以保存地址。另外，R13-R15稍有特殊。R13又被称为栈指针寄存器，通常用于保存栈指针。R14  又被称为程序连接寄存器或连接寄存器，当执行BL子程序调用指令时，R14中得到R15（程序计数器PC）的备份。而当发生中断或者异常时，对应的R14_svc、R14_irq、R14_fiq、R14_abt或R14_und中保存R15的返回值。R15是程序计数器。<br>快速中断模式有7个备份寄存器R8-R14（即R8_fiq-R14_fiq），这使得进入快速中断模式执行很大部分程序时（只要它们不改变R0-R7），甚至不需要保存任何寄存器。用户模式、管理模式、数据访问终止模式和未定义指令中止模式都含有两个独占的寄存器副本R13、R14，这样可以令每个模式拥有自己的栈指针寄存器和连接寄存器。<br>每种工作模式除R0-R15共有16个寄存器外，还有第17个寄存器CPSR，即“当前程序状态寄存器（Current Program Status Register）”。CPSR中一些位被用于表示各种状态，一些位被用于标识当前处于说明工作模式。<br>CPSR中各位意义如下：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2.jpeg" alt="img not found"></p>
<ol>
<li>T位：置位时，CPU处于Thumb状态，否则处于ARM状态。</li>
<li>中断禁止位：I位和F位属于中断禁止位。它们置位时，IRQ中断、FIQ中断分别被禁止。</li>
<li>工作模式位：表明CPU当前处于什么工作模式。可以编写这些位，使CPU进入指定的工作模式。</li>
</ol>
<p>除CPSR外，还有快速中断模式、中断模式、管理模式、数据访问终止模式和未定义指令中止模式等5种工作模式和一个寄存器–SPSR，即“程序状态保存寄存器（Saved Process Status Registers）”。当切换进入这些工作模式时，在SPSR中保存前一个工作模式的CPSR值，这样，当返回前一个工作模式时，可以将SPSR的值恢复到CPSR中。<br>综上所述，当一个异常发生时，将切换进入相应的工作模式（下文中将称为异常模式），这是CPU核将自动完成以下事情：</p>
<ol>
<li>在异常工作模式的连接寄存器R14中保存前一个工作模式的下一条，即将执行的指令的地址。对于ARM状态，这个值是当前PC值加4或加8。</li>
<li>将CPSR的值复制到异常模式的SPSR。</li>
<li>将CPSR的工作模式位设为这个异常对应的工作模式。</li>
<li>令PC值等于这个异常模式在异常向量表中的地址，即跳转去执行异常向量表中的相应指令。</li>
</ol>
<p>相反的，从异常工作模式推出到之前的工作模式时，需要通过软件完成如下事情。</p>
<ol>
<li>前面进入异常工作模式时，连接寄存器保存了前一工作模式的一个指令地址，将它减去一个适当的值后赋值给PC寄存器。</li>
<li>将SPSR的值复制回CPSR。</li>
</ol>
<table>
<thead>
<tr>
<th>异常模式</th>
<th>退出异常模式时PC的计算方法</th>
<th>进入异常模式时R14中保存的值（ARM状态）</th>
</tr>
</thead>
<tbody><tr>
<td>管理模式（通过SWI指令进入）</td>
<td>MOVS PC，R14</td>
<td>PC + 4 ①</td>
</tr>
<tr>
<td>未定义指令中止模式</td>
<td>MOVS PC，R14</td>
<td>PC + 4  ①</td>
</tr>
<tr>
<td>快速中断模式</td>
<td>SUBS PC，R14，#4</td>
<td>PC + 4 ②</td>
</tr>
<tr>
<td>中断模式</td>
<td>SUBS PC，R14，#4</td>
<td>PC + 4 ②</td>
</tr>
<tr>
<td>数据访问终止模式</td>
<td>异常原因：指令预取终止 SUBS PC，R14，#4</td>
<td>PC + 4 ①</td>
</tr>
<tr>
<td>数据访问终止模式</td>
<td>异常原因：指令访问终止 SUBS PC，R14，#8</td>
<td>PC + 8 ③</td>
</tr>
</tbody></table>
<p>注：<br>①PC值是这些指令的地址：SWI、未定义的指令、在预取时就失败的指令。<br>②PC值是这些指令的地址：进入快速中断模式、中断模式前、被打断而未执行的指令。<br>③PC值是这些指令的地址：导致数据访问终止的加载&#x2F;存储指令（LDR、STR、LDM、STM）。</p>
<h2 id="S3C2410-x2F-S3C2440中断控制器"><a href="#S3C2410-x2F-S3C2440中断控制器" class="headerlink" title="S3C2410&#x2F;S3C2440中断控制器"></a>S3C2410&#x2F;S3C2440中断控制器</h2><p>CPU运行过程中，如何知道各类外设发生了某些不预期的事件，比如串口收到了新数据，USB接口中插入了设备，按下了某个按键等。主要有以下两种方法：</p>
<ol>
<li>轮询方式：程序循环的查询各个设备的状态并作出相应反应。它实现简单，常用在功能相对单一的系统中。比如在一个温控系统中可以使用查询方式不断检测温度的变化。缺点是占用CPU资源过高，不适用于多任务系统。</li>
<li>中断方式：当某件事情发生时，硬件会设置某个寄存器；CPU在每执行完一条指令时，通过硬件查看这个寄存器，如果发现所关注的事情发生了，则中断当前程序流程，跳转到一个固定的地址处理这件事情，最后返回继续执行被中断的程序。它的实现相对复杂，但是效率很高，是常用的方法。</li>
</ol>
<p>参考下图，不论何种CPU，中断的处理过程是相似的：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/3.jpeg" alt="img not found"></p>
<ol>
<li>中断控制器汇集各类外设发出的中断信号，然后告诉CPU。</li>
<li>CPU保存当前程序的运行环境（各个寄存器等），调用中断服务程序（ISR，Interrupt Service Routine）来处理这些中断。</li>
<li>在ISR中通过读取中断控制器、外设的相关寄存器来识别这是哪个中断，并进行相应的处理。</li>
<li>清除中断：通过读写中断控制器和外设的相关寄存器来实现。</li>
<li>最后恢复被中断程序的运行环境（即上面保存的各个寄存器等），继续执行。</li>
</ol>
<p>对于不同的CPU而言，中断的处理只是细节的不同，S3C2410&#x2F;S3C2440的中断控制器结构如下图所示：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/4.jpeg" alt="img not found"><br>SUBSRCPND和SRCPND寄存器表明有哪个中断被触发了，正在等待处理（pending）；SUBMASK（INTSUBMSK）和MASK（INTMSK）用于屏蔽某些中断。<br>图中的“Request sources （with sub -register）”表示INT_RXD0、INT_TXD0等中断源（S3C2410中这类中断有11个，而S3C2440中有15个）。它们不同于“Request sources （without sub -register）”。</p>
<ol>
<li>Request sources （without sub -register）中的中断源被触发之后，SRCPND寄存器中相应位被置1，如果此中断没有被INTMSK寄存器屏蔽或者快中断（FIQ）的话，它将被进一步处理。</li>
<li>对于Request sources （with sub -register）中的中断源被触发之后，SUBSRCPND寄存器中的相应位被置1，如果此中断没有被INTSUBMSK寄存器屏蔽的话，它在SRCPND寄存器中的相应位也被置1，之后的处理过程就和“Request sources （without sub -register）”一样了。</li>
</ol>
<p>在SRCPND寄存器中，被触发的中断的相应位被置1，等待处理：</p>
<ol>
<li>如果被触发的中断中有快速中断（FIQ）—MODE（INTMOD寄存器）中为1的位对应的中断是FIQ，则CPU进入快速中断模式（FIQ Mode）进行处理。</li>
<li>对于一般中断IRQ，可能同时有几个中断被触发，未被INTMSK寄存器屏蔽的中断经过比较后，选出优先级最高的中断，此中断在INTPND寄存器中的相应位被置1，然后CPU进入中断模式（IRQ Mode）进行处理。中断服务程序可以通过读取INTPND寄存器或者INTOFFSET寄存器来确定中断源。</li>
</ol>
<p>“Priority”表示中断的优先级判选，通过PRIORITY寄存器进行设置。</p>
<p>综上所述，使用中断的步骤如下：</p>
<ol>
<li>设置好中断模式和快速中断模式下的栈：当发生中断IRQ时，CPU进入中断模式，这是使用中断模式下的栈；当发生快速中断模式FIQ时，CPU进入快速中断模式，这时使用快速中断模式下的栈。</li>
<li>准备好中断处理函数。<br>  ①异常向量：<br>  在异常向量表中设置好当进入中断模式或快速中断模式时的跳转函数，它们的异常向量地址分别为0x00000018、0x0000001C。<br>  ②中断服务程序（ISR）：<br>  IRQ、FIQ的跳转函数，最终将调用具体中断的服务函数。对于IRQ，读取INTPND寄存器或者INTOFFSET寄存器的值来确定中断源，然后分别处理。<code>对于FIQ，因为只有一个中断可以设为FIQ</code>，因此无需判断。<br>  ③清除中断：<br>  如果不清除中断，则CPU会误以为这个中断又一次发生了。<br>  可以在调用ISR之前清除中断，也可以在调用ISR之后清除中断，这取决于在ISR执行过程中，这个中断是否可能继续发生、是否能够丢弃。如果在ISR执行过程中，这个中断可能发生并不能丢弃，则在调用ISR之前就清除中断，这样在ISR过程中发生的中断能够被各寄存器再次记录并通知CPU；如果在ISR过程中，这个中断并不能发生或者可以丢弃，则在调用ISR后清除中断。<br>  清除中断时，从源头开始：首先，需要的话，操作具体外设清除中断信号；其次，清除SUBSRCPND、SRCPND寄存器的相应位（往相应位写1即可）；最后，清除INTPND寄存器的相应位（往相应位写1即可），最简单的方法就是“INTPND&#x3D;INTPND”。</li>
<li>进入、退出中断模式或快速中断模式时，需要保存、恢复被中断程序的运行环境。<br>  ①对于IRQ：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub lr,lr,#4              @计算返回地址</span><br><span class="line">stmdb   sp!,&#123;r0-r12,lr&#125;   @保存使用到的寄存器</span><br><span class="line">... ...                   @处理中断</span><br><span class="line">ldmia   sp!,&#123;r0-r12,pc&#125;   @中断返回</span><br><span class="line">                          @^表示将spsr的值赋值给cpsr</span><br></pre></td></tr></table></figure>
  ②对于FIQ<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sub lr,lr,#4              @计算返回地址</span><br><span class="line">stmdb   sp!,&#123;r0-r7,lr&#125;   @保存使用到的寄存器</span><br><span class="line">... ...                   @处理中断</span><br><span class="line">ldmia   sp!,&#123;r0-r7,pc&#125;   @中断返回</span><br><span class="line">                          @^表示将spsr的值赋值给cpsr</span><br></pre></td></tr></table></figure></li>
<li>根据具体中断，设置相关外设。不比如对于GPIO中断，需要将相应引脚的功能设置为“外部引脚”、设置中断触发条件（低电平出发、高电平触发、下降沿触发还是上升沿触发）等。一些中断拥有自己的屏蔽寄存器，还要开启它。</li>
<li>对于“Request sources （without sub -register）”中的中断，将INTSUBMSK寄存器中相应位设为0。</li>
<li>确定使用此中断的方式：FIQ或IRQ。<br>  ①如果是FIQ，则在INTMOD寄存器中设置相应位为1。<br>  ②如果是IRQ，则在PRIORITY寄存器中设置优先级。</li>
<li>如果是IRQ，将IMTMSK寄存器中相应位设为0（FIQ不受INTMSK寄存器控制）。</li>
<li>设置CPSR寄存器中的I-bit位（IRQ）或者F-bit（对于FIQ）为0，使能IRQ或者FIQ。</li>
</ol>
<h2 id="中断控制器寄存器"><a href="#中断控制器寄存器" class="headerlink" title="中断控制器寄存器"></a>中断控制器寄存器</h2><p>SUBSRCPND、INTSUBMSK这两个寄存器中相同的位对应相同的中断；SRCPND、INTMSK、INTMOD、INTPND这四个寄存器中相同的位对应相同的中断。</p>
<h3 id="SUBSRCPND寄存器（SUB-SOURCE-PENDING）"><a href="#SUBSRCPND寄存器（SUB-SOURCE-PENDING）" class="headerlink" title="SUBSRCPND寄存器（SUB SOURCE PENDING）"></a>SUBSRCPND寄存器（SUB SOURCE PENDING）</h3><p>SUBSRCPND寄存器被用来标识INT_RXD0、INT_TXD0等中断（S3C2410中这类中断有11个，而S3C2440中有15个）受否已经发生，每位对应一个中断。当这些中断发生并且没有被INTSUBSMSK寄存器屏蔽，则它们中的若干位将“汇集”出现在SRCPND寄存器的一位下。比如SUBSRCPND寄存器中的3个中断，INT_RXD0、INT_TXD0、INT_ERR0，只要有一个发生了并且它没有被屏蔽，则SRCPND寄存器中的INT_UART0位被置1。<br>要清除中断时，往SUBSRCPND寄存器中某位写入1即可令此位为0；写入0无效果，数据保持不变。</p>
<h3 id="INTSUBMSK寄存器（INTERRUPT-SUB-MSK）"><a href="#INTSUBMSK寄存器（INTERRUPT-SUB-MSK）" class="headerlink" title="INTSUBMSK寄存器（INTERRUPT SUB MSK）"></a>INTSUBMSK寄存器（INTERRUPT SUB MSK）</h3><p>INTSUBMSK寄存器被用来屏蔽SUBSRCPND寄存器标识的中断。INTSUBMSK寄存器中某位被设为1时，对应的中断被屏蔽。</p>
<h3 id="SRCPND寄存器（SOURCE-PENDING）"><a href="#SRCPND寄存器（SOURCE-PENDING）" class="headerlink" title="SRCPND寄存器（SOURCE PENDING）"></a>SRCPND寄存器（SOURCE PENDING）</h3><p>SRCPND中每一位被用来表示一个（或者一类）中断是否已经发生。例如：</p>
<ol>
<li>使用SUBSRCPND&#x2F;INTSUBMSK控制的中断。</li>
<li>不使用SUBSRCPND&#x2F;INTSUBMSK控制的中断。<br>SRPND寄存器的操作与SUBSRCPND类似，若想清除某一位，往此位写入1。</li>
</ol>
<h3 id="INTMSK-寄存器（INTERRUPT-MASK）"><a href="#INTMSK-寄存器（INTERRUPT-MASK）" class="headerlink" title="INTMSK 寄存器（INTERRUPT MASK）"></a>INTMSK 寄存器（INTERRUPT MASK）</h3><p>INTMSK寄存器被用来屏蔽SRCPND寄存器所标识的中断。INTMSK寄存器中某位被设为1时，对应的中断被屏蔽。<br>INTMSK寄存器只能屏蔽被设为IRQ的中断，不能屏蔽被设为FIQ的中断。</p>
<h3 id="INTMOD-寄存器（INTERRUPT-MODE）"><a href="#INTMOD-寄存器（INTERRUPT-MODE）" class="headerlink" title="INTMOD 寄存器（INTERRUPT MODE）"></a>INTMOD 寄存器（INTERRUPT MODE）</h3><p>当INTMOD寄存器中某位被设为1时，它对应的中断被设为FIQ，即此中断发生时，CPU将进入快速中断模式，这通常用来处理特别紧急的中断。</p>
<h3 id="PRIORITY-寄存器"><a href="#PRIORITY-寄存器" class="headerlink" title="PRIORITY 寄存器"></a>PRIORITY 寄存器</h3><p>上面INTMOD寄存器中，将设为1的中断称为快速中断（FIQ），将其余设为0的中断称为普通中断（IRQ）。<br>当有多个普通中断发生时，中断处理器将选出优先级最高的中断，首先处理它。中断优先级的判选通过7个仲裁器来完成，包括6个以及仲裁器和1个二级仲裁器：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/5.jpeg" alt="img not found"><br>每个仲裁器含6个输入引脚REQ0-REQ5。对于每个仲裁器，PRIORITY寄存器使用三位来控制其行为：一位被用于选择仲裁器工作模式，称为ARB_MODE；两位被用于控制各输入信号的优先级，称为ARB_SEL。<br>ARB_SEL的取值和REQ0-REQ5的优先级如下表所示：</p>
<table>
<thead>
<tr>
<th>ARB_SEL</th>
<th>优先级（从高到低）</th>
</tr>
</thead>
<tbody><tr>
<td>00b</td>
<td>REQ0、REQ1、REQ2、REQ3、REQ4、REQ5</td>
</tr>
<tr>
<td>01b</td>
<td>REQ0、REQ2、REQ3、REQ4、REQ1、REQ5</td>
</tr>
<tr>
<td>10b</td>
<td>REQ0、REQ3、REQ1、REQ1、REQ2、REQ5</td>
</tr>
<tr>
<td>11b</td>
<td>REQ0、REQ4、REQ4、REQ2、REQ3、REQ5</td>
</tr>
</tbody></table>
<p>注：REQ0的优先级永远是最高的、REQ5的优先级永远是最低的。</p>
<p>当某个仲裁器的ARB_MODE位被设为0时，它的ARB_SEL位是不会自动变化的，此时这个仲裁器的6个输入引脚的优先级固定不变（当然，可以通过软件修改ARB_SEL来改变它们的优先级）。当ARB_MODE位被设为1时，ARB_SEL会随着“已经被服务的REQx”（x&#x3D;1~4）自动变化：</p>
<table>
<thead>
<tr>
<th>已经被服务的REQx</th>
<th>ARB_SEL的新值</th>
</tr>
</thead>
<tbody><tr>
<td>REQ0&#x2F;REQ5</td>
<td>维持不变</td>
</tr>
<tr>
<td>REQ1</td>
<td>01b</td>
</tr>
<tr>
<td>REQ2</td>
<td>10b</td>
</tr>
<tr>
<td>REQ3</td>
<td>11b</td>
</tr>
<tr>
<td>REQ4</td>
<td>00b</td>
</tr>
<tr>
<td>结合上表可知：当ARB_MODE为1时，某个REQx（x&#x3D;1~4）被服务之后，它的优先级变为REQ0-REQ4中的最低。</td>
<td></td>
</tr>
<tr>
<td>PRIORITY寄存器中位[0:6]对应这7个仲裁器的ARB_MODE位（位[0]是ARB_MODE0，依此类推），位[7:20]位对应这7个仲裁器的ARB_SEL位（[7:8]是ARB_SEL0，依此类推）。</td>
<td></td>
</tr>
</tbody></table>
<h3 id="INTPND寄存器（INTERRUPT-PENDING）"><a href="#INTPND寄存器（INTERRUPT-PENDING）" class="headerlink" title="INTPND寄存器（INTERRUPT PENDING）"></a>INTPND寄存器（INTERRUPT PENDING）</h3><p>经过中断优先级仲裁器选出的优先级最高的中断后，这个中断在INTPND寄存器中的相应位被置1，随后，CPU将进入中断模式处理它。<br>同一时间内，此寄存器只有一位被置1；在ISR中，可以根据这个位确定是哪个中断。清除中断时，往这个位写1。</p>
<h3 id="INTOFFSET-寄存器（INTERRUPYT-OFFSET）"><a href="#INTOFFSET-寄存器（INTERRUPYT-OFFSET）" class="headerlink" title="INTOFFSET 寄存器（INTERRUPYT OFFSET）"></a>INTOFFSET 寄存器（INTERRUPYT OFFSET）</h3><p>这个寄存器被用来表示INTPND寄存器中哪位被置1了，即INTPND寄存器中位[X]为1时，INTOFFSET寄存器中的值为x（x为0~31）。<br>在清除SRCPND、INTPND寄存器时，INTOFFSET寄存器被自动清除。</p>
<h1 id="中断控制器操作实例：外部中断"><a href="#中断控制器操作实例：外部中断" class="headerlink" title="中断控制器操作实例：外部中断"></a>中断控制器操作实例：外部中断</h1><h2 id="按键中断代码实详解"><a href="#按键中断代码实详解" class="headerlink" title="按键中断代码实详解"></a>按键中断代码实详解</h2><p>开发板上，K1-K4四个按键所接的CPU引脚可以设成外部中断功能。本程序的main函数是一个不做任何事的无限循环，程序的功能完全靠中断来驱动：当按下某个按键时，CPU调用其中断服务程序来点亮对应的LED。</p>
<h3 id="head-S代码详解"><a href="#head-S代码详解" class="headerlink" title="head.S代码详解"></a>head.S代码详解</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line">@******************************************************</span><br><span class="line">@File:head.S</span><br><span class="line">@功能：初始化，设置中断模式、系统模式的栈，设置好中断处理函数</span><br><span class="line">@******************************************************</span><br><span class="line"></span><br><span class="line">.<span class="keyword">extern</span> main</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line"></span><br><span class="line">_start:</span><br><span class="line">@******************************************************</span><br><span class="line">@中断向量，本程序中，除Reset和HandleIRQ外，其他异常都没有使用</span><br><span class="line">@******************************************************</span><br><span class="line">  b Reset</span><br><span class="line"></span><br><span class="line">@<span class="number">0x04</span>：未定义指令终止模式的向量地址</span><br><span class="line">HandleUndef：</span><br><span class="line">  b HandleUndef</span><br><span class="line"></span><br><span class="line">@<span class="number">0x08</span>：管理模式的向量地址，通过SWI指令进入此模式</span><br><span class="line">HandleSWI：</span><br><span class="line">  b HandleSWI</span><br><span class="line"></span><br><span class="line">@<span class="number">0x0c</span>：指令预取终止导致的异常的向量地址</span><br><span class="line">HandlePrefetchAbort：</span><br><span class="line">  b HandlePrefetchAbort</span><br><span class="line"></span><br><span class="line">@<span class="number">0x10</span>：数据访问终止导致的异常的向量地址</span><br><span class="line">HandleDataAbort：</span><br><span class="line">  b HandleDataAbort</span><br><span class="line"></span><br><span class="line">@<span class="number">0x14</span>：保留</span><br><span class="line">HandleNotUsed:</span><br><span class="line">  b HandleNotUsed</span><br><span class="line"></span><br><span class="line">@<span class="number">0x18</span>：中断模式的向量地址</span><br><span class="line">  b HandleIRQ</span><br><span class="line"></span><br><span class="line">@<span class="number">0x1c</span>：快中断模式的向量地址</span><br><span class="line">HandleFIQ：</span><br><span class="line">  b HandleFIQ</span><br></pre></td></tr></table></figure>
<p>上面7行指令所对应的地址为0x00、0x04、…、0x1C，这些地址上的指令称为“异常向量”。当发生各类异常时，CPU进入相应的工作模式，并跳转去执行它的异常向量。比如当复位时，CPU进入系统模式，并跳到0x00地址开始执行；发生中断时，CPU进入中断模式，并跳到地址0x18开始执行。<br>本程序中，只能使用“复位”和“中断”对应的异常向量，其他异常向量没有实际作用。<br>0x00地址处的指令为“b Reset”，在系统复位后，这条指令将跳去执行“Reset”开始的代码，它们完成一些初始化，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Reset:</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置栈指针，以下都是C函数，调用前需要设置好栈</span><br><span class="line">  bl disable_watch_dog    @关闭看门狗，否则CPU会不断重启</span><br><span class="line">  </span><br><span class="line">  msr cpsr_c,#<span class="number">0xd2</span>        @进入中断模式</span><br><span class="line">  ldr sp,=<span class="number">3072</span>            @设置中断模式栈指针</span><br><span class="line"></span><br><span class="line">  msr cpsr_c,#<span class="number">0xdf</span>        @进入系统模式</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置系统模式栈指针</span><br><span class="line">                          @其实复位之后，CPU就处于系统模式</span><br><span class="line">                          @前面的“ldr sp,=<span class="number">4096</span>”完成同样的功能，此句可省略</span><br></pre></td></tr></table></figure>
<p>第5-6行、第8-9行代码的功能相似，前者用于设置中断模式的栈指针，后者用于设置系统模式的栈指针。注意，这是尚未设完成所有初始化，所以还不能开开中断—第5、第8行代码中，CPSR中寄存器的I、F位都被设为1。第6、第9行代码中sp寄存器并不是同一个寄存器，前者为sp_irq、后者为sp_sys。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">bl  init_led                  @初始化LED的GPIO管脚</span><br><span class="line">bl  init_irq                  @调用中断初始化函数，在init.c中</span><br><span class="line">msr cpsr_c, #<span class="number">0x5f</span>             @设置I-bit=<span class="number">0</span>, 开IRQ中断</span><br><span class="line"></span><br><span class="line">ldr lr, =halt_loop            @设置返回地址</span><br><span class="line">ldr pc, =main                 @调用main函数</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">  b halt_loop</span><br></pre></td></tr></table></figure>
<p>第1行调用init_led函数设置LED1-LED4这四个LED的GPIO为输出功能，第2行进行中断管脚的初始化。<br>当完成所有初始化后，第3行将CPSR寄存器中的I位设置为0，开IRQ中断。<br>标号“HandleIRQ”开始的代码用于处理中断。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">HandleIRQ:</span><br><span class="line">  sub lr, lr,#<span class="number">4</span>                         @计算返回地址</span><br><span class="line">  stmdb sp!,  &#123;r0-r12,lr&#125;               @保存使用到的寄存器</span><br><span class="line">                                        @注意，此时的sp是中断模式的sp</span><br><span class="line">                                        @初始值是上面设置的<span class="number">3072</span></span><br><span class="line">  ldr lr, =int_return                   @设置调用ISR即EINT_Handle函数后的返回地址</span><br><span class="line">  ldr pc, =EINT_Handle                  @调用中断服务函数，在interrupt.c中。</span><br><span class="line"></span><br><span class="line">int_return:</span><br><span class="line">  ldmia sp!,  &#123;r0-r12,lr&#125;^              @中断返回,^表示将spsr的值复制到cpsr</span><br></pre></td></tr></table></figure>
<p>第2行计算处理中断处理完毕后的返回地址，lr寄存器的值等于被中断指令的地址加4，所以返回地址为lr的值减去4。<br>第3行用于保存被中断程序的运行环境，即各个寄存器。其中的sp为中断模式的栈，在上面的“ldr sp,&#x3D;3072”中初始化。这样，r0-r12,lr这14个寄存器被保存在中断模式的栈中。<br>第6行用于设置EINT_Handle函数执行完后的返回地址，这个地址为第10行指令的地址。<br>第7行调用中断服务函数EINT_Handle（代码在interrput.c中）。<br>当EINT_Handle函数处理完所发生的中断后，返回第10行的指令。它恢复前面第3行保存的各个寄存器，即恢复被中断程序的运行环境：从栈中恢复r0-r12、pc这14个寄存器的值，同时，将SPSR寄存器的值复制到CPSR（在进入中断模式时，CPU自动将原来的CPSR值保存到SPSR中），这导致CPU切换到原来的工作模式。</p>
<h3 id="init-c中与中断相关的代码详解"><a href="#init-c中与中断相关的代码详解" class="headerlink" title="init.c中与中断相关的代码详解"></a>init.c中与中断相关的代码详解</h3><p>下面详述init_irq函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化GPIO引脚作为外部中断</span></span><br><span class="line"><span class="comment">GPIO引脚用作外部中断时，默认为低电平触发、IRQ方式（不用设置INTMOD）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  GPFCON = GPF0_eint | GPF2_eint;</span><br><span class="line">  GPGCON = GPG3_eint | GPG11_eint;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//对于EINT11、EINT19，需要在EINTMASK寄存器中使能它们。</span></span><br><span class="line">  EINTMASK &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">11</span>)) &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">19</span>));</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  设定优先级：</span></span><br><span class="line"><span class="comment">  ARB_SEL0 = 00b，ARB_MODE0 = 0：REQ1 &gt; REQ3,即EINT0 &gt; EINT2</span></span><br><span class="line"><span class="comment">  仲裁器1、6无需设置</span></span><br><span class="line"><span class="comment">  最终：</span></span><br><span class="line"><span class="comment">  EINT0 &gt; EINT2 &gt; ETIN11、EINT9。即K4 &gt; K3 &gt; K1、K2</span></span><br><span class="line"><span class="comment">  EINT11 和 EINT9优先级相同</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  PRIORITY = (PRIORITY &amp; ((~<span class="number">0x01</span>) | (<span class="number">0x3</span> &lt;&lt; <span class="number">7</span>))) &amp; (<span class="number">0x0</span> &lt;&lt; <span class="number">7</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//EINT0、EINT2、EINT8_23使能</span></span><br><span class="line">  INTMSK  &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">0</span>)) &amp; (~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>)) &amp; (~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7、8行用于设置K1-K4对应的GPIO管脚为中断功能。使用GPIO的中断功能时，还需要确定它们的中断触发模式（低电平触发、高电平触发、下降沿触发、上升沿触发）。我们默认使用低电平触发，无需额外设置。<br>第11行在EINTMASK寄存器中开启EINT19、EINT11中断，它们对应的K1、K2。K3、K4对应的EINT2、EINT10不受EINTMASK寄存器控制。EINTMASK可以屏蔽的中断可以参考数据手册。<br>第21行用于设置中断优先级。本开发板中，外部中断EINT9、EINT11、EINT2和EINT0分别对应K1、K2、K3和K4四个按键。EINT0、EINT2被接到仲裁器0的REQ1、REQ3，程序中设置ARB_SEL0为0（即0b00），所以REQ1的优先级高于REQ3，即K4的优先级高于K3。程序中设置ARB_MODE0为0，所以仲裁器0中各优先级保持不变。EINT8-EINT23共用仲裁器1的REQ1，所以EINT11和EINT9的中断优先级相同。仲裁器0、1的输出接到仲裁器6的REQ0、REQ1，而仲裁器中REQ0的优先级总是高于REQ1，所以这4个按键的优先级：K4 &gt; K3 &gt; K1、K2。<br>本程序使用的GPIO的默认中断方式—IRQ，不是FIQ，所以不用设置INTMOD寄存器。<br>最后，第24行将INTMSK寄存器中EINT0、EINT2、EINT8_23这3个中断对应的位设为0，使能中断。但是仍未完全开启中断，head.S中的“msr cpsr_c, #0x5f”才打开了最后一个开关。</p>
<h3 id="interrupt-c中的中断处理函数"><a href="#interrupt-c中的中断处理函数" class="headerlink" title="interrupt.c中的中断处理函数"></a>interrupt.c中的中断处理函数</h3><p>上面说明了中断的初始化、中断的进入与退出。真正的处理函数为EINT_Handle，它被称为中断服务程序（ISR），代码在interrupt.c中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;s3c24xx.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">EINT_Handle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> oft = INTOFFSET;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> val;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(oft)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//K4被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">0</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |= (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//所有LED灯熄灭</span></span><br><span class="line">      GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);         <span class="comment">//LED4点亮</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//K3被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |= (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//所有LED灯熄灭</span></span><br><span class="line">      GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);         <span class="comment">//LED3点亮</span></span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//K1或K2被被按下  </span></span><br><span class="line">    <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">    &#123;</span><br><span class="line">      GPBDAT  |=  (<span class="number">0x0f</span> &lt;&lt; <span class="number">5</span>);      <span class="comment">//所有LED熄灭</span></span><br><span class="line"></span><br><span class="line">      <span class="comment">//需要进一步判断是K1还是K2被按下，或者K1、K2被同时按下</span></span><br><span class="line">      val = EINTPEND;</span><br><span class="line">      <span class="keyword">if</span>(val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>))</span><br><span class="line">        GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);       <span class="comment">//K2被按下，LED2点亮</span></span><br><span class="line">      <span class="keyword">if</span>(val &amp; (<span class="number">1</span> &lt;&lt; <span class="number">19</span>))</span><br><span class="line">        GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);       <span class="comment">//K1被按下，LED1点亮</span></span><br><span class="line">      </span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//清除中断</span></span><br><span class="line">  <span class="keyword">if</span>(oft == <span class="number">5</span>)</span><br><span class="line">    EINTPEND = (<span class="number">1</span> &lt;&lt; <span class="number">11</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">19</span>);   <span class="comment">//EINT8-EINT23合用IRQ5</span></span><br><span class="line">  SRCPND = <span class="number">1</span> &lt;&lt; oft;</span><br><span class="line">  INTPND = <span class="number">1</span> &lt;&lt; oft;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上代码主要关注中断的识别与清除，其余代码根据所识别出来的中断（按键）点亮对应的LED。第5行用来读取INTOFFSET寄存器，它的值被用来标识INTPND寄存器中哪位被设为1。此值为0是表示INTPND寄存器的位[0]为1，即EINT0中断发生了，说明K4被按下；此值为2时表示INTPND寄存器的位[2]为1，即EINT2中断发生了，说明按键K3被按下；此值为5时表示INTPND寄存器的位[5]为1，即EINT8-EINT23中至少一个中断发生了，在本程序中这表明K1、K2中至少按下了一个，至于是哪一个，需要进一步判断。<br>第27行用来读取EINTPEND寄存器，它的位x为1时，表示EINTx已经发生了（x为4-23）。本程序就是通过读取EINTPEND寄存器的值来进一步判断EINT11还是EINT19发生了，即是K1还是K2按下了。<br>第45行用于清除EINTPEND寄存器，往某位写入1即可清除此位。<br>第46、47行用于清除SRCPND、INTPND寄存器。</p>
<h3 id="主函数"><a href="#主函数" class="headerlink" title="主函数"></a>主函数</h3><p>程序的主函数很简单，在main.c中，只是个不做任何事情的无限循环。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下图演示了代码的运行过程，注意PC和SP寄存器的变化：<br><img src="/2022/08/19/%E4%B8%AD%E6%96%AD%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/6.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第9章 中断体系结构</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>中断</tag>
      </tags>
  </entry>
  <entry>
    <title>系统时钟和定时器</title>
    <url>/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第10章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440的时钟体系结构</li>
<li>掌握通过设置MPLL改变系统时钟的方法</li>
<li>掌握在不同频率下设置存储控制器的方法</li>
<li>掌握PWM定时器的用法</li>
<li>了解WATCHDOG定时器的用法</li>
</ol>
<h1 id="时钟体系以及各类时钟部件"><a href="#时钟体系以及各类时钟部件" class="headerlink" title="时钟体系以及各类时钟部件"></a>时钟体系以及各类时钟部件</h1><h2 id="S3C2410-x2F-S3C2440时钟体系"><a href="#S3C2410-x2F-S3C2440时钟体系" class="headerlink" title="S3C2410&#x2F;S3C2440时钟体系"></a>S3C2410&#x2F;S3C2440时钟体系</h2><p>S3C2410&#x2F;S3C2440的时钟控制逻辑既可以外接晶振，然后通过内部电路产生时钟源；也可以直接使用外部提供的时钟源，它们通过引脚的设置来选择。时钟控制逻辑给整个芯片提供了3种时钟。FCLK用于CPU核，HCLK用于AHB总线上的设备，比如CPU核、存储控制器、中断控制器、LCD控制器、DMA和USB主机模块等，PCLK用于APB总线上的设备，比如WATCHDOG、IIS、IIC、PWM定时器、MMC接口、ADC、UART、GPIO、RTC、SPI。<br>AHB（Advanced High performance Bus）总线主要用于高性能模块（CPU、DMA和DSP等）之间的连接；APB（Advanced Peripheral Bus）总线主要用于低带宽的周边外设之间的连接，例如UART，IIC等。<br>S3C2410核的工作电压为1.8V时，主频可达200MHz；工作电压为2.0V，主频可达266MHz。S3C2440核的工作电压为1.2V时，主频可达300MHz；工作电压为1.3V时，主频可达300MHz。为了降低电磁干扰，降低板间布线的要求，S3C2410&#x2F;S3C2440外接晶振的频率一般很低，本开发板上的为12MHz，需要通过时钟控制逻辑的PLL提高系统时钟。<br>S3C2410&#x2F;S3C2440有两个PLL，MPLL和UPLL。UPLL专用于USB设备，MPLL用于设置FCLK、HCLK、PCLK。它们的设置方式类似。以MPLL为例。<br>上电时，PLL没启动，FCLK即等于外部输入的时钟，称为Fin。若要提高系统时钟，需要软件来启动PLL。结合下图来介绍PLL的设置过程。<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/1.jpeg" alt="img not found"></p>
<ol>
<li>上电几毫秒后，晶振（图中的OSC）输出稳定，FCLK&#x3D;Fin（晶振频率），nRESET信号恢复高电平之后，CPU开始执行指令。</li>
<li>可以在程序开头启动MPLL，设置MPLL的几个寄存器之后，需要等待一段时间（Lock Time），MPLL的输出才稳定。这段时间（Lock Time）内，FCLK停振，CPU停止工作。Lock Time的长短由寄存器LOCKTIME设定。</li>
<li>Lock Time之后，MPLL的输出才稳定，CPU工作在新的FCLK下。</li>
</ol>
<p>FCLK、HCLK、PCLK的比例是可以改变的，设置它们三者的比例，启动MPLL只需要设置3个寄存器。</p>
<ol>
<li>LOCKTIME寄存器（LOCK TIME COUNT），用于设置“Lock Time”的长度。<br>MPLL启动后需要等待一段时间（Lock Time），使得其输出稳定。S3C2410中，位[23:12]用于UPLL，位[11:0]用于MPLL。S3C2440中，位[31:16]用于UPLL，位[15:0]用于MPLL。一般而言。使用它的默认值即可，S3C2410中默认值为0x00FFFFFF，S3C2440中的默认值为0xFFFFFFFF。</li>
<li>MPLLCON寄存器（Main PLL Control），用于设置FCLK与Fin的倍数，<br>位[19:12]的值称为MDIV，位[9:4]的值称为PDIV，位[1:0]的值称为SDIV。FCLK与Fin的关系有如下计算公式：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于S3C2410</span></span><br><span class="line">MPLL（FCLK） = （m*Fin）/(p*<span class="number">2</span>^s)</span><br><span class="line">其中：m = MDIV + <span class="number">8</span>，p = PDIV + <span class="number">2</span>,s = SDIV。</span><br><span class="line"></span><br><span class="line"><span class="comment">//对于S3C2440</span></span><br><span class="line">MPLL（FCLK） = （<span class="number">2</span>*m*Fin）/(p*<span class="number">2</span>^s)</span><br><span class="line">其中：m = MDIV + <span class="number">8</span>，p = PDIV + <span class="number">2</span>,s = SDIV。</span><br></pre></td></tr></table></figure>
设置MPLLCON就相当于之前图中说的“首先使用软件来设置PLL”，Lock Time就被自动插入。Lock Time之后，MPLL输出稳定，CPU工作在新的FCLK下。</li>
<li>CLKDIVN寄存器（CLOCK DIVIDER CONTROL），用于设置FCLK、HCLK、PCLK三者的比例。<br>对于S3C2410、S3C2440这个寄存器表现稍有不同<table>
<thead>
<tr>
<th>CLKDIVN</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HDIVN1</td>
<td>2</td>
<td>0表示保留，1表示FCLK：HCLK：PCLK&#x3D;1：4：4，此时HDIVN、PDIVN必须设为0b00</td>
</tr>
<tr>
<td>HDIVN</td>
<td>1</td>
<td>HCLK的分频系数，0-HCLK&#x3D;FCLK，1-HCLK&#x3D;FCLK&#x2F;2</td>
</tr>
<tr>
<td>PDIVN</td>
<td>0</td>
<td>PCLK的分频系数，0-PCLK&#x3D;HCLK，1-PCLK&#x3D;HCLK&#x2F;2</td>
</tr>
</tbody></table>
</li>
</ol>
<p>对于S3C2440的一些时钟比例，还需要额外设置一个寄存器CAMDIVN。下图中，HDIVN为CLKDIVN寄存器的位[2:1]，PDIVN为位[0]；HCLK4_HALF、HCLK3_HALF分别为CAMDIVN寄存器的位[9]、[8]。各种时钟比例对应的寄存器设置如下图所示：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/2.jpeg" alt="img not found"><br>对于S3C2410，HDIVN是CLKCIVN寄存器的位[1]，对于S3C2440，HDIVN是CLKDIVN寄存器的位[2:1]。如果HDIVN非0，CPU的总线模式应该从“fast bus mode”变为“asynchronous bus mode”，这可以通过如下指令来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#MMU_SetAsyncBusMode</span><br><span class="line">mrc p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br><span class="line">orr r0,r0,#R1_nF:OR:R1_iA</span><br><span class="line">mcr p15,<span class="number">0</span>,r0,c1,c0,<span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>其中的“#R1_nF:OR:R1_iA”等于0xC0000000。如果HDIVN非0时，而CPU的总线模式仍是“fast bus mode”，则CPU的工作频率将自动变为HCLK，而不再是FCLK。</p>
<h2 id="PWM定时器"><a href="#PWM定时器" class="headerlink" title="PWM定时器"></a>PWM定时器</h2><p>S3C2410&#x2F;S3C2440的定时器部件完全一样，共有5个16位的定时器。其中定时器0、1、2、3有PWM（Pulse Width Modulation）功能，即它们都只有一个输出引脚，可以通过定时器来控制引脚周期性的高低电平变化；定时器4没有输出引脚。<br>定时器部件的时钟源为PCLK，首先通过两个8位的预分频器降低频率：定时器0、1共用第一个预分频器，定时器2、3、4共用第一个预分频器。预分频器的输出将进入第二级分频器。它们输出5种频率的时钟，2、4、8、16分频或者外部时钟TCLK0&#x2F;TCLK1。每个定时器的工作时钟可以从这5种频率中选择。<br>两个预分频都可以通过TCFG0寄存器来设置，每个定时器工作在哪个频率下也可以通过TCFG1寄存器来选择。下图形象的说明了定时器的结构：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/3.jpeg" alt="img not found"><br>上面只是确定了定时器的工作频率，至于定时器如何工作还得了解其内部结构。定时器内部控制逻辑的工作流程如下：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/4.jpeg" alt="img not found"></p>
<ol>
<li>程序初始化，设定TCMPBn、TCNTBn这两个寄存器，它们表示定时器n的比较值，初始计数值。</li>
<li>随之设置TCON寄存器启动定时器n，这时，TCMPBn、TCNTBn的值将被装入其内部寄存器TCMPn、TCNTn中。在定时器n的工作频率下，TCNTn开始减1计数，其值可以通过读取TCNTOn寄存器得知。</li>
<li>当TCNTn的值等于TCMPn的值时，定时器n的输出管脚TOUTn反转；TCNTn继续减1计数。</li>
<li>当TCNTn的值到达0时，其输出管脚TOUTn再次反转，并触发定时器n的中断（如果使能了中断的话）。</li>
<li>当TCNTn的值到达0时，如果在TCON寄存器中将定时器n设为自动加载，则TCMPB0和TCNTB0寄存器的值被自动装入TCMP0和TCNT0寄存器中，下一个计数流程开始。<br>定时器n的输出管脚TOUTn初始状态为高电平，以后在TCNTn的值等于TCMPn的值、TCNTn的值时反转。也可以通过TCON寄存器设置其初始电平，这样TOUTn的输出就完全反相了。通过设置TCMPBn、TCNTBn的值可以设置管脚TOUTn输出信号的占空比，这就是所谓的可调制脉冲（PWM），所以这些定时器就可以称为PWM定时器。</li>
</ol>
<p>定时器的寄存器：</p>
<ol>
<li>TCFG0寄存器（TIMER CONTFIGURATION）<br>位[7:0]、位[15:8]分别用来控制预分频器0、1。它们的值为0-255。经过预分频器出来的时钟频率为PCLK&#x2F;{prescaler value + 1}。</li>
<li>TCFG1寄存器（TIMER CONTFIGURATION）<br>经过预分频器的得到的时钟将被2分频、4分频、8分频和16分频，除这4种频率外，额外的，定时器0、1还可以工作在外接的TCLK0时钟下，定时器2、3、4还可以工作在外接的TCLK1时钟下。<br>通过TCFG1寄存器来设置这5个定时器，分别工作于这5个频率的哪一个之下，如下表所示：<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/4.jpeg" alt="img not found"><br>这样，定时器n的工作频率或者是外接的TCLK0或TCLK1可通过这个公式进行计算：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">定时器工作频率 = PCLK / &#123;presacaler value + 1&#125; / &#123;divider value&#125;</span><br><span class="line">&#123;prescaler value&#125; = 0-255</span><br><span class="line">&#123;divider value&#125; = 2,4,8,16</span><br></pre></td></tr></table></figure></li>
<li>TCNTBn&#x2F;TCMPBn寄存器（COUNT BUFFER REGISTER &amp; COMPARE BUFFER REGISTER）<br>n为0-4，这四个寄存器都只用到位[15:0],TCNTBn中保存定时器的初始计数值，TCMPBn中保存比较值。它们的值在启动定时器时，被传到定时器内部寄存器TCNTn、TCMPn中。<br>没有TCMPB4因为定时器4没有输出引脚。</li>
<li>TCNTOn寄存器（COUNT OBSERVATION）。<br>n为0-4，定时器n被启动后，内部寄存器TCNTn在其工作时钟下不断减1计数，可以通过读取TCNTOn寄存器得知其值。</li>
<li>TCON寄存器（TIMER CONTROL）。<br>它有以下4个作用:<ol>
<li>第一次启动定时器时“手动”将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中。</li>
<li>启动、停止定时器。</li>
<li>决定在定时器计数到达0时是否自动将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中。</li>
<li>决定定时器的管脚TOUTn的输出电平是否反转。<br>TCON寄存器位[3:0]、位[11:8]、位[15:12]、位[19:16]、位[22:20]分别用于定时器0-4。除定时器因为没有输出引脚在没有“输出反转”位外，其他位的功能相似，下表以定时器0为例说明这些寄存器：<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>位置</th>
</tr>
</thead>
<tbody><tr>
<td>开启&#x2F;停止</td>
<td>0</td>
<td>0：停止定时器  1：开启定时器</td>
</tr>
<tr>
<td>手动更新</td>
<td>1</td>
<td>0：无用  1：将TCNTBn&#x2F;TCMPBn寄存器的值装入内部寄存器TCNTn、TCMPn中</td>
</tr>
<tr>
<td>输出反转</td>
<td>2</td>
<td>0：TOUT0不反转  1：TOUT0反转</td>
</tr>
<tr>
<td>自动加载</td>
<td>3</td>
<td>0：不自动加载   1：在定时器计数达到0时，TCNTBn&#x2F;TCMPBn寄存器的值自动装入内部寄存器TCNTn、TCMPn中</td>
</tr>
</tbody></table>
</li>
</ol>
</li>
</ol>
<p>第一次使用定时器时，需要设置“手动更新”位为1以使TCNTBn&#x2F;TCMPBn寄存器的值装入TCNTn、TCMPn中。下一次如果还要设置这一位，需要先将它清0。</p>
<h2 id="WATCHDOG-定时器"><a href="#WATCHDOG-定时器" class="headerlink" title="WATCHDOG 定时器"></a>WATCHDOG 定时器</h2><p>WATCHDOG定时器可以像一般16位定时器一样用于产生周期性的中断，也可以用于发出复位信号以重启失常的系统。它与PWM定时器结构类似。<br><img src="/2022/08/23/%E7%B3%BB%E7%BB%9F%E6%97%B6%E9%92%9F%E5%92%8C%E5%AE%9A%E6%97%B6%E5%99%A8/6.jpeg" alt="img not found"><br>同样的，WATCHDOG定时器的8位预分频器将PCLK分频后，将再次分频得到4种频率。16、32、64、128分频。WATCHDOG 定时器可以选择工作于哪种频率之下。WTCNT寄存器按照其工作频率减1计数，当达到0时，可以产生中断信号，可以输出复位信号。在第一次使用WATCHDOG 定时器时，需要往WTCNT寄存器中写入初始计数值，以后在计数值达到0时自动从WATDAT寄存器中装入，重新开始下一个计数周期。<br>使用WATCHDOG 定时器的“WATCHDOG 功能”时，在正常的程序中，必须不断重新设置WTCNT寄存器使得它不为0，这样可以保证系统不被重启，称为“喂狗”。当程序崩溃时不能正常喂狗，计数值达到0后系统将被重启，这样程序将程序运行。为了克服各种干扰、避免各类系统错误时系统彻底死机，经常使用WATCHDOG 功能。<br>WATCHDOG 定时器涉及到的寄存器如下：</p>
<ol>
<li>WTCON寄存器（WATCHDOG TIMER CONTROL）<br>用于设置预分频系数，选择各种频率，决定是否使能中断，是否启用WATCHDOG 功能（即是否输出复位信号）。<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>WATCHDOG功能</td>
<td>0</td>
<td>当定时器达到0时，0：不输出复位信号  1：输出复位信号</td>
</tr>
<tr>
<td>中断使能</td>
<td>1</td>
<td>0：禁止中断  1：使能中断</td>
</tr>
<tr>
<td>时钟选择</td>
<td>[4:3]</td>
<td>选择分频系数  0b00：16  0b01：32 0b10：64 0b11：128</td>
</tr>
<tr>
<td>定时器启动</td>
<td>5</td>
<td>0：停止  1：启动</td>
</tr>
<tr>
<td>预分频系数</td>
<td>[15:8]</td>
<td>预分频系数：0-255</td>
</tr>
</tbody></table>
</li>
</ol>
<p>与PWM定时器相似，WATDOG定时器的工作频率可以通过这公式计算：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">WATDOG定时器工作频率=PCLK/&#123;presacler value + 1&#125;/&#123;divider value&#125;</span><br><span class="line">&#123;prescaler value&#125; = 0-255</span><br><span class="line">&#123;divider value&#125; = 16,32,64,128</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>WTDAT寄存器（WATCHDOG TIMER DATA）<br>WTDAT寄存器被用来决定WATCHDOG定时器的超时周期，在定时器启动后，当计数达到0时，WTDAT寄存器的值会自动传入WTCNT寄存器。不过，第一次启动WATCHDOG定时器时，WTDAT寄存器的值会自动传入WTCNT寄存器。</li>
<li>WTCNT寄存器（WATCHDOG TIMER COUNT）<br>在启动WATCHDOG前，必须往这个寄存器写入初始计数值。启动定时器后，它减1计数，当计数值达到0时：如果中断被使能的话发出中断，如果WATCHDOG功能被使能的话就发出复位信号，装载WTDAT寄存器的值并重新计数。</li>
</ol>
<h1 id="MPLL和定时器操作实例"><a href="#MPLL和定时器操作实例" class="headerlink" title="MPLL和定时器操作实例"></a>MPLL和定时器操作实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例讲解MPLL、定时器的使用。首先启动MPLL提高系统时钟，初始化存储控制器使SDRAM工作在新的HCLK下，然后将定时器0设为0.5s产生一次中断，在中断程序里改变LED的状态。</p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><p>4个关键点：设置&#x2F;启动MPLL、根据HCLK设置存储控制器、初始化定时器0、定时器中断。</p>
<h3 id="设置-x2F-启动MPLL"><a href="#设置-x2F-启动MPLL" class="headerlink" title="设置&#x2F;启动MPLL"></a>设置&#x2F;启动MPLL</h3><p>clock_init函数用于设置MPLL，本开发板的输入时钟频率Fin为12MHz，将FCLK、HCLK、PCLK分别设为200MHz、100MHz和50MHz。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_MPLL_200MHZ ((0x5C &lt;&lt; 12) | (0x04 &lt;&lt; 4) | (0x00))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_MPLL_200MHZ ((0x5C &lt;&lt; 12) | (0x01 &lt;&lt; 4) | (0x02))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">对于MPLLCON寄存器，[19:12]为MDIV，[9:4]为PDIV，[1:0]为SDIV</span></span><br><span class="line"><span class="comment">有如下计算公式：</span></span><br><span class="line"><span class="comment">S3C2410：MPLL（FCLK） = （m*Fin）/ (p*2^s)</span></span><br><span class="line"><span class="comment">S3C2440：MPLL（FCLK） = （2*m*Fin）/ (p*2^s)</span></span><br><span class="line"><span class="comment">其中 m = MDIV + 8，p = PDIV + 2,s = SDIV。</span></span><br><span class="line"><span class="comment">本开发板Fin = 12MHz</span></span><br><span class="line"><span class="comment">设置CLKDIVN，令分频比为FCLK：HCLK：PCLK=1：2：4</span></span><br><span class="line"><span class="comment">FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">clock_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// LOCKTIME = 0x00ffffff;                   //使用默认值即可</span></span><br><span class="line">    CLKDIVN = <span class="number">0x03</span>;                             <span class="comment">//FCLK：HCLK：PCLK=1：2：4  HDIVN = 1,PDIVN = 1</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果HDIVN非0，CPU的总线模式应该从“fast bus mode”变为“asynchronous bus mode”</span></span><br><span class="line">    __asm__(</span><br><span class="line">        <span class="string">&quot;mrc p15,0,r1,c1,c0,0\n&quot;</span>                <span class="comment">//读出控制寄存器</span></span><br><span class="line">        <span class="string">&quot;orr r1,r1,#0xc0000000\n&quot;</span>               <span class="comment">//设置为“asynchronous bus mode”</span></span><br><span class="line">        <span class="string">&quot;mcr p15,0,r1,c1,c0,0\n&quot;</span>                <span class="comment">//写入控制寄存器</span></span><br><span class="line">    ); </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//判断是S3C2410还是S3C2440</span></span><br><span class="line">    <span class="keyword">if</span>((GSTATUS1 == <span class="number">0x3241000</span>) || (GSTATUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        MPLLCON = S3C2410_MPLL_200MHZ;          <span class="comment">//FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        MPLLCON = S3C2440_MPLL_200MHZ;          <span class="comment">//FCLK = 200MHz，HCLK = 100MHz，PCLK = 50MHz</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第17行设置FCLK、HCLK、PCLK三者分频比为1：2：4。<br>当HDIVN非0时，需要将CPU总线模式从“fast bus mode”设为“asynchronous bus mode”，第21-23行的汇编代码即完成此事。<br>第27-34行代码判断芯片是S3C2410还是S3C2440，它们的MPLL计算公式稍有不同，需要区分开来。如果处理器为S3C2410，使用第29行设置MPLL寄存器，令MDIV&#x3D;0x5C，PDIV&#x3D;0x04，SDIV&#x3D;0，所以</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MPLL(FCLK)=(m * Fin)/(p * 2 ^ s) = (0x5c + 8)*12MHz / ((0x04+2)*2^0) = 200MHz</span><br><span class="line">HCLK = FCLK / 2 = 100MHz</span><br><span class="line">PCLK = FCLK / 4 = 50MHz</span><br></pre></td></tr></table></figure>
<p>类似的，S3C2440的FCLK &#x3D; 200MHz，HCLK &#x3D; 100MHz，PCLK &#x3D; 50MHz。</p>
<h3 id="设置存储控制器"><a href="#设置存储控制器" class="headerlink" title="设置存储控制器"></a>设置存储控制器</h3><p>memsetup函数被用来设置存储控制器，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用存储控制器以使用SDRAM</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memsetup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)MEM_CTL_BASE;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个函数之所以这样赋值，而不是像前面的实验（MMU）那样将配置值写在数组中，是因为要生成位置无关的代码，使得这个函数可以被复制到SDRAM之前就可以在Steppingstone中运行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*存储控制器13个寄存器的值*/</span></span><br><span class="line">    p[<span class="number">0</span>] = <span class="number">0x22011110</span>;                  <span class="comment">//BWSCON</span></span><br><span class="line">    p[<span class="number">1</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON0</span></span><br><span class="line">    p[<span class="number">2</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON1</span></span><br><span class="line">    p[<span class="number">3</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON2</span></span><br><span class="line">    p[<span class="number">4</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON3</span></span><br><span class="line">    p[<span class="number">5</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON4</span></span><br><span class="line">    p[<span class="number">6</span>] = <span class="number">0x00000070</span>;                  <span class="comment">//BANKCON5</span></span><br><span class="line">    p[<span class="number">7</span>] = <span class="number">0x00018005</span>;                  <span class="comment">//BANKCON6</span></span><br><span class="line">    p[<span class="number">8</span>] = <span class="number">0x00018005</span>;                  <span class="comment">//BANKCON7</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    REFRESH,</span></span><br><span class="line"><span class="comment">    HCLK = 12MHz:0x008C07A3</span></span><br><span class="line"><span class="comment">    HCLK = 100MHz:0x008C04F4</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    p[<span class="number">9</span>] = <span class="number">0x008C04F4</span>;                  </span><br><span class="line">    p[<span class="number">10</span>] = <span class="number">0x000000B1</span>;                  <span class="comment">//BANKSIZE</span></span><br><span class="line">    p[<span class="number">11</span>] = <span class="number">0x00018030</span>;                  <span class="comment">//MRSRB6</span></span><br><span class="line">    p[<span class="number">12</span>] = <span class="number">0x00018030</span>;                  <span class="comment">//MRSRB7</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在HCLK的值等于100MHz，REFRESH寄存器的值需要重新计算。<br>R_CNT &#x3D; 2^11 + 1 - 100MHz * 7.8125μS &#x3D; 0x04F4，所以REFRESH &#x3D; 0x008C0000 + R_CNT &#x3D; 0x008C0000 + 0x04F4 &#x3D; 0x008C04F4。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">REFRESH = 0x008c0000 + R_CNT</span><br><span class="line">R_CNT = 2 ^ 11 + 1 - SDRAM时钟频率（MHz） * SDRAM刷新周期（μS）</span><br></pre></td></tr></table></figure>
<p>对于第12到第20行为何用这么笨拙的方式设置存储控制器的13个寄存器，在连接脚本timer.lds中，全部代码的起始运行地址都被设为0x30000000，但是在执行memsetup函数时，代码仍在SRAM（Steppingstone）中，为了能够在Steppingstone中运行这个函数，它应该是位置无关的代码，而第12到第20行得手工赋值可以达到这个要求。</p>
<h3 id="初始化定时器0"><a href="#初始化定时器0" class="headerlink" title="初始化定时器0"></a>初始化定时器0</h3><p>tiemr0_init函数用于初始化定时器0，根据相关寄存器的格式并参考代码中的注释就可以理解这个函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Timer input clock Frequence = PCLK / &#123;prescaler value + 1&#125;/&#123;divider value&#125;</span></span><br><span class="line"><span class="comment">&#123;prescaler value&#125; = 0-255</span></span><br><span class="line"><span class="comment">&#123;divider value&#125; = 2,4,8,16</span></span><br><span class="line"><span class="comment">本实验的Timer0的时钟频率=100MHz/(99 + 1)/(16) = 62500Hz</span></span><br><span class="line"><span class="comment">设置Timer0 0.5s触发一次中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">timer0_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TCFG0 = <span class="number">99</span>;                 <span class="comment">//预分频器0 = 99</span></span><br><span class="line">    TCFG1 = <span class="number">0x03</span>;               <span class="comment">//选择16分频</span></span><br><span class="line">    TCNB0 = <span class="number">31250</span>;              <span class="comment">//0.5s触发一次中断</span></span><br><span class="line">    TCON |= (<span class="number">1</span> &lt;&lt; <span class="number">1</span>);           <span class="comment">//手动更新</span></span><br><span class="line">    TCON = <span class="number">0x09</span>;                <span class="comment">//自动加载，清除“手动更新位”，启动定时器0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="定时器中断"><a href="#定时器中断" class="headerlink" title="定时器中断"></a>定时器中断</h3><p>head.S中调用timer0_init函数之后，定时器0即开始工作；调用init_irq函数使能定时器0中断，设置CPSR寄存器开启IRQ中断之后，每当定时器0达到0就会触发中断。init_irq函数很简单，在init.c中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">定时器0中断使能</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_irq</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//定时器0中断使能</span></span><br><span class="line">    INTMSK &amp;= (~(<span class="number">1</span> &lt;&lt; <span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>发生定时器中断时，CPU将调用其中断服务程序Timer0_Handle,它在interrupt.c中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Timer0_Handle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    每次中断令4个LED改变状态</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(INTOFFSET == <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        GPBDAT = ~(GPBDAT &amp; (<span class="number">0xf</span> &lt;&lt; <span class="number">5</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//清除中断</span></span><br><span class="line">    SRCPND = <span class="number">1</span> &lt;&lt; INTOFFSET;</span><br><span class="line">    INTPND = INTPND;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器0的中断使用SRCPND、INTPND寄存器中的位10来表示。中断服务程序Timer0_Handle先判断是否定时器0的中断，若是则反转4个LED的状态。</p>
<h3 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h3><p>编译生成的bin文件烧入NAND Flash后，上电运行，即可看到4个LED每1S闪烁一次。<br>将head.S中对clock_init函数的调用去掉，不启用MPLL，并随之将init.c中的memesetup函数的REFRESH寄存器改为12MHz对应的0x008C07A3。重新编译、烧写。可以看到差不多8S这4个LED才闪烁一次。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第10章 系统时钟和定时器</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>时钟</tag>
      </tags>
  </entry>
  <entry>
    <title>IIC</title>
    <url>/2022/08/25/IIC/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第12章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解IIC总线协议</li>
<li>掌握S3C2410&#x2F;S3C2440中IIC的使用方法</li>
</ol>
<h1 id="IIC总线协议及硬件介绍"><a href="#IIC总线协议及硬件介绍" class="headerlink" title="IIC总线协议及硬件介绍"></a>IIC总线协议及硬件介绍</h1><h2 id="IIC总线协议"><a href="#IIC总线协议" class="headerlink" title="IIC总线协议"></a>IIC总线协议</h2><h3 id="IIC总线的概念"><a href="#IIC总线的概念" class="headerlink" title="IIC总线的概念"></a>IIC总线的概念</h3><p>IIC（Inter-Integrated Circuit）总线是一种由PHILIPS公司开发的串行总线，用于连接微控制器及其外围设备。</p>
<ol>
<li>只有两条总线线路：一条串行数据线（SDA），一条串行时钟线（SCL）。</li>
<li>每个连接到总线的器件都可以使用软件根据它的唯一地址来识别。</li>
<li>传输数据的设备间是简单的主从关系。</li>
<li>主机可以用作主机发送器或主机接收器。</li>
<li>它是一个真正的多主机总线，两个或多个主机同时发起数据传输时，可以通过冲突检测和仲裁来防止数据被破坏。</li>
<li>串行的8位双向数据传输，位速率在标准模式下可达100kbit&#x2F;s，在快速模式下可达400kbit&#x2F;s，在高速模式下可达3.4Mbit&#x2F;s。</li>
<li>片上的滤波器可以增加抗干扰功能，保证数据的完整。</li>
<li>连接到同一总线上的IC数量只受到总线最大电容400pF的限制。</li>
</ol>
<p>下图是一条IIC总线多个设备相连的例子：<br><img src="/2022/08/25/IIC/1.jpeg" alt="img not found"></p>
<p>一些术语如下表：</p>
<table>
<thead>
<tr>
<th>术语</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>发送器</td>
<td>发送数据到总线的器件</td>
</tr>
<tr>
<td>接收器</td>
<td>从总线接收数据的器件</td>
</tr>
<tr>
<td>主机</td>
<td>发起&#x2F;停止数据传输、提供时钟信号的器件</td>
</tr>
<tr>
<td>从机</td>
<td>被主机寻址的器件</td>
</tr>
<tr>
<td>多主机</td>
<td>可以有多个主机试图去控制总线，但是不会破坏数据</td>
</tr>
<tr>
<td>仲裁</td>
<td>当多个主机试图去控制总线时，通过仲裁可以使得只有一个主机获得总线控制权，并且它传输的信息不会被破坏</td>
</tr>
<tr>
<td>同步</td>
<td>多个器件同步时钟信号的过程</td>
</tr>
</tbody></table>
<h3 id="IIC总线的信号类型"><a href="#IIC总线的信号类型" class="headerlink" title="IIC总线的信号类型"></a>IIC总线的信号类型</h3><p>IIC总线在传送数据的过程中共有3种类型信号：开始信号、结束信号和响应信号。</p>
<ol>
<li>开始信号（S）：SCL为高电平时，SDA由高电平向低电平跳变，开始传送数据。</li>
<li>结束信号（P）：SCL为高电平时，SDA由低电平向高电平跳变，结束传送数据。</li>
<li>响应信号（ACk）：接收器在接收到8位数据之后，在第9个时钟周期，拉低SDA电平。</li>
</ol>
<p>它们的波形如下图：<br><img src="/2022/08/25/IIC/2.jpeg" alt="img not found"></p>
<p>SDA上传输的数据必须在SCL为高电平期间保持稳定，SDA上的数据只能在SCL为低电平期间变化，如下图所示：<br><img src="/2022/08/25/IIC/3.jpeg" alt="img not found"></p>
<h3 id="IIC总线的数据传输格式"><a href="#IIC总线的数据传输格式" class="headerlink" title="IIC总线的数据传输格式"></a>IIC总线的数据传输格式</h3><p>发送到SDA线上的每个字节必须是8位的，每次传输可以发送的字节数量不受限制。每个字节后必须跟一个响应位。首先传输的是数据的最高位。如果从机要完成一些其他功能后（例如一个内部中断程序）才能继续接收或发送下一个字节，从机可以拉低SCL迫使主机进入等待状态。当从机准备好接收下一个数据并释放SCL后，数据继续传输。如果主机在传输数据期间也需要完成一些其他功能（例如一个内部中断程序）也可以拉低SCL以占住总线。<br>启动一个传输时，主机发出S信号，然后发出8位数据。这8位数据中前7位为从机的地址，第8位表示传输的方向（0表示写操作，1表示读操作）。被选中的从机发出响应信号。紧接着传输一系列字节及其响应位。最后，主机发出P信号结束本次传输。<br>下图是IIC数据传输的3种类型读、写、读写转换：<br><img src="/2022/08/25/IIC/4.jpeg" alt="img not found"></p>
<p>并非每传输8位之后就会由ACK信号，以下3种例外：</p>
<ol>
<li>当主机不能响应从机地址时（例如它正忙着其他事情而无法响应IIC总线的操作，或者这个地址没有对应的主机），在第9个SCL周期内SDA线没有被拉低，即没有ACK信号。这时，主机发出一个P信号终止传输或者重新发出一个S信号开始新的传输。</li>
<li>如果从机接收器在传输过程中不能接收更多数据时，它也不会发出ACK信号。这样，主机就可以意识到这点，从而发出一个P信号终止传输或者重新发出一个S信号开始新的传输。</li>
<li>主机接收器在接收到最后一个字节后，也不会发出ACK信号，于是，从机发送器释放SDA线，以允许主机发出P信号结束传输。</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-IIC-总线控制器"><a href="#S3C2410-x2F-S3C2440-IIC-总线控制器" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线控制器"></a>S3C2410&#x2F;S3C2440 IIC 总线控制器</h2><h3 id="S3C2410-x2F-S3C2440-IIC-总线控制器介绍"><a href="#S3C2410-x2F-S3C2440-IIC-总线控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线控制器介绍"></a>S3C2410&#x2F;S3C2440 IIC 总线控制器介绍</h3><p>S3C2410&#x2F;S3C2440 IIC 接口有4种工作模式：主机发送器、主机接收器、从机发送器、从机接收器。其内部结构如下图所示：<br><img src="/2022/08/25/IIC/5.jpeg" alt="img not found"><br>S3C2410&#x2F;S3C2440提供4个寄存器来完成所有的IIC操作，SDA线上的数据从IICDS寄存器发出，或传入IICDS寄存器中；IICADD寄存器中保存S3C2410&#x2F;S3C2440当作从机的地址：IICCON、IICSTAT两个寄存器用来控制或标识各种各种状态，比如选择工作模式，发出S信号，P信号，决定是否发出ACK信号，检测是否收到ACK信号。寄存器的用法如下：</p>
<ol>
<li>IICCON寄存器（Multi-master IIC-bus control）<br>IICCON寄存器用于控制是否发出ACK信号、设置发送器的时钟、开启IIC中断，并标识中断是否发生。<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ACK信号使能</td>
<td>[7]</td>
<td>0 &#x3D; 禁止 1 &#x3D; 使能 <br> 在发送模式，此位无意义 <br> 在接收模式，此位使能时，SDA线在响应周期内将被拉低，即发出ACK信号</td>
</tr>
<tr>
<td>发送模式时钟源选择</td>
<td>[6]</td>
<td>0 &#x3D; IICCLK 为PCLK&#x2F;6，1 &#x3D; IICCLK为PCLK&#x2F;512</td>
</tr>
<tr>
<td>发送&#x2F;接收中断使能</td>
<td>[5]</td>
<td>0 &#x3D; IIC总线 Tx&#x2F;Rx中断使能 <br> 1 &#x3D; IIC总线 Tx&#x2F;Rx中断使能</td>
</tr>
<tr>
<td>中断标记</td>
<td>[4]</td>
<td>此位用来标识是否有IIC中断发生，读出为0时表示没有中断发生，读出为1时表示有中断发生。当此位为1时，SCL线被拉低，此时所有IIC传输停止：如果需要继续传输，需写入0清除它</td>
</tr>
<tr>
<td>发生模式时钟分频系数</td>
<td>[3:0]</td>
<td>发送器时钟&#x3D;IICCLK&#x2F;(IICCON[3:0] + 1)</td>
</tr>
</tbody></table>
</li>
</ol>
<p>使用IICCON寄存器时，有如下注意事项：<br>①发送模式的时钟频率由位[6]、位[3:0]联合决定。另外，当IICCON[6]&#x3D;0时，IICCON[3:0]不能取0或1。<br>②IIC中断在以下3种情况下发生：当发出地址信息或者接收到一个从机地址并且吻合时，当总线仲裁失败时，当发送&#x2F;接收完一个字节的数据（包括ACK）时。<br>③基于SDA、SCL线上时间特性的考虑，要发送数据时，先将数据写入IICDS寄存器，然后再清除中断。<br>④如果IICCON[5] &#x3D; 0，IICCON[4]将不能正常工作。所以，即使不使用IIC中断，也要将IICCON[5]设为1。</p>
<ol start="2">
<li><p>IICSTAT（Multi-master IIC-bus control&#x2F;status）<br>IICSTAT寄存器用于选择IIC接口的工作模式，发出S信号、P信号，使能接收&#x2F;发送功能，并标识各种状态，比如总线仲裁是否成功、作为从机是否被寻址、是否接受到0地址、是否接收到ACK信号等。<br>IICSTAT寄存器的各位表示如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>工作模式</td>
<td>[7:6]</td>
<td>0b00：从机接收器 <br> 0b01：从机发送器 <br> 0b10：从机接收器 <br> 0b11：从机发送器</td>
</tr>
<tr>
<td>忙状态位&#x2F;S信号、P信号</td>
<td>[5]</td>
<td>读此位时0：总线空闲，1：总线忙 <br> 写此位时0：发出P信号，1：发出S信号。当发出S信号后，IICDS寄存器中的数据将被自动发送。</td>
</tr>
<tr>
<td>串行输出使能位</td>
<td>[4]</td>
<td>0：禁止接收&#x2F;发送功能，1：使能接收&#x2F;发送功能</td>
</tr>
<tr>
<td>仲裁状态</td>
<td>[3]</td>
<td>0：总线仲裁成功 1：总线仲裁失败</td>
</tr>
<tr>
<td>从机地址状态</td>
<td>[2]</td>
<td>作为从机时，在检测到S&#x2F;P信号时此位被自动清0 <br> 接收到的地址与IICADD寄存器中的值相等时，此位被置1</td>
</tr>
<tr>
<td>0地址状态</td>
<td>[1]</td>
<td>在检测到S&#x2F;P信号时此位被自动清0 <br> 接收到的地址为0b0000000时，此位被置1</td>
</tr>
<tr>
<td>最后一位的状态</td>
<td>[0]</td>
<td>0：接收到的最后一位为0（接收到ACK信号） <br> 1：接收到的最后一位为1 （没有接受到ACK信号）</td>
</tr>
</tbody></table>
</li>
<li><p>IICADD寄存器（Multi-master IIC-bus address）<br>用到IICADD寄存器的位[7:1]，表示从机地址。IICADD寄存器在串行输出使能位IICSTAT[4]为0时，才可以写入；在任何时间都可以读出。</p>
</li>
<li><p>IICDS寄存器（Multi-master IIC-bus Tx&#x2F;Rx data shift）<br>用到IICDS寄存器的位[7:0]，其中保存的是要发送或已经接受的数据。IICDS寄存器在串行输出使能位IICSTAT[4]为1时，才可以写入；在任何时候都可以读出。</p>
</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440-IIC-总线操作方法"><a href="#S3C2410-x2F-S3C2440-IIC-总线操作方法" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 总线操作方法"></a>S3C2410&#x2F;S3C2440 IIC 总线操作方法</h3><p>启动或恢复S3C2410&#x2F;S3C2440 的IIC传输有以下两种方法：</p>
<ol>
<li>当IICCON[4]即中断状态位为0时，通过写IICSTAT寄存器启动IIC操作，有以下两种情况：<br>①在主机模式，令IICSTAT[5:4]等于0b11，将发出S信号和IICDS寄存器的数据（寻址），令IICSTAT[5:4]等于0b01，将发出P信号。<br>②在从机模式，令IICSTAT[4]等于1将等待其他主机发出S信号及地址信息。</li>
<li>当IICCON[4]即中断位为1时，表示IIC操作被暂停。在这期间设置好其他寄存器之后，向IICCON[4]中写入0即可恢复IIC操作。所谓“设置其他寄存器”，有以下3种情况。<br>①对于主机模式，可以按照上面①的方法写IICSTAT寄存器，恢复IIC操作后即可发出S信号和IICDS寄存器的值（寻址），或者发出P信号。<br>②对于发送器，可以将下一个要发送的数据写入IICDS寄存器中，恢复IIC操作后即可发出这个数据。<br>③对于接收器，可以从IICDS寄存器中读出接收到的数据。最后向IICCON[4]写入0的同时，设置IICCON[7]以决定在接收到下一个数据后是否发出ACK信号。</li>
</ol>
<p>通过中断服务程序来驱动IIC传输。</p>
<ol>
<li>当仲裁失败时发生中断—本次传输没有抢到总线，可以稍后继续。</li>
<li>对于主机模式，当发出S信号、地址信息并经过一个SCL周期（对于ACK信号）后，发生中断—主机可在此时判断是否成功寻址到从机。</li>
<li>对于从机模式，当接收到的地址与IICADD寄存器吻合时，先发出ACK信号，然后发生中断—从机可在此时准备后续的传输。</li>
<li>对于发送器，当发送完一个数据并经过一个SCL周期（对于ACK信号）后，发生中断。这是可以准备下一个要发送的数据，或者发送P信号以停止传输。</li>
<li>对于接收器，当接收到一个数据时，先根据IICCON[7]决定是否发出ACK信号后，然后发生中断。这时可以读取IICDS寄存器得到数据，并设置IICCON[7]以决定接收到下一个数据后是否发出ACK信号。</li>
</ol>
<p>对于4种工作模式，S3C2410&#x2F;S3C2440数据手册中都有它们的操作流程图。现在以主机发送器作为例子说明，它的工作流程如图所示：<br><img src="/2022/08/25/IIC/6.jpeg" alt="img not found"></p>
<ol>
<li>配置主机发送器的各类参数。<br>设置GPE15、GPE14引脚用于SDA、SCL，设置IICCON寄存器选择IIC发送时钟，最后设置IICSTAT[4]为1。这样，后面才能写IICDS寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips：初始时IICCON[4]为0，不能将IICSTAT设为主机模式，否则就会立刻发出S信号，发送IICDS寄存器的值。</span><br></pre></td></tr></table></figure></li>
<li>将要寻址的从机地址写入IICDS寄存器。</li>
<li>将0xF0写入IICSTAT寄存器，即设为主机发送器、使能串行输出功能、发出S信号。</li>
<li>发出S信号后，步骤2中设置的IICDS寄存器值也将被发出，它用来寻址从机。</li>
<li>在响应周期之后，发生中断，此时IICCON[4]为1，IIC传输暂停。</li>
<li>如果没有数据要发送，则跳到步骤10，否则跳到步骤7。</li>
<li>将下一个要发送的数据写入IICDS寄存器中。</li>
<li>往IICCON[4]中写入0，恢复IIC传输。</li>
<li>这时IICDS寄存器中的值将被一位一位地发送出去。当8位数据发送完毕，在经过另一个SCL周期（对应ACK信号）后，中断再次发生，跳到步骤5。</li>
<li>将0xF0写入IICSTAT寄存器，即：设为主机发送器、使能串行输出功能、发出P信号。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Tips：这时的P信号并没有实际发出，只有清除了IICCON[4]后才会发出P信号。</span><br></pre></td></tr></table></figure></li>
<li>清除IICCON[4]，P信号得以发出。</li>
<li>等待一段时间，使得P信号完全发出。</li>
</ol>
<h1 id="IIC总线操作实例"><a href="#IIC总线操作实例" class="headerlink" title="IIC总线操作实例"></a>IIC总线操作实例</h1><h2 id="IIC接口RTC芯片M41t11的操作方法"><a href="#IIC接口RTC芯片M41t11的操作方法" class="headerlink" title="IIC接口RTC芯片M41t11的操作方法"></a>IIC接口RTC芯片M41t11的操作方法</h2><p>本书所用的开发板中，通过IIC总线连接RTC（实时时钟）芯片的M41t11，它使用电池供电，系统断电时也可以维持日期和时间。S3C2410&#x2F;S3C2440作为IIC主机向M41t11发送数据以设置日期和时间、读取M41t11以获得日期和时间。连接图如下图所示：<br><img src="/2022/08/25/IIC/7.jpeg" alt="img not found"><br>M41t11中有8个寄存器，分别对应秒、分、时、天、日、月、年、控制寄存器，其中的数据都是以BCD格式保存（0x15表示数值15），如下表所示：<br><img src="/2022/08/25/IIC/8.jpeg" alt="img not found"><br>除上表的8个寄存器（地址为0-7）之外，M41t11内部还有56字节的RAM（地址为8-63）。访问M41t11前，先设置寄存器地址，以后每次读写操作完成后，M41t11内部会自动将寄存器地址加1。<br>所以读写M41t11分为以下两个步骤：</p>
<ol>
<li>主机向M41t11发出要操作的寄存器地址（0-7）。</li>
<li>要设置M41t11时，主机连续发出数据；要读取M41t11时，主机连续读取数据。M41t11的IIC从机地址为0xD0。</li>
</ol>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例将在串口上输出一个菜单，可以选择设置时间和日期，或者将它们读出来。将通过本实例验证IIC主机的发送、接收操作。</p>
<h2 id="设置-x2F-读取M41t11的源码详解"><a href="#设置-x2F-读取M41t11的源码详解" class="headerlink" title="设置&#x2F;读取M41t11的源码详解"></a>设置&#x2F;读取M41t11的源码详解</h2><p>文件i2c.c封装了S3C2410&#x2F;S3C2440作为主机发送器、主机接收器的4个操作函数：i2c_init用于初始化，i2c_write用于发起发送数据，i2c_read用于发起读取数据，I2CHandle是IIC中断服务程序，它用于完成后续的数据传输。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC控制器初始化"><a href="#S3C2410-x2F-S3C2440-IIC控制器初始化" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC控制器初始化"></a>S3C2410&#x2F;S3C2440 IIC控制器初始化</h3><p>i2c_init函数对应于图12.7的步骤1，它用来初始化IIC，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IIC初始化</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPEUP |= <span class="number">0xc000</span>;                <span class="comment">//禁止内部上拉</span></span><br><span class="line">    GPECON  |=  <span class="number">0xa0000000</span>;         <span class="comment">//选择引脚功能，GPE15：IICSDA  GPE14：IICSCL</span></span><br><span class="line"></span><br><span class="line">    INTMSK  &amp;=  ~(BIT_IIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    bit[7]=1，使能ACK</span></span><br><span class="line"><span class="comment">    bit[6]=0，IICCLK=PCLK/16</span></span><br><span class="line"><span class="comment">    bit[5]=1，使能中断</span></span><br><span class="line"><span class="comment">    bit[3:0] = 0xf，Tx clock = IICCLK/16</span></span><br><span class="line"><span class="comment">    PCLK = 50MHz，IICCLK = 3.125MHz，Tx Clock = 0.195MHz</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    IICCON = (<span class="number">1</span> &lt;&lt; <span class="number">7</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">6</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">5</span>) | (<span class="number">0xf</span>);        <span class="comment">//0xaf</span></span><br><span class="line"></span><br><span class="line">    ICCADD = <span class="number">0x10</span>;                                          <span class="comment">// S3C24xx slave address = [7:1]</span></span><br><span class="line">    IICSTAT = <span class="number">0x10</span>;                                         <span class="comment">// IIC串行输出使能（Rx/Tx）</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6、7行代码将GPE15、GPE14的功能选择用于IIC：IICSDA、IICSCL。<br>第9行在INTMSK寄存器中开启IIC中断，这样，以后调用i2c_read、i2c_write启动传输时，即可以触发中断，进而可以在中断服务程序中进一步完成后续传输。<br>第19行用于选择发送时钟，并进行一些设置：使能ACK、使能中断。<br>第21行用于设置S3C2410&#x2F;S3C2440作为IIC从机时的地址。<br>第22行使能IIC串行输出（设置IICSTAT[4]为1），这样，在i2c_write、i2c_read函数中就可以写IICDS寄存器了。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-主机发送函数"><a href="#S3C2410-x2F-S3C2440-IIC-主机发送函数" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 主机发送函数"></a>S3C2410&#x2F;S3C2440 IIC 主机发送函数</h3><p>初始化完成后，就可以调用i2c_read、i2c_write函数读写IIC从机了。它们的使用方法从参数名称中可以看出。这两个函数仅仅是启动IIC传输，然后等待，直到数据在中断服务程序中传输完毕后再返回。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主机发送</span></span><br><span class="line"><span class="comment">slvAddr：从机地址，buf：数据存放的缓冲区，len：数据长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_write</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slvaddr,<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tS3C24xx_IIC.Mode         = WRDATA;           <span class="comment">//写操作</span></span><br><span class="line">    g_tS3C24xx_IIC.Pt           = <span class="number">0</span>;                <span class="comment">//索引初始值为0</span></span><br><span class="line">    g_tS3C24xx_IIC.pData        = buf;              <span class="comment">//保存缓冲区地址</span></span><br><span class="line">    g_tS3C24xx_IIC.DataCount    = len;              <span class="comment">//传输长度</span></span><br><span class="line"></span><br><span class="line">    IICDS   = slvAddr;</span><br><span class="line">    IICSTAT = <span class="number">0xf0</span>;                                 <span class="comment">//主机发送，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*等待直至数据发送完毕*/</span></span><br><span class="line">    <span class="keyword">while</span>(g_tS3C24xx_IIC.DataCount != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7-10行用于设置全局变量g_tS3C24xx_IIC，它表明当前是写操作，并保存缓冲区地址、要传送数据的长度，将缓冲区索引值初始化为0。<br>第12行将从机地址写入IICDS寄存器，这样，再第13行启动传输并发出S信号后，紧接着就自动发出从机地址。<br>第13行设置IICSTAT寄存器，将S3C2410&#x2F;S3C2440设为主机发送器，并发出S信号。后续的传输工作将在中断服务程序中完成。<br>第16行等待g_tS3C24xx_IIC.DataCount在中断服务程序中被设为-1，这表明传输完成，于是返回。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-主机接收函数"><a href="#S3C2410-x2F-S3C2440-IIC-主机接收函数" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 主机接收函数"></a>S3C2410&#x2F;S3C2440 IIC 主机接收函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">主机接收</span></span><br><span class="line"><span class="comment">slvAddr：从机地址，buf：数据存放的缓冲区，len：数据长度</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">i2c_read</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> slvAddr,<span class="type">unsigned</span> <span class="type">char</span> *buf,<span class="type">int</span> len)</span></span><br><span class="line">&#123;</span><br><span class="line">    g_tS3C24xx_IIC.Mode         = RDDATA;                   <span class="comment">//读操作</span></span><br><span class="line">    g_tS3C24xx_IIC.Pt           = <span class="number">-1</span>;                       <span class="comment">//索引值初始化为-1，表示第一个中断时不接受数据（地址中断）</span></span><br><span class="line">    g_tS3C24xx_IIC.pData        = buf;                      <span class="comment">//保存缓冲区地址</span></span><br><span class="line">    g_tS3C24xx_IIC.DataCount    = len;                      <span class="comment">//传输长度</span></span><br><span class="line"></span><br><span class="line">    IICDS = slvAddr;</span><br><span class="line">    IICSTAT = <span class="number">0xb0</span>;                                         <span class="comment">//主机接收，启动</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*等待直至数据传输完毕*/</span></span><br><span class="line">    <span class="keyword">while</span>(g_tS3C24xx_IIC.DataCount != <span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>需要注意的是第8行将索引值设为-1，在中断处理函数中根据这个值决定是否从IICDS寄存器中读取数据。读操作时，第一次中断发生时表示发出了地址，这时候还不能读取数据。</p>
<h3 id="S3C2410-x2F-S3C2440-IIC-中断服务程序"><a href="#S3C2410-x2F-S3C2440-IIC-中断服务程序" class="headerlink" title="S3C2410&#x2F;S3C2440 IIC 中断服务程序"></a>S3C2410&#x2F;S3C2440 IIC 中断服务程序</h3><p>IIC操作的主体在中断服务程序，它分为3部分：首先是在SRCPND、INTPND中清除中断，后面两部分分别对应于写操作、读操作。先看清除中断的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">IIC中断服务程序</span></span><br><span class="line"><span class="comment">根据剩余的数据长度选择继续传输或者结束</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">I2CIntHandle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> iicSt,i;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清中断</span></span><br><span class="line">    SRCPND = BIT_IIC;</span><br><span class="line">    INTPND = BIT_IIC;</span><br><span class="line"></span><br><span class="line">    iicSt = IICSTAT;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(iicSt &amp; <span class="number">0x8</span>) &#123;<span class="built_in">printf</span>(<span class="string">&quot;Bus arbitration failed\n\r&quot;</span>);&#125;         <span class="comment">//仲裁失败</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第10、11行用来清除IIC中断的代码。需要注意的是，即使清除中断之后，IICCON寄存器中的位[4]（中断标志位）仍为1，这导致IIC传输暂停。<br>第13行读取状态寄存器IICSTAT,发生中断时有可能因为仲裁失败，在第15行对它进行处理。<br>接下来一个swicth语句，分别处理读、写操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(g_tS3C24xx_IIC.Mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> WRDATA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((g_tS3C24xx_IIC.DataCount--) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//下面两行用来恢复IIC操作，发出P信号</span></span><br><span class="line">            IICSTAT = <span class="number">0xd0</span>;</span><br><span class="line">            IICCON = <span class="number">0xaf</span>;</span><br><span class="line">            Delay(<span class="number">10000</span>);   <span class="comment">//等待一段时间以便P信号发出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        IICDS = g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++];</span><br><span class="line"></span><br><span class="line">        <span class="comment">//将数据写入IICDS后，需要一段时间才能出现在SDA线上</span></span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">10</span>;i++)</span><br><span class="line"></span><br><span class="line">        IICCON = <span class="number">0xaf</span>;          <span class="comment">//恢复IIC传输</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>g_tS3C24xx_IIC.DataCount表示剩余等待传输的数据个数，第4行判断数据是否已经全部发送完毕：若是，则通过第7、8行发出P信号，停止传输。<br>第7行设置IICSTAT寄存器以便发出P信号，但是由于这时IICCON[4]仍为1，P信号还没有实际发出。当8行清除IICCON[4]后，P信号才真正发出。第9行等待一段时间，确保P信号已经发送完毕。<br>如果数据还没有发送完毕，第12行从缓冲区得到下一个要发送的数据，将它写入IICDS寄存器中。稍加等待之后，即可在第17行清除IICCON[4]以恢复IIC传输，这时，IICDS寄存器中的数据就会发送出去，这将触发下一个中断。<br>IIC的读操作代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(g_tS3C24xx_IIC.Mode)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> RDDATA:</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(g_tS3C24xx_IIC.Pt == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//这次中断是在发送IIC设备地址后发生的，没有数据</span></span><br><span class="line">            <span class="comment">//只接收一个数据时，不要发出ACK信号</span></span><br><span class="line">            g_tS3C24xx_IIC.Pt = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(g_tS3C24xx_IIC.DataCount == <span class="number">1</span>)</span><br><span class="line">                IICCON = <span class="number">0x2f</span>;      <span class="comment">//恢复IIC传输，开始接收数据，接收数据时不发出ACK</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                IICCON = <span class="number">0xaf</span>;      <span class="comment">//恢复IIC传输，开始接收数据</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>((g_tS3C24xx_IIC.DataCount--) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++] = IICDS;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//下面两行用来恢复IIC操作，发出P信号</span></span><br><span class="line">            IICSTAT = <span class="number">0x90</span>;</span><br><span class="line">            IICCON = <span class="number">0xaf</span>;</span><br><span class="line">            Delay(<span class="number">10000</span>);   <span class="comment">//等待一段时间以便P信号发出</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        g_tS3C24xx_IIC.pData[g_tS3C24xx_IIC.Pt++] = IICDS;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//接收最后一个数据时，不要发出ACK信号</span></span><br><span class="line">        <span class="keyword">if</span>(g_tS3C24xx_IIC.DataCount == <span class="number">0</span>)</span><br><span class="line">            IICCON = <span class="number">0x2f</span>;          <span class="comment">//恢复IIC传输，接收到下一数据时无ACK</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            IICCON = <span class="number">0xaf</span>;          <span class="comment">//恢复IIC传输，接收到下一数据时发出ACK</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>读操作比写操作多了一个步骤：第一次中断发生时表示发出了地址，这时候还不能读取数据，在代码中要分辨这点。对应第5-15行：如果g_tS3C24xx_IIC.P等于-1，表示这是第一次中断，然后修改g_tS3C24xx_IIC.Pt为0，并设置IICCON寄存器恢复IIC传输（第10-14行）。<br>当数据传输开始后，每接收到一个数据就会触发一次中断。后面的代码读取数据，判断所有的数据是否已经完成：如果完成就发出P信号，否则就继续下一次传输。<br>第17行判断数据是否已经全部接收完毕：若是，先通过第19行将当前数据从IICDS寄存器中取出存入缓冲区，然后通过22、23行发出P信号停止传输。<br>第22行设置IICSTAT寄存器以便发出P信号，但是由于这时IICCON[4]仍为1，P信号没有实际发出。第23行清除IICCON[4]后，P信号才真正发出。第24行等待一段时间，确保P信号已经发送完毕。<br>第28-25用来启动下一个数据的接收。<br>第28行将当前数据从IICDS寄存器中取出存入缓存区中。<br>第31-35行判断是否只剩下最后一个数据了：若是，就通过第32行中清除IICCON[4]、IICCON[7]，这样即可恢复IIC传输，并使得接收到数据后，S3C2410&#x2F;S3C2440不发出ACK信号（这样从机即可知道数据传输完毕）；否则，在第34行中只要清除IICCON[4]以恢复IIC传输。<br>中断服务程序中，当数据传输完毕时，g_tS3C24xx_IIC.DataCount将自减为-1，这样，i2c_read或i2c_write函数即可跳出等待，直接返回。</p>
<h3 id="RTC芯片M41t11特性相关的操作"><a href="#RTC芯片M41t11特性相关的操作" class="headerlink" title="RTC芯片M41t11特性相关的操作"></a>RTC芯片M41t11特性相关的操作</h3><p>M41t11.c文件中提供两个函数M41t11_set_datetime、M41t11_get_datetime，前者用来设置日期和时间，后者用来读取日期与时间。它们都通过调用i2c_read或i2c_write函数来完成与M41t11的交互。<br>前面说过，操作M41t11只需要两个步骤：发出寄存器地址，发出数据或读出数据。M41t11_set_datetime函数把这两个步骤合为一个IIC写操作。M41t11_get_datetime函数先发起一个IIC写传输，再发起一个IIC读传输。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">写M41t11、设置日期与时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">M41t11_set_datetime</span><span class="params">(<span class="keyword">struct</span> rtc_time *dt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> leap_yr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">char</span> addr;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rtc_registers</span> <span class="title">rtc</span>;</span></span><br><span class="line">    &#125;__attribute__((packed)) addr_and_regs;</span><br><span class="line">    ... ... <span class="comment">/*设置rtc结构，即根据传入的参数构造各寄存器的值*/</span></span><br><span class="line">    i2c_write(<span class="number">0xD0</span>,(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;addr_and_regs,<span class="keyword">sizeof</span>(addr_and_regs));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>省略号表示的代码用来设置addr_and_regs结构。这个结构分为两部分：addr_and_regs.addr表示M41t11寄存器地址（它被设为0），addr_and_regs.rtc表示M41t11的8个寄存器。<br>根据传入的参数填充好addr_and_regs结构之后，就可以启动IIC写操作了。“<strong>attribute</strong>((packed))”设置这个结构体为紧凑格式，使得它的大小为9Byte（否则按照内存对齐的规则为12Byte）：1个字节用来保存寄存器地址，8个字节用来保存8个寄存器的值。<br>第12行发起一次IIC写操作，将addr_and_regs结构中的数据发送给M41t11：M41t11会把接收到的第一个数据当作寄存器的起始地址，随后是要写入寄存器的数据。<br>M41t11_get_datetime函数的代码与M41t11_set_datetime函数类似，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">读取M41t11，获取日期与时间</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">M41t11_get_datetime</span><span class="params">(<span class="keyword">struct</span> rtc_time *dt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> addr[<span class="number">1</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rtc_registers</span> <span class="title">rtc</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;rtc,<span class="number">0</span>,<span class="keyword">sizeof</span>(rtc));</span><br><span class="line"></span><br><span class="line">    i2c_write(<span class="number">0xD0</span>,addr,<span class="number">1</span>);</span><br><span class="line">    i2c_read(<span class="number">0xD0</span>,(<span class="type">unsigned</span> <span class="type">char</span> *)&amp;rtc,<span class="keyword">sizeof</span>(rtc));</span><br><span class="line"></span><br><span class="line">    ... ...<span class="comment">/*根据读出的各寄存器的值，设置dr结构*/</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第12行发起一次IIC写传输，设置要操作的M41t11寄存器地址为0。<br>第13行发起一次IIC读传输，读出M41t11各寄存器的值。<br>省略号对应的代码根据读出的各寄存器的值，设置dr结构。M41t11下中以BCD码表示日期与时间，需要转换为程序使用的一般二进制格式。</p>
<h2 id="IIC实例的连接脚本"><a href="#IIC实例的连接脚本" class="headerlink" title="IIC实例的连接脚本"></a>IIC实例的连接脚本</h2><p>本实例要用到第8章NAND Flash控制器的函数将代码从NAND Flash复制到SDRAM中。由于nand代码中用到了全局变量，而全局变量要运行于可读写的内存中，为了方便，使用连接脚本将这些初始化代码放在Steppingstone中。<br>连接脚本为i2c.lds,内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS&#123;</span><br><span class="line">    . = <span class="number">0x00000000</span>;</span><br><span class="line">    .init : AT(<span class="number">0</span>) &#123;head.o init.o nand.o&#125;</span><br><span class="line">    . = <span class="number">0x30000000</span>;</span><br><span class="line">    .text : AT(<span class="number">4096</span>) &#123; *(.text) &#125;</span><br><span class="line">    .rodata <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span> : <span class="title function_">AT</span><span class="params">((LOADADDR(.text) + SIZEOF(.text) + <span class="number">3</span>) &amp;~ (<span class="number">0x03</span>))</span> &#123; *(.rodata*) &#125; </span><br><span class="line">    .data <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>  : <span class="title function_">AT</span><span class="params">((LOADADDR(.rodata) + SIZEOF(.rodata) + <span class="number">3</span>) &amp;~ (<span class="number">0x03</span>))</span> &#123; *(.data) &#125;</span><br><span class="line">    __bss_start = .;</span><br><span class="line">    .bss <span class="title function_">ALIGN</span><span class="params">(<span class="number">4</span>)</span>   : &#123;*(.bss) *(COMMON) &#125;</span><br><span class="line">    __bss_end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2-3行将head.S、init.c和nand.c对应的代码的运行地址设为0，加载地址（存在NAND Flash上的地址）设为0。从NAND Flash启动时，这些代码被复制到Steppingstone后就可以直接运行。<br>第4行设置其余代码的运行地址为0x3000000；第5行将代码段的加载地址设为4096，表示代码段将存在NAND Flash地址4096处。<br>第6-7行的“AT(…)”设置rodata段，data段的加载地址依次位于代码段之后。“LOADADDR(…)”表示某段的加载地址，“SIZEOF(…)”表示它的大小。这两行的前面使用“ALIGN(4)”使得它们的运行地址为4字节对齐，为了使各段之间加载地址的相对偏移值等于运行地址的相对偏移值，需要将“AT(…)”中的值也设为4字节对齐：先加上3，然后与~(0x03)进行与操作（将低2位设为0）。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第12章 IIC</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>IIC总线</tag>
      </tags>
  </entry>
  <entry>
    <title>ADC和TP接口</title>
    <url>/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第14章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440 ADC和触摸屏的结构</li>
<li>了解电阻触摸屏的工作原理和等效电路图</li>
<li>了解S3C2410&#x2F;S3C2440触摸屏控制器的多种工作方式</li>
<li>掌握S3C2410&#x2F;S3C2440 ADC和触摸屏的编程方法</li>
</ol>
<h1 id="ADC和触摸屏硬件介绍和使用"><a href="#ADC和触摸屏硬件介绍和使用" class="headerlink" title="ADC和触摸屏硬件介绍和使用"></a>ADC和触摸屏硬件介绍和使用</h1><h2 id="S3C2410-x2F-S3C2440-ADC和触摸屏接口概述"><a href="#S3C2410-x2F-S3C2440-ADC和触摸屏接口概述" class="headerlink" title="S3C2410&#x2F;S3C2440 ADC和触摸屏接口概述"></a>S3C2410&#x2F;S3C2440 ADC和触摸屏接口概述</h2><p>S3C2410&#x2F;S3C2440 的CMOS模数转换器（ADC，Analog to Digital Converter）可以接收8个通道的模拟信号输入，并将它们转换为10位的二进制数据。在2.5MHz的A&#x2F;D转换时钟下，最大的转换速率可达500KSPS（samples per second，每秒采样的次数）。<br>S3C2410&#x2F;S3C2440 都提供触摸屏的接口，不过有所不同。S3C2410的触摸屏接口向外提供4个控制信号引脚（nYPON、YMON、nXPON、XMON）和2个模拟信号输入引脚（AIN[7]、AIN[5]）。这6个引脚通过4个晶体管与触摸屏的4个引脚相连。而S3C2440提供了与触摸屏直接相连的4个引脚，不在需要外接晶体管。<br>S3C2410&#x2F;S3C2440 ADC和触摸屏接口有如下特性：</p>
<ol>
<li>分辨率：10位</li>
<li>微分线性度误差：±1.0LSB</li>
<li>积分线性度误差：±2.0LSB</li>
<li>最大转换功率：500KSPS</li>
<li>低功耗</li>
<li>供电电压：3.3V</li>
<li>输入模拟电压范围：0-3.3V</li>
<li>片上采样保持功能</li>
<li>普通转换模式</li>
<li>分离的x&#x2F;y轴坐标转换模式</li>
<li>自动（连续）x&#x2F;y轴坐标转换模式</li>
<li>等待中断模式</li>
</ol>
<p>ADC和触摸屏接口结构如图所示：<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/1.jpeg" alt="img not found"><br>从上图可以知道，ADC和触摸屏接口中只有一个A&#x2F;D转换器可以通过设置寄存器来选择对哪路模拟信号（多达8路）进行采样。图中有两个中断信号：INT_ADC、INT_TC，前者表示A&#x2F;D转化器已经转换完毕，后者表示触摸屏被按下了。<br>对于S3C2410，在使用触摸屏时，AIN[7]和AIN[5]被用来测量XP、YP的电平，只剩下AIN[6]、AIN[4:0]共6个引脚被用于一般的ADC输入。对于S3C2440，在使用触摸屏时，引脚XP、XM、YP和YM被用于和触摸屏直接相连，只剩下AIN[3:0]共4个引脚用于一般的ADC输入；当不使用触摸屏时，XP、XM、YP和YM这4个引脚也可以用于一般的ADC输入。<br>S3C2410与触摸屏的连接比S3C2440复杂，需要增加几个外接晶体管，如下图所示：<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/2.jpeg" alt="img not found"></p>
<h2 id="S3C2410-x2F-S3C2440-ADC接口的使用方法"><a href="#S3C2410-x2F-S3C2440-ADC接口的使用方法" class="headerlink" title="S3C2410&#x2F;S3C2440 ADC接口的使用方法"></a>S3C2410&#x2F;S3C2440 ADC接口的使用方法</h2><p>ADC的启动方式有两种：手工启动、读结果时就自动启动下一次转换。也有两种方法获知当前转换是否已经结束：查询状态位、转换结束时就发出中断。<br>ADC的操作只涉及3个寄存器：ADCCON、ADCTSC、ADCDAT0。下面介绍它们的用法，有关触摸屏的数据位将在下面的小节介绍。<br>ADCCON寄存器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>ECFLG</td>
<td>[15]</td>
<td>只读，A&#x2F;D转换结束标志。<br> 0：正在转换。1：转换结束。</td>
</tr>
<tr>
<td>PRSCEN</td>
<td>[14]</td>
<td>决定A&#x2F;D转换器的时钟是否分频。<br> 0：不使用。1：使用。</td>
</tr>
<tr>
<td>PRSCVL</td>
<td>[13:6]</td>
<td>预分频系数，取值0-255：A&#x2F;D时钟 &#x3D; PCLK&#x2F;(PRSCVL + 1)。<br>注意：A&#x2F;D时钟必须小于PCLK的1&#x2F;5。</td>
</tr>
<tr>
<td>SEL_MUX</td>
<td>[5:3]</td>
<td>选择进行A&#x2F;D转换的通道。 <br> 对于S3C2410,取值如下：<br>000：AIN 0； 001：AIN 1；010：AIN 2；011：AIN 3；<br>100：AIN 4；101：AIN 5；110：AIN 6；111：AIN 7（XP）；<br>对于S3C2440，取值如下：<br>000：AIN 0； 001：AIN 1；010：AIN 2；011：AIN 3；<br>100：YM；101：YP；110：XM；111：XP；</td>
</tr>
<tr>
<td>STDBM</td>
<td>[2]</td>
<td>选择静态模式（Standby Mode）。<br>0：正常模式；1：静态模式。</td>
</tr>
<tr>
<td>READ_START</td>
<td>[1]</td>
<td>读转换数据时是否启动下一次转换。<br> 0：不启动；1：启动；</td>
</tr>
<tr>
<td>ENABLE_START</td>
<td>[0]</td>
<td>启动A&#x2F;D转换（当READ_START为1时，此位无效）。<br> 0：无作用；1：启动A&#x2F;D转换（转换真正开始时，此位被清零）。</td>
</tr>
</tbody></table>
<p>ADCDAT0寄存器</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>UPDOWN</td>
<td>[15]</td>
<td>对于触摸屏，使用“等待中断模式”时，<br>0：触摸屏被按下；1：触摸屏没有被按下。</td>
</tr>
<tr>
<td>AUTO_PST</td>
<td>[14]</td>
<td>决定是否使用自动（连续）x&#x2F;y轴坐标转换模式。<br>0：正常转换；1：自动（连续）x&#x2F;y坐标轴转换。</td>
</tr>
<tr>
<td>XY_PST</td>
<td>[13:12]</td>
<td>手动x&#x2F;y轴坐标转换模式。<br>00：无操作；01：x轴坐标转换；<br>10：y轴坐标转换；11：等待中断模式。</td>
</tr>
<tr>
<td>Reserved</td>
<td>[11:10]</td>
<td>保留</td>
</tr>
<tr>
<td>XPDATA（普通ADC转换数据）</td>
<td>[9:0]</td>
<td>x轴坐标转换数据值（或普通ADC转换数据值）<br> 数值范围：0-0x3FF</td>
</tr>
</tbody></table>
<p>ADC的使用分4个步骤：</p>
<ol>
<li>设置ADCCON寄存器，选择信号输入通道，设置A&#x2F;D转换器的时钟。<br>使能A&#x2F;D转化器时钟的预分频功能时，A&#x2F;D时钟的计算公式如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">A/D时钟 = PCLK / (PRSCVL + <span class="number">1</span>)</span><br><span class="line">注：A/D时钟最大为 <span class="number">2.5</span>MHz，并且应该小于PCLK的<span class="number">1</span>/<span class="number">5</span>。</span><br></pre></td></tr></table></figure></li>
<li>设置ADCTSC寄存器，使用设为普通转换模式，不使用触摸屏功能。<br>ADCTSC寄存器多用于触摸屏，对于普通ADC，使用它的默认值即可，或设置其位[2]为0。ADCTSC寄存器的格式在下面的小节介绍。</li>
<li>设置ADCCON寄存器，启用A&#x2F;D转换。<br>如果设置READ_START位，则读转换数据（读ADCDAT0寄存器）时即启动下一次转换；否则，可以通过设置ENABLE_START位来启动A&#x2F;D转换。</li>
<li>转换结束时，读取ADCDAT0寄存器获得数值。<br>如果使用查询方式，则可以不断读取ADCCON寄存器的ECFLG位来确定转换是否结束；否则可以使用INT_ADC中断，发生INT_ADC中断时表示转换结束。</li>
</ol>
<h2 id="触摸屏原理及接口"><a href="#触摸屏原理及接口" class="headerlink" title="触摸屏原理及接口"></a>触摸屏原理及接口</h2><h3 id="电阻触摸屏的原理"><a href="#电阻触摸屏的原理" class="headerlink" title="电阻触摸屏的原理"></a>电阻触摸屏的原理</h3><p>触摸屏已经在现实生活中大量使用，种类也有很多，比如超声波触摸屏、红外触摸屏、电容触摸屏、电阻触摸屏等。电阻触摸屏由于造价低廉，在电气上可以直接接入用户的系统而得到大量使用。电阻触摸屏有几种类型，比如“四线”、“五线”、“八线”。线越多，精度就越高，温度漂移也越少，但是基本的操作是一样的。它本质是个电阻分压器，将矩形区域中的触摸点（x，y）的物理位置转换为代表x坐标和y坐标的电压。<br>S3C2410&#x2F;S3C2440的触摸屏接口可以驱动四线电阻触摸屏，四线电阻触摸屏的等效电路如下图所示:<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/3.jpeg" alt="img not found"><br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/4.jpeg" alt="img not found"><br>图中粗黑线表示相互绝缘的两层导电层，当按压时，它们在触点外相连；不同的触点在x，y方向上的分压值不一样，将这两个电压值经过A&#x2F;D转换后即可得到x，y坐标。下面根据等效电路图说明触摸屏的工作过程。</p>
<ol>
<li>平时触摸屏没有被按下时，等效电路如图14.5所示。<br>S4、S5闭合，S1、S2、S3断开，即YM接地、XP上拉、XP作为模拟输入（对CPU而言）、YP作为模拟输入（对CPU而言）、XM高阻。<br>平时触摸屏没有按下时，由于上拉电阻的关系，Y_ADC为高电平；当x轴和y轴受挤压而接触导通之后，Y_ADC的电压由于联通到y轴接地而变为低电平，此此低电平可作为中断触发信号来通知CPU发生“Pen Down”事件。在S3C2410&#x2F;S3C2440中，称为等待中断模式。</li>
<li>采样X_ADC电压，得到x坐标，等效电路如图14.6所示。<br>S1、S3闭合，S2、S4、S5断开，即XP接上电源、XM接地、YP作为模拟输入（对CPU而言）、YM高阻、XP禁止上拉。这时，YP即X_ADC就是x轴的分压点，进行A&#x2F;D转化后得到x坐标。</li>
<li>采样Y_ADC电压，得到y坐标，等效电路如图14.7所示。<br>S2、S4闭合，S1、S3、S5断开，即YP接上电源、YM接地、XP作为模拟输入（对CPU而言）、XM高阻、XP禁止上拉。这时，XP即Y_ADC就是y轴的分压点，进行A&#x2F;D转换后得到y坐标。</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440触摸屏接口"><a href="#S3C2410-x2F-S3C2440触摸屏接口" class="headerlink" title="S3C2410&#x2F;S3C2440触摸屏接口"></a>S3C2410&#x2F;S3C2440触摸屏接口</h3><p>与上面描述的触摸屏工作过程的3个步骤对应，触摸屏控制器也有4种工作模式。</p>
<ol>
<li>等待中断模式（Waiting for Interrupt Mode）<br>设置ADCTSC寄存器为0xD3即可令触摸屏控制器处于这种模式。这时，它在等待触摸屏按下。当触摸屏被按下时，触摸屏控制器将发出INT_TC中断信号，这时触摸屏控制器要转入以下两种工作模式中的一种，以读取x、y坐标。<br>对于S3C2410，当触摸屏按下或松开的时候，都产生INT_TC中断信号。<br>对于S3C2440，可以设置ADCTSC寄存器的位[8]为0或1时，表示等待Pen Down中断或Pen Up中断。</li>
<li>分离的x&#x2F;y轴坐标转换模式<br>这分别对应上述触摸屏工作过程的第2、3步骤。设置ADCTSC寄存器为0x69进入x轴坐标转换模式，x坐标值转换完毕后被写入ADCDAT0，然后发出INT_ADC中断；相似的，设置ADCTSC寄存器为0x9A进入y轴坐标转换模式，y坐标轴转换完毕后被写入ADCDAT1，然后发出INT_ADC中断。</li>
<li>自动（连续）x&#x2F;y轴坐标转换模式<br>上述触摸屏工作过程的第2、3步骤可以合成一个步骤，设置ADCTSC寄存器值为0x0C，进入自动（连续）x&#x2F;y轴坐标转换模式，触摸屏控制器就会自动转换x、y坐标值，并分别写入ADCDAT0、ADCDAT1寄存器中，然后发出INT_ADC中断。</li>
<li>普通转换模式<br>不使用触摸屏时，触摸屏控制器处于这种模式。在这种模式下，可以通过设置ADCCON寄存器启动普通的A&#x2F;D转换，转换完成时数据被写入ADCDAT0寄存器中。<br>ADCTSC寄存器被用来选择触摸屏的工作模式，下面介绍ADCTSC寄存器。<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Reserved&#x2F;UD_SEN</td>
<td>[8]</td>
<td>对于S3C2410，此位必须为0。<br> 对于S3C2440，此位表示将检测哪类中断（触点按下、触点松开）。<br>0：按下；1：松开。</td>
</tr>
<tr>
<td>YM_SEN</td>
<td>[7]</td>
<td>对于S3C2410，用于选择YMON的输出值。<br>0：YMON输出0（YM：高阻）；1：YMON输出1（YM：GND）<br> 对于S3C2440,YM使能开关。<br>0：YM驱动禁止（高阻）；1：YM驱动使能（接地）</td>
</tr>
<tr>
<td>YP_SEN</td>
<td>[6]</td>
<td>对于S3C2410，用于选择nYPON的输出值。<br>0：nYPON输出0（YP：外部电压）；1：nYPON输出1（YM接AIN[5]）<br> 对于S3C2440,YP使能开关。<br>0：YP驱动禁止（接外部电压）；1：YP驱动使能（接模拟输入）</td>
</tr>
<tr>
<td>XM_SEN</td>
<td>[5]</td>
<td>对于S3C2410，用于选择XMON的输出值。<br>0：XMON输出0（XM：高阻）；1：XMON输出1（XM：GND）<br> 对于S3C2440,XM使能开关。<br>0：XM驱动禁止（高阻）；1：XM驱动使能（接地）</td>
</tr>
<tr>
<td>XP_SEN</td>
<td>[4]</td>
<td>对于S3C2410，用于选择nXPON的输出值。<br>0：nXPON输出0（XP：外部电压）；1：nXPON输出1（XM接AIN[7]）<br> 对于S3C2440,XP使能开关。<br>0：XP驱动禁止（接外部电压）；1：XP驱动使能（接模拟输入）</td>
</tr>
<tr>
<td>PULL_UP</td>
<td>[3]</td>
<td>XP上拉使能。 <br> 0：使能上拉；1：禁止上拉</td>
</tr>
<tr>
<td>AUTO_PST</td>
<td>[2]</td>
<td>是否使用自动（连续）x&#x2F;y轴坐标转换模式。<br>0：普通转换模式 1：自动（连续）x&#x2F;y轴坐标转换模式</td>
</tr>
<tr>
<td>XY_PST</td>
<td>[1:0]</td>
<td>手动测量x、y轴坐标。<br> 00：无操作模式；01：测量x轴坐标；<br>10：测量y轴坐标；11：等待中断模式</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：<br>①处于等待中断模式时，XP_SEN必须设为1（XP接模拟输入），PULL_UP必须设为0（使能上拉）。<br>②AUTO_PST设为1时，必须处于自动（连续）x&#x2F;y轴坐标转换模式下。</p>
<p>对于S3C2410，当触摸控制器处于等待中断模式时，触摸屏被按下时，可以不断发出INT_TC中断信号，以便进入自动（连续）x&#x2F;y轴转换模式转换x、y坐标。发出中断信号的间隔可以通过ADCDLY寄存器来设置。<br>对于S3C2440，当CPU处于休眠模式下，触摸屏被按下时可以不断发出INT_TC中断信号以唤醒CPU。发出中断信号的间隔可以通过ADCDLY寄存器来设置。<br>另外，对于普通转换模式、分离的x&#x2F;y轴坐标转换模式、自动（连续）x&#x2F;y轴坐标转换模式，都可以通过ADCDLY来设置采样的延时时间。<br>ADCDLY寄存器格式如下表所示，在等待中断模式时，延时时钟为X-tal（3.68MHz），其他情况为PCLK。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>DELAY</td>
<td>[15:0]</td>
<td>采样的延时值，或发出中断的间隔值</td>
</tr>
</tbody></table>
<p><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/5.jpeg" alt="img not found"></p>
<p>ADCDAT1寄存器的格式如下表所示。它与ADCDAT0寄存器格式相似，ADCDAT1寄存器中保存y坐标值；而ADCDAT0寄存器中保存普通A&#x2F;D转换的值或x坐标值。</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>UPDOWN</td>
<td>[15]</td>
<td>对于触摸屏，使用“等待中断模式”时如下。<br>0：触摸屏被按下；1：触摸屏没有被按下</td>
</tr>
<tr>
<td>AUTO_PST</td>
<td>[14]</td>
<td>决定是否使用自动（连续）x&#x2F;y坐标转换模式。 <br> 0：正常转换；1：自动（连续）x&#x2F;y轴坐标转换</td>
</tr>
<tr>
<td>XY_PST</td>
<td>[13:12]</td>
<td>手动x&#x2F;y轴坐标转换模式 <br> 00：无操作；01：x轴坐标转换 <br> 10：y轴坐标转换 11：等待中断模式</td>
</tr>
<tr>
<td>Reserved</td>
<td>[11:10]</td>
<td>保留</td>
</tr>
<tr>
<td>YPDATA</td>
<td>[9:0]</td>
<td>x轴坐标转换数据值</td>
</tr>
</tbody></table>
<h1 id="ADC和触摸屏操作实例"><a href="#ADC和触摸屏操作实例" class="headerlink" title="ADC和触摸屏操作实例"></a>ADC和触摸屏操作实例</h1><h2 id="硬件设计"><a href="#硬件设计" class="headerlink" title="硬件设计"></a>硬件设计</h2><p>模拟输入引脚AIN0、AIN1外接可调电阻器，电路图如下图所示：<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/6.jpeg" alt="img not found"><br>图中的两个电阻器是可调电阻器，程序通过AIN0、AIN1这两个通道采集、转换电压值。<br>触摸屏的接口是标准的，它的电路图如图14.4所示。</p>
<h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>测试ADC时，程序不断测量AIN0、AIN1的电压，并在串口上显示出来。测试触摸屏时，只是测试触笔按下、松开的事件，并且把按下时采集到的x、y坐标打印出来，它们只是原始的数据。<br>主要文件为adc_ts.c。主要接口为adc_ts.c中的Test_Adc、Test_Ts函数。</p>
<h2 id="测试ADC的代码详解"><a href="#测试ADC的代码详解" class="headerlink" title="测试ADC的代码详解"></a>测试ADC的代码详解</h2><h3 id="ADC主入口函数Test-Adc"><a href="#ADC主入口函数Test-Adc" class="headerlink" title="ADC主入口函数Test_Adc"></a>ADC主入口函数Test_Adc</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试ADC</span></span><br><span class="line"><span class="comment">通过A/D转换，测量可变电阻器的电压值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_Adc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">float</span> vol0,vol1;</span><br><span class="line">    <span class="type">int</span> t0,t1;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!awaitkay(<span class="number">0</span>))                                     <span class="comment">//串口无输出，则不断测试</span></span><br><span class="line">    &#123;</span><br><span class="line">        vol0 = ((<span class="type">float</span>)ReadAdc(<span class="number">0</span>)*<span class="number">3.3</span>)/<span class="number">1024.0</span>;              <span class="comment">//计算电压值</span></span><br><span class="line">        vol1 = ((<span class="type">float</span>)ReadAdc(<span class="number">1</span>)*<span class="number">3.3</span>)/<span class="number">1024.0</span>               <span class="comment">//计算电压值</span></span><br><span class="line">        t0   = (vol0 - (<span class="type">int</span>)vol0) * <span class="number">1000</span>;                   <span class="comment">//计算小数部分</span></span><br><span class="line">        t1   = (vol1 - (<span class="type">int</span>)vol1) * <span class="number">1000</span>;                   <span class="comment">//计算小数部分</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;AIN0 = %d.%-3dV     AIN1 = %d.%-3dV\r&quot;</span>,(<span class="type">int</span>)vol0,t0,(<span class="type">int</span>)vol1,t1,);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第12、13行先调用ReadAdc函数发起A&#x2F;D转换，返回10位转换值（最大值为1023）；然后计算实际电压值（S3C2410&#x2F;S3C2440模拟信号最大电压3.3V）。</p>
<h3 id="ReadAdc-函数：设置、启动ADC，获取转换结果"><a href="#ReadAdc-函数：设置、启动ADC，获取转换结果" class="headerlink" title="ReadAdc 函数：设置、启动ADC，获取转换结果"></a>ReadAdc 函数：设置、启动ADC，获取转换结果</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用查询方式读取A/D转换值</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    ch：模拟信号通道，取值为0-7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">ReadAdc</span><span class="params">(<span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//使用模拟通道，使能预分频功能，设置A/D转换器的时钟 = PCLK/（49 + 1）</span></span><br><span class="line">    ADCCON = PRESCALE_EN | PRSCVL(<span class="number">49</span>) | ADC_INPUT(ch);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除位[2]，设为普通转换模式</span></span><br><span class="line">    ADCTSC &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">2</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置位[0]为1，启动A/D转换</span></span><br><span class="line">    ADCCON |= ADC_START;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//当A/D转换真正开始时，位[0]会自动清0</span></span><br><span class="line">    <span class="keyword">while</span>(ADCCON &amp; ADC_START);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//检测位[15]，当它为1时表示转换结束</span></span><br><span class="line">    <span class="keyword">while</span>(!(ADCCON &amp; ADC_ENDCVT));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//读取数据</span></span><br><span class="line">    <span class="keyword">return</span> (ADCDAT0 &amp; <span class="number">0x3ff</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>程序流程与前面介绍的ADC的4个步骤一一对应。</p>
<ol>
<li>第10行选择模拟通道，使能预分频功能，设置A&#x2F;D转化器的时钟。<br>本程序中，PCLK为50MHz，所以A&#x2F;D转换器的时钟为50MHz&#x2F;(49 + 1) &#x3D; 1MHz，小于最大A&#x2F;D时钟2.5MHz。</li>
<li>第13行清除ADCTSC寄存器位[2]，设为普通转换模式，ADCTSC寄存器格式上文有表格描述。</li>
<li>第16行设置ADCCON寄存器位[0]，启动A&#x2F;D转换。<br>ADC的启动有两种方式，如果使用“读启动”方式（此时ADCCON寄存器位[1]被设为1），则读一下ADCDAT0寄存器即可启动；如果使用手动方式，设置ADCCON寄存器位[0]即可启动。</li>
<li>第22行循环检测ADCCON的位[15]，直到它为1为止，这表示A&#x2F;D转换结束。<br>也可以使用中断方式，当A&#x2F;D转换结束时，ADC会发出INT_ADC中断信号。</li>
<li>最后，第25行读取ADCDAT0即可得到转换的数据（低10位为有效数据）。</li>
</ol>
<h3 id="测试触摸屏的代码详解"><a href="#测试触摸屏的代码详解" class="headerlink" title="测试触摸屏的代码详解"></a>测试触摸屏的代码详解</h3><p>触摸屏的操作稍微复杂，下面将程序流程图和触摸屏控制的状态转换图合并在一起，以便代码分析。<br><img src="/2022/08/30/ADC%E5%92%8CTP%E6%8E%A5%E5%8F%A3/7.jpeg" alt="img not found"></p>
<h4 id="触摸屏的主入口函数Test-Ts"><a href="#触摸屏的主入口函数Test-Ts" class="headerlink" title="触摸屏的主入口函数Test_Ts"></a>触摸屏的主入口函数Test_Ts</h4><p>Test_Ts函数进行初始化、开启ADC中断之后，就不再参与触摸屏的操作，这都通过中断服务程序来完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">测试触摸屏，打印触点坐标</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_Ts</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    isr_handle_array[ISR_ADC_OFT] = AdcTsIntHandlel;                <span class="comment">//设置中断服务程序</span></span><br><span class="line">    INTMSK &amp;= ~BIT_ADC;                                             <span class="comment">//开启ADC总中断</span></span><br><span class="line">    INTSUBMSK &amp;= ~(BIT_SUB_TC);                                     <span class="comment">//开启INT_TC中断，即触摸屏被按下或松开时产生中断</span></span><br><span class="line">    INTSUBMSK &amp;= ~(BIT_SUB_ADC);                                    <span class="comment">//开启INT_ADC中断，即A/D转换结束时产生中断</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//使能预分频功能，设置A/D转换器的时钟 = PCLK / (49 + 1);</span></span><br><span class="line">    ADCCON = PRESCALE_EN | PRSCVL(<span class="number">49</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    采样延时时间 = (1/3.6864M)*50000 = 13.56ms</span></span><br><span class="line"><span class="comment">    即按下触摸屏后，再过13.56ms才能采样 </span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ADCDLY = <span class="number">50000</span>;</span><br><span class="line"></span><br><span class="line">    wait_down_int();                                                <span class="comment">//进入“等待中断模式”，等待触摸屏按下</span></span><br><span class="line"></span><br><span class="line">    getc();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//屏蔽ADC中断</span></span><br><span class="line">    INTSUBMSK |= BIT_SUB_TC;</span><br><span class="line">    INTSUBMSK |= BIT_SUB_ADC;</span><br><span class="line">    INTMSK |= BIT_ADC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6行设置ADC中断的处理函数，第7-9行开启ADC中断。ADC中断有两类：INT_TC和INT_ADC，前者表示触摸屏被按下或松开，后者表示A&#x2F;D转换结束。<br>第12行使能预分频功能，设置A&#x2F;D转化器的时钟为PCLK&#x2F;（49 + 1）；本程序中，PCLK为50MHz，所以A&#x2F;D转换器的时钟为50MHz&#x2F;(49 + 1) &#x3D; 1MHz，小于最大A&#x2F;D时钟2.5MHz。<br>第18行设置延时时间。<br>第20行调用wait_down_int()宏，令触摸屏控制器进入“等待中断模式”，等待触摸屏被按下。<br>第22行等待串口的输入，以退出测试。等待期间通过中断来驱动触摸屏的操作。<br>第25-28行屏蔽ADC中断。<br>wait_down_int、wait_up_int、mode_auto_xy都是宏定义，它们用于设置触摸屏进入“等待Pen Down中断模式”、“等待Pen Up中断模式”、“自动（连续）x&#x2F;y轴坐标转换模式”。<br>需要注意以下几点：</p>
<ol>
<li>对于S3C2410，ADCTSC的位[8]属于保留位，只能设为0；当处于“等待中断模式”时，无论是“Pen Down”中断还是“Pen Up”中断都可以检测到。</li>
<li>对于S3C2440，ADCTSC的位[8]为0、1时分别表示等待Pen Down中断或者Pen Up中断。</li>
<li>要进入“自动（连续）x&#x2F;y坐标轴坐标转换模式”，XP、XM、YP、YM的状态不必理会，触摸屏在采样时会自动控制它们。</li>
</ol>
<p>上述宏定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置进入等待中断模式，XP_PU、XP_Dis、XM_Dis、YP_Dis、YM_En</span></span><br><span class="line"><span class="comment">1. 对于S3C2410，位[8]只能为0，所以只能使用下面的wait_down_int,它既等待Pen Down中断，也等待Pen Up中断</span></span><br><span class="line"><span class="comment">2. 对于S3C2440，位[8]为0、1时分别表示等待Pen Down中断或Pen Up中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">/*进入“等待中断模式”，等待触摸屏被按下*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_down_int() &#123;   ADCTSC = DOWN_INT | XP_PULL_UP_EN | \</span></span><br><span class="line"><span class="meta">                            XP_AIN | XM_HIZ | YP_AIN | YM_GND | \</span></span><br><span class="line"><span class="meta">                            XP_PST(WAIT_INT_MODE);&#125;</span></span><br><span class="line"><span class="comment">/*进入“等待中断模式”，等待触摸屏被松开*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> wait_up_int() &#123;   ADCTSC = UP_INT | XP_PULL_UP_EN | \</span></span><br><span class="line"><span class="meta">                            XP_AIN | XM_HIZ | YP_AIN | YM_GND | \</span></span><br><span class="line"><span class="meta">                            XP_PST(WAIT_INT_MODE);&#125;</span></span><br><span class="line"><span class="comment">/*进入自动（连续）x/y轴坐标转换模式*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> mode_auto_xy()  &#123;ADCTSC = CONVERT_AUTO | XP_PULL_UP_DIS | XP_PST(NOP_MODE);&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="触摸屏中断处理函数：转换触摸屏的工作模式"><a href="#触摸屏中断处理函数：转换触摸屏的工作模式" class="headerlink" title="触摸屏中断处理函数：转换触摸屏的工作模式"></a>触摸屏中断处理函数：转换触摸屏的工作模式</h4><p>执行Test_Ts函数之后，触摸屏控制器处于“等待Pen Down中断模式”。这时，如果按下触摸屏，则发生INT_TC中断，进入AdcTsIntHandle中断处理函数。它很简单，只是判断当前中断时INT_TC还是INT_ADC，然后分别调用他们的中断服务程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">ADC、触摸屏的中断服务程序</span></span><br><span class="line"><span class="comment">对于INT_TC、INT_ADC中断，分别调用它们的处理程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">AdcTsIntHandle</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(SUBSRCPND &amp; BIT_SUB_TC)</span><br><span class="line">        Isr_Tc();</span><br><span class="line">    <span class="keyword">if</span>(SUBSRCPND &amp; BIT_SUB_ADC)</span><br><span class="line">        Isr_Adc();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>INT_TC的中断服务程序Isr_Tc代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INT_TC的中断服务程序</span></span><br><span class="line"><span class="comment">当触摸屏被按下时，进入自动（连续）x/y轴坐标转换模式</span></span><br><span class="line"><span class="comment">当触摸屏被松开时，进入等待中断模式，再次等待INT_TC中断</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Isr_Tc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(ADCDAT0 &amp; <span class="number">0x8000</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        wait_down_int();                                <span class="comment">//进入“等待中断模式”，等待触摸屏被按下</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        mode_auto_xy();                                 <span class="comment">//进入自动（连续）x/y轴坐标转换模式</span></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置位[0]为1，启动A/D转换</span></span><br><span class="line"><span class="comment">        注意：ADCDLY为50000，PCLK = 50MHz</span></span><br><span class="line"><span class="comment">            要经过（1/50MHz）x 50000 = 1ms 后才开始转换x坐标</span></span><br><span class="line"><span class="comment">            再经过1ms之后才开始转换y坐标</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        ADCCON |= ADC_START;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除INT_TC中断</span></span><br><span class="line">    SUBSRCPND |= BIT_SUB_TC;</span><br><span class="line">    SRCPND |= BIT_ADC;</span><br><span class="line">    INTPND |= BIT_ADC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第7行首先判断是“Pen Down”还是“Pen Up”中断，如果是“Pen Up”中断，表示触摸完成，在第9行通过wait_down_int()宏令触摸屏控制器进入“等待Pen Down中断模式”，等待下一次操作。<br>如果是“Pen Down”中断，则在第13行通过mode_auto_xy()宏令触摸屏控制器进入“自动（连续）x&#x2F;y轴坐标转换模式”，然后在20行启动A&#x2F;D转换。也可以使用“分离的x&#x2F;y轴坐标转换模式”手动的分别转换x坐标、y坐标。<br>第24-26行清除INT_TC中断。</p>
<h4 id="在ADC中断处理函数中获取x、y坐标"><a href="#在ADC中断处理函数中获取x、y坐标" class="headerlink" title="在ADC中断处理函数中获取x、y坐标"></a>在ADC中断处理函数中获取x、y坐标</h4><p>在“自动（连续）x&#x2F;y轴坐标转换模式”下，x、y坐标都转换完毕后，产生INT_ADC中断，进入AdcTsIntHandle中断处理函数，它进而调用INT_ADC的中断服务程序Isr_Adc，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">INT_ADC的中断服务程序</span></span><br><span class="line"><span class="comment">A/D转换结束时发生此中断</span></span><br><span class="line"><span class="comment">先读取x、y坐标值，在进入等待中断模式</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">Isr_Adc</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//打印x、y坐标值</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;xdata = %4d, ydata = %4d\r\n&quot;</span>,(<span class="type">int</span>)(ADCDAT0 &amp; <span class="number">0x3ff</span>),(<span class="type">int</span>)(ADCDAT1 &amp; <span class="number">0x3ff</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断是S3C2410还是S3C2440</span></span><br><span class="line">    <span class="keyword">if</span>((GSTATUS1 == <span class="number">0x32410000</span>) || (GSTATUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//S3C2410</span></span><br><span class="line">        wait_down_int();        <span class="comment">//进入“等待中断模式”，等待触摸屏松开</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//S3C2440</span></span><br><span class="line">        wait_up_int();          <span class="comment">//进入“等待中断模式”，等待触摸屏松开</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//清除INT_ADC中断</span></span><br><span class="line">    SUBSRCPND |= BIT_SUB_ADC;</span><br><span class="line">    SRCPND |= BIT_ADC;</span><br><span class="line">    INTPND |= BIT_ADC;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，第9行从ADCDAT0、ADCDAT1寄存器中读出x、y的值，并打印出来。然后，通过第13（S3C2410）、18（S3C2440）行进入“等待Pen Up中断模式”，等待触摸屏松开。S3C2410的触摸屏控制器既等待Pen Down中断，又等待Pen Up中断；S3C2440的触摸屏控制器可以分开设置：等待被按下或（和）等待被松开。<br>最后，第22-24行清除ADC中断。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第14章 ADC和TP接口</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>ADC数模转化</tag>
        <tag>Touchscreen</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核调试技术</title>
    <url>/2022/09/20/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统移植之Linux内核调试技术</p>
<p>《嵌入式Linux应用完全开发手册》第3篇第18章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>掌握几种调试内核的方法：printk、kgdb、分析Oops、栈回溯</li>
<li>使用调试工具：gdb、ddd</li>
</ol>
<h1 id="内核打印函数printk"><a href="#内核打印函数printk" class="headerlink" title="内核打印函数printk"></a>内核打印函数printk</h1><h2 id="printk的使用"><a href="#printk的使用" class="headerlink" title="printk的使用"></a>printk的使用</h2><h3 id="printk函数的记录级别"><a href="#printk函数的记录级别" class="headerlink" title="printk函数的记录级别"></a>printk函数的记录级别</h3><p>调试内核、驱动最简单的方法，是使用printk函数打印信息。printk函数与用户空间的printf函数格式完全相同，它所打印的字符串头部可以加入“<n>”样式的字符，其中n为0-7，表示这条信息的记录级别。<br>在内核代码<code>include/linux/kernel.h</code>中，下面几个宏控制了printk函数所能输出的信息的记录级别。</n></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> console_loglevel (console_printk[0])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_message_loglevel (console_printk[1])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> minimun_message_loglevel (console_printk[2])</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> default_console_loglevel (console_printk[3])</span></span><br></pre></td></tr></table></figure>
<p>举例说明这几个宏的含义。<br>①对于printk(“<n>…”)，只有n小于console_loglevel时，这个信息才会被打印。<br>②假设default_message_loglevel的值小于4，如果printk的参数开头没有“<n>”样式的字符，则在printk函数中进一步处理前会自动加上“&lt;4&gt;”；<br>③minimun_console_loglevel是一个预设值，平时不起作用。通过其他工具来设置console_loglevel的值时，这个值不能小于minimun_console_loglevel。<br>④default_console_loglevel也是一个预设值，平时不起作用。它表示设置console_loglevel时的默认值，通过其他工具来设置console_loglevel的值时，会用到这个值。</n></n></p>
<p>minimun_console_loglevel和default_console_loglevel这两个值的作用，可以参考内核源文件<code>kernel/printk.c</code>的<code>do_syslog</code>函数。<br>上面代码中，console_printk是一个数组，它在<code>kernel/printk.c</code>中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* printk&#x27;s without a loglevel use this.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_MESSAGE_LOGLEVEL 4 <span class="comment">/* KERN_WARNING */</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* We show everything that is MORE important than this.. */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MINIMUM_CONSOLE_LOGLEVEL 1 <span class="comment">/* Minimum loglevel we let people use */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DEFAULT_CONSOLE_LOGLEVEL 7 <span class="comment">/* anything MORE serious than KERN_DEBUG */</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">int</span> console_printk[<span class="number">4</span>] = &#123;</span><br><span class="line">	DEFAULT_CONSOLE_LOGLEVEL,	<span class="comment">/* console_loglevel */</span></span><br><span class="line">	DEFAULT_MESSAGE_LOGLEVEL,	<span class="comment">/* default_message_loglevel */</span></span><br><span class="line">	MINIMUM_CONSOLE_LOGLEVEL,	<span class="comment">/* minimum_console_loglevel */</span></span><br><span class="line">	DEFAULT_CONSOLE_LOGLEVEL,	<span class="comment">/* default_console_loglevel */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="在用户空间修改printk函数的记录级别"><a href="#在用户空间修改printk函数的记录级别" class="headerlink" title="在用户空间修改printk函数的记录级别"></a>在用户空间修改printk函数的记录级别</h3><p>挂接proc文件系统后，读取<code>/proc/sys/kernel/printk</code>文件可以得知console_loglevel、default_message_loglevel、minimun_console_loglevel和default_console_loglevel这4个值。<br>比如执行以下命令，它的结果是“7 4 1 7”表示这4个值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/sys/kernel/printk</span><br><span class="line">7   4   1   7</span><br></pre></td></tr></table></figure>
<p>也可以直接修改<code>/proc/sys/kernel/printk</code>文件来改变这4个值，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">echo &quot;1 4 1 7&quot; &gt; /proc/sys/kernel/printk</span><br></pre></td></tr></table></figure>
<p>这使得console_loglevel被改为1，于是所有的printk信息都不会被打印。</p>
<h3 id="printk函数记录级别的名称及使用"><a href="#printk函数记录级别的名称及使用" class="headerlink" title="printk函数记录级别的名称及使用"></a>printk函数记录级别的名称及使用</h3><p>在内核代码<code>include/linux/kernel.h</code>中有如下代码，它们表示0-7这8个记录级别的名称。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_EMERG	<span class="string">&quot;&lt;0&gt;&quot;</span>	<span class="comment">/* system is unusable			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_ALERT	<span class="string">&quot;&lt;1&gt;&quot;</span>	<span class="comment">/* action must be taken immediately	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_CRIT	<span class="string">&quot;&lt;2&gt;&quot;</span>	<span class="comment">/* critical conditions			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_ERR	<span class="string">&quot;&lt;3&gt;&quot;</span>	<span class="comment">/* error conditions			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_WARNING	<span class="string">&quot;&lt;4&gt;&quot;</span>	<span class="comment">/* warning conditions			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_NOTICE	<span class="string">&quot;&lt;5&gt;&quot;</span>	<span class="comment">/* normal but significant condition	*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_INFO	<span class="string">&quot;&lt;6&gt;&quot;</span>	<span class="comment">/* informational			*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>	KERN_DEBUG	<span class="string">&quot;&lt;7&gt;&quot;</span>	<span class="comment">/* debug-level messages			*/</span></span></span><br></pre></td></tr></table></figure>
<p>在使用printk函数时，可以这样使用记录级别；</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk(KERN_WARNING<span class="string">&quot;there is a warning here!\n&quot;</span>);</span><br></pre></td></tr></table></figure>

<h2 id="串口控制台"><a href="#串口控制台" class="headerlink" title="串口控制台"></a>串口控制台</h2><h3 id="串口与printk函数的关系"><a href="#串口与printk函数的关系" class="headerlink" title="串口与printk函数的关系"></a>串口与printk函数的关系</h3><p>在嵌入式Linux开发中，printk信息常常从串口输出，这时串口被称为串口控制台。从内核<code>kernel/printk.c</code>的printk函数开始，往下查看它的调用关系，可以知道printk函数是如何与具体设备的输出函数挂钩的。<br>printk函数调用的子函数的主要脉络如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">printk  -&gt;</span><br><span class="line">    vprintk -&gt;</span><br><span class="line">        emit_log_char   //把要打印的数据写入一个全局缓冲区（log_buf）中</span><br><span class="line">        release_console_sem -&gt;</span><br><span class="line">            call_console_drivers -&gt;</span><br><span class="line">                _call_console_drivers -&gt;</span><br><span class="line">                    __call_console_drivers -&gt;</span><br><span class="line">                        con-&gt;write  //con是console_drivers链表的表项，调用具体的输出函数</span><br></pre></td></tr></table></figure>
<p>对于可以作为控制台的设备，在初始化时会通过register_console函数向console_drivers链表注册一个console结构，里面有write函数指针。<br>以<code>drivers/serial/s3c2410.c</code>文件中的串口初始化函数s3c24xx_serail_initconsole为例，它的部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_serial_initconsole</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	register_console(&amp;s3c24xx_serial_console);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第4行的s3c24xx_serial_console就是console结构，它在相同的文件中定义，部分内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console</span> <span class="title">s3c24xx_serial_console</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">	.name		= S3C24XX_SERIAL_NAME,                  <span class="comment">//这个宏被定义为“SAC”</span></span><br><span class="line">	.device		= uart_console_device,                  <span class="comment">//init进行、用户程序打开/dev/console时用到</span></span><br><span class="line">	.flags		= CON_PRINTBUFFER,                      <span class="comment">//打印先前在log_buf中保存的信息</span></span><br><span class="line">	.index		= <span class="number">-1</span>,                                   <span class="comment">//表示使用哪个串口由命令行决定</span></span><br><span class="line">	.write		= s3c24xx_serial_console_write,         <span class="comment">//串口控制台的输出函数</span></span><br><span class="line">	.setup		= s3c24xx_serial_console_setup          <span class="comment">//串口控制台的设置函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>第5行的CON_PRINTBUFFER表示注册这个结构之后，要把log_buf缓冲区中的所有信息打印出来。这表明，在实际的硬件被初始化之前，就可以使用printk函数，只不过这时的打印信息时保存在log_buf缓冲区中，还没有真正输出。<br>第7行的s3c24xx_serial_console_write是串口输出函数，它会调用s3c24xx_serial_console_putchar函数将要打印的字符一个一个的从串口输出。<br>s3c24xx_serial_console_putchar是最底层的函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">s3c24xx_serial_console_putchar</span><span class="params">(<span class="keyword">struct</span> uart_port *port, <span class="type">int</span> ch)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> ufcon = rd_regl(cons_uart, S3C2410_UFCON);</span><br><span class="line">	<span class="keyword">while</span> (!s3c24xx_serial_console_txrdy(port, ufcon))</span><br><span class="line">		barrier();</span><br><span class="line">	wr_regb(cons_uart, S3C2410_UTXH, ch);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从上面的代码可以知道，从串口输出printk打印信息时，是一个一个字符地发送、等待发送完成、发送、接着等待，…，效率很低。调试完毕后，通常需要将printk信息去掉。</p>
<h3 id="设置内核命令行参数使用串口控制台"><a href="#设置内核命令行参数使用串口控制台" class="headerlink" title="设置内核命令行参数使用串口控制台"></a>设置内核命令行参数使用串口控制台</h3><p>在使用U-Boot时，设置了命令行参数“console&#x3D;ttySAC0”，它使得printk的信息从串口0输出。<br>内核是怎样根据这些命令行参数确定printk的输出设备呢，在<code>kernel/printk.c</code>中有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__setup(&quot;console=&quot;,console_setup);</span><br></pre></td></tr></table></figure>
<p>内核开始执行时，发现形如“console&#x3D;…”的命令行参数时，就会调用console_setup函数进行解析。对于命令行参数“console&#x3D;ttySAC0”，它会解析出：设备名（name）为ttySAC，索引（index）为0，这些信息被保存在类型为console_cmdline、名称为console_cmdline的全局数组中。<br>在后面使用“register_console(&amp;s3c24xx_serial_cosole)”注册控制台时，会将s3c24xx_serial_cosole结构与console_cmdline数组中的设备进行比较，发现名字、索引相同。<br>①s3c24xx_serial_console结构中名字（name）为S3C24XX_SERIAL_NAME，即“ttySAC”，而根据“console&#x3D;ttySAC0”解析出来的名字也是“ttySAC”。<br>②s3c24xx_serial_console结构中索引为-1，表示使用命令行中解析出来的索引0，表示串口0。<br>综上所述，命令行参数“console&#x3D;ttySAC0”决定printk信息将通过s3c24xx_serial_console结构中的相关函数，从串口0输出。<br>最后，既然printk输出的信息是先保存在缓冲区log_buf中，那么也可以读取log_buf以获得这些信息：系统启动后，想查看printk信息时，直接运行dmesg命令即可。通过其他非串口的手段（ssh、telnet）登录系统时，也可以使用dmesg查看printk信息。</p>
<h1 id="内核源码级别的调试方法"><a href="#内核源码级别的调试方法" class="headerlink" title="内核源码级别的调试方法"></a>内核源码级别的调试方法</h1><h2 id="内核调试工具KGDB的作用与原理"><a href="#内核调试工具KGDB的作用与原理" class="headerlink" title="内核调试工具KGDB的作用与原理"></a>内核调试工具KGDB的作用与原理</h2><h3 id="KGDB介绍"><a href="#KGDB介绍" class="headerlink" title="KGDB介绍"></a>KGDB介绍</h3><p>KGDB是一个源码级别的Linux内核调试器。使用KGDB调试内核时，需要结合GDB一起使用。它们使得调试内核就像调试调试应用程序一样，可以在内核代码中设置断点、一步一步地执行指令、观察变量的值。<br>使用KGDB时，需要两台机器，即主机和目标机，两者通过串口线相连。要调试的内核需要增加KGDB功能，它在目标机上运行，GDB在主机上运行。串口线被GDB用来与内核通信。<br>KGDB是一个内核补丁，目前支持i386、x86_64、ppc、s390、ARM等架构。将内核打上KGDB补丁后才能够使用GDB来调试。</p>
<h3 id="KGDB的原理"><a href="#KGDB的原理" class="headerlink" title="KGDB的原理"></a>KGDB的原理</h3><p>安装KGDB调试环境需要为Linux内核加上kgdb补丁，补丁实现GDB远程调试所需要的功能，包括命令处理、陷阱处理及串口通信3个主要的部分。KGDB补丁的主要作用是在Linux内核中添加一个调试stub。调试stub是Linux内核中的一小段代码，是运行GDB的开发机和所调试内核之间的一个媒介。GDB和调试stub之间通过GDB串行协议进行通信。GDB串行协议是一种基于消息的ASCII码协议，包含了各种调试命令。当设置断点时，KGDB将断点的指令替换为一条trap指令，当执行到断点时控制权就转移到调试stub中去。此时，调试stub的任务就是使用远程串行通信协议将当前环境传送给GDB，然后从GDB处接收命令。GDB命令告诉stub下一步做什么，当stub收到继续执行的命令时，将恢复程序的运行环境，把对CPU的控制权重新交给内核。<br>KGDB补丁给内核添加以下3个部件。</p>
<ol>
<li>GDB stub<br>GDB stub被称为调试桩机（简称stub），是KGDB调试器的核心。它是Linux内核中的一小段代码，用来处理主机上GDB发来的各种请求；并且在内核处于被调试状态时，控制目标板上的机器。</li>
<li>修改异常处理函数<br>当这个异常发生时，内核将控制权交给KGDB调试器，程序进入KGDB提供的异常处理函数中。在里面，可以分析程序的各种情况。</li>
<li>串口通信<br>GDB和stub之间通过GDB串行协议进行通信。它是基于消息的ASCII码协议，包含了各种调试命令。<br>除串口外，也可以使用网卡进行通信。<br>以设置内核断点为例说明KGDB与GDB之间的工作过程。设置断点时，KGDB修改内核代码，将断点位置的指令替换成一条异常指令（在ARM中这是一条未定义的指令）。当执行到断点发生异常时，控制权将转移到stub的异常处理函数中。此时，stub的任务就是使用GDB串行通信协议将当前环境传送给GDB，然后从GDB接收命令，GDB命令告诉stub下一步该做什么。当stub收到继续执行的命令时，将恢复原来替换的指令、恢复程序的运行环境，把对CPU的控制权重新交还给内核。</li>
</ol>
<h2 id="给内核添加KGDB功能支持S3C2410-x2F-S3C2440"><a href="#给内核添加KGDB功能支持S3C2410-x2F-S3C2440" class="headerlink" title="给内核添加KGDB功能支持S3C2410&#x2F;S3C2440"></a>给内核添加KGDB功能支持S3C2410&#x2F;S3C2440</h2><h3 id="给内核添加KGDB补丁"><a href="#给内核添加KGDB补丁" class="headerlink" title="给内核添加KGDB补丁"></a>给内核添加KGDB补丁</h3><p>略</p>
<h3 id="修改补丁本身带入的错误"><a href="#修改补丁本身带入的错误" class="headerlink" title="修改补丁本身带入的错误"></a>修改补丁本身带入的错误</h3><p>略</p>
<h3 id="编写S3C2410-x2F-S3C2440的KGDB串口函数"><a href="#编写S3C2410-x2F-S3C2440的KGDB串口函数" class="headerlink" title="编写S3C2410&#x2F;S3C2440的KGDB串口函数"></a>编写S3C2410&#x2F;S3C2440的KGDB串口函数</h3><p>目前的KGDB补丁不支持S3C2410&#x2F;S3C2440的串口，需要自己编写相关函数。可以参考<code>arch/arm/mach-pxa/kgdb-serial.c</code>，在<code>arch/arm/mach-s3c2410/</code>目录下也建立一个kgdb-serial.c文件。<br>KGDB只需要3个函数：初始化函数、发送单字符函数、接收单字符函数。然后将它们填入同一文件中，一个名为kgdb_io_ops的struct kgdb_io结构中。</p>
<ol>
<li>串口初始化函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kgdb_serial_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">clk</span> *<span class="title">clock_p</span>;</span></span><br><span class="line">    u32 pclk;</span><br><span class="line">    u32 ubrdiv;</span><br><span class="line">    u32 val;</span><br><span class="line">    u32 index = CONFIG_KGDB_PORT_NUM;</span><br><span class="line"></span><br><span class="line">    clock_p = clk_get(<span class="literal">NULL</span>,<span class="string">&quot;pclk&quot;</span>);</span><br><span class="line">    pclk = clk_get_rate(clock_p);</span><br><span class="line"></span><br><span class="line">    ubrdiv = (pclk / (UART_BAUDRATE * <span class="number">16</span>)) - <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置GPIO用作串口，并且禁止内部上拉</span></span><br><span class="line"><span class="comment">        GPH2 GPH3 用作TXD0、RXD0</span></span><br><span class="line"><span class="comment">        GPH4 GPH5 用作TXD1、RXD1</span></span><br><span class="line"><span class="comment">        GPH6 GPH3 用作TXD2、RXD2</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(index &lt; MAX_PORT)</span><br><span class="line">    &#123;</span><br><span class="line">        index = <span class="number">2</span> + index * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">        val = inl(S3C2410_GPHUP) | (<span class="number">0x3</span> &lt;&lt; index);</span><br><span class="line">        outl(val,S3C2410_GPHUP);</span><br><span class="line"></span><br><span class="line">        index *= <span class="number">2</span>;</span><br><span class="line">        val = (inl(S3C2410_GPHCON) &amp; ~(~(<span class="number">0xF</span> &lt;&lt; index))) |  \</span><br><span class="line">              (<span class="number">0xA</span> &lt;&lt; index);</span><br><span class="line">        outl(val,S3C2410_GPHCON);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//8N1(8个数据位，无校验位，1个停止位)</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_ULCON,<span class="number">0x03</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//中断/查询方式，UART时钟源为PCLK</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_UCON,<span class="number">0x3c5</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用FIFO</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_UFCON,<span class="number">0x51</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//不使用流控</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_UMCON,<span class="number">0x00</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置波特率</span></span><br><span class="line">    wr_reg1(CONFIG_KGDB_PORT_NUM,S3C2410_UBRDIV,ubrdiv);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
要使用串口，需要选择相关的GPIO引脚用作串口，并且设置串口的数据格式、时钟源、波特率等。</li>
<li>发送单字符函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">kgdb_serial_putchar</span><span class="params">(u8 c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*等待，知道发送缓冲区中的数据已经全部发送出去*/</span></span><br><span class="line">    <span class="keyword">while</span>(!(rd_regb(CONFIG_KGDB_PORT_NUM,S3C2410_UTRSTAT) &amp; S3C2410_UTRSTAT_TXE));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*向UTXH寄存器中写入数据，UART即自动将它发送出去*/</span></span><br><span class="line">    wr_regb(CONFIG_KGDB_PORT_NUM,S3C2410_UTXH,c);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>接收单字符函数<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">kgdb_serial_getchar</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*等待，直到接收缓冲区中有数据*/</span></span><br><span class="line">    <span class="keyword">while</span>(!(rd_regb(CONFIG_KGDB_PORT_NUM,S3C2410_UTRSTAT) &amp; S3C2410_UTRSTAT_RXDR));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*直接读取URXH寄存器，即可获得接收到的数据*/</span></span><br><span class="line">    <span class="keyword">return</span> rd_regb(CONFIG_KGDB_PORT_NUM,S3C2410_TRXH);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>使用这些函数构建kgdb_io_ops结构。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kgdb_io</span> <span class="title">kgdb_io_ops</span> =</span> &#123;</span><br><span class="line">    .init = kgdb_serial_init,</span><br><span class="line">    .read_char = kgdb_serial_getchar,</span><br><span class="line">    .write_char = kgdb_serial_putchar,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
kgdb_io_opsj结构将在<code>kernel/kgdb.c</code>中被用到，这个结构封装了开发板相关的串口操作函数。其他的KGDB代码都是具体开发板无关的。</li>
</ol>
<h3 id="修改内核配置文件、Makefile"><a href="#修改内核配置文件、Makefile" class="headerlink" title="修改内核配置文件、Makefile"></a>修改内核配置文件、Makefile</h3><ol>
<li><p>修改<code>arch/arm/mach-s3c2410/Makefile</code>，将新增的kgdb-serial.c文件编译进内核。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+ obj-$(CONFIG_KGDB_S3C24XX_SERIAL) += kgdb-serial.o</span><br></pre></td></tr></table></figure></li>
<li><p>上面的CONFIG_KGDB_S3C24XX_SERIAL是新加的配置项，是修改配置文件lib&#x2F;Kconfig.kgdb来支持它。<br>修改了4个地方，下面的修改内容仿照补丁文件的格式，首字母为“-”的行表示是老文件中的代码，首字母为“+”的行表示是新文件中的代码。<br>①在“Method for KGDB communication”下增加一个选择项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choice </span><br><span class="line">    prompt &quot;Method for KGDB communication&quot;</span><br><span class="line">    depends on KGDB</span><br><span class="line">+   default KGDB_S3C24XX_SERIAL if ARCH_S3C2410</span><br></pre></td></tr></table></figure>
<p>②用来配置KGDB_S3C24XX_SERIAL选项</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">+   config KGDB_S3C24XX_SERIAL</span><br><span class="line">+   bool &quot;KGDB: On the S3C24XX serial port&quot;</span><br><span class="line">+   depends on ARCH_S3C2410</span><br><span class="line">+   help    </span><br><span class="line">+       Enables the KGDB serial driver for s3c24xx</span><br></pre></td></tr></table></figure>
<p>③配置KGDB_S3C24XX_SERIAL后，也可以设置KGDB所用的串口的波特率</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config KGDB_BAUDRATE</span><br><span class="line">        int &quot;Debug serial port baud rate&quot;</span><br><span class="line">        depends on (KGDB_8250 &amp;&amp; KGDB_SIMPLE_SERIAL) || \</span><br><span class="line">                KGDB_MPSC || KGDB_CPM_UART || \</span><br><span class="line">-               KGDB_TXX9 || KGDB_PXA_SERIAL || KGDB_AMBA_PL011</span><br><span class="line">-               KGDB_TXX9 || KGDB_PXA_SERIAL || KGDB_AMBA_PL011 || KGDB_S3C24XX_SERIAL</span><br></pre></td></tr></table></figure>
<p>④配置KGDB_S3C24XX_SERIAL后，也可以设置KGDB使用哪个串口，默认使用第1个</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config KGDB_PORT_NUM</span><br><span class="line">        int &quot;Serial port number for KGDB&quot;</span><br><span class="line">        range 0 1 if KGDB_MPSC</span><br><span class="line">        range 0 3</span><br><span class="line">-       depends on (KGDB_8250 &amp;&amp; KGDB_SIMPLE_SERIAL) || KGDB_MPSC || KGDB_TXX9</span><br><span class="line">-       default &quot;1&quot;</span><br><span class="line">+       depends on (KGDB_8250 &amp;&amp; KGDB_SIMPLE_SERIAL) || KGDB_MPSC || KGDB_TXX9 || KGDB_S3C24XX_SERIAL</span><br><span class="line">+       default &quot;0&quot;</span><br></pre></td></tr></table></figure>
</li>
<li><p>配置内核，使能KGDB功能<br>执行“make menuconfig”来配置内核，如下配置以使能KGDB功能</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Kernel hacking ---&gt;</span><br><span class="line">    [*]KGDB: kernel debugging with remote gdb   //表示使能KGDB</span><br><span class="line">    [*]KGDB: Console messages through gdb       //表示控制台信息（printk）会发送到GDB</span><br><span class="line">        Method for KGDB communication (KGDB: On the S3C24XX serial port) ---&gt;   //S3C24XX串口</span><br><span class="line">        &lt;&gt;KGDB: On ethernet (NEW)</span><br><span class="line">        (115200) Debug serial port baud rate (NEW)      //波特率115200</span><br><span class="line">        (0) Serial port number for KGDB (NEW)           //使用第一个S3C24XX串口</span><br></pre></td></tr></table></figure>
<p>然后执行“make uImage”即可生成内核vmlinux、arch&#x2F;arm&#x2F;boot&#x2F;uImage。</p>
</li>
</ol>
<h2 id="结合可视化图形前端DDD和GDB来调试内核"><a href="#结合可视化图形前端DDD和GDB来调试内核" class="headerlink" title="结合可视化图形前端DDD和GDB来调试内核"></a>结合可视化图形前端DDD和GDB来调试内核</h2><h3 id="DDD介绍与安装"><a href="#DDD介绍与安装" class="headerlink" title="DDD介绍与安装"></a>DDD介绍与安装</h3><p>略</p>
<h3 id="GDB介绍及安装"><a href="#GDB介绍及安装" class="headerlink" title="GDB介绍及安装"></a>GDB介绍及安装</h3><p>通过GDB这类调试器，程序员可以知道一个程序执行时内部动作过程，可以知道一个程序崩溃时发生了什么事。<br>GDB可以完成以下4个主要功能，这可以帮助程序员捕捉到程序的错误。</p>
<ol>
<li>启动程序，并指定各类能够影响程序运行的参数。</li>
<li>使程序在指定条件下停止运行。</li>
<li>当程序停止时，观察各种状态，检查发生了什么事情</li>
<li>修改程序的执行参数，比如修改某个变量，这使得查错时可以试验各种参数。<br>GDB支持多种编程语言，可以调试用c&#x2F;c++、Modula-2和Fortan等语言编写的程序。GDB是基于命令行的，GDB启动后，在它的控制界面使用各种命令进行操作。<br>Ubuntu 7.10自带的GDB工具是基于X86系列的，需要自己下载源码为ARM平台编译的一个GDB工具，为便于区分，将它命名为arm-linux-gdb。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xjf gdb-6.7.tar.bz2</span><br><span class="line">cd gdb-6.7/</span><br><span class="line">./configure --target=arm-linux</span><br><span class="line">make </span><br><span class="line">sudo make install</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="使用arm-linux-gdb-调试内核（命令行方式）"><a href="#使用arm-linux-gdb-调试内核（命令行方式）" class="headerlink" title="使用arm-linux-gdb 调试内核（命令行方式）"></a>使用arm-linux-gdb 调试内核（命令行方式）</h3><p>先启动支持KGDB的内核，然后在主机上启动arm-linux-gdb。</p>
<ol>
<li>启动内核<br>要使用KGDB功能，需要增加两个命令参数，：console&#x3D;kgdb和kgdbwait。前者表示内核打印信息会被发送给GDB，即通过什么增加的kgdb-serial.c中的相关函数进行发送；后者表示内核启动时先停住，等待GDB的连接。<br>假设将上面编译好的内核uImage放在<code>/work/nfs_root</code>目录下，则可以在U-Boot上使用以下命令设置命令行参数、启动内核。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set bootargs noinitrd root=/dev/mtdblock 2 console=kgdb kgdbwait</span><br><span class="line">nfs 0x31000000 192.168.1.57:/work/nfs_root/uImage</span><br><span class="line">bootm 0x31000000</span><br></pre></td></tr></table></figure>
这时可以看到以下启动信息：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Starting kernel ...</span><br><span class="line">Uncompressing</span><br><span class="line">Linux .......................................done,booting the kernel.</span><br></pre></td></tr></table></figure>
内核在等待主机arm-linux-gdb的连接。</li>
<li>启动arm-linux-gdb<br>启动arm-linux-gdb之前，先退出刚才操作U-Boot所用的工具，因为arm-linux-gdb也要使用这个串口。<br>然后在主机上进入内核目录，启动arm-linux-gdb，可以执行以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/system/linux-2.6.22.6</span><br><span class="line">sudo arm-linux-gdb ./vmlinux</span><br></pre></td></tr></table></figure>
这时会看到arm-linux-gdb的启动信息，进入控制界面：<br><img src="/2022/09/20/Linux%E5%86%85%E6%A0%B8%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/1.jpeg" alt="img not found"><br>最后，执行两个命令设置口、连接目标板。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">(gdb) set remotebaud 115200</span><br><span class="line">(gdb) target remote /dev/ttyS0</span><br></pre></td></tr></table></figure>
这时就会看到如下信息，表明已经连接上目标板，目标板在<code>kernel/kgdb.c</code>的1775行暂停运行。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Remote debugging using /dev/ttyS0</span><br><span class="line">0xc0067a28 in breakpoint () at kernel/kdb.c:1775</span><br><span class="line">1775            atomic_set(&amp;kgdb_setting_breakpoint,1);</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>
现在就可以使用GDB的命令控制内核的执行、进行调试了。比如输入n命令执行下一条指令，输入c命令全速运行，输出q命令退出。<br>为了避免每次启动arm-linux-gdb时手工设置串口、连接目标板，可以在内核目录建立一个名为“.gdbinit”文件，内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set remotebaud 115200</span><br><span class="line">target remote /dev/ttyS0</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="通过DDD调用arm-linux-gdb来调试内核（图形界面）"><a href="#通过DDD调用arm-linux-gdb来调试内核（图形界面）" class="headerlink" title="通过DDD调用arm-linux-gdb来调试内核（图形界面）"></a>通过DDD调用arm-linux-gdb来调试内核（图形界面）</h3><p>略</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第3篇第18章 Linux内核调试技术</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Debug</tag>
      </tags>
  </entry>
  <entry>
    <title>字符设备驱动程序</title>
    <url>/2022/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux设备驱动开发之字符设备驱动程序</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第19章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解Linux系统中驱动程序的地位和作用</li>
<li>了解驱动程序开发的一般流程</li>
<li>掌握简单的字符设备驱动程序的开发方法</li>
</ol>
<h1 id="Linux驱动程序开发概述"><a href="#Linux驱动程序开发概述" class="headerlink" title="Linux驱动程序开发概述"></a>Linux驱动程序开发概述</h1><h2 id="应用程序、库、内核、驱动程序的关系"><a href="#应用程序、库、内核、驱动程序的关系" class="headerlink" title="应用程序、库、内核、驱动程序的关系"></a>应用程序、库、内核、驱动程序的关系</h2><p>从上到下，一个软件系统可以分为：应用程序、库、操作系统、驱动程序。开发人员可以专注于自己熟悉的部分，对于相邻层，只需要了解它的接口，无需关注它的实现细节。<br>以点亮一个LED为例，这4层软件的协作关系如下：<br><img src="/2022/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/1.jpeg" alt="img not found"></p>
<ol>
<li>应用程序使用库提供的open函数打开代表LED的设备文件。</li>
<li>库根据open函数传入的参数执行“swi”指令，这条指令会引起CPU异常，进入内核。</li>
<li>内核的异常处理函数根据这些参数找到相应的驱动程序，返回一个句柄给库，进而返回给应用程序。</li>
<li>应用程序得到文件句柄后，使用库提供的write或ioctl函数发出控制命令。</li>
<li>库根据write或ioctl函数传入的参数执行“swi”指令，这条指令会引起CPU异常，进入内核。</li>
<li>内核的异常处理函数根据这些参数调用驱动程序的相关函数，点亮LED。</li>
</ol>
<p>库（例如glic）给应用程序提供的open、read、write、ioctl、mmap函数等接口函数称为系统调用，它们都是设置好相关寄存器后，执行某条指令引发异常进入内核。对于ARM架构的CPU，这条指令为swi。除系统调用接口之外，库还提供其他函数，比如字符串处理函数，输入输出函数，数学库，还有应用程序的启动代码。<br>在异常处理函数中，内核会根据传入的参数执行各种操作，比如根据设备文件找到对应的驱动程序，调用驱动程序的相关函数等。<br>一般来说，当应用程序调用open、read、write、ioctl、mmap等函数后，将会使用驱动程序中的open、read、write、ioctl、mmap函数来进行相关操作。比如初始化、读、写等。<br>实际上，内核和驱动程序之间并没有界限，因为驱动程序最终要编进内核去的：通过静态链接或动态加载。<br>从上面操作LED的过程可以知道，与应用程序不同，驱动程序从不主动进行，它是被动的：根据应用程序的要求进行初始化，根据应用程序的要求进行读写。驱动程序加载进内核时，只是告诉内核“我这这里，我能做这些工作”，至于“工作”何时开始，取决于应用程序。当然，这不是绝对的，比如用户完全可以写一个由系统时钟触发的驱动程序，让它自己点亮LED。<br>在Linux系统中，应用程序运行于“用户空间”，拥有MMU的系统能够限制应用程序的权限（比如将它限制在某一块内存中），这可以避免应用程序的错误使整个操作系统崩溃。而驱动程序运行于内核空间，它是系统信任的一部分，驱动程序的错误可能导致整个操作系统崩溃。</p>
<h2 id="Linux-驱动程序的分类和开发步骤"><a href="#Linux-驱动程序的分类和开发步骤" class="headerlink" title="Linux 驱动程序的分类和开发步骤"></a>Linux 驱动程序的分类和开发步骤</h2><h3 id="Linux-驱动程序分类"><a href="#Linux-驱动程序分类" class="headerlink" title="Linux 驱动程序分类"></a>Linux 驱动程序分类</h3><p>Linux的外设可以分为3类：字符设备、块设备和网络接口。<br>字符设备是能够像字节流一样被访问的设备，就是说对它的读写是以字节为单位的。比如串口在进行收发数据时就是一个一个字节进行的，我们可以在驱动程序内部使用缓冲区来存放数据以提高效率，但是串口本身对这并没有要求。字符设备的驱动程序中实现了open、close、read、write等系统调用，应用程序可以通过设备文件（比如&#x2F;dev&#x2F;ttySAC0等）来访问字符设备。<br>块设备上的数据以块的形式存放，比如NAND Flash上的数据就是以页为单位存放的。块设备驱动程序向用户层提供的接口与字符设备一样，应用程序也可以通过相应的设备文件（&#x2F;dev&#x2F;mtdblock0、&#x2F;dev&#x2F;hda1）来调用open、close、read、write等系统调用，与块设备传送任意字节的数据。对用户而言，字符设备和块设备的访问方式没有差别。块设备驱动程序的特别之处如下：</p>
<ol>
<li>操作硬件的接口实现方式不一样。<br>块设备驱动程序先将用户发来的数据组织成块，在写入设备；或从设备中读出若干块数据，再从中挑出用户需要的。</li>
<li>数据块上的数据可以有一定的格式<br>通常在块设备上按照一定的格式存放数据，不同文件系统类型就是用来定义这些格式的。内核中，文件系统的层次位于块设备块驱动程序上面，这意味着块设备驱动程序除了向用户层提供像字符设备一样的接口之外，还要向内核其他部件提供一些接口，这些接口用户是看不到的。这些接口使得可以在块设备上存放文件系统，挂接块设备。<br>网络设备同时具有字符设备、块设备的部分特点，无法将它归入两类中：如果说它是字符设备，它的输入输出确是有结构的、成块的（报文、包、帧）；如果说它是块设备，它的块又不是固定大小的，大到几百几千字节，小到几字节。UNIX式的操作系统访问网络接口的方法是给它们分配一个唯一的名字（eth0），但这个名字在文件系统中不存在对应的文件节点。应用程序、内核和网络驱动程序之间的通信完全不同于字符设备、块设备。库、内核还提供了一套和数据包传输相关的函数，而不是open、read、write等。</li>
</ol>
<h3 id="Linux-驱动程序开发步骤"><a href="#Linux-驱动程序开发步骤" class="headerlink" title="Linux 驱动程序开发步骤"></a>Linux 驱动程序开发步骤</h3><p>Linux内核就是由各种驱动组成，内核源码中有大约85%是各种驱动程序的代码。内核中驱动程序种类齐全，可以在同类型驱动的基础上进行修改以符合具体单板。<br>编写驱动程序的难点并不是硬件的具体操作，而是弄清楚现有驱动程序的框架，在这个框架中加入这个硬件。比如，x86架构的内核对IDE硬盘的支持非常完善：首先通过BIOS得到硬盘的信息，或者使用默认的I&#x2F;O地址去枚举硬盘，然后识别分区、挂接文件系统。对于其他架构的内核，只要指定了硬盘的访问地址和中断号，后面的枚举、识别和挂接的过程完全是一样的。也许修改的代码不超过10行，花费精力的地方在于：了解硬盘驱动的框架，找到修改的位置。<br>编写驱动程序还有很多需要注意的地方，比如：驱动程序可能同时被多个进程使用，这需要考虑并发的问题；尽可能发挥硬件的作用以提高性能。比如在硬盘驱动程序中既可以使用DMA也可以不用，使用DMA时程序比较复杂，但是可以提高效率；处理硬件的各种异常情况，否则出错时可能导致整个系统崩溃。<br>一般来说，编写一个Linux设备驱动程序的大致流程如下。</p>
<ol>
<li>查看原理图、数据手册，了解设备的操作方法。</li>
<li>在内核中找到相近的驱动程序，以它为模板进行开发，有时候需要从零开始。</li>
<li>实现驱动程序的初始化：比如向内核注册这个驱动程序，这样应用程序传入文件名时，内核才能找到相应的驱动程序。</li>
<li>设计所要实现的操作：open、read、write、close等。</li>
<li>实现中断服务（中断并不是每个设备驱动所必需的）。</li>
<li>编译该驱动程序到内核中，或者用insmod命令加载。</li>
<li>测试驱动程序。</li>
</ol>
<h2 id="驱动程序的加载和卸载"><a href="#驱动程序的加载和卸载" class="headerlink" title="驱动程序的加载和卸载"></a>驱动程序的加载和卸载</h2><p>可以将驱动程序静态编译进内核中，也可以将它作为模块在使用时加载。在配置内核时，如果某个配置项被设为m，就表示它将会被编译成一个模块。在2.6的内核中，模块的扩展名为.ko，可以只用insmod命令加载，使用rmmod命令卸载，使用lsmod命令查看内核中已经加载了哪些模块。<br>当使用insmode加载模块时，模块的初始化函数被调用，它用来向内核注册驱动程序；当使用rmmod卸载模块时，模块的清除函数被调用。在驱动代码中，这两个函数要么取固定的名字：init_module和cleanup_module，要么使用以下两行来标记它们。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">module_init(my_init);</span><br><span class="line">module_exit(my_cleanup);</span><br></pre></td></tr></table></figure>


<h1 id="字符设备驱动程序开发"><a href="#字符设备驱动程序开发" class="headerlink" title="字符设备驱动程序开发"></a>字符设备驱动程序开发</h1><h2 id="字符设备驱动程序中重要的数据结构和函数"><a href="#字符设备驱动程序中重要的数据结构和函数" class="headerlink" title="字符设备驱动程序中重要的数据结构和函数"></a>字符设备驱动程序中重要的数据结构和函数</h2><p>Linux操作系统将所有的设备看作文件，以操作文件的方式访问设备。应用程序不能直接操作硬件，而是使用统一的接口函数调用硬件驱动程序。这组接口被称为系统调用，在库函数中定义。可以在glibc的fcntl.h、unistd.h、sys&#x2F;ioctl.h等文件中看到如下定义，这些文件也可以在交叉编译工具链的<code>/usr/local/arm/3.4.1/include</code>目录下找到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">open</span><span class="params">(__const <span class="type">char</span> *__file,<span class="type">int</span> __oflag,...)</span>__<span class="title function_">nonnull</span><span class="params">((<span class="number">1</span>))</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> __fd,<span class="type">void</span> *__buf,<span class="type">size_t</span> __nbyte)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> __fd,__const <span class="type">void</span> *__buf,<span class="type">size_t</span> __n)</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> __fd,<span class="type">unsigned</span> <span class="type">long</span> <span class="type">int</span> __request,...)</span>;__THROW;</span><br></pre></td></tr></table></figure>
<p>对于上述每个系统调用，驱动程序都有一个与之对应的函数。对于字符设备驱动程序，这些函数集合在一个file_operations类型的数据结构中。file_operations结构在Linux内核的<code>include/linux/fs.h</code>文件中定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">module</span> *<span class="title">owner</span>;</span></span><br><span class="line">    <span class="type">loff_t</span> (*llseek) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span>, <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_read) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*aio_write) (<span class="keyword">struct</span> kiocb *, <span class="type">const</span> <span class="keyword">struct</span> iovec *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">loff_t</span>);</span><br><span class="line">    <span class="type">int</span> (*readdir) (<span class="keyword">struct</span> file *, <span class="type">void</span> *, <span class="type">filldir_t</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">int</span> <span class="params">(*poll)</span> <span class="params">(<span class="keyword">struct</span> file *, <span class="keyword">struct</span> poll_table_struct *)</span>;</span><br><span class="line">    <span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*unlocked_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">long</span> (*compat_ioctl) (<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line">    <span class="type">int</span> (*mmap) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> vm_area_struct *);</span><br><span class="line">    <span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*flush) (<span class="keyword">struct</span> file *, <span class="type">fl_owner_t</span> id);</span><br><span class="line">    <span class="type">int</span> (*release) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line">    <span class="type">int</span> (*fsync) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> dentry *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*aio_fsync) (<span class="keyword">struct</span> kiocb *, <span class="type">int</span> datasync);</span><br><span class="line">    <span class="type">int</span> (*fasync) (<span class="type">int</span>, <span class="keyword">struct</span> file *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*lock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendfile) (<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">read_actor_t</span>, <span class="type">void</span> *);</span><br><span class="line">    <span class="type">ssize_t</span> (*sendpage) (<span class="keyword">struct</span> file *, <span class="keyword">struct</span> page *, <span class="type">int</span>, <span class="type">size_t</span>, <span class="type">loff_t</span> *, <span class="type">int</span>);</span><br><span class="line">    <span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span><span class="params">(<span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>, <span class="type">unsigned</span> <span class="type">long</span>)</span>;</span><br><span class="line">    <span class="type">int</span> (*check_flags)(<span class="type">int</span>);</span><br><span class="line">    <span class="type">int</span> (*dir_notify)(<span class="keyword">struct</span> file *filp, <span class="type">unsigned</span> <span class="type">long</span> arg);</span><br><span class="line">    <span class="type">int</span> (*flock) (<span class="keyword">struct</span> file *, <span class="type">int</span>, <span class="keyword">struct</span> file_lock *);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_write)(<span class="keyword">struct</span> pipe_inode_info *, <span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">    <span class="type">ssize_t</span> (*splice_read)(<span class="keyword">struct</span> file *, <span class="type">loff_t</span> *, <span class="keyword">struct</span> pipe_inode_info *, <span class="type">size_t</span>, <span class="type">unsigned</span> <span class="type">int</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当应用程序使用open函数打开某个设备时，设备驱动程序的file_operations结构中的open成员就会被调用；当应用程序使用read、write、ioctl等函数读写、控制设备时，驱动程序的file_operations结构中的相应成员（read、write、ioctl等）就会被调用。从这个角度来说，编写字符设备驱动程序就是为具体硬件的file_operations结构编写各个函数（并不需要全部实现file_operations结构中的成员）。<br>那么，当应用程序通过open、read、write等系统调用访问某个设备文件时，Linux系统怎么知道去调用哪个驱动程序的file_operations结构中的open、read、write等成员呢。</p>
<ol>
<li>设备文件有主次设备号。<br>设备文件分为字符设备、块设备，比如PC机上的串口属于字符设备，硬盘属于块设备。在PC上运行命令”ls &#x2F;dev&#x2F;ttyS0 &#x2F;dev&#x2F;hda1 -l”可以看到。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brw-rw----  1 root  disk  3,  1 Jan 30  2003  /dev/hda1</span><br><span class="line">crw-rw----  1 root  uucp  4, 64 Jan 30  2003  /dev/ttyS0</span><br></pre></td></tr></table></figure>
“brw-rw—-”中的“b”表示&#x2F;dev&#x2F;hda1是个块设备，它的主设备号是3，次设备号是1；“crw-rw—-”中的“c”表示&#x2F;dev&#x2F;ttyS0是一个字符设备，它的主设备号是4，次设备号是64。</li>
<li>模块初始化时，将主设备号与file_operations结构一起向内核注册。<br>驱动程序有一个初始化函数，在安装驱动程序时会调用它。在初始化函数中，会将驱动程序的file_operations结构连同其主设备号一起向内核进行注册。对于字符设备使用如下函数进行注册。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">register_chrdev</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> major,<span class="type">const</span> <span class="type">char</span> *name,<span class="keyword">struct</span> file_operations *fops)</span>;</span><br></pre></td></tr></table></figure>
这样，应用程序操作设备文件时，Linux系统就会根据设备文件的类型（字符设备或者块设备）、主设备号找到在内核中注册的file_operations（对于块设备为block_device_operations结构），次设备号供驱动程序自身来分辨它是同类设备中的第几个。<br>编写字符设备驱动的过程大概如下：<br>①编写驱动程序初始化函数<br>  进行必要的初始化，包括硬件初始化、向内核注册驱动程序等。<br>②构造file_operations结构中要用到的各个成员函数。<br>实际的驱动程序当然比上述两个步骤复杂，但是这两个步骤已经可以让我们编写比较简单的驱动程序，比如LED控制。其他比较高级的技术，比如中断、select机制、fsync异步通知机制，将在其他章节的例子中介绍。</li>
</ol>
<h2 id="LED-驱动程序源码分析"><a href="#LED-驱动程序源码分析" class="headerlink" title="LED 驱动程序源码分析"></a>LED 驱动程序源码分析</h2><p>本书以一个简单的LED驱动程序作为例子，让读者初步了解驱动程序的开发。<br>本书的开发板使用引脚使用引脚GPB5-8外接4个LED，它们的操作方法之前的章节已经做了细致的说明。</p>
<ol>
<li>引脚功能设置为输出。</li>
<li>点亮LED，引脚输出0；熄灭LED，引脚输出1。<br>硬件连接如下图所示：<br><img src="/2022/09/22/%E5%AD%97%E7%AC%A6%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F/2.jpeg" alt="img not found"></li>
</ol>
<h3 id="LED驱动代码分析"><a href="#LED驱动代码分析" class="headerlink" title="LED驱动代码分析"></a>LED驱动代码分析</h3><p>模块的初始化函数和卸载函数如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行“insmod s3c24xx_leds.ko”命令时就会调用这个函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3c24xx_leds_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">      注册字符设备驱动程序</span></span><br><span class="line"><span class="comment">      参数为主设备号、设备名字、file_operations结构</span></span><br><span class="line"><span class="comment">      这样，主设备号就和具体的file_operations结构联系起来了，</span></span><br><span class="line"><span class="comment">      操作主设备为LED_MAJOR的设备文件时，就会调用s3c24xx_led_fops中的相关成员函数</span></span><br><span class="line"><span class="comment">      LED_MAJOR可以设为0，表示由内核自动分配主设备号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = register_chrdev(LED_MAJOR,DEVICE_NAME,&amp;s3c24xx_led_fops);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(DEVICE_NAME<span class="string">&quot;can&#x27;t register major number\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(DEVICE_NAME<span class="string">&quot;initialized\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">执行“rmmod s3c24xx_leds.ko”命令时就会调用这个函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">s3c24xx_leds_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*卸载驱动程序*/</span></span><br><span class="line">    unregister_chrdev(LED_MAJOR,DEVICE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这两行知道驱动程序地初始化函数和卸载函数*/</span></span><br><span class="line">module_init(s3c24xx_leds_init);</span><br><span class="line">module_exit(s3c24xx_leds_exit);</span><br></pre></td></tr></table></figure>
<p>最后两行用来指明装载、卸载模块时所调用的函数。也可以不使用这两行，但是需要将这两个函数的名字改为init_module、cleanup_module。<br>执行“insmod s3c24xx_leds.ko”命令时就会调用<code>s3c24xx_leds_init</code>函数，这个函数的核心的代码是<code>register_chrdev</code>函数。它向内核注册驱动程序：将主设备号LED_MAJOR与file_operations结构s3c24xx_leds_fops联系起来。以后应用程序操作主设备号为LED_MAJOR的设备文件时，比如open、read、write、ioctl，s3c24xx_leds_fops中的相应成员函数将会被调用。但是并不需要实现所有成员函数，用到哪个实现哪个。<br>执行“rmmod s3c24xx_leds.ko”命令时就会调用<code>s3c24xx_leds_exit</code>函数，它进而调用<code>unregister_chrdev</code>函数卸载驱动程序，它的功能与<code>register_chrdev</code>函数相反。<br><code>s3c24xx_leds_init</code>、<code>s3c24xx_leds_exit</code>函数前的“__init”、“__exit”只有在将驱动程序静态链接进内核时才有意义。前者表示<code>s3c24xx_leds_init</code>函数的代码被放在<code>“.init.text”</code>段中，这个段在使用一次之后被释放（可以节省内存）；后者表示<code>s3c24xx_leds_exit</code>函数的代码被放在<code>“.exit.data”</code>段中，在连接内核时这个段没有使用，因为不可能卸载静态链接的驱动程序。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    这个结构时字符设备驱动程序的核心</span></span><br><span class="line"><span class="comment">    当应用程序操作设备文件时所调用的open、read、write等函数</span></span><br><span class="line"><span class="comment">    最终会调用这个结构中的对应函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">s3c24xx_leds_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,           <span class="comment">//这是一个宏，指向编译模块时主动创建的__this_module变量</span></span><br><span class="line">    .open  = s3c24xx_leds_open,</span><br><span class="line">    .ioctl = s3c24xx_leds_ioctl，</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>宏THIS_MODULE在<code>include/linux/module.h</code>中定义如下，__this_module变量在编译模块时自动创建，无需关注。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> THIS_MODULE (&amp;__this_module)</span></span><br></pre></td></tr></table></figure>
<p>file_operations类型的s3c24xx_leds_fops结构是驱动中最重要的数据结构，编写字符设备驱动程序的主要工作也是填充其中的各个成员。比如本驱动程序中用到的open、ioctl成员被设为<code>s3c24xx_leds_open</code>、<code>s3c24xx_leds_fops</code>函数前者用来初始化LED所用的GPIO引脚，后者用来根据用户传入的参数设置GPIO的输出电平。<br>s3c24xx_leds_open函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    应用程序对设备文件/dev/leds执行open时，</span></span><br><span class="line"><span class="comment">    就会调用s3c24xx_leds_open</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_leds_open</span><span class="params">(<span class="keyword">struct</span> inode *inode,<span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++) &#123;</span><br><span class="line">        <span class="comment">//设置GPIO引脚的功能：本驱动中LED所涉及的GPIO引脚设为输出功能</span></span><br><span class="line">        s3c2410_gpio_cfgpin(led_table[i],led_cfg_table[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在应用程序执行<code>open(&quot;/dev/leds&quot;,...)</code>系统调用时，<code>s3c24xx_leds_open</code>函数将被调用。它用来将LED所涉及的GPIO引脚设为输出功能。不在模块的初始化函数中进行这些设置的原因是：虽然加载了模块，但是这个模块却不一定被用到，就是说这些引脚不一定用于这些用途，它们可能在其他模块中另作他用。所以，在使用时才去设置它，我们把对引的初始化放在open操作中。<br><code>s3c2410_gpio_cfgpin</code>函数是内核中实现的，它用来选择引脚的功能。其实现原理是设置GPIO的控制寄存器。<br>s3c24xx_leds_ioctl函数的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    应用程序对设备文件/dev/leds 执行ioctl()时，</span></span><br><span class="line"><span class="comment">    就会调用s3c24xx_leds_ioctl函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_leds_ioctl</span><span class="params">(</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">        <span class="keyword">struct</span> file *file,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">int</span> cmd,</span></span><br><span class="line"><span class="params">        <span class="type">unsigned</span> <span class="type">long</span> arg)</span> </span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(arg &gt; <span class="number">4</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    swicth(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> IOCTL_LED_ON:</span><br><span class="line">        <span class="comment">//设置指定引脚的输出电平为0</span></span><br><span class="line">        s3c2410_gpio_setpin(led_table[arg],<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> IOCTL_LED_OFF:</span><br><span class="line">        <span class="comment">//设置指定引脚的输出电平为1</span></span><br><span class="line">        s3c2410_gpio_setpin(led_table[arg],<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用程序执行系统调用<code>ioctl(fd,cmd,arg)</code>时，<code>s3c24xx_leds_ioctl</code>函数将被调用。第18、22行根据传入的cmd、arg参数调用<code>s3c2410_gpio_setpin</code>函数，来设置引脚的输出电平；输出0时点亮LED，输出1时熄灭LED。<br><code>s3c2410_gpio_setpin</code>函数也是内核中实现的，它通过GPIO的数据寄存器来设置输出电平。<br>系统调用函数原型如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname,<span class="type">int</span> flags)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">ioctl</span><span class="params">(<span class="type">int</span> d,<span class="type">int</span> request,...)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">read</span><span class="params">(<span class="type">int</span> fd,<span class="type">void</span> *buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line"><span class="type">ssize_t</span> <span class="title function_">write</span><span class="params">(<span class="type">int</span> fd,<span class="type">const</span> <span class="type">void</span> *buf,<span class="type">size_t</span> count)</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>file_operations结构中的成员如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> (*open) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *);</span><br><span class="line"><span class="type">int</span> (*ioctl) (<span class="keyword">struct</span> inode *, <span class="keyword">struct</span> file *, <span class="type">unsigned</span> <span class="type">int</span>, <span class="type">unsigned</span> <span class="type">long</span>);</span><br><span class="line"><span class="type">ssize_t</span> (*read) (<span class="keyword">struct</span> file *, <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line"><span class="type">ssize_t</span> (*write) (<span class="keyword">struct</span> file *, <span class="type">const</span> <span class="type">char</span> __user *, <span class="type">size_t</span>, <span class="type">loff_t</span> *);</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>可以看到，这些参数有很大一部分相似。</p>
<ol>
<li>系统调用open传入的参数已经被内核文件系统层处理了，在驱动程序中看不出原来的参数了。</li>
<li>系统调用ioctl的参数个数可变，一般最多传入3个：后面两个参数与file_operations结构中ioctl成员后的两个参数对应。</li>
<li>系统调用read传入的buf、count参数，对应file_operations结构中read成员的buf、count参数。而参数offp表示用户在文件中进行存取的位置，当执行完读写操作后由驱动程序进行设置。</li>
<li>系统调用write与file_operations结构中write成员的参数关系，与第3点相似。</li>
</ol>
<p>在驱动程序的最后，有如下描述信息，它们不是必须的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*描述驱动程序的一些信息，不是必须的*/</span></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Nibil&quot;</span>);             <span class="comment">//驱动程序的作者</span></span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;LED Driver&quot;</span>);   <span class="comment">//一些描述信息</span></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;GPL&quot;</span>);              <span class="comment">//遵循的协议</span></span><br></pre></td></tr></table></figure>

<h3 id="驱动程序编译"><a href="#驱动程序编译" class="headerlink" title="驱动程序编译"></a>驱动程序编译</h3><p>将驱动文件放入内核<code>drivers/char</code>子目录下，在<code>drivers/char/Makefile</code>中增加下面一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m += s3c24xx_leds.o</span><br></pre></td></tr></table></figure>
<p>然后在内核根目录下执行“make modules”，就可以生成模块<code>drivers/char/s3c24xx_leds.ko</code>。把它放到单板根文件系统的<code>lib/modules/2.6.22.6</code>目录下，就可以使用“insmode s3c24xx_leds”、“rmmod s3c24xx_leds”命令进行加载卸载了。</p>
<h3 id="驱动程序测试"><a href="#驱动程序测试" class="headerlink" title="驱动程序测试"></a>驱动程序测试</h3><p>首先要编译测试程序<code>led_test.c</code>，它的代码很简单，关键部分如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_LED_ON  0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IOCTL_LED_OFF 1</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    fd = open(<span class="string">&quot;/dev/leds&quot;</span>,<span class="number">0</span>);         <span class="comment">//打开设备</span></span><br><span class="line">...</span><br><span class="line">    led_no = strtoul(argv[<span class="number">1</span>],<span class="number">0</span>,<span class="number">0</span>) - <span class="number">1</span>;<span class="comment">//操作哪个LED？</span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;on&quot;</span>)) &#123;</span><br><span class="line">        ioctl(fd,IOCTL_LED_ON,led_no);<span class="comment">//点亮它    </span></span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(argv[<span class="number">2</span>],<span class="string">&quot;off&quot;</span>)) &#123;</span><br><span class="line">        ioctl(fd,IOCTL_LED_OFF,led_no);<span class="comment">//熄灭它    </span></span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">goto</span> err;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中的open、ioctl最终会调用驱动程序中的<code>s3c24xx_leds_open</code>、<code>s3c24xx_leds_ioctl</code>函数。<br>在测试程序目录下执行“make”命令生成可执行程序led_test，将它放入单板根文件系统<code>/usr/bin</code>目录下后。<br>然后在单板根文件系统中建立设备文件:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod /dev/leds c 231 0</span><br></pre></td></tr></table></figure>
<p>运行测试程序</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">led_test 1 on</span><br><span class="line">led_test 1 off</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第4篇第19章 字符设备驱动程序</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>扩展串口驱动程序移植</title>
    <url>/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux设备驱动开发之扩展串口驱动程序移植</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第21章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解串口终端设备驱动程序的层次结构</li>
<li>掌握移植标准串口驱动程序的方法</li>
</ol>
<h1 id="串口驱动程序框架概述"><a href="#串口驱动程序框架概述" class="headerlink" title="串口驱动程序框架概述"></a>串口驱动程序框架概述</h1><h2 id="串口驱动程序术语介绍"><a href="#串口驱动程序术语介绍" class="headerlink" title="串口驱动程序术语介绍"></a>串口驱动程序术语介绍</h2><p>在Linux中经常碰到“控制台”、“终端”、“console”、“tty”、“terminal”等术语，也经常使用到这些设备文件：<code>/dev/ttySAC0</code>、<code>/dev/tty0</code>、<code>/dev/console</code>等。要理解这些术语，需要从以前的计算机说起。<br>最初的计算机价格昂贵，一台计算机通常连接多套键盘和显示器供人使用。在以前专门有这种可以连上一台电脑的设备，他只有显示器和键盘，外加简单的处理电路，本身不具备处理信息的能力。用户通过它连接到计算机上（通常是通过串口），然后登录系统，对计算机进行操作。这样一台只有输入、显示部件，并能够连接到计算机的设备就叫做终端。tty是Teletype的缩写，Teletype是最早出现的一种终端设备，很像电传打字机。在Linux中，就用“tty”来表示终端设备，比如内核文件“tty_io.c”、“tty_ioctl.c”等都是与“终端相关的驱动程序”。设备文件<code>/dev/ttySAC0</code>、<code>/dev/tty0</code>等也表示某类终端设备。<br>“console”的意思即为控制台，顾名思义，控制台就是用户与系统进行交互的设备，这和终端的作用类似。实际上控制台和终端相比，也只是多了一项功能：它可以显示系统信息，比如内核消息、后台服务消息。从硬件上看，控制台和终端都是具备输入和显示功能的设备。<br>控制台和终端的区别体现在软件上，Linux内核从很早之前发展而来，代码中仍保留了“控制台”、“终端”的概念。启动Linux内核前传入的命令行参数“console&#x3D;…”就是用来指定“控制台”的。控制台在tty驱动初始化之前就可以使用了，它最开始的时候被用来显示内核消息（比如printk函数输出的消息）。<br>当tty驱动初始化完毕之后。用户程序就可以通过tty驱动的接口来操作各类终端设备，包括控制台。从这个意义上来说，控制台也是一种终端，只不过它还能显示内核信息。<br>从命令行参数“console&#x3D;ttySAC0”、“console&#x3D;tty0”可以了解到：系统中有很多终端设备，可以选取其中一个或多个来作为控制台。<code>设备文件/dev/console对应的设备就是命令行参数“console=...”指定的、用作控制台的终端设备</code>。</p>
<h2 id="串口驱动程序的4种结构"><a href="#串口驱动程序的4种结构" class="headerlink" title="串口驱动程序的4种结构"></a>串口驱动程序的4种结构</h2><p>终端设备有很多种类，比如串行终端、键盘和显示器、通过网络实现的终端等。串口也属于一种终端设备，它的驱动程序不仅仅是初始化硬件、发送&#x2F;接收数据。在基本硬件操作的基础上，还增加了很多软件的功能，这是一个多层次的驱动程序。<br>串口驱动程序从上到下分为4层：终端设备层、行规程、串口抽象层、串口芯片层。这种分法不是绝对的，只是为了更方便理解程序，如下图所示：<br><img src="/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/1.jpeg" alt="img not found"><br>终端设备层和行规程的下面还有其他类型的层次和串口的层次并列，比如键盘、显示器等，接下来只关注串口。<br>终端设备层向上提供统一的访问接口，使得用户不必关注具体终端的类型。<br>行规程的作用是指定数据交互的“规矩”，比如流量控制、对输入的数据进行变换处理等。常见的用途有：将TAB字符转换为8个空格，当接收到删除键时删除前面输入的字符，当接收到“CTRL + C”时，发送SIGINT信号。<br>串口抽象层和串口芯片层都属于底层的驱动程序，它们用来操作硬件。串口抽象层将各类串口的共性概括出来，他也是底层串口驱动的核心部分，比如根据串口芯片层提供的地址识别串口类型，设置波特率等。<br>串口芯片层与芯片无关，主要是向串口抽象层提供串口芯片所用的资源（访问地址、中断号等），还进行一些与芯片相关的设置。对于标准串口，移植的工作主要在这一层。</p>
<h3 id="串口接收到-“Ctrl-C”时"><a href="#串口接收到-“Ctrl-C”时" class="headerlink" title="串口接收到 “Ctrl + C”时"></a>串口接收到 “Ctrl + C”时</h3><p>在串口控制台的前台运行一个程序时，如果要手动结束它，可以输入“Ctrl + C”，处理流程如下：</p>
<ol>
<li>串口接受到字符“Ctrl + C”（ASCII码为0x03）后触发中断。假设中断处理函数是<code>drivers/serial/8250.c</code>中的<code>serial8250_interrupt</code>，它属于最底层的函数。</li>
<li>中断处理函数会将这个字符放入tty层的缓冲区中，每个终端设备都有一个接收缓冲区，里面保存的是原始数据。这一步的函数调用顺序如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">serial8250_interrupt(串口芯片层)---&gt;</span><br><span class="line">    serial8250_handle_port(串口芯片层)---&gt;</span><br><span class="line">        receive_chars(串口芯片层)---&gt;</span><br><span class="line">            usrt_insert_char(串口抽象层)---&gt;</span><br><span class="line">                tty_insert_flip_char(终端设备层)---&gt;</span><br></pre></td></tr></table></figure></li>
<li>中断处理函数还要调用其他函数进一步处理原始数据，他最终会向当前进程发送SIGINT信号，让它退出。函数调用顺序如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">serial8250_interrupt(串口芯片层)---&gt;</span><br><span class="line">    serial8250_handle_port(串口芯片层)---&gt;</span><br><span class="line">        receive_chars(串口芯片层)---&gt;</span><br><span class="line">            usrt_insert_char(串口抽象层)---&gt;</span><br><span class="line">                tty_insert_flip_char(终端设备层)<span class="comment">//保存接收到的数据及它的标志（是否有错误）</span></span><br><span class="line">                tty_flip_buffer_push(终端设备层)---&gt;</span><br><span class="line">                    flush_to_ldisc(终端设备层)---&gt;</span><br><span class="line">                        disc-&gt;receive_buf，即n_tty_receive_buf(行规程)---&gt;</span><br><span class="line">                            n_tty_receive_char(行规程)---&gt;</span><br><span class="line">                                n_tty_receice_char(终端设备层)---&gt;<span class="comment">//根据字符进行不同的处理</span></span><br><span class="line">                                发送SIGINT信号，isig(行规程)<span class="comment">//对于“Ctrl + C”，发信号</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="串口接收普通数据时"><a href="#串口接收普通数据时" class="headerlink" title="串口接收普通数据时"></a>串口接收普通数据时</h3><p>串口的接口简单，它的驱动程序相对于USB、IDE等接口的驱动程序而言比较容易掌握。但是串口驱动程序中的分层思想、通过中断处理函数或者定时器处理函数来完成硬件的操作以释放CPU资源的技巧等，这些技术在内核中比较普遍。<br>以串口接收到字符为例，在控制台上输入“ls”并按回车键时，发生如下事情：</p>
<ol>
<li>shell程序一直在休眠，等待接收到“足够”或者“合适”的字符。</li>
<li>串口接受到字符“l”，将它保存起来。</li>
<li>串口输出字符“l”，这样控制台就能看到“l”的字样了。</li>
<li>同理，字符“s”也是如此。</li>
<li>串口接收到回车符，唤醒shell进程。</li>
<li>shell进程就会读取这些字符做什么事情，本例中，它会打印出当前目录下的内容。</li>
</ol>
<p>这些过程涉及的函数与上面对“Ctrl + C”的处理过程类似，只是在<code>n_tty_sereive_char</code>函数中，对于普通字符将调用<code>echo_char</code>函数将它回显；对于回车符，回显之后还要调用<code>waitqueue_active</code>唤醒等待数据的进程。</p>
<h3 id="串口发送数据时"><a href="#串口发送数据时" class="headerlink" title="串口发送数据时"></a>串口发送数据时</h3><p>在往串口上发送数据时，在U-Boot中是发送一个字符之后，循环查询串口状态，当串口再次就绪时，发送下一个字符。如此循环，知道发送完所有字符。在查询状态的过程中，耗费了CPU资源，效率低下。<br>在Linux中，串口字符的发送也是通过中断来驱动的。比如在串口控制台上运行一个程序，里面有<code>printf(&quot;hello,world\n&quot;)</code>字样的语句，它的函数调用关系如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tty_write(终端设备层)---&gt;</span><br><span class="line">    do_tty_write(终端设备层)---&gt;</span><br><span class="line">        write_chan(行规程)---&gt;</span><br><span class="line">            add_wait_queue(&amp;tty_write_wait, &amp;wait);     <span class="comment">//加入等待队列</span></span><br><span class="line">            tty-&gt;driver-&gt;write, 即uart_write(串口抽象层)---&gt;</span><br><span class="line">                <span class="comment">//数据先被保存在串口端口(port)的缓冲区，然后启动发送</span></span><br><span class="line">                uart_start(串口抽象层)---&gt;</span><br><span class="line">                    __uart_start(串口抽象层)---&gt;</span><br><span class="line">                        port-&gt;ops-&gt;start_tx,即serial8250_start_tx(串口芯片层)---&gt;</span><br><span class="line">                            up-&gt;ier |= UART_IER_THRI;   <span class="comment">//这两行使能串口发送中断</span></span><br><span class="line">                            serial_out(up, UART_IER,up-&gt;ier);   <span class="comment">//字符的发送在中断函数中进行</span></span><br><span class="line">            schedule()  <span class="comment">//假如uart_write没立刻发送完数据，进程休眠</span></span><br></pre></td></tr></table></figure>
<p>可见，即使是发送数据，也没有使用循环查询的方法，他只是把数据保存起来，然后开启发送中断。当串口芯片内部的发送缓冲区可以再次存入数据时，这个中断被触发；在中断处理函数中将数据一点点地发送给串口芯片。<br>仍以<code>serial8250_interrupt</code>函数为例，发送数据时的调用关系如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">serial8250_interrupt(串口芯片层)---&gt;</span><br><span class="line">    serial8250_handle_port(串口芯片层)---&gt;</span><br><span class="line">        transmit_chars(串口芯片层)---&gt;</span><br><span class="line">            serial_out(串口芯片层)---&gt; <span class="comment">//将数据写入串口芯片</span></span><br><span class="line">            <span class="comment">//如果已经发送完毕，唤醒进程</span></span><br><span class="line">            uart_write_wakeup,将调用uart_tasklet_action(串口抽象层)---&gt;</span><br><span class="line">                tty_wakeup(终端设备层)---&gt;</span><br><span class="line">                    <span class="comment">//与上面的write_chan中的“add_wait_queue(&amp;tty-&gt;write_wait,&amp;wait)”对应</span></span><br><span class="line">                    wake_up_interruptible(&amp;tty-&gt;write_wait); <span class="comment">//唤醒“等待发送完毕”的进程</span></span><br><span class="line">            <span class="comment">//如果已经发送完毕，则禁止发送中断</span></span><br><span class="line">            __stop_tx(串口芯片层)</span><br></pre></td></tr></table></figure>

<h1 id="扩展串口驱动移植"><a href="#扩展串口驱动移植" class="headerlink" title="扩展串口驱动移植"></a>扩展串口驱动移植</h1><h2 id="串口驱动程序底层代码分析"><a href="#串口驱动程序底层代码分析" class="headerlink" title="串口驱动程序底层代码分析"></a>串口驱动程序底层代码分析</h2><p>扩展串口在开发板上的连线如下图所示，中间的缓冲器用来提高电路的驱动能力。<br><img src="/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/2.jpeg" alt="img not found"><br>扩展串口芯片16C2550属于标准串口，内核的串口驱动程序对它支持良好。可以大胆假设，移植的工作只有一点：告诉这些驱动程序这个扩展芯片所使用的资源，即访问地址和中断号。<br>与具体芯片相关的驱动代码在“串口芯片层”。对于16C2550，它就是<code>drivers/serial/8250.c</code>。入口函数为<code>serial8250_init</code>，它被用来向上层驱动程序注册串口的物理信息。只要弄清楚了这个函数就知道怎么增加对扩展串口的支持了。<br><code>serial8250_init</code>函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">serial8250_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	ret = uart_register_driver(&amp;serial8250_reg); <span class="comment">//注册串口终端设备，未和具体串口挂钩</span></span><br><span class="line">...</span><br><span class="line">	serial8250_isa_devs = platform_device_alloc(<span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">						    PLAT8250_DEV_LEGACY);<span class="comment">//分配platform_device 结构</span></span><br><span class="line">...</span><br><span class="line">	ret = platform_device_add(serial8250_isa_devs);<span class="comment">//加入内核设备层</span></span><br><span class="line">...</span><br><span class="line">	serial8250_register_ports(&amp;serial8250_reg, &amp;serial8250_isa_devs-&gt;dev);<span class="comment">//枚举old_serial_port中定义的串口</span></span><br><span class="line"></span><br><span class="line">	ret = platform_driver_register(&amp;serial8250_isa_driver);<span class="comment">//枚举内核设备层中的接口</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述5个函数是关键，其中<code>platform_driver_register</code>是重点。<br><code>uart_register_driver</code>函数向“终端设备层”注册驱动<code>serial8250_reg</code>，它指定了终端设备的名称、主次设备号等。<code>serial8250_reg</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> <span class="title">serial8250_reg</span> =</span> &#123;</span><br><span class="line">	.owner			= THIS_MODULE,</span><br><span class="line">	.driver_name		= <span class="string">&quot;serial&quot;</span>, <span class="comment">//驱动名称，可以使用“cat /proc/tty/driver/serial”来查看</span></span><br><span class="line">	.dev_name		= <span class="string">&quot;ttyS&quot;</span>,<span class="comment">//设备名称，可以使用“cat /proc/devices”来查看</span></span><br><span class="line">	.major			= TTY_MAJOR,<span class="comment">//主设备号为4</span></span><br><span class="line">	.minor			= <span class="number">64</span>,<span class="comment">//次设备号</span></span><br><span class="line">	.nr			= UART_NR,<span class="comment">//支持的最大串口数，默认为8</span></span><br><span class="line">	.cons			= SERIAL8250_CONSOLE,<span class="comment">//控制台，如果非空，可以用作控制台</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>uart_register_driver</code>只是注册了主次设备号分别为4和64的终端设备，它还没和具体的硬件挂钩。<br><code>platform_device_alloc</code>、<code>platform_device_add</code>、<code>serial8250_register_ports</code>三个函数被用来枚举“老方法定义的”串口设备。所谓“老方法定义的”串口设备就是使用old_serial_port结构指定物理信息的串口，这是为了与以前的串口驱动兼容而遗留下的数据结构。在<code>drivers/serial/8250.c</code>中有如下几行，其中的SERIAL_PORT_DFNS宏在本书所用的内核中被定义为NULL:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">old_serial_port</span> <span class="title">old_serial_port</span>[] =</span> &#123;</span><br><span class="line">	SERIAL_PORT_DFNS <span class="comment">/* defined in asm/serial.h */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>platform_driver_register</code>函数向内核注册了一个平台驱动serial8250_isa_driver，它用来枚举名称为“serial8250”的平台设备。<br>内核根据其他发生确定了很多设备的信息，这些设备被称为平台设备；加载平台驱动程序时将驱动程序与平台设备逐个比较，如果两者匹配，就是用这个驱动来进一步处理。是否匹配的判断方法是：设备名称和驱动名称是否一样。<code>serial8250_isa_driver</code>结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">serial8250_isa_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= serial8250_probe,</span><br><span class="line">	.remove		= __devexit_p(serial8250_remove),</span><br><span class="line">	.suspend	= serial8250_suspend,</span><br><span class="line">	.resume		= serial8250_resume,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可见，serial8250_isa_driver中驱动名称为“serial8250”，只要内核中有相同名称的平台设备，<code>platform_driver_register</code>函数最终会调用<code>serial8250_probe</code>函数来枚举它。<br>只要内核中名为“serial8250”的平台设备定义了正确的串口物理信息，<code>serial8250_probe</code>函数就能自动的检测串口，并将它和前面注册的终端设备联系起来。<br>总而言之，移植扩展串口的主要工作是构建一个平台设备的数据结构，在里面指定串口的物理信息。</p>
<h2 id="修改代码以支持扩展串口"><a href="#修改代码以支持扩展串口" class="headerlink" title="修改代码以支持扩展串口"></a>修改代码以支持扩展串口</h2><p>串口的物理信息主要有两类，访问地址、中断号。只要指明了这两点，并使它们可用，就可以驱动串口了。“使它们可用”的意思是：设置相关的存储控制器以适当的位宽访问这些地址，注册中断时指明合适的触发方式。</p>
<h3 id="构建串口平台设备的数据结构"><a href="#构建串口平台设备的数据结构" class="headerlink" title="构建串口平台设备的数据结构"></a>构建串口平台设备的数据结构</h3><p>在内核代码中查找字符“serial8250”，可以在<code>arch/arm/mach-s3c2410/mach-bast.c</code>中看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_serial8250_port</span> <span class="title">bast_sio_data</span>[] =</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">bast_sio</span> =</span> &#123;</span><br><span class="line">    .name   = <span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">    .id     = PLAT8250_DEV_PLATFORM,</span><br><span class="line">    .dev    = &#123;</span><br><span class="line">        .platform_data  =   &amp;bast_sio_data,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">bast_devices</span>[] _<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">...</span><br><span class="line">    &amp;bast_sio,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>arch/arm/plat-s3c24xx/common-smdk.c</code>中仿照mach-bast.c文件增加如下3段代码。增加的代码如下，它们都使用宏CONFIG_SERIAL_EXTEND_S3C24XX包含起来：</p>
<ol>
<li><p>增加要包含的头文件</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/serial_8250.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>增加平台设备数据结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for extend serial chip</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_serial8250_port</span> <span class="title">s3c_device_8250_data</span>[] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .mapbase    = <span class="number">0x28000000</span>,</span><br><span class="line">        .irq        = IRQ_EINT18,</span><br><span class="line">        .flag       = (UPF_BOOT_AUTOCONF | UPF_IOREMAP | UPF_SHARE_IRQ),</span><br><span class="line">        .iotype     = UPIO_MEM,</span><br><span class="line">        .regshift   = <span class="number">0</span>,</span><br><span class="line">        .uartclk    = <span class="number">115200</span> * <span class="number">16</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .mapbase    = <span class="number">0x29000000</span>,</span><br><span class="line">        .irq        = IRQ_EINT17,</span><br><span class="line">        .flag       = (UPF_BOOT_AUTOCONF | UPF_IOREMAP | UPF_SHARE_IRQ),</span><br><span class="line">        .iotype     = UPIO_MEM,</span><br><span class="line">        .regshift   = <span class="number">0</span>,</span><br><span class="line">        .uartclk    = <span class="number">115200</span> * <span class="number">16</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">s3c_device_8250</span> =</span> &#123;</span><br><span class="line">    .name   = <span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">    .id     = <span class="number">0</span>,</span><br><span class="line">    .dev    = &#123;</span><br><span class="line">        .platform_data  =   &amp;s3c_device_8250_data,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>s3c_device_8250_data</code>结构定义了两个数组项，表示16C2550芯片中的两个串口。数组项0表示扩展串口A，数组项1表示扩展串口B。<br><code>.mapbase = 0x28000000</code>表示串口A的访问基址，这是物理地址。<br><code>.irq = IRQ_EINT18</code>指定串口A使用的中断号为IRQ_EINT18，由电路连接图可知道。<br><code>UPF_BOOT_AUTOCONF</code>表示自动配置串口，即自动检测它的类型、FIFO大小等；<code>UPF_IOREMAP</code>表示需要将前面使用的<code>.mapbase = 0x28000000</code>指定的物理地址映射为虚拟地址，然后才能使用这个虚拟地址来访问串口A；<code>UPF_SHARE_IRQ</code>表示IRQ_EINT18是个共享中断。<br><code>.iotype = UPIO_MEM</code>表示使用“内存地址”（就是mapbase映射后的地址）来访问串口A，与之对应的有UPIO_HUB6、UPIO_RM9000等，它们读写串口芯片的方式有所不同。<br><code>.regshift = 0</code>用来计算串口的寄存器地址。串口的寄存器都有特定的序号，比如发送&#x2F;接收寄存器（TX&#x2F;RX）序号为0，中断使能寄存器（IER）序号为1。假设mapbase映射后的地址为membase，寄存器序号为index，则它的访问地址为：membase + (index &lt;&lt; regshift)。由电路连接图可知，S3C2410&#x2F;S3C2440与16C2550的连接的总线宽度为8，所以regshift为0；如果总线宽度为16，则regshift为1；如果总线宽度为32，则regshift为2。<br><code>.uartclk = 115200 * 16</code>表示串口A的时钟。此值计算方法为：假设为了设置串口波特率为baud，需要往串口的商数寄存器写入数值quot&#x3D;uart&#x2F;(baudx16)。从16C2550的芯片手册可知quot的计算公式为</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">divisor(decimal) = (XTAL1 clock frequency) / (serial data rate x 16)</span><br></pre></td></tr></table></figure>
<p>由电路连接图可知，晶振频率为1.8432MHz，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">uartclk = (XTAL1 clock frequency) = 1.8432M = 115200 * 16</span><br></pre></td></tr></table></figure>
<p>串口B与串口A类似，不再赘述。<br><code>s3c_device_8250(platform_device类型的数据结构)</code>，它的名字为“serial8250”，这与<code>drivers/serial/8250.c</code>中的平台驱动程序serial8250_isa_driver相对应。</p>
</li>
<li><p>加入内核设备列表<br>把平台设备s3c_device_8250加入smdk_devs数组后，系统启动时会把这个数组中的设备注册进内核中。增加的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> __<span class="title">initdata</span> *<span class="title">smdk_devs</span>[] =</span> &#123;</span><br><span class="line">    &amp;s3c_device_nand,</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line">    &amp;s3c_device_8250,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，平台设备的数据结构已经设置好。</p>
</li>
</ol>
<h3 id="增加开发板相关的代码使得串口可用"><a href="#增加开发板相关的代码使得串口可用" class="headerlink" title="增加开发板相关的代码使得串口可用"></a>增加开发板相关的代码使得串口可用</h3><p>这一步需要实现两点：设置相关的存储控制器以适当的位宽访问串口芯片，注册中断时指明合适的触发方式。这需要在<code>drivers/serial/8250.c</code>中增加代码。</p>
<ol>
<li>增加头文件<br>设置存储控制器的BANK5时需要用到这个头文件，代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//for extend serial chip,</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24xx</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch-s3c2410/regs-mem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>设置存储控制器的BANK5的位宽<br>由电路原理图可知，16C2550扩展串口芯片需要以8位的总线宽度进行访问，我们在<code>drivers/serial/8250.c</code>的初始化函数前面进行设置，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">serial8250_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret, i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nr_uarts &gt; UART_NR)</span><br><span class="line">		nr_uarts = UART_NR;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Serial: 8250/16550 driver $Revision: 1.90 $ &quot;</span></span><br><span class="line">		<span class="string">&quot;%d ports, IRQ sharing %sabled\n&quot;</span>, nr_uarts,</span><br><span class="line">		share_irqs ? <span class="string">&quot;en&quot;</span> : <span class="string">&quot;dis&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line">    <span class="comment">//设置BANK5的位宽为8</span></span><br><span class="line">    *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON) =    \</span><br><span class="line">    ((*((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON)) &amp; ~(<span class="number">3</span> &lt;&lt; <span class="number">20</span>)) | S3C2410_BWSCON_DW5_8;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注册中断处理程序时，指定触发方式<br>由电路原理图可知，16C2550扩展串口芯片的INTA、INTB中断信号为高电平有效。<code>低电平有效的信号在电路原理图中一般都在前面加上字母“n”，或者加上上划线</code>，比如图中的nIOR、nIOW等信号表示低电平有效。<br>所以需要将INTA、INTB指定为上升沿触发（指定为高电平触发也可以），在<code>drivers/serial/8250.c</code>文件中调用<code>request_irq</code>函数之前增加如下代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">serial_link_irq_chain</span><span class="params">(<span class="keyword">struct</span> uart_8250_port *up)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line">    irq_flags |= IRQF_TRIGGER_RISING;   <span class="comment">//中断触发方式为上升沿触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ret = request_irq(up-&gt;port.irq, serial8250_interrupt, </span><br><span class="line">    irq_flags, <span class="string">&quot;serial&quot;</span>, i);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="增加内核配置项-CONFIG-SERIAL-EXTEND-S3C24XX"><a href="#增加内核配置项-CONFIG-SERIAL-EXTEND-S3C24XX" class="headerlink" title="增加内核配置项 CONFIG_SERIAL_EXTEND_S3C24XX"></a>增加内核配置项 CONFIG_SERIAL_EXTEND_S3C24XX</h3><p>在内核文件<code>drivers/serial/Kconfig</code>中增加如下几行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config CONFIG_SERIAL_EXTEND_S3C24XX</span><br><span class="line">    bool &quot;Extend UART for S3C24XX DEMO Board&quot;</span><br><span class="line">    depends on SERIAL_8250=y</span><br><span class="line">    --help--</span><br><span class="line">        Say Y here to use the extend UART</span><br></pre></td></tr></table></figure>

<h2 id="测试扩展串口"><a href="#测试扩展串口" class="headerlink" title="测试扩展串口"></a>测试扩展串口</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先配置内核，选中配置项CONFIG_SERIAL_EXTEND_S3C24XX。执行“make menuconfig”后，如下选择：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">    Character devices ---&gt;</span><br><span class="line">        Serial drivers ---&gt;</span><br><span class="line">            &lt;*&gt; 8250/16550 and compatible serial support</span><br><span class="line">            ...</span><br><span class="line">            [*] Extend UART for S3C24XX DEMO board</span><br></pre></td></tr></table></figure>
<p>然后执行“make uImage”编译内核，这将在内核<code>arch/arm/boot</code>目录下生成内核映像文件uImage。<br>最后修改开发板根文件系统，步骤如下。</p>
<ol>
<li>如果不使用mdev，如下增加ttyS0，ttyS1设备文件；如果使用mdev，这步可以省略。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod  /dev/ttyS0 c 4 64</span><br><span class="line">mknod  /dev/ttyS1 c 4 64</span><br></pre></td></tr></table></figure></li>
<li>修改&#x2F;etc&#x2F;inittab文件，增加如下代码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ttyS0::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="测试扩展串口-1"><a href="#测试扩展串口-1" class="headerlink" title="测试扩展串口"></a>测试扩展串口</h3><p>使用新内核、新的根文件系统启动系统，然后原来的控制台下执行如下命令，可以看到检测到了两个串口。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cat /proc/tty/driver/serial</span><br><span class="line">serinfo:1.0 driver revision:</span><br><span class="line">0: uart:16550A mmio:0x28000000 irq:62 mmbase 0xC486A000 tx:0 rx:0</span><br><span class="line">1: uart:16550A mmio:0x29000000 irq:61 mmbase 0xC486C000 tx:0 rx:0</span><br></pre></td></tr></table></figure>
<p>将第一个扩展串口连接到主机上、将主机的串口设为（9600，8N1）后，就可以通过这个扩展串口来控制系统了。<br>如果想设置串口的默认波特率为115200，可以参加如下修改内核文件<code>drivers/serial/serial_core.c</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">改为：</span><br><span class="line">    normal-&gt;init_termios.c_cflag = B115200 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第4篇第21章 扩展串口驱动程序移植</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>网卡驱动移植</title>
    <url>/2022/09/29/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux设备驱动开发之网卡驱动移植</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第22章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解Linux系统的网络栈结构</li>
<li>掌握移植网卡驱动程序的一般方法</li>
<li>掌握CS8900A、DM9000两类网卡驱动程序的移植</li>
</ol>
<h1 id="CS8900A网卡驱动程序移植"><a href="#CS8900A网卡驱动程序移植" class="headerlink" title="CS8900A网卡驱动程序移植"></a>CS8900A网卡驱动程序移植</h1><h2 id="CS8900A网卡特性"><a href="#CS8900A网卡特性" class="headerlink" title="CS8900A网卡特性"></a>CS8900A网卡特性</h2><p>CS8900A 是一款针对嵌入式应用的低成本局域以太网控制器。与其他以太网控制器不同，该款产品采用高集成度的设计，因此无需昂贵的外部元件。<br>CS8900A 包括片上RAM、10Bast-T发送和接收滤波器，以及一个有24mA驱动器的直接ISA-Bus接口。<br>除了高集成度，CS8900A 还具有众多性能特点，并可采用不同的配置。其独特的PacketPage架构可以自动适应网络流量模式和可用系统资源的变化。因此可以使系统的效率大大提高。<br>CS8900A 采用100引脚TQFP封装，是小型化及对成本敏感的以太网应用的理想选择。采用CS8900A，用户可以设计出完整的以太网电路。这些电路仅占用不到10cm²的板上空间。<br>CS8900A 特点如下：</p>
<ol>
<li>单芯片的IEEE 802.3以太网解决方案</li>
<li>拥有完整的软件驱动程序</li>
<li>高效的PacketPage架构可以采用DMA从模式在I&#x2F;O及存储空间运行</li>
<li>全双工操作</li>
<li>片上RAM缓冲器发送和接收架构</li>
<li>10Base-T端口和滤波器（极性检测及纠错）</li>
<li>10Base-2、10Base-5和10Base-F全部采用AUI端口</li>
<li>冲突自动再发送、填充及CRC（循环冗余校验）功能</li>
<li>可编程接收功能</li>
<li>流传输可降低CPU负荷</li>
<li>DMA和片上存储器间的自动切换</li>
<li>可早期中断结构先置处理</li>
<li>自动抑制错误信息包</li>
<li>EEPROM支持无跳线配置</li>
<li>Boot PROM支持无盘系统</li>
<li>边界扫描和循环测试</li>
<li>LED驱动器支持链接状态及局域网活动</li>
<li>待机及休眠模式</li>
<li>工作电压为3V~5V，满足商业及工业应用温度要求</li>
<li>5V最大功耗为120mA，5V典型功耗为90mA</li>
<li>采用100引脚无铅TQFP封装</li>
</ol>
<h2 id="CS8900A-网卡驱动程序修改"><a href="#CS8900A-网卡驱动程序修改" class="headerlink" title="CS8900A 网卡驱动程序修改"></a>CS8900A 网卡驱动程序修改</h2><h3 id="Linux系统网络架构概述"><a href="#Linux系统网络架构概述" class="headerlink" title="Linux系统网络架构概述"></a>Linux系统网络架构概述</h3><p>与串口驱动程序类似，网络驱动程序也分为多个层次，Linux系统网络栈的架构如图所示：<br><img src="/2022/09/29/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D/1.jpeg" alt="img not found"><br>最上面的的是用户空间层，或称为应用层，它通常是一个语义层，能够理解要传输的数据。例如，超文本传输协议（HTTP）就负责传输服务器和客户机之间对Web内容的请求与响应，电子邮件协议SMTP向用户提供高效、可靠的邮件传输。<br>最下面的是物理设备，提供了对网络的连接能力（串口或以太网之类的高速网络）。<br>中间是内核空间，即网络子系统，它是驱动移植的重点所在。顶部是系统调用接口，它简单的为用户空间的应用程序提供了一种访问内核网络子系统的方法。位于它下面的是一个协议无关等，它提供了一种通用方法来使用底层传输层协议。然后是实际协议，在Linux中包括内嵌的协议TCP、UDP，当然还有IP。然后是另一个设备无关层，提供了与各个设备驱动程序通信的通用接口。</p>
<h3 id="CS8900A驱动程序代码修改"><a href="#CS8900A驱动程序代码修改" class="headerlink" title="CS8900A驱动程序代码修改"></a>CS8900A驱动程序代码修改</h3><p>Linux内核中已经有CS8900A网卡驱动程序，源文件为<code>drivers/net/cs89x0.c</code>。与移植扩展串口驱动程序类似，所要做的工作也是：“告诉内核”CS8900A芯片使用的资源（访问地址、中断号等），使得这些资源可用。<br>CS8900A在开发板上的连线如下图所示：<br><img src="/2022/09/29/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D/2.jpeg" alt="img not found"><br>从上图可以确定以下几点：</p>
<ol>
<li>CS8900A的访问基址为0x19000000（由BANK3的基址为0x18000000并且ADDR24为高可以确定）。</li>
<li>总线位宽为16，用到nWAIT、nBE1（字节使能）信号。在CS8900A芯片手册中，nSBHE引脚被称为“System Bus High Enable”，它为低电平时表示系统数据总线上高字节（SD8-SD15）的数据有效。所以S3C2410&#x2F;S3C2440中，“nBE1:nWBE1:DQM1”引脚的功能应该设为“nBE1”。</li>
<li>中断引脚为EINT9<br> 驱动文件<code>drivers/net/cs89x0.c</code>即可以编进内核，也可以编译为一个可加载模块。编译进内核时，它的入口函数为<code>cs89x0_probe</code>；编译为模块时，它的入口函数为<code>init_module</code>。这两个函数最终都会调用<code>cs89x0_probe1</code>函数来枚举CS8900A。需要在调用<code>cs89x0_probe1</code>函数之前，指明CS8900A芯片使用的资源。</li>
</ol>
<p><code>drivers/net/cs89x0.c</code>被编译进内核时，入口函数<code>cs89x0_probe</code>在<code>drivers/net/space.c</code>文件中被调用了8次，调用过程如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">net_olddevs_init -&gt;</span><br><span class="line">    ethif_probe2(被调用8次) -&gt;</span><br><span class="line">        probe_list2 -&gt;</span><br><span class="line">            cs89x0_probe</span><br></pre></td></tr></table></figure>
<p>下面修改驱动文件<code>drivers/net/cs89x0.c</code>。</p>
<ol>
<li><p>指定CS8900A使用的资源<br>在文件的开头增加以下几行，它们在宏CONFIG_ARCH_S3C2410被定义时起作用，表示用于S3C2410&#x2F;S3C2440开发板。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">elif</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch-s3c2410/regs-mem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C24XX_PA_CS8900 0x19000000 <span class="comment">//物理基地址</span></span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> netcard_portlist[] _initdata = &#123;<span class="number">0</span>,<span class="number">0</span>&#125;<span class="comment">//在下面进行设置</span></span><br><span class="line"><span class="type">static</span> <span class="type">unsigned</span> <span class="type">int</span> cs8900_irq_map[] = &#123;IRQ_EINT9, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;;<span class="comment">//中断号</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>宏<code>S3C24XX_PA_CS8900</code>表示访问CS8900A时使用的物理地址，在后面需要将它映射为虚拟地址。<br><code>netcard_portlist</code>用来指定网卡的访问地址（还未设置），它是虚拟地址或者I&#x2F;O地址，可以直接用来访问网卡。后面将指定的物理地址映射为虚拟地址之后，存入<code>netcard_portlist</code>。<br><code>cs8900_irq_map</code>指定CS8900A使用的中断号。</p>
</li>
<li><p>修改入口函数cs89x0_probe<br>以下使用宏CONFIG_ARCH_S3C2410包括起来的代码是新加的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> net_device * __init <span class="title function_">cs89x0_probe</span><span class="params">(<span class="type">int</span> unit)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> oldval_bwscon;         <span class="comment">//用来保存BWSCON寄存器的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> oldval_bankcon3;       <span class="comment">//S3C2410_BANKCON3寄存器的值</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">    io = dev-&gt;base_addr;</span><br><span class="line">    irq = dev-&gt;irq;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">    <span class="comment">//cs89x0_probe会被多次调用，我们只需要一次，根据netcard_portlist[0]的值忽略后面的调用</span></span><br><span class="line">    <span class="keyword">if</span>(netcard_portlist[<span class="number">0</span>])</span><br><span class="line">        <span class="keyword">return</span> -ENODEV;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//将CS8900A的物理地址转换为虚拟地址，0x300是CS8900A内部的I/O空间的偏移地址</span></span><br><span class="line">    netcard_portlist[<span class="number">0</span>] = (<span class="type">unsigned</span> <span class="type">int</span>)ioremap(S3C24XX_PA_CS8900, SZ_1M) + <span class="number">0x300</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置默认MAC地址</span></span><br><span class="line"><span class="comment">        MAC地址可以由CS8900A外接的EEPROM设定</span></span><br><span class="line"><span class="comment">        或者启动系统后使用ifconfig修改</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dev-&gt;dev_addr[<span class="number">0</span>] = <span class="number">0x08</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">1</span>] = <span class="number">0x89</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">2</span>] = <span class="number">0x89</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">3</span>] = <span class="number">0x89</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">4</span>] = <span class="number">0x89</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">5</span>] = <span class="number">0x89</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Bank3：总线宽带为16，使能nWAIT，使能UB/LB。</span></span><br><span class="line">    oldval_bwscon = *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON);</span><br><span class="line">    *((volitale <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON) = (oldval_bwscon &amp; ~(<span class="number">3</span> &lt;&lt; <span class="number">12</span>)) \</span><br><span class="line">        | S3C2410_BWSCON_DW3_16 | S3C2410_BWSCON_WS3 | S3C2410_BWSCON_ST3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置Bank3的时间参数</span></span><br><span class="line">    oldval_bankcon3 = *((volitale <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BANKCON3);</span><br><span class="line">    *((volitale <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON3) = <span class="number">0x1f7c</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">for</span>(port = netcard_portlist; *port; port++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (cs89x0_probe1(dev, *port, <span class="number">0</span>) == <span class="number">0</span>)</span><br><span class="line">...</span><br><span class="line">out:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">    iounmap(netcard_portlist[<span class="number">0</span>]);</span><br><span class="line">    netcard_portlist[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复寄存器原来的值</span></span><br><span class="line">    *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON) = oldval1_bwscon;</span><br><span class="line">    *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BANKCON3) = oldval_bankcon3;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>cs89x0_probe会被调用8次，第14行用来略过后面的7次。<br>第18行将CS8900A的访问地址存在<code>netcard_portlist[0]</code>中，这是虚拟地址，在Linux内核空间访问硬件时都使用虚拟地址。它将CS8900A的物理基址转换为虚拟地址，再加上0x300（CS8900A内部的I&#x2F;O空间的偏移地址）。从图22.2的nIOR、nIOW信号可知，本开发板通过它的I&#x2F;O空间来使用CS8900A。<br>第25-30行设置CS8900A的MAC地址，在后面，还会尝试从CS8900A外接的EEPROM读取MAC地址，也可以在系统启动后通过ifconfig命令修改MAC地址。<br>第33-35行用来设置BWSCON寄存器，将BANK3设为：总线宽度为16，使能nWAIT信号，使能UB&#x2F;LB信号。<br>第39-39行设置BANK3的时间参数，本书使用最宽松的值，几乎都取最大值，可根据CS8900A的数据手册进行调整。<br>第42-43就是实际的枚举函数了。<br>第46-53行用来处理出错情况，它将函数映射的虚拟地址释放掉，设置netcard_portlist[0]为0，将BWSCON、BANKCON3寄存器设为原来的值。</p>
</li>
<li><p>修改模块入口函数init_module、卸载函数cleanup_module<br><code>init_module</code>函数的修改与上述<code>cs89x0_probe</code>函数相似，使用宏CONFIG_ARCH_S3C2410包括起来的代码是新加的。它们的作用可以参考上面的<code>cs89x0_probe</code>函数的描述，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> __init <span class="title function_">init_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">net_device</span> *<span class="title">dev</span> =</span> alloc_etherdev(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> net_local));</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> oldval_bwscon;         <span class="comment">//用来保存BWSCON寄存器的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> oldval_bankcon3;       <span class="comment">//S3C2410_BANKCON3寄存器的值</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span>(!dev)</span><br><span class="line">        <span class="keyword">return</span> -ENOMEN;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">    <span class="comment">//将CS8900A的物理地址转换为虚拟地址，0x300是CS8900A内部的I/O空间的偏移地址</span></span><br><span class="line">    dev-&gt;base_addr = io = (<span class="type">unsigned</span> <span class="type">int</span>)ioremap(S3C24XX_PA_CS8900, SZ_1M) + <span class="number">0x300</span>;</span><br><span class="line">    dev-&gt;irq = irq = cs8900_irq_map[<span class="number">0</span>];<span class="comment">//中断号</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置默认MAC地址</span></span><br><span class="line"><span class="comment">        MAC地址可以由CS8900A外接的EEPROM设定</span></span><br><span class="line"><span class="comment">        或者启动系统后使用ifconfig修改</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    dev-&gt;dev_addr[<span class="number">0</span>] = <span class="number">0x08</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">1</span>] = <span class="number">0x89</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">2</span>] = <span class="number">0x89</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">3</span>] = <span class="number">0x89</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">4</span>] = <span class="number">0x89</span>;</span><br><span class="line">    dev-&gt;dev_addr[<span class="number">5</span>] = <span class="number">0x89</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置Bank3：总线宽带为16，使能nWAIT，使能UB/LB。</span></span><br><span class="line">    oldval_bwscon = *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON);</span><br><span class="line">    *((volitale <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON) = (oldval_bwscon &amp; ~(<span class="number">3</span> &lt;&lt; <span class="number">12</span>)) \</span><br><span class="line">        | S3C2410_BWSCON_DW3_16 | S3C2410_BWSCON_WS3 | S3C2410_BWSCON_ST3;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置Bank3的时间参数</span></span><br><span class="line">    oldval_bankcon3 = *((volitale <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BANKCON3);</span><br><span class="line">    *((volitale <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON3) = <span class="number">0x1f7c</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    dev-&gt;irq = irq;</span><br><span class="line">    dev-&gt;base_addr = io;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">    <span class="keyword">if</span>(io == <span class="number">0</span>) &#123;</span><br><span class="line">...</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(io &lt;= <span class="number">0x1ff</span>) &#123;</span><br><span class="line">        ret = -ENXIO;</span><br><span class="line">        <span class="keyword">goto</span> out;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br><span class="line">    ret = cs89x0_probe1(dev, io, <span class="number">1</span>);</span><br><span class="line">...</span><br><span class="line">out:</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">    iounmap(dev-&gt;base_addr);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//恢复寄存器原来的值</span></span><br><span class="line">    *((volitale <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON) = oldval_bwscon;</span><br><span class="line">    *((volitale <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BANKCON3) = oldval_bankcon3;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    free_netdev(dev);</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>判断语句<code>io &lt;= 0x1ff</code>，io变量本来的类型为int，需要将它改为unsigned int，因为之前映射得到的地址在0x80000000之上，使用int的话，这是一个负数。<br>卸载驱动时，要将前面映射的虚拟地址释放掉，这需要修改<code>cleanup_module</code>函数，下面使用宏CONFIG_ARCH_S3C2410包括起来的代码是新加的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __exit</span><br><span class="line"><span class="title function_">cleanup_module</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    unregister_netdev(dev_cs89x0);</span><br><span class="line">    writeword(dev_cs89x0-&gt;base_addr, ADD_PORT, PP_ChipID);</span><br><span class="line">    release_region(dev_cs89x0-&gt;base_addr, NETCARD_IO_EXTEND);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">    iounmap(dev_cs89x0-&gt;base_addr;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    free_netdev(dev_cs89x0);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>注册中断处理程序时，指定中断触发方式<br>驱动程序中，在<code>net_open</code>函数使用<code>request_irq</code>函数注册中断处理函数。如下修改，使用宏CONFIG_ARCH_S3C2410包括起来的代码是新加的，CS8900A的中断触发方式是上升沿触发。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">    writereg(dev, PP_BusCTL, ENABLE_IRQ | MEMORY_ON);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    write_irq(dev, lp-&gt;chip_type, dev-&gt;irq);</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">    ret = request_irq(dev-&gt;irq, &amp;net_interrupt, IRQF_TRIGGER_RISING, dev-&gt;name, dev);</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    ret = request_irq(dev-&gt;irq, &amp;net_interrupt, <span class="number">0</span>, dev-&gt;name, dev);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>其他修改</p>
<ol>
<li>在<code>drivers/net/cs89x0.c</code>中适当的位置加上CONFIG_ARCH_S3C2410宏的编译开关，这可以在用到宏CONFIG_ARCH_PNX010X的一些地方，仿照它加上宏CONFIG_ARCH_S3C2410。<br>①第一个位置：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> </span><br><span class="line"><span class="title function_">net_open</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">net_local</span> *<span class="title">lp</span> =</span> netdev_priv(dev);</span><br><span class="line">     <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">     <span class="type">int</span> i;</span><br><span class="line">     <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_SH_HICONSH4) &amp;&amp; !defined(CONFIG_ARCH_PNX010X) </span></span><br><span class="line">修改后：</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_SH_HICONSH4) &amp;&amp; !defined(CONFIG_ARCH_PNX010X) &amp;&amp; !defined(CONFIG_ARCH_S3C2410)</span></span><br></pre></td></tr></table></figure>
②第二个位置<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_MACH_IXDP2351) &amp;&amp; !defined(CONFIG_ARCH_IXDP2X01) &amp;&amp; !defined(CONFIG_ARCH_PNX010X)</span></span><br><span class="line">修改后：</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> !defined(CONFIG_MACH_IXDP2351) &amp;&amp; !defined(CONFIG_ARCH_IXDP2X01) &amp;&amp; !defined(CONFIG_ARCH_PNX010X) &amp;&amp; !defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">     <span class="keyword">if</span>(((<span class="number">1</span> &lt;&lt; dev-&gt;irq) &amp; lp-&gt;irq_map) == <span class="number">0</span>) &#123;</span><br></pre></td></tr></table></figure>
②第三个位置<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_PNX010X)</span></span><br><span class="line">修改后：</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_PNX010X) &amp;&amp; defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">     result = A_CNF_10B_T;</span><br></pre></td></tr></table></figure></li>
<li>全局变量“static int io;”改为“static unsigned int io;”。</li>
</ol>
</li>
</ol>
<h3 id="内核配置文件修改"><a href="#内核配置文件修改" class="headerlink" title="内核配置文件修改"></a>内核配置文件修改</h3><p>要使用驱动文件<code>drivers/net/cs89x0.c</code>，需要设置配置项CONFIG_CS89X0，它在配置文件<code>drivers/net/Kconfig</code>中描述。修改前代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config CS89X0</span><br><span class="line">    tristate    &quot;CS89X0 support&quot;</span><br><span class="line">    depends on NET_PCI &amp;&amp; (ISA || MACH_IXDP2351 || ARCH_IXDP2X01 || ARCH_PNX010X)</span><br></pre></td></tr></table></figure>
<p>本书的开发板中，CS8900A并不需要使用PCI，所以需要修改它的依赖条件，修改后的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config CS89X0</span><br><span class="line">    tristate    &quot;CS89X0 support&quot;</span><br><span class="line">    depends on (NET_PCI &amp;&amp; (ISA || MACH_IXDP2351 || ARCH_IXDP2X01 || ARCH_PNX010X)) || ARCH_S3C2410</span><br></pre></td></tr></table></figure>

<h3 id="使用CS8900A网卡"><a href="#使用CS8900A网卡" class="headerlink" title="使用CS8900A网卡"></a>使用CS8900A网卡</h3><p>在内核根目录下执行“make menuconfig”后，如下配置将CS8900A编入内核（也可以配置为模块）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device Drivers  ---&gt;</span><br><span class="line">    Network device support  ---&gt;</span><br><span class="line">        [*] Network device support</span><br><span class="line">            Ethernet (10 or 100Mbit) ---&gt;</span><br><span class="line">                &lt;*&gt; CS89X0 support</span><br></pre></td></tr></table></figure>
<p>另外，增加对NFS的支持，如下配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File System ---&gt;</span><br><span class="line">    Network File Systems ---&gt;</span><br><span class="line">        &lt;*&gt; NFS file system support</span><br><span class="line">        [*] Provide NFSv3 client support</span><br><span class="line">        [*] Provide client support for the NFSv3 ACL protocool extension</span><br><span class="line">        [*] Provide NFSv4 client support (EXPERIMENTAL)</span><br><span class="line">        [*] Root file system on NFS</span><br></pre></td></tr></table></figure>
<p>然后编译内核：执行“make uImage”命令即可生成<code>arch/arm/boot/uImage</code>。<br>新内核具备了网络功能，这是可以通过NFS启动系统，或者从NAND Flash上启动系统后挂接NFS文件系统，可以telnet登录到开发板上等。这时候调试程序就非常方便了，不需要每次都将程序烧写到开发板上。<br>按照U-Boot的使用说明烧写新内核，在Linux主机上启动NFS服务，现在就可以在U-Boot控制界面修改命令行参数通过NFS启动系统了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set bootargs noinitrd root=/dev/nfs console=ttySAC0 nfsroot=192.168.1.57:/work/my_root_fs ip=192.168.1.17:192.168.1.57:192.168.1.2:255.255.255.0::eth0:off</span><br></pre></td></tr></table></figure>
<p>ip的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ip=&lt;client-ip&gt;:&lt;server-ip&gt;:&lt;gw-ip&gt;:&lt;netmask&gt;:&lt;hostname&gt;:&lt;device&gt;:&lt;autoconf&gt;</span><br></pre></td></tr></table></figure>
<p>当系统启动后，还可以在控制台使用以下命令挂接NFS文件系统</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.17</span><br><span class="line">mount -t nfs -o nolock 192.168.1.57:/work/nfs_root/fs_mini_mdev /mnt</span><br></pre></td></tr></table></figure>
<p>要从主机上通过telnet登录开发板，首先要在开发板上启动telnet服务。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ifconfig eth0 192.168.1.17</span><br><span class="line">telnetd -l /bin/sh</span><br></pre></td></tr></table></figure>
<p>telnet的参数“-l &#x2F;bin&#x2F;sh”表示连接时运行程序“&#x2F;bin&#x2F;sh”，否则需要验证密码。本书构建的根文件系统中没有设置用户和密码，无法登录。<br>如果将CS8900A的驱动配置为模块，在内核根目录下执行“make modules”命令后，会在<code>drivers/net</code>下生成可加载模块cs89x0.ko。将它放到开发板根文件系统下，加载之后再设置IP，就可以挂接NFS文件系统、启动telnet服务了。</p>
<h1 id="DM9000-网卡驱动程序移植"><a href="#DM9000-网卡驱动程序移植" class="headerlink" title="DM9000 网卡驱动程序移植"></a>DM9000 网卡驱动程序移植</h1><h2 id="DM9000的网卡特性"><a href="#DM9000的网卡特性" class="headerlink" title="DM9000的网卡特性"></a>DM9000的网卡特性</h2><p>DM9000是一款高度集成的、低成本的单片快速以太网MAC控制器，含有带有通用处理器接口、10M&#x2F;100M物理层和16KB的SRAM。<br>DM9000有如下特点:</p>
<ol>
<li>支持的处理器接口类型：以字节、字、双字的I&#x2F;O指令访问DM9000的内部数据。</li>
<li>集成的10M&#x2F;100M收发器。</li>
<li>支持MII&#x2F;RMII接口。</li>
<li>支持半双工背压流量控制模式。</li>
<li>IEEE802.3x全双工流量控制模式。</li>
<li>支持远端唤醒和连接状态变化。</li>
<li>集成4KB的双字SRAM。</li>
<li>支持从EEPROM中自动获取厂商ID（vendor ID）和产品ID（product ID）。</li>
<li>支持4个GPIO管脚。</li>
<li>可以使用EEPROM来配置。</li>
<li>低功耗模式。</li>
<li>I&#x2F;O管脚3.3V和5V兼容。</li>
<li>100-pin CMOS工艺 LQFP封装。</li>
</ol>
<h2 id="DM9000网卡驱动程序修改"><a href="#DM9000网卡驱动程序修改" class="headerlink" title="DM9000网卡驱动程序修改"></a>DM9000网卡驱动程序修改</h2><p>DM9000在开发板上的连线如图所示：<br><img src="/2022/09/29/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D/3.jpeg" alt="img not found"><br>从上图可以确定以下几点。</p>
<ol>
<li>DM9000的访问基址为0x20000000（BANK4的基址），这是物理地址。</li>
<li>只用到一条地址线：ADDR2。这是由DM9000的特性决定的：DM9000的地址信号和数据信号复用，使用CMD引脚来区分它们（CMD为低时数据总线上传输的是地址信号，CMD为高时传输的是数据信号）。访问DM9000内部寄存器时，需要先将CMD置为低电平，发出地址信号；然后将CMD置为高电平，读写数据。</li>
<li>总线位宽为16，用到nWAIT信号。</li>
<li>中断引脚为EINT7。</li>
</ol>
<p>Linux内核中已经有DM9000网卡驱动程序，源文件为<code>dirvers/net/dm9000.c</code>。它既可以编译进内核，也可以编译为一个模块。入口函数都是<code>dm9000_init</code>，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init</span><br><span class="line"><span class="title function_">dm9000_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;%s Ethernet Driver\n&quot;</span>, CARDNAME);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;dm9000_driver);	<span class="comment">/* search board and register */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6行向内核注册平台驱动<code>dm9000_driver</code>。<code>dm9000_driver</code>结构的名称为“dm9000”，如果内核中有相同名称的平台设备，则调用<code>dm9000_probe</code>函数，<code>dm9000_driver</code>结构如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">dm9000_driver</span> =</span> &#123;</span><br><span class="line">	.driver	= &#123;</span><br><span class="line">		.name    = <span class="string">&quot;dm9000&quot;</span>,</span><br><span class="line">		.owner	 = THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">	.probe   = dm9000_probe,</span><br><span class="line">	.remove  = dm9000_drv_remove,</span><br><span class="line">	.suspend = dm9000_drv_suspend,</span><br><span class="line">	.resume  = dm9000_drv_resume,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>所以首先要为DM9000定义一个平台设备的数据结构，然会修改<code>drivers/net/dm9000.c</code>，增加一些开发板相关的代码。</p>
<h3 id="增加DM9000平台设备"><a href="#增加DM9000平台设备" class="headerlink" title="增加DM9000平台设备"></a>增加DM9000平台设备</h3><p>增加平台设备的方法在移植串口驱动程序时已经介绍过，过程相似。需要修改<code>arch/arm/plat-s3c24xx/common-smdk.c</code>文件。</p>
<ol>
<li>添加要包含的头文件，增加以下代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/dm9000.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>添加DM9000的平台设备结构，增加以下代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)</span></span><br><span class="line"><span class="comment">/*DM9000*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">s3c_dm9k_resource</span>[] =</span> &#123;</span><br><span class="line">     [<span class="number">0</span>] = &#123;</span><br><span class="line">         .start = S3C2410_CS4,       <span class="comment">//ADDR2=0，发送地址时使用这个地址</span></span><br><span class="line">         .end = S3C2410_CS4 + <span class="number">3</span>,</span><br><span class="line">         .flags = IORESOURCE_MEM,</span><br><span class="line">     &#125;,</span><br><span class="line">     [<span class="number">1</span>] = &#123;</span><br><span class="line">         .start = S3C2410_CS4 + <span class="number">4</span>,       <span class="comment">//ADDR2=1，传输数据时使用这个地址</span></span><br><span class="line">         .end = S3C2410_CS4 + <span class="number">4</span> + <span class="number">3</span>,</span><br><span class="line">         .flags = IORESOURCE_MEM,</span><br><span class="line">     &#125;,</span><br><span class="line">     [<span class="number">2</span>] = &#123;</span><br><span class="line">         .start = IRQ_EINT7,       <span class="comment">//中断号</span></span><br><span class="line">         .end = IRQ_EINT7,</span><br><span class="line">         .flags = IORESOURCE_IRQ,</span><br><span class="line">     &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*for the moment we limit ourselves to 16bit IO until some </span></span><br><span class="line"><span class="comment">better IO routines can be written and tested*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">dm9000_plat_data</span> <span class="title">s3c_dm9k_platdata</span> =</span> &#123;</span><br><span class="line">     .flags = DM9000_PLATF_16BITONLY,    <span class="comment">//数据总线宽度为16</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">paltform_device</span> <span class="title">s3c_device_dm9k</span> =</span> &#123;</span><br><span class="line">     .name = <span class="string">&quot;dm9000&quot;</span>,</span><br><span class="line">     .id = <span class="number">0</span>,</span><br><span class="line">     .num_resource = ARRAY_SIZE(s3c_dm9k_resource),</span><br><span class="line">     .resource = s3c_dm9k_resource,</span><br><span class="line">     .dev = &#123;</span><br><span class="line">         .platform_data = &amp;s3c_dm9k_platdata,</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/*CONFIG_DM9000*/</span></span></span><br></pre></td></tr></table></figure>
以上代码是仿照<code>arch/arm/mach-s3c2410/mach-bast.c</code>增加的，主要修改了DM9000所使用的资源，即<code>s3c_dm9k_resource</code>结构。<code>s3c_dm9k_resource</code>定义了3个资源：两个内存空间、中断号。数组项0、1定义了访问DM9000时使用的地址，前一个地址的ADDR2为0，用来传输地址；后一个地址的ADDR2为1，用来传输数据。数组项2定义了DM9000使用的中断号。<br>第25行指定访问DM9000时，数据位宽为16。DM9000支持8&#x2F;16&#x2F;32位的访问方式。</li>
<li>加入内核设备列表中<br>把平台设备s3c_device_dm9k加入smdk_decs数组即可，系统启动时会把这个数组中的设备注册进入内核中，增加的代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> __<span class="title">initdata</span> *<span class="title">smdk_devs</span>[] =</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="meta">#<span class="keyword">if</span> defined(CONFIG_DM9000) || defined(CONFIG_DM9000_MODULE)</span></span><br><span class="line">         &amp;s3c_device_dm9k,</span><br><span class="line">     <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="修改drivers-net-dm9000-c"><a href="#修改drivers-net-dm9000-c" class="headerlink" title="修改drivers/net/dm9000.c"></a>修改<code>drivers/net/dm9000.c</code></h3><p>对DM9000的枚举最终由<code>dm9000_probe</code>函数来完成，首先从它分析这个驱动是如何使用上面定义的两个内存空间地址和中断号的，然后再给出修改方法。</p>
<ol>
<li><p>驱动源码简要分析<br>从<code>dm9000_probe</code>函数就可以看出前面定义的资源是如何被使用的，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> </span><br><span class="line"><span class="title function_">dm9000_probe</span><span class="params">(<span class="keyword">struct</span> paltform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span>(pdev-&gt;num_resources &lt; <span class="number">2</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">     &#125;<span class="keyword">else</span> <span class="keyword">if</span>(pdev-&gt;num_resources == <span class="number">2</span>) &#123;</span><br><span class="line">     ...</span><br><span class="line">     &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">         db-&gt;addr_res = platform_get_resource(pdev, IORESORCE_MEM, <span class="number">0</span>);<span class="comment">//S3C2410_CS4</span></span><br><span class="line">         db-&gt;data_res = platform_get_resource(pdev, IORESORCE_MEM, <span class="number">1</span>);<span class="comment">//S3C2410_CS4 + 4</span></span><br><span class="line">         db-&gt;data_res = platform_get_resource(pdev, IORESORCE_IRQ, <span class="number">0</span>);<span class="comment">//IRQ_EINT7</span></span><br><span class="line">         ...</span><br><span class="line">         i = res_size(db-&gt;addr_res);</span><br><span class="line">         ...</span><br><span class="line">         db-&gt;io_addr = ioremap(db-&gt;addr_res-&gt;start, i);<span class="comment">//S3C2410_CS4对应的虚拟地址</span></span><br><span class="line">         ...</span><br><span class="line">         ndev-&gt;base_addr = (<span class="type">unsigned</span> <span class="type">long</span>)db-&gt;io_addr;</span><br><span class="line">         ndev-&gt;irq = db-&gt;irq_res-&gt;start;<span class="comment">//IRQ_EINT7</span></span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span>(pdata != <span class="literal">NULL</span>) &#123;</span><br><span class="line">         ...</span><br><span class="line">         <span class="keyword">if</span>(pdata-&gt;flags &amp; DM9000_PLATF_16BITONLY)</span><br><span class="line">             dm9000_set_io(db, <span class="number">2</span>);</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     dm9000_reset(db);</span><br><span class="line">     <span class="comment">/*tty two times,DM9000 sometimes gets the first read wrong*/</span></span><br><span class="line">     <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">2</span> ;i++) &#123;</span><br><span class="line">         id_val = ior(db, DM9000_VIDL);</span><br><span class="line">         id_val |= (u32)ior(db, DM9000_VIDH) &lt;&lt; <span class="number">8</span>;</span><br><span class="line">         id_val |= (u32)ior(db, DM9000_PIDL) &lt;&lt; <span class="number">16</span>;</span><br><span class="line">         id_val |= (u32)ior(db, DM9000_PIDH) &lt;&lt; <span class="number">24</span>;</span><br><span class="line">         ...</span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>arch/arm/plat-s3c24xx/common-smdk.c</code>文件中的<code>s3c-dm9k_resource</code>结构中有3个数组项，表示有3个资源，所以pdev-&gt;num_resources数值为3，将执行第9行的分支。<br>参考第10-第20行的代码，可以知道<code>s3c_dm9k_resource</code>结构中定义的两个内存空间经过映射后，它们的虚拟基地址保存在db-&gt;io_addr和db-&gt;io_data中，下面可以看到它们如何使用的。ndev-&gt;irq中保存了中断号。<br>第25-26行根据<code>arch/arm/plat-s3c24xx/common-smdk.c</code>文件中的s3c_dm9k_platdata结构指定的访问位宽，设置了相关的读写函数。<br>现在来看看程序中是如何使用db-&gt;id_addr和db-&gt;id_data来访问DM9000的。第29行的<code>dm9000_reset</code>函数如下定义，先往地址db-&gt;io_addr写入值DM9000_NCR，再往地址db-&gt;io_data写入NCR_RST就可以复位DM9000。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dm9000_reset</span><span class="params">(<span class="type">board_info_t</span> *db)</span></span><br><span class="line">&#123;</span><br><span class="line">     PRINTK(<span class="string">&quot;dm9000x: resetting\n&quot;</span>);</span><br><span class="line">     <span class="comment">/*RESET device*/</span></span><br><span class="line">     writeb(DM9000_CNR, db-&gt;io_addr);</span><br><span class="line">     udelay(<span class="number">200</span>);</span><br><span class="line">     writeb(NCR_RST, db-&gt;io_data);</span><br><span class="line">     udelay(<span class="number">200</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>ior</code>用来读取DM9000的寄存器，它的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> u8</span><br><span class="line"><span class="title function_">ior</span><span class="params">(<span class="type">board_info_t</span> *db, <span class="type">int</span> reg)</span></span><br><span class="line">&#123;</span><br><span class="line">     writeb(reg, db-&gt;io_addr);<span class="comment">//先往地址db-&gt;io_addr写入寄存器地址</span></span><br><span class="line">     <span class="keyword">return</span> readb(db-&gt;io_data);<span class="comment">//再从地址db-&gt;io_data读出数值</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>iow</code>用来写DM9000的寄存器，它的定义如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">iow</span><span class="params">(<span class="type">board_info_t</span> *db, <span class="type">int</span> reg, <span class="type">int</span> value)</span></span><br><span class="line">&#123;</span><br><span class="line">     writeb(reg, db-&gt;io_addr);<span class="comment">//先往地址db-&gt;addr写入寄存器地址</span></span><br><span class="line">     writeb(value,db-&gt;io_data);<span class="comment">//再将数值写入地址db-&gt;io_data</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>驱动源码修改：<code>drivers/net/dm9000.c</code></p>
<ol>
<li>添加要包含的头文件，增加以下代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch-s3c2410/regs-mem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>设置存储控制器使BANK4可用，设置默认MAC地址。<br>增加的代码如下，它们被宏CONFIG_ARCH_S3C2410包含起来：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dm9000_probe</span><span class="params">(<span class="keyword">struct</span> platform_device *pdev)</span></span><br><span class="line">&#123;</span><br><span class="line">     ...</span><br><span class="line">     <span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> oldval_bwscon;         <span class="comment">//用来保存BWSCON寄存器的值</span></span><br><span class="line">     <span class="type">unsigned</span> <span class="type">int</span> oldval_bankcon4;       <span class="comment">//用来保存S3C2410BANKCON4寄存器的值</span></span><br><span class="line">     <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     ...</span><br><span class="line">     PRINTK(<span class="string">&quot;dm9000_probe()\n&quot;</span>);</span><br><span class="line">     <span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">     <span class="comment">/*设置Bank4：总线宽度为16，使能nWAIT*/</span></span><br><span class="line">     oldval_bwscon = *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>*)S3C2410_BWSCON);</span><br><span class="line">     *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>*)S3C2410_BWSCON) = (oldval_bwscon &amp; ~(<span class="number">3</span> &lt;&lt; <span class="number">16</span>)) \</span><br><span class="line">         | S3C2410_BWSCON_DW4_16 | S3C2410_BWSCON_WS4 | S3C2410_BWSCON_ST4;</span><br><span class="line">     <span class="comment">/*设置BANK3的时间参数*/</span></span><br><span class="line">     oldval_bankcon4 = *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BANKCON4);</span><br><span class="line">     *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BANKCON4) = <span class="number">0x1f7c</span>;</span><br><span class="line">     <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     ...</span><br><span class="line">     <span class="keyword">if</span>(!is_valid_ether_addr(ndev-&gt;dev_addr)) &#123;</span><br><span class="line">         printk(<span class="string">&quot;%s: Invalid ethernet MAC address. Please set using ifconfig\n&quot;</span>,ndev-&gt;name);</span><br><span class="line">         <span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">         printk(<span class="string">&quot;Now use the default MAC address: 08:90:90:90:90:90\n&quot;</span>);</span><br><span class="line">         ndev-&gt;dev_addr[<span class="number">0</span>] = <span class="number">0x08</span>;</span><br><span class="line">         ndev-&gt;dev_addr[<span class="number">1</span>] = <span class="number">0x90</span>;</span><br><span class="line">         ndev-&gt;dev_addr[<span class="number">2</span>] = <span class="number">0x90</span>;</span><br><span class="line">         ndev-&gt;dev_addr[<span class="number">3</span>] = <span class="number">0x90</span>;</span><br><span class="line">         ndev-&gt;dev_addr[<span class="number">4</span>] = <span class="number">0x90</span>;</span><br><span class="line">         ndev-&gt;dev_addr[<span class="number">5</span>] = <span class="number">0x90</span>;</span><br><span class="line">         <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     &#125;</span><br><span class="line">     ...</span><br><span class="line">     out:</span><br><span class="line">         printk(<span class="string">&quot;%s:not found (%d).\n&quot;</span>,CARDNAME,ret);</span><br><span class="line">     <span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">     <span class="comment">/*恢复寄存器原来的值*/</span></span><br><span class="line">     oldval_bwscon = *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span>*)S3C2410_BWSCON);</span><br><span class="line">     oldval_bankcon4 = *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BANKCON4);</span><br><span class="line">     <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注册中断时，指定触发方式<br>在<code>dm9000_open</code>中使用<code>request_irq</code>函数注册中断处理函数，修改它即可。DM9000的中断触发方式为上升沿触发。修改代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span></span><br><span class="line"><span class="title function_">dm9000_open</span><span class="params">(<span class="keyword">struct</span> net_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">     <span class="type">board_info_t</span> *db = (<span class="type">board_info_t</span> *)dev-&gt;priv;</span><br><span class="line"></span><br><span class="line">     PRINTF2(<span class="string">&quot;entering dm9000_open\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">     <span class="meta">#<span class="keyword">if</span> defined(CONFIG_ARCH_S3C2410)</span></span><br><span class="line">     <span class="keyword">if</span>(request_irq(dev-&gt;irq, &amp;dm9000_interrupt, IRQF_SHARED | IRQF_TRIGGER_RISING,dev-&gt;name,dev))</span><br><span class="line">     <span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">     <span class="keyword">if</span>(request_irq(dev-&gt;irq, &amp;dm9000_interrupt, IRQF_SHARED ,dev-&gt;name,dev))</span><br><span class="line">     <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">     ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="使用网卡DM9000"><a href="#使用网卡DM9000" class="headerlink" title="使用网卡DM9000"></a>使用网卡DM9000</h3><p>在内核根目录下执行“make menuconfig”命令后，如下配置内核将DM9000编译入内核</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">    Network device support ---&gt;</span><br><span class="line">        [*] Network device support</span><br><span class="line">            Ethernet (10 or 100Mbit) ---&gt;</span><br><span class="line">                &lt;*&gt; DM9000 support</span><br></pre></td></tr></table></figure>
<p>然后编译内核，执行“make uImage”命令即可生成<code>arch/arm/boot/uImage</code>。<br>它的使用方法与上面介绍的CS8900A一样，需要注意一下两点。</p>
<ol>
<li>如果内核中同时加载了CS8900A和DM9000，分别使用eth0、eth1表示它们。如果它们都是编译进内核的，则eth0表示CS8900A、eth1表示DM9000。如果作为模块加载，则根据它们的加载顺序先后使用eth0、eth1来表示。</li>
<li>如果要同时使用CS8900A和DM9000，它们的IP不能是同一网段。<br>从两款网卡芯片CS8900A和DM9000的移植过程，读者可以了解到移植、修改标准驱动程序的方法：了解驱动程序框架，确定外设使用的资源，然后将它们告诉驱动程序，并进行适当设置使它们可用。串口驱动程序移植、网卡驱动移植都遵循这个步骤。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第4篇第22章 网卡驱动移植</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux应用程序调试技术</title>
    <url>/2022/10/20/Linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统应用开发之Linux应用程序调试技术</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第27章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>掌握使用strace工具跟踪系统调用和信号的方法</li>
<li>掌握各类内存测试工具，比如memwatch</li>
<li>掌握使用库函数backtrace和backtrace_symbols来定位段错误</li>
</ol>
<h1 id="使用strace工具跟踪系统调用和信号"><a href="#使用strace工具跟踪系统调用和信号" class="headerlink" title="使用strace工具跟踪系统调用和信号"></a>使用strace工具跟踪系统调用和信号</h1><h2 id="strace介绍及移植"><a href="#strace介绍及移植" class="headerlink" title="strace介绍及移植"></a>strace介绍及移植</h2><h3 id="strace介绍"><a href="#strace介绍" class="headerlink" title="strace介绍"></a>strace介绍</h3><p>strace是一个很有用的诊断、学习、调试工具。使用时无需重新编译程序，这也使得可以用来跟踪没有源代码的程序。系统调用和信号是发生在用户空间和内核空间边界处的事件，检查这些边界事件有助于隔离错误、检查完整性、跟踪程序。<br>使用strace工具来执行程序时，它会记录程序执行过程中调用的系统调用、接收到的信号。通过查看记录结果，可以知道程序打开了哪些文件、是否打开成功、对文件进行了哪些读写操作、映射了哪些内存、向系统申请了多少内存等。</p>
<h3 id="strace移植"><a href="#strace移植" class="headerlink" title="strace移植"></a>strace移植</h3><p>略</p>
<h2 id="使用strace来调试程序"><a href="#使用strace来调试程序" class="headerlink" title="使用strace来调试程序"></a>使用strace来调试程序</h2><h3 id="strace的用法"><a href="#strace的用法" class="headerlink" title="strace的用法"></a>strace的用法</h3><p>直接运行strace可以看到它的用法，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace</span><br><span class="line">usage：strace [-dffhiqrttTvVxx] [-a column] [-e expr] ... [-o file]</span><br><span class="line">            [-p pid] ... [-s strsize] [-u username] [-E val=val] ...</span><br><span class="line">            [command [arg ...]]</span><br><span class="line">    or: strace -c [-e expr] ... [-O overhead] [-S sortby] [-E var=val] ...</span><br><span class="line">        [command [arg ...]]</span><br></pre></td></tr></table></figure>
<p>上面的“[command [arg …]]”表示要执行的程序及其参数；前面是各种选项。下面是几个常用的选项。<br>-f：除了跟踪当前进程外，还跟踪其子进程。<br>-o file：将输出信息写到文件file中，而不是显示到标准错误输出（stderr）。<br>-p pid：绑定到一个由pid对应的正在运行的进程。此参数常用来调试后台进程。<br>-t：打印各个系统调用被调用时的绝对时间，想观察程序的各部分的执行时间可以使用这个选项。<br>-tt：与选项t相似，打印时间精度为μs。<br>-r：与选项t相似，打印时间为相对时间</p>
<h3 id="strace输出结果分析"><a href="#strace输出结果分析" class="headerlink" title="strace输出结果分析"></a>strace输出结果分析</h3><p>使用strace的最简单的例子为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strace cat /dev/null</span><br></pre></td></tr></table></figure>
<p>它的输出结果如下，其中的省略号表示还有其他系统调用</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">execve(<span class="string">&quot;/bin/cat&quot;</span>,[<span class="string">&quot;cat&quot;</span>,<span class="string">&quot;/dev/null&quot;</span>],[<span class="comment">/*6 vars */</span>]) = <span class="number">0</span></span><br><span class="line">... ...</span><br><span class="line">open(<span class="string">&quot;/lib/librcypto.so.1&quot;</span>,O_RDONLY) = <span class="number">3</span></span><br><span class="line">... ...</span><br><span class="line">open(<span class="string">&quot;/lib/libm.so.6&quot;</span>,O_RDONLY) = <span class="number">3</span></span><br><span class="line">... ...</span><br><span class="line">open(<span class="string">&quot;/lib/libc.so.6&quot;</span>,O_RDONLY) = <span class="number">3</span></span><br><span class="line">... ...</span><br><span class="line">open(<span class="string">&quot;/dev/null&quot;</span>,O_RDONLY | O_LARGEFILE) = <span class="number">3</span></span><br><span class="line">read(<span class="number">3</span>,<span class="string">&quot;&quot;</span>,<span class="number">8192</span>) = <span class="number">0</span></span><br><span class="line">close(<span class="number">3</span>) = <span class="number">0</span></span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>第1行表示通过系统调用execve来建立一个进程，他就是“cat &#x2F;dev&#x2F;null”对应的进程。在控制台中执行各种命令，比如“ls”、“cd”时，都是通过系统调用execv来建立它们进程的。通过strace，可以看到程序运行的细节。<br>第2-7行打开动态链接库，如果cat程序是静态链接的，这几个步骤将不需要。<br>第9-10行才是“cat &#x2F;dev&#x2F;null”命令的真正处理过程，首先打开“&#x2F;dev&#x2F;null”文件，然后读取它的内容。<br>在strace的输出过程中，每一行对应一个系统调用：左起是系统调用的名字，紧接着是被包含在括号中的参数，最后是它的返回值，比如上面输出结果的第7行。<br>系统调用出错时（返回值通常是-1），在返回值的后面会打印错误记号及其注释，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;/foo/bar&quot;</span>,O_RDONLY) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br></pre></td></tr></table></figure>
<p>接收信号时会将信号记号及其注释打印出来，比如执行以下命令使用strace在后台开启一个sleep进程，然后向这个进程发送SIGINT信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strace -o sleep.<span class="built_in">log</span> sleep <span class="number">100</span> &amp;</span><br><span class="line">kill -INT <span class="number">868</span>   <span class="comment">//假设sleep的进程号为868，可以使用ps命令查看</span></span><br></pre></td></tr></table></figure>
<p>在sleep.log文件中可以发现如下字样，表示接收到SIGINT信号，它是“Interrupt”信号。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">--- SIGINT (Interrupt) @ <span class="number">0</span> (<span class="number">0</span>) ---</span><br><span class="line">+++ killed by SIGINT +++</span><br></pre></td></tr></table></figure>
<p>对系统调用的参数，有多种打印格式，往往让人一目了然。下面是一些常见的格式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;xyzzy&quot;</span>,O_WRONLY | O_APPEND | O_CREATE, <span class="number">0666</span>) = <span class="number">3</span></span><br><span class="line">lstat(<span class="string">&quot;/dev/null&quot;</span>,&#123;st_mode = S_IFCHR | <span class="number">0666</span>,st_rdev = makede(<span class="number">1</span>,<span class="number">3</span>),...&#125;) = <span class="number">0</span></span><br><span class="line">lstat(<span class="string">&quot;/foo/bar&quot;</span>,<span class="number">0xb004</span>) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">read(<span class="number">3</span>,<span class="string">&quot;root::0:0:System Administrator:/&quot;</span>...,<span class="number">1024</span>) = <span class="number">422</span></span><br></pre></td></tr></table></figure>
<p>第1行的系统调用open有3个参数，第一个为文件名，使用字符串格式表示；第二个为flag标志，它由3个按位相或的宏组成；第三个为mode参数，它使用八进制表示。<br>第2行系统调用lstat的第二个参数的数据类型为“struct stat”，它被展开了。lstat的第一个参数是输入参数，第二个参数是输出参数。如果系统调用失败，相应的输出参数不会被展开，比如第3行的第二个参数。<br>当参数是字符串指针时，这些字符串将被打印出来。默认只打印字符串的前32字节，其余字节使用省略号表示，这个省略号紧跟在双引号包含起来的被打印字符之后，比如第4行的第二个参数。<br>对于比较简单的指针或者数组，它们的内容被中括号包含起来，其中的各个元素使用逗号来分离，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">getgroups(<span class="number">32</span>,[<span class="number">100</span>,<span class="number">0</span>]) = <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>最后，位的集合（bit-sets）也是使用中括号包含起来的，其中的元素以空格分离，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_BLOCK,[CHLD TTOU],[ ]) = <span class="number">0</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第二个参数是两个信号SIGCHLD和SIGTTOU的集合。有时候集合的元素很多，只打印出不使用的元素比较直观，这时可以加上前缀“&#96;”，比如下面语句中第二个参数表示信号的全集：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sigprocmask(SIG_UNBLOCK,`[],<span class="literal">NULL</span>) = <span class="number">0</span></span><br></pre></td></tr></table></figure>

<h3 id="调试程序"><a href="#调试程序" class="headerlink" title="调试程序"></a>调试程序</h3><p>在前面移植基于X的GUI程序时，就多次使用strace工具来跟踪程序，根据其中的出错信息建立一些必需的目录，复制字库到特定的目录等。当不了解一个程序依赖于哪些目录和文件时，可以使用strace工具来跟踪它。<br>下面举几个例子来说明如何使用strace来调试程序。</p>
<ol>
<li>使用strace来定位gtkboard的警告信息。<br>通过以下命令启动gtkboard。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strace -o gtkboard.log gtkboard &amp;   </span><br></pre></td></tr></table></figure>
然后查看gtkboard.log文件，发现如下字样：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open(<span class="string">&quot;/usr/lib/gconv/gconv-modules.cache&quot;</span>,O_RDONLY) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">open(<span class="string">&quot;/usr/lib/gconv/gconv-modules&quot;</span>,O_RDONLY) = <span class="number">-1</span> ENOENT (No such file or directory)</span><br><span class="line">write(<span class="number">2</span>,<span class="string">&quot;\n(gtkboard:855):GLib-WARNING **&quot;</span>...,<span class="number">82</span>) = <span class="number">82</span></span><br></pre></td></tr></table></figure>
而交叉编译工具链中lib目录下刚好有gconv目录，把它复制到开发板根文件系统的&#x2F;usr&#x2F;lib目录后重新启动gtkboard，这些警告信息消失。</li>
<li>使用strace来测量程序的执行时间<br>如果发现某个程序突然执行得很慢，通常需要找出其中哪部分代码执行得时间过长。使用strace工具可以轻松达到这个目的。<br>执行以下命令，可以发现第2行和第3行的时间相差2s左右，符合“sleep2”意图。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">strace -r sleep <span class="number">2</span></span><br><span class="line">... ...</span><br><span class="line"><span class="number">01</span>   <span class="number">0.002608</span> rt_sigprocmask(SIG_SETMASK, [], <span class="literal">NULL</span>, <span class="number">8</span>) = <span class="number">0</span></span><br><span class="line"><span class="number">02</span>   <span class="number">0.002392</span> nanosleep(&#123;<span class="number">2</span>,<span class="number">0</span>&#125;, &#123;<span class="number">2</span>,<span class="number">0</span>&#125;) = <span class="number">0</span></span><br><span class="line"><span class="number">03</span>   <span class="number">2.005517</span> exit_group(<span class="number">0</span>) = ?</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="内存调试工具"><a href="#内存调试工具" class="headerlink" title="内存调试工具"></a>内存调试工具</h1><h2 id="使用memwatch进行内存调试"><a href="#使用memwatch进行内存调试" class="headerlink" title="使用memwatch进行内存调试"></a>使用memwatch进行内存调试</h2><h3 id="memwatch介绍"><a href="#memwatch介绍" class="headerlink" title="memwatch介绍"></a>memwatch介绍</h3><p>段错误与内存错误是C语言编程中经常碰到的问题，段错误的调试与解决在下节描述。所以内存错误是指使用动态分配的内存时出现的各种错误，比如内存泄漏（malloc分配的内存没有使用free释放掉）和缓冲区溢出（例如对越界存储动态分配的内存）是一些常见的问题。<br>memwatch是一个开放源代码的C语言内存错误检测工具。它可以跟踪程序中的内存泄露和错误，支持ANSI C，提供结果日志记录，能检测双重释放（double free）、错误释放（erroneous free）、没有释放的内存（unfreed memory）、溢出和下溢等。<br>memwatch并不是一个可以单独运行的程序，它提供一套实现动态内存管理、检测的代码，用它们来代替C库中的相关函数。它有两个文件：memwatch.h和memwatch.c。前者将malloc、free等库函数重新定义为在memwatch.c中实现的相应库函数，部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> malloc(n)       mwMalloc(n,__FILE__,__LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> strdup(n)       mwStrdup(p,__FILE__,__LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> realloc(p,n)    mwRealloc(p,n,__FILE__,__LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> calloc(n,m)     mwCalloc(n,m,__FILE__,__LINE__)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> free(n)         mwFree(p,__FILE__,__LINE__)</span></span><br></pre></td></tr></table></figure>

<h3 id="memwatch调试实例"><a href="#memwatch调试实例" class="headerlink" title="memwatch调试实例"></a>memwatch调试实例</h3><p>要使用memwatch，需要完成以下3点：</p>
<ol>
<li>在代码中加入头文件memwatch.h</li>
<li>程序的代码与memwatch.c一起编译、链接</li>
<li>使用gcc编译器进行编译时要定义宏MEMWATCH、MEMWATCH_STDIO，即在编译程序时增加“-DMEMWATCH -DMEMWATCH_STDIO”标志</li>
</ol>
<p>测试代码memtest.c代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;memwatch.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *ptr1;</span><br><span class="line">    <span class="type">char</span> *ptr2;</span><br><span class="line"></span><br><span class="line">    ptr1 = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line">    ptr2 = <span class="built_in">malloc</span>(<span class="number">512</span>);</span><br><span class="line"></span><br><span class="line">    ptr1[<span class="number">512</span>] = <span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">    ptr2 = ptr1;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">free</span>(ptr2);</span><br><span class="line">    <span class="built_in">free</span>(ptr1);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>其中第13行的错误为缓冲区溢出；第15行修改ptr2变量后的值，将导致第17、18行释放ptr1对应的内存两次（double-free），而原来的ptr2对应的内存没有被释放。<br>下面使用memwatch查看是否能检查出这些错误。</p>
<ol>
<li>源文件memtest.c在第3行中包含了头文件memwatch.h</li>
<li>Makefile内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">CC=arm-linux-gcc</span><br><span class="line">CFLAGS=-DMEMWATCH -DMEMWATCH_STDIO</span><br><span class="line"></span><br><span class="line">memtest: memtest.o memwatch.o</span><br><span class="line">     $(CC) -o $@ $^</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">     $(CC) $(CFLAGS) -c -o $@ $^</span><br><span class="line">clean:</span><br><span class="line">     rm -f   memtest *.o</span><br></pre></td></tr></table></figure>
基于该Makefile生成的可执行文件memtest，将它复制到根文件系统下运行，会生成一个记录文件memwatch.log，其内容如下图：<br><img src="/2022/10/20/Linux%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E8%B0%83%E8%AF%95%E6%8A%80%E6%9C%AF/1.jpeg" alt="img not found"><br>第9行表示发生了缓冲区上溢，“memtest.c(17)”并不是表示在memtest.c是第17行发生了上溢，他表示这个错误是当程序执行到memtest.c的第17行“free(ptr2)”时才检测到的；“512 bytes alloc’d at &lt;1&gt; memtest.c(10)”表示这个出错的缓冲区大小为512字节，是在memtest.c的第10行分配的。根据这些信息查看代码，可以容易的发现是memtest.c的第13行代码导致这个错误。<br>第10行表示发生了双重释放（double-free）的错误，其中的“memtest.c(18)”表示这个错误是当程序执行到memtest.c的第18行“free(ptr1)”时才检测到的；“0x1a1fc was freed from memtest.c(17)”表示首地址为0x1a1fc的内存在memtest.c的第17行已经被释放过了。<br>第14行表示有一块内存没被释放（unfreed memory），“memtest.c(11),512 bytes at 0x1a42c”表示这块内存是在memtest.c的第11行分配，大小为512字节，首地址为0x1a42c。<br>第16-20行是一些统计信息：第17行表示了分配了两次内存，第18行表示程序结束时能够使用的最大动态内存，第19行表示总共分配的动态内存，第20行表示未释放的内存。</li>
</ol>
<h2 id="其他内存工具介绍：mtrace、dmalloc、yamd"><a href="#其他内存工具介绍：mtrace、dmalloc、yamd" class="headerlink" title="其他内存工具介绍：mtrace、dmalloc、yamd"></a>其他内存工具介绍：mtrace、dmalloc、yamd</h2><p>略</p>
<h1 id="段错误的调试方法"><a href="#段错误的调试方法" class="headerlink" title="段错误的调试方法"></a>段错误的调试方法</h1><h2 id="使用库函数backtrace和backtrace-symbols定位段错误"><a href="#使用库函数backtrace和backtrace-symbols定位段错误" class="headerlink" title="使用库函数backtrace和backtrace_symbols定位段错误"></a>使用库函数backtrace和backtrace_symbols定位段错误</h2><p>访问没有权限或是不存在的内存时，会产生段错误（Segmentation fault），它很常见，比如访问空字符串等都会引起这类错误。<br>使用库函数backtrace和backtrace_symbols来进行栈回溯，可以知道发生错误时函数的调用关系，这不依赖于其他工具，这两个函数的原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">backtrace</span><span class="params">(<span class="type">void</span> **buffer,<span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">char</span> **<span class="title function_">backtrace_symbols</span><span class="params">(<span class="type">void</span> *<span class="type">const</span> buffer,<span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>C语言中，A函数调用B函数时，会在栈中保存一个地址，当B函数执行完毕后，程序返回这个地址继续执行；而这个地址处于A函数中，可以根据B函数的返回地址反向找到它的调用者A。根据栈中的返回地址向上回溯栈，一级一级的找到各个调用函数，就可以得到完整的调用关系。<br>backtrace函数就是利用这个原理得到这些调用关系的，它分析栈的内容，找到各级调用的返回地址，将它们保存在字符串数组buffer中，最大数目由参数size决定，它的返回值表示所确定的返回地址的数目。如果返回值小于或等于参数size，表示栈中所有的内容都被分析了；如果栈很大。要想回溯所有内容，就需要增大字符串数组buffer、增大参数size。<br>backtrace_symbols函数将这些返回地址转换为描述性的字符串，返回地址保存在字符串数组buffer中，参数size表示它们的数目。这些描述性的字符串的格式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">程序名（函数名+偏移）[返回地址]</span><br></pre></td></tr></table></figure>
<p>其中的“函数名”是根据返回地址找找到的函数名称，偏移是这个返回地址与这个函数的首地址之间的偏移。如果找不到函数名称，则小括号中的“（函数名+偏移）”不打印。<br>backtrace_symbols函数将这些描述性字符保存在一个字符串数组中，作为它的返回值。需要注意，使用完毕后这个字符串数组需要释放掉，但是它的元素（即各个字符串）不需要也不能释放。<br>综上所述，库函数backtrace和backtrace_symbols通常一起使用，实例代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DebugBacktrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">array</span>[SIZE];</span><br><span class="line">    <span class="type">int</span> size,i;</span><br><span class="line">    <span class="type">char</span> **strings;</span><br><span class="line"></span><br><span class="line">    size = backtrace(<span class="built_in">array</span>,SIZE);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;\nBacktrace (%d deep):\n&quot;</span>,size);</span><br><span class="line">    strings = backtrace_symbols(<span class="built_in">array</span>,size);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; size; i++)    </span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;%d: %s\n&quot;</span>,i,strings[i]);</span><br><span class="line">    <span class="built_in">free</span>(strings);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这两个函数能显示正确的结果是基于一下假设的。</p>
<ol>
<li>编译程序时，gcc的优化选项是0。</li>
<li>内联（inline）函数没有栈。</li>
<li>尾调用的优化使得一个“stack frame”替换另一个“stack frame”</li>
</ol>
<p><em><strong>连接程序时，使用“-rdynamic”选项，这使得程序包含更多的符号（symbol）。静态（static）函数的符号没有导出来，所以使用这些函数进行回溯时无法找到静态函数的符号</strong></em></p>
<h2 id="段错误调试实例"><a href="#段错误调试实例" class="headerlink" title="段错误调试实例"></a>段错误调试实例</h2><p>当程序发生段错误时，内核会向程序发送SIGSEGV信号，这个信号的默认处理行为是使程序退出。可以修改信号处理函数，在程序退出之前就使用库函数backtrace和backtrace_symbols打印出函数的调用关系，这有助于找到出错的代码及出错原因。<br>这需要修改代码，只要将SIGSEGV信号的处理函数设为DebugBacktrace函数即可。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;execinfo.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> b)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> c)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DebugBacktrace</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">A</span><span class="params">(<span class="type">int</span> a)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: A call B\n&quot;</span>,a);</span><br><span class="line">    B(<span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">B</span><span class="params">(<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: B call C\n&quot;</span>,b);</span><br><span class="line">    C(<span class="number">3</span>);<span class="comment">//这个函数调用将导致段错误</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">C</span><span class="params">(<span class="type">int</span> c)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *p = (<span class="type">char</span> *)c;</span><br><span class="line">    *p = <span class="string">&#x27;A&#x27;</span>;<span class="comment">//如果参数c不是一个可用的地址值，则这条语句导致段错误</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d: function C\n&quot;</span>,c);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//SIGSEGV信号的处理函数，回溯栈，打印函数的调用关系</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DebugBacktrace</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line">    <span class="type">void</span> *<span class="built_in">array</span>[SIZE];</span><br><span class="line">    <span class="type">int</span> size,i;</span><br><span class="line">    <span class="type">char</span> **strings;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;\nSegmentation fault\n&quot;</span>);</span><br><span class="line">    size = backtrace(<span class="built_in">array</span>,SIZE);</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">&quot;Backtrace (%d deep):\n&quot;</span>,size);</span><br><span class="line">    strings = backtrace_symbols(<span class="built_in">array</span>,size);</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; size; i++)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;%d: %s\n&quot;</span>,i,strings[i]);</span><br><span class="line">    <span class="built_in">free</span>(strings);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置SIGSEGV信号的处理函数</span></span><br><span class="line">    signal(SIGSEGV,DebugBacktrace);</span><br><span class="line"></span><br><span class="line">    A(<span class="number">1</span>);</span><br><span class="line">    C(&amp;a);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>第1-27行的代码定义了A、B、C共3个函数，A调用B，B调用C。在函数C中，第24、25行的代码有漏洞，如果参数c不是一个可用的地址值，则第25行赋值语句导致段错误。在函数B中，故意使第19行调用函数C时传入一个非法地址。<br>第30行是信号处理函数，它通过库函数backtrace和backtrace_symbols获得并打印函数的调用关系后，退出程序（第44行）。这个函数是本实例的重点，读者可以在自己的应用程序代码中加入这个函数，然后使用第52行的函数将它设为SIGSEGV信号的处理函数。<br>segfault.c的Makefile如下，可以看到，编译时选项为“-g -O0”，连接时的选项为“-rdynamic”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CC=arm-linux-gcc</span><br><span class="line">CFLAGS=-g -O0</span><br><span class="line">LDFLAGS=-rdynamic</span><br><span class="line"></span><br><span class="line">segfault: segfault.o</span><br><span class="line">    $(CC) $(LDFLAGS) -o $@ $^</span><br><span class="line"></span><br><span class="line">%.o: %.c</span><br><span class="line">    $(CC) $(CFLAGS) -c -o $@ $^</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">    rm -rf segfault *.o</span><br></pre></td></tr></table></figure>
<p>执行make命令生成可执行程序segfault，运行后可以看到如下信息:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">segfault</span><br><span class="line"><span class="number">1</span>:  A call B</span><br><span class="line"><span class="number">2</span>:  B call C</span><br><span class="line"></span><br><span class="line">Segmentation fault</span><br><span class="line"><span class="title function_">Backtrace</span> <span class="params">(<span class="number">6</span> deep)</span>:</span><br><span class="line">0: <span class="title function_">segfault</span><span class="params">(DebugBacktrace+<span class="number">0x30</span>)</span> [0x89b4]</span><br><span class="line">1: /lib/libc.so.6 [0x4004bd10]</span><br><span class="line">2: <span class="title function_">segfault</span><span class="params">(B+<span class="number">0x28</span>)</span> [0x893c]</span><br><span class="line">3: <span class="title function_">segfault</span><span class="params">(A+<span class="number">0x28</span>)</span> [0x890c]</span><br><span class="line">4: <span class="title function_">segfault</span><span class="params">(main+<span class="number">0x2c</span>)</span> [0x8a84]</span><br><span class="line">5: /lib/libc.so.6<span class="params">(__libc_start_main+<span class="number">0xe4</span>)</span> [0x40034f14]</span><br></pre></td></tr></table></figure>
<p>标号0-5行表示从下到上的函数调用关系：标号5的__libc_start_main函数调用第4行的main函数，main函数调用标号3的A函数，A函数调用标号2的B函数。B调用C时出错，这导致内核发出SIGSEGV信号，这时正常的流程被打断，信号处理函数DebugBacktrace被强行调用，标号1、0的行表示处理信号时的函数调用关系。<br>从这几个标号可以看出，当main函数调用A、A调用B时，出现段错误。这些调用关系可以帮助开发人员缩小定位错误的范围，在很复杂的程序中尤其如此。<br>从上面的输出信息“2: segfault (B + 0x28)[0x893c]”中可以知道，B函数调用的某个函数的返回地址为0x893c，这个地址前面的语句就是调用下一级函数。<br>单从这些调用关系还是不能直接看出是在函数C中出错，这时要用到segfault程序的反汇编代码。使用下面的指令进行反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-objdump -D segfault &gt; segfault.dis</span><br></pre></td></tr></table></figure>
<p>反汇编文件segfault.dis的部分内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00008914&lt;B&gt;:</span><br><span class="line">    ... ...</span><br><span class="line">    8938: eb000001  b1  8944&lt;C&gt;</span><br><span class="line">    893c: e89da808  ldmia   sp, &#123;r3,fp,sp,pc&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到，返回地址0x893c前面的代码调用函数C，所以可以确定是在函数C出错。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第4篇第27章 Linux应用程序调试技术</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux 应用程序</tag>
      </tags>
  </entry>
  <entry>
    <title>LCD和USB驱动程序移植</title>
    <url>/2022/10/19/LCD%E5%92%8CUSB%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux设备驱动开发之LCD和USB驱动程序移植</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第24章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解TTY层下LCD和USB键盘驱动程序的框架</li>
<li>掌握移植LCD驱动程序的方法</li>
<li>使用LCD和USB设备</li>
</ol>
<h1 id="LCD驱动程序移植"><a href="#LCD驱动程序移植" class="headerlink" title="LCD驱动程序移植"></a>LCD驱动程序移植</h1><h2 id="LCD和USB键盘驱动程序框架"><a href="#LCD和USB键盘驱动程序框架" class="headerlink" title="LCD和USB键盘驱动程序框架"></a>LCD和USB键盘驱动程序框架</h2><h3 id="框架概述"><a href="#框架概述" class="headerlink" title="框架概述"></a>框架概述</h3><p>具备人机交互功能的串口可以作为控制台和终端，同样，LCD和键盘组合起来也可以。<br>对LCD的操作可以像串口一样，通过终端设备层的封装（&#x2F;dev&#x2F;ttyx设备）来输出内容，也可以通过frame buffer（&#x2F;dev&#x2F;fbx）直接再显存上绘制图像。<br>frame buffer即帧缓冲，是一种独立于硬件的抽象图形设备，它使得应用程序可以通过一组定义良好的接口访问各类图形设备，不需要了解底层硬件细节。从用户的观点来看，frame buffer设备与&#x2F;dev目录下其他设备没有区别，通过&#x2F;dev&#x2F;fbx设备文件来访问它（fb0表示第一个frame buffer设备、fb1表示第二个、…）。<br>frame buffer设备提供了一些ioctl接口来查询、设置图形设备的属性，比如分辨率、像素位宽等，另外，它属于“普通的”内存设备，类似&#x2F;dev&#x2F;mem：可以读（read）、写（write）、移动访问位置（seek）以及将这块内存映射给用户（mmap）。不同的是frame buffer的内存不是所有的内存，而是显卡专用的内存。应用程序可以直接更改frame buffer内存中的数据，效果立刻就能在显示器中看到。<br>&#x2F;de&#x2F;&#x2F;tty1等终端设备文件通过显示驱动程序和键盘驱动程序（还有其他输入设备，比如触摸屏）为它们提供输出、输入功能。<br>TTY和frame buffer驱动程序的框架如下图所示，输入设备以USB键盘为例：<br><img src="/2022/10/19/LCD%E5%92%8CUSB%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/1.jpeg" alt="img not found"><br><code>drivers/char/vt.c</code>用来支持显示器&#x2F;键盘组成的终端设备，之所以被称为“虚拟终端”，是因为可以在一个物理终端设备上运行多个“虚拟终端”（也叫虚拟控制台），比如可以使用第一个虚拟终端来显示系统信息，使用第2个虚拟终端来运行文本模式程序，第3个虚拟终端来运行图形程序。它们可以同时运行，使用一些组合键可以切换到某个虚拟终端上。<br>虚拟终端层管理着这些虚拟终端，比如为它们分配缓冲区、切换虚拟终端时把它的内容输出到显示器、键盘有输入时把数据填入到当前终端的缓冲区中。它向上提供了封装好的接口，向下通过调用显示器&#x2F;键盘的接口完成输入输出功能。</p>
<ol>
<li>显示驱动程序<br><code>drivers/console/fbcon.c</code>文件向上提供了一个很重要的数据结构fb_con，所有的输出都是通过fb_con中的成员函数来实现的，bitblit.c、font.c也都处于<code>drivers/console</code>目录下，它们和<code>drivers/video/fbmem.c</code>一起，实现fb_con结构中的函数。另外，fbmem.c是frame buffer驱动程序，它向应用层提供&#x2F;dev&#x2F;fbx设备的访问接口，应用程序可以通过它绘制图形。<br><code>drivers/video/s3c2410fb.c</code>文件是架构相关的代码，它实现LCD控制器的初始化、向fbmem.c注册frame buffer设备，并提供一些与架构相关的函数，比如设置分辨率、像素位宽等需要设置操作寄存器的函数。</li>
<li>键盘驱动程序<br><code>drivers/input/input.c</code>表示“输入设备”，有键盘、鼠标等。<code>drivers/keyboard.c</code>是键盘驱动程序的封装，在它的下边，可以是一般的键盘，也可以是符合HID规范的键盘。HID是英文“Human Interface Device”得缩写，它通常指USB-HID规范，但是也有其他类型的遵循HID规范的设备（比如蓝牙键盘、蓝牙鼠标）。所以<code>drivers/hid-core.c</code>、<code>hid-input.c</code>两个文件将HID规范的共性提炼出来，它们的下面是各类具体实现，比如USB的<code>drivers/hid/hidusb/hid-core.c</code>、<code>hid-quirks.c</code>等。</li>
</ol>
<h3 id="操作实例"><a href="#操作实例" class="headerlink" title="操作实例"></a>操作实例</h3><p>下面以几个操作的函数调用过程来理解TTY和frame buffer驱动程序的层次结构。注意：这只是为了在阅读内核源码时，给读者提供一些函数调用间的脉络关系。刚接触某类驱动时，了解各函数、结构间的调用关系是一件困难的事情。</p>
<ol>
<li>注册frame buffer设备时，显示LOGO的过程<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3c2410fb_probe(video/s3c2410fb.c) -&gt;</span><br><span class="line">     register_framebuffer(fbmem.c) -&gt;</span><br><span class="line">         fb_info-&gt;node = i;<span class="comment">//registered_fb[i]为空项，本例中i=0</span></span><br><span class="line">         registered_fb[i] = fb_info;</span><br><span class="line">         fb_notifier_call_chain(fb_notify.c) -&gt;<span class="comment">//它会调用fbcon_event_notify(fbcon.c)</span></span><br><span class="line">             fbcon_fb_registered(video/console/fbcon.c)</span><br><span class="line">                 info_idx = idx<span class="comment">//即info-&gt;node，值为上面的i</span></span><br><span class="line">                 fbcon_takeover(<span class="number">1</span>)(video/console/fbcon.c) -&gt;</span><br><span class="line">                     con2fb_map[i] = info_idx;<span class="comment">//i=0，info_idx=0</span></span><br><span class="line">                     take_over_console(<span class="type">char</span>/vt.c) -&gt;</span><br><span class="line">                         register_con_driver(<span class="type">char</span>/vt.c) -&gt;</span><br><span class="line">                             csw-&gt;con_startup(...) -&gt;<span class="comment">//即fbcon_startup(video/console/fbcon.c)</span></span><br><span class="line">                                 info = registered_fb[info_idx];</span><br><span class="line">                                 info-&gt;fbops-&gt;fb_open(...)(video/s3c2410fb.c)</span><br><span class="line">                         bind_con_driver(<span class="type">char</span>/vt.c) -&gt;</span><br><span class="line">                             visual_init(<span class="type">char</span>/vt.c) -&gt;</span><br><span class="line">                                 vc-&gt;vc_sw-&gt;con_init <span class="comment">//即fbcon_init</span></span><br><span class="line">                                 fbcon_init(video/console/fbcon.c) -&gt;</span><br><span class="line">                                 <span class="comment">//以下准备LOGO</span></span><br><span class="line">                                 fbcon_prepare_logo(video/console/fbcon.c) -&gt;</span><br><span class="line">                                     fb_prepare_logo(video/fbmem.c) -&gt;</span><br><span class="line">                                         fb_logo.logo = fb_find_logo(depth);<span class="comment">//logo.c</span></span><br><span class="line">                             <span class="comment">//打印Console：swicthing to colour frame buffer device 30x40</span></span><br><span class="line">                             update_screen(vc);(include/linux/vt_kern.h) -&gt;</span><br><span class="line">                             redraw_screen(<span class="type">char</span>/vt.c) -&gt;</span><br><span class="line">                                 vc-&gt;vc_sw-&gt;con_switch(vc);-&gt;<span class="comment">//即fbcon_switch(fbcon.c)</span></span><br><span class="line">                                     fb_show_logo(video/fbmem.c)<span class="comment">//显示LOGO</span></span><br></pre></td></tr></table></figure></li>
<li>对&#x2F;dev&#x2F;ttyx调用write函数时的过程<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tty_write(<span class="type">char</span>/tty_io.c)-&gt;</span><br><span class="line"> ld = tty_ldisc_ref_wait(tty)<span class="comment">//它就是char/n_tty.c中的tty_ldisc_N_TTY</span></span><br><span class="line"> do_tty_write(ld-&gt;write,tty,file,buf,count)(<span class="type">char</span>/tty_io.c)-&gt;</span><br><span class="line">     write_chan(就是上面的ld-&gt;write,<span class="type">char</span>/n_tty.c中tty_ldisc_N_TTY的成员函数)-&gt;</span><br><span class="line">         tty-&gt;driver-&gt;write(即con_write，<span class="type">char</span>/vt.c)-&gt;</span><br><span class="line">             do_con_write(<span class="type">char</span>/vt.c)-&gt;</span><br><span class="line">                 vc-&gt;vc_sw-&gt;con_putcs(即fbcon_putcs，video/console/fbcon.c)-&gt;</span><br><span class="line">                     ops-&gt;putcs(即bit_putcs,video/console/bitblit.c)-&gt;</span><br><span class="line">                         dst = fb_get_buffer_offset(video/fbmem.c)<span class="comment">//获取要写入的显存位置</span></span><br><span class="line">                         bit_putcs_aligned/bit_putcs_unaligned(video/console/bitblit.c)</span><br><span class="line">                             src = vc-&gt;vc_font.data + (src_readw(s++)&amp;charmask)*cellsize;<span class="comment">//获得字符的点阵</span></span><br><span class="line">                             __fb_pad_aligned_buffer(fb.h)<span class="comment">//将点阵写入显存</span></span><br></pre></td></tr></table></figure>
在使用&#x2F;dev&#x2F;ttyx作为控制台的shell中，运行某个程序时，如果里面有“printf(“hello world!”)”字样的语句，它会调用到内核的tty_write函数。<br>然后会调用行规程的write_chan函数，它又会调用“tty-&gt;driver-&gt;write”，对于串口，它是<code>drivers/serial/serial_core.c</code>中的uart_write函数，它直接输出ASCII字符；对于显示器，它是<code>drivers/char/vt.c</code>中的con_write函数，它更复杂。在LCD显示器上显示字符时，先要根据这些字符得到它们的点阵，然后再将它们画出来。<br><code>drivers/video/console/fbcon.c</code>中的fbcon_putcs函数通过<code>drivers/video/console/bitblit.c</code>、<code>drivers/video/fbmem.c</code>提供的一些函数来获得点阵、写到显存中去。其中的“vc-&gt;vc_font.data”指向某个字库，以字符为索引即可找到它的点阵。在<code>drivers/video/console/fonts.c</code>文件中定义了一个fonts数组，每个表项是一个字库，比如font_vga_8x8、font_vga_8x16等。在<code>devices/video/fbcon.c</code>中初始化frame buffer控制台时，会把vc-&gt;vc_font.data指向某个字库。</li>
<li>USB键盘按下时的函数调用过程<br>与串口相似，键盘的读取以中断来驱动。以USB键盘为例，调用过程如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">hid_irq_in(hid/usbhid/hid-core.c) -&gt;</span><br><span class="line">     hid_input_report(hid/hid-core.c) -&gt;</span><br><span class="line">         hid_input_field(hid/hid-core.c) -&gt;</span><br><span class="line">             hid_process_event(hid/hid-core.c) -&gt;</span><br><span class="line">                 hidinput_hid_evenet(hid/hid-input) -&gt;</span><br><span class="line">                     input_event(input/input.c) -&gt;</span><br><span class="line">                         dev-&gt;event(...)</span><br><span class="line">                         handle-&gt;handler-&gt;event，即kbd_event(<span class="type">char</span>/keyboard.c) -&gt;</span><br><span class="line">                             kbd_rawcode/kbd_keycode(<span class="type">char</span>/keyboard.c) -&gt;</span><br><span class="line">                                 put_queue(vc,data)(<span class="type">char</span>/keyboard.c) -&gt;<span class="comment">//数据放入终端缓冲区</span></span><br><span class="line">                                     tty_insert_flip_char(include/linux/tty_flip.h)<span class="comment">//放数据</span></span><br><span class="line">                                     con_schedule_flip(kbd_kern.h)<span class="comment">//唤醒等待数据的进程</span></span><br></pre></td></tr></table></figure>
hid_irq_in是USB中断传输方式的中断处理函数，当键盘被按下时，它导致后续的一系列函数被调用，与图24.1对应，它从底层的<code>drivers/hid/usbhid/hid-core.c</code>一直向上调用到<code>drivers/input/input.c</code>中的input_event函数，接着input_event函数根据调用<code>drivers/char/keyboard.c</code>注册的处理函数将数据放入虚拟终端设备的缓冲区中，然后等待数据的进程。</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-LCD控制器驱动程序移植"><a href="#S3C2410-x2F-S3C2440-LCD控制器驱动程序移植" class="headerlink" title="S3C2410&#x2F;S3C2440 LCD控制器驱动程序移植"></a>S3C2410&#x2F;S3C2440 LCD控制器驱动程序移植</h2><p>从图24.1可知，架构相关的代码为<code>drivers/video/s3c2410fb.c</code>，移植的思想是一样的：先确定LCD控制器所用的资源，然后把它们加入平台设备结构，最后修改代码是这些资源可用。<br>硬件连线图如下图所示：<br><img src="/2022/10/19/LCD%E5%92%8CUSB%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/2.jpeg" alt="img not found"></p>
<h2 id="平台设备结构"><a href="#平台设备结构" class="headerlink" title="平台设备结构"></a>平台设备结构</h2><p>LCD控制器的平台设备在<code>arch/arm/plat-s3c24xx/devs.c</code>中定义，它所用的资源都是固定的，不需要任何改动。它的平台设备结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* LCD Controller */</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">s3c_lcd_resource</span>[] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .start = S3C24XX_PA_LCD,</span><br><span class="line">        .end = S3C24XX_PA_LCD + S3C24XX_SZ_LCD - <span class="number">1</span>,</span><br><span class="line">        .flag = IORESOURCE_MEM,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .start = IRQ_LCD,</span><br><span class="line">        .end = IRQ_LCD,</span><br><span class="line">        .flag = IORESOURCE_IRQ,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> u64 s3c_device_lcd_dmamask = <span class="number">0xffffffff</span>UL;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">s3c_device_lcd</span> =</span> &#123;</span><br><span class="line">    .name = <span class="string">&quot;s3c2410-lcd&quot;</span>,</span><br><span class="line">    .id = <span class="number">-1</span>,</span><br><span class="line">    .num_resources = ARRAY_SIZE(s3c_lcd_resource),</span><br><span class="line">    .resource = s3c_lcd_resource,</span><br><span class="line">    .dev = &#123;</span><br><span class="line">        .dma_mask = &amp;s3c_device_lcd_dmamask,</span><br><span class="line">        .coherent_dma_mask = <span class="number">0xffffffff</span>UL,</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>s3c_device_lcd</code>结构，已经加入了S3C2410、S3C2440开发板的设备列表中了。</p>
<ol>
<li><code>arch/arm/mach-s3c2410/mach-smdk2410.c</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">smdk2410_devices</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     &amp;s3c_device_lcd,</span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><code>arch/arm/mach-s3c2440/mach-smdk2440.c</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">smdk2440_devices</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     &amp;s3c_device_lcd,</span><br><span class="line">     ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
而LCD控制器驱动程序<code>drivers/video/s3c2410fb.c</code>的入口函数为：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">s3c2410fb_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= s3c2410fb_probe,</span><br><span class="line">	.remove		= s3c2410fb_remove,</span><br><span class="line">	.suspend	= s3c2410fb_suspend,</span><br><span class="line">	.resume		= s3c2410fb_resume,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;s3c2410-lcd&quot;</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> __devinit <span class="title function_">s3c2410fb_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;s3c2410fb_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
平台设备s3c_device_lcd和平台驱动s3c2410fb_driver的名字都是“s3c2410-lcd”，所以注册了s3c2410fb_driver之后，它的s3c2410fb_probe函数将被调用来设置LCD控制器。</li>
</ol>
<h3 id="底层驱动代码分析及修改"><a href="#底层驱动代码分析及修改" class="headerlink" title="底层驱动代码分析及修改"></a>底层驱动代码分析及修改</h3><p>s3c2410fb_probe函数完成初始化LCD控制器、注册中断处理函数、注册frame buffer设备等工作，它的流程图如下图所示：<br><img src="/2022/10/19/LCD%E5%92%8CUSB%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/3.jpeg" alt="img not found"><br>这个函数中，与单板相关的就是其中的mach-info结构。它是平台设备s3c_device_lcd结构中的dev.platform_data成员，读者可以查看s3c2410fb_init_registers函数来了解它的功能。但是在前面看到的s3c_device_lcd结构中，并没有指定这个成员。它在其他函数中设置；对于S3C2440，单板初始化函数smdk2440_machine_init调用s3c24xx_fb_set_platdata函数来设置；对于S3C2410，没有设置。<br>smdk2440_machine_init函数在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">smdk2440_machine_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    s3c24xx_fb_set_platdata(&amp;smdk2440_lcd_cfg);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>smdk2440_lcd_cfg结构表示LCD控制器的一些配置，比如分辨率、时间特性等。<br>s3c24xx_fb_set_platdata函数在<code>arch/arm/plat-s3c24xx/devs.c</code>中，它直接将参数smdk2440_lcd_cfg赋给设置平台设备s3c_device_lcd结构中的dev.platform_data成员。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">s3c24xx_fb_set_platdata</span><span class="params">(<span class="keyword">struct</span> s3c2410fb_mach_info *pd)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    <span class="built_in">memcpy</span>(npd,pd,<span class="keyword">sizeof</span>(*npd));</span><br><span class="line">    s3c_device_lcd.dev.platform_data = npd;</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>所以，对于S3C2440，需要修改smdk2440_lcd_cfg结构；对于S3C2410，仿照S3C2410增加一个smdk2410_lcd_cfg结构，并调用s3c24xx_fb_set_platdata函数来设置它。<br>smdk2440_lcd_cfg是s3c2410fb_mach_info结构类型，这个类型在<code>include/asm-arm/arch-s3c2410/fb.h</code>文件中定义，下面分析它的各个成员的意义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_mach_info</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span>	fixed_syncs;	<span class="comment">/* do not update sync/border */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* LCD types */</span></span><br><span class="line">	<span class="type">int</span>		type;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Screen size */</span></span><br><span class="line">	<span class="type">int</span>		width;</span><br><span class="line">	<span class="type">int</span>		height;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Screen info */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_val</span> <span class="title">xres</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_val</span> <span class="title">yres</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_val</span> <span class="title">bpp</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* lcd configuration registers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_hw</span>  <span class="title">regs</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* GPIOs */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	gpcup;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	gpcup_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	gpccon;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	gpccon_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	gpdup;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	gpdup_mask;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	gpdcon;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	gpdcon_mask;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* lpc3600 control register */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>	lpcsel;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>fixed_syncs</code>被设为1时表示“固定的”时间参数和边框大小，这意味着用户程序无法调整分辨率等参数，因为底层驱动不修改时间参数和边框大小。从s3c2410fb.c中的相关代码来看，它就是不在重新设置LCDCON2&#x2F;3&#x2F;4寄存器中的相关位。<br><code>type</code>表示LCD的类型，从LCDCON1寄存器位[6:5]可以知道它有4种取值，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">00 = 4-bit dual scan display mode (STN)</span><br><span class="line">01 = 4-bit single scan display mode (STN)</span><br><span class="line">10 = 8-bit single scan display mode (STN)</span><br><span class="line">11 = TFT LCD panel</span><br></pre></td></tr></table></figure>
<p><code>width</code>、<code>height</code>用来设置图像的宽度和高度，它们取xres、yres的默认值。<br><code>s3c2410fb_val</code>结构的定义如下，xres、yres和bpp分别表示图像宽度、高度和像素位宽的最小、最大、默认值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_val</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> defval;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> min;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> max;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>struct s3c2410fb_hw regs</code>表示LCDCON1-LCDCON5共5个LCD控制器的控制寄存器。它们用来设置LCD类型、像素数据的格式。<br><code>gpcup</code>、<code>gpcup_mask</code>、<code>gpccon</code>、<code>gpccon_mask</code>、<code>gpdup</code>、<code>gpdup_mask</code>、<code>gpdcon</code>、<code>gpdcon_mask</code>用来设置GPC、GPD两组GPIO引脚，<code>gpcup</code>和<code>gpccon_mask</code>两个成员被用来设置GPCUP寄存器：<code>gpcup</code>表示新值，<code>gpccon_mask</code>表示要设置的位。<br><code>lpcsel</code>表示LPCSEL寄存器，它用来支持SEC公司生产的TFT LCD，对于一般的LCD，不用设置这个寄存器。<br>本开发板使用240x320，16bpp的TFT LCD，内核自带的smdk2440_lcd_cfg结构并不适用于这个开发板，并且它的设置有一些错误：没有指定GPIO寄存器的值，“type”设置错了。原来的值如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_mach_info</span> <span class="title">smdk2440_lcd_cfg</span> __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line">	<span class="comment">/* currently setup by downloader */</span></span><br><span class="line">	.gpccon		= <span class="number">0xaa940659</span>,</span><br><span class="line">	.gpccon_mask	= <span class="number">0xffffffff</span>,</span><br><span class="line">	.gpcup		= <span class="number">0x0000ffff</span>,</span><br><span class="line">	.gpcup_mask	= <span class="number">0xffffffff</span>,</span><br><span class="line">	.gpdcon		= <span class="number">0xaa84aaa0</span>,</span><br><span class="line">	.gpdcon_mask	= <span class="number">0xffffffff</span>,</span><br><span class="line">	.gpdup		= <span class="number">0x0000faff</span>,</span><br><span class="line">	.gpdup_mask	= <span class="number">0xffffffff</span>,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">...</span><br><span class="line">	.type		= S3C2410_LCDCON1_TFT16BPP,</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>它把GPIO的值屏蔽掉了，原因是“currently setup by downloader”，这也许是这个驱动的开发者在调试时，另外使用某种下载器来设置GPIO。<br>上面的<code>type</code>被设置为<code>S3C2410_LCDCON1_TFT16BPP</code>，这是错误的，“type”表示“类型”，而“S3C2410_LCDCON1_TFT16BPP”表示“TFT”类型下数据的格式。应该设为以下4个值之一：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_LCDCON1_DSCAN4	   (0&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_LCDCON1_STN4	   (1&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_LCDCON1_STN8	   (2&lt;&lt;5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_LCDCON1_TFT	       (3&lt;&lt;5)</span></span><br></pre></td></tr></table></figure>
<p>下面修改代码</p>
<ol>
<li>对于S3C2440单板<br>修改smdk2440_lcd_cfg结构，它在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>文件中，修改后的代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* LCD driver info */</span></span><br><span class="line"> <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_mach_info</span> <span class="title">smdk2440_lcd_cfg</span> __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">     .regs	= &#123;</span><br><span class="line"></span><br><span class="line">         .lcdcon1	= S3C2410_LCDCON1_TFT16BPP |</span><br><span class="line">                 S3C2410_LCDCON1_TFT |</span><br><span class="line">                 S3C2410_LCDCON1_CLKVAL(<span class="number">0x04</span>),</span><br><span class="line"></span><br><span class="line">         .lcdcon2	= S3C2410_LCDCON2_VBPD(<span class="number">1</span>) |</span><br><span class="line">                 S3C2410_LCDCON2_LINEVAL(<span class="number">319</span>) |</span><br><span class="line">                 S3C2410_LCDCON2_VFPD(<span class="number">5</span>) |</span><br><span class="line">                 S3C2410_LCDCON2_VSPW(<span class="number">1</span>),</span><br><span class="line"></span><br><span class="line">         .lcdcon3	= S3C2410_LCDCON3_HBPD(<span class="number">36</span>) |</span><br><span class="line">                 S3C2410_LCDCON3_HOZVAL(<span class="number">239</span>) |</span><br><span class="line">                 S3C2410_LCDCON3_HFPD(<span class="number">19</span>),</span><br><span class="line"></span><br><span class="line">         .lcdcon4	= S3C2410_LCDCON4_MVAL(<span class="number">13</span>) |</span><br><span class="line">                 S3C2410_LCDCON4_HSPW(<span class="number">5</span>),</span><br><span class="line"></span><br><span class="line">         .lcdcon5	= S3C2410_LCDCON5_FRM565 |</span><br><span class="line">                 S3C2410_LCDCON5_INVVLINE |</span><br><span class="line">                 S3C2410_LCDCON5_INVVFRAME |</span><br><span class="line">                 S3C2410_LCDCON5_PWREN |</span><br><span class="line">                 S3C2410_LCDCON5_HWSWP,</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     <span class="comment">/* currently setup by downloader */</span></span><br><span class="line">     .gpccon		= <span class="number">0xaaaaaaaa</span>,</span><br><span class="line">     .gpccon_mask	= <span class="number">0xffffffff</span>,</span><br><span class="line">     .gpcup		= <span class="number">0xffffffff</span>,</span><br><span class="line">     .gpcup_mask	= <span class="number">0xffffffff</span>,</span><br><span class="line">     .gpdcon		= <span class="number">0xaaaaaaaa</span>,</span><br><span class="line">     .gpdcon_mask	= <span class="number">0xffffffff</span>,</span><br><span class="line">     .gpdup		= <span class="number">0xffffffff</span>,</span><br><span class="line">     .gpdup_mask	= <span class="number">0xffffffff</span>,</span><br><span class="line"></span><br><span class="line">     .fixed_syncs = <span class="number">1</span>,</span><br><span class="line">     .type		= S3C2410_LCDCON1_TFT,</span><br><span class="line"></span><br><span class="line">     .width		= <span class="number">240</span>,</span><br><span class="line">     .height		= <span class="number">320</span>,</span><br><span class="line"></span><br><span class="line">     .xres		= &#123;</span><br><span class="line">         .min	= <span class="number">240</span>,</span><br><span class="line">         .max	= <span class="number">240</span>,</span><br><span class="line">         .defval	= <span class="number">240</span>,</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     .yres		= &#123;</span><br><span class="line">         .min	= <span class="number">320</span>,</span><br><span class="line">         .max	= <span class="number">320</span>,</span><br><span class="line">         .defval = <span class="number">320</span>,</span><br><span class="line">     &#125;,</span><br><span class="line"></span><br><span class="line">     .bpp		= &#123;</span><br><span class="line">         .min	= <span class="number">16</span>,</span><br><span class="line">         .max	= <span class="number">16</span>,</span><br><span class="line">         .defval = <span class="number">16</span>,</span><br><span class="line">     &#125;,</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure></li>
<li>对于S3C2410单板<br>仿照<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>来修改<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code><br>①增加smdk2410_lcd_cfg结构<br>直接把smdk2440_lcd_cfg的内容搬到mach-smdk2410.c中，改名为smdk2410_lcd_cfg即可。<br>②使用smdk2410_lcd_cfg结构<br>在S3C2410单板初始化函数smdk2410_init中，调用s3c24xx_fb_set_platdata函数。除增加的smdk2410_lcd_cfg结构外，还要增加如下所示的代码：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/fb.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="comment">/* LCD driver info */</span></span><br><span class="line"> <span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c2410fb_mach_info</span> <span class="title">smdk2440_lcd_cfg</span> __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">     ...</span><br><span class="line"> &#125;;</span><br><span class="line"> ...</span><br><span class="line"> <span class="type">static</span> <span class="type">void</span> __init <span class="title function_">smdk2410_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line"> &#123;</span><br><span class="line">     s3c24xx_fb_set_platdata(&amp;smdk2410_lcd_cfg);</span><br><span class="line">     ...</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="配置内核以使用LCD"><a href="#配置内核以使用LCD" class="headerlink" title="配置内核以使用LCD"></a>配置内核以使用LCD</h3><p>对LCD的配置有两方面，一是frame buffer方面的配置，二是控制台方面的配置。<br>配置内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">    Graphics support ---&gt;</span><br><span class="line">        &lt;*&gt; Support for frame buffer devices    //支持frame buffer</span><br><span class="line">        &lt;*&gt; S3c2410 LCD frame buffer support    //支持S3C24xx</span><br><span class="line">            Console display driver support ---&gt;</span><br><span class="line">            &lt;*&gt; Frame buffer Console support    //支持frame buffer控制它</span><br><span class="line">            [ ] Select Compile-in fonts         //选择字库，默认为VGA 8x8、VGA 8x16字库</span><br><span class="line">        [*] Bootup logo ---&gt;                    //启动时显示LOGO</span><br><span class="line">            [*] Standard 224-color Linux logo   //选择LOGO图像，有单色、16色、244色</span><br></pre></td></tr></table></figure>
<ol>
<li>通过LCD显示内核信息<br>以前使用串口作为控制台（打印内核信息）时，命令行参数为“console&#x3D;ttySAC0”，现在可以多加一项，比如“console&#x3D;ttySAC0 console&#x3D;tty1”。tty1表示第一个虚拟终端，tty2表示第二个虚拟终端，而tty0表示当前的虚拟终端。</li>
<li>操作&#x2F;dev&#x2F;tty1输出字符：如果使用mdev机制，这个步骤可以省略。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mknod /dev/tty0 c <span class="number">4</span> <span class="number">0</span></span><br><span class="line">mknod /dev/tty1 c <span class="number">4</span> <span class="number">1</span></span><br><span class="line">mknod /dev/tty2 c <span class="number">4</span> <span class="number">2</span></span><br><span class="line">mknod /dev/tty3 c <span class="number">4</span> <span class="number">3</span></span><br><span class="line">mknod /dev/tty4 c <span class="number">4</span> <span class="number">4</span></span><br><span class="line">mknod /dev/tty5 c <span class="number">4</span> <span class="number">5</span></span><br><span class="line">mknod /dev/tty6 c <span class="number">4</span> <span class="number">6</span></span><br></pre></td></tr></table></figure>
在串口控制台，使用“echo hello &gt; &#x2F;dev&#x2F;tty0”命令可以在LCD上显示“hello”字符串。</li>
<li>操作&#x2F;dev&#x2F;fb0绘制图像<br>首先如下创建设备文件，如果使用mdev机制，这个步骤可以省略：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mknod /dev/fb0 c <span class="number">29</span> <span class="number">0</span></span><br></pre></td></tr></table></figure>
然后使用frame buffer测试程序执行“fb_test &#x2F;dev&#x2F;fb0”即可在LCD上看到很多同心圆，并且在控制台打印出frame buffer的属性。</li>
</ol>
<h1 id="USB驱动程序移植"><a href="#USB驱动程序移植" class="headerlink" title="USB驱动程序移植"></a>USB驱动程序移植</h1><h2 id="USB驱动程序概述"><a href="#USB驱动程序概述" class="headerlink" title="USB驱动程序概述"></a>USB驱动程序概述</h2><p>USB（Universal Serial Bus）即“通用串行外部总线”，在各种场所已经大量使用。它接口简单（只有5V和GND、两根数据线D+和D-），可以外接硬盘、键盘、鼠标、打印机等多种设备。要使用尽可能少的接口支持尽可能多的外设，USB是一个好的选择，在嵌入式设备中尤其如此。<br>USB总线规范有1.1版和2.0版。USB1.1支持两种传输速率：低速（Low Speed）1.5Mbit&#x2F;s、全速12Mbit&#x2F;s，对于鼠标、键盘、CD-ROM等设备，这样的速率足够。但是在访问硬盘、摄像机时，就显得很慢。为此，USB2.0提供了一种更高的传输速率：高速，它可以达到480Mbit&#x2F;s。USB2.0向下兼容USB1.1，可以遵循USB1.1规范的设备连接到USB2.0控制器上，也可以把USB2.0的设备USB1.1控制器上。<br>USB总线的硬件拓扑结构如下图所示。<br>USB主机控制器（USB Host Controller）通过根集线器（Root Hub）与其他设备相连接。集线器也属于USB设备，通过它可以在一个USB接口上扩展出多个接口。除根集线器外，最多可以层叠5个集线器，每条USB电缆的最大长度是5m，所以USB总线的最大距离为30m。一条USB总线上可以外接127个设备，包括根集线器和其他集线器。整个结构图就是一个星状结构，一条USB总线上所有设备共享一条通往主机的数据通道，同一时刻只能有一个设备与主机通信。<br><img src="/2022/10/19/LCD%E5%92%8CUSB%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/4.jpeg" alt="img not found"><br>通过USB主机控制器来管理外接的USB设备，USB主机控制器共分3种，UHCI、OHCI和EHCI，其中的“HCI”表示“Host Controller Interface”。UHCI、OHCI属于USB1.1的主机控制器规范，而EHCI是USB2.0的主机控制规范。UHCI（Universal HCI），它是由Intel公司制定得标准，它的硬件做的事情少，这使得软件比较复杂。与之相对的是OHC（Open HCI）,它由Compaq、Microsoft和National Semiconductor联合制定，在硬件方面它具备更多的智能，使得软件相对简单。<br><em><strong>这些差别只存在于底层的USB主机控制器的驱动程序，对它之上的软件没有影响。USB2.0的主机控制程序只有EHCI（Enhanced HCI）一种</strong></em><br>在配置内核的时候，经常可以看到“HCD”字样，它表示“Host Controller Drivers”，即主机控制器驱动程序。比如有uhci-hcd、ohci-hcd、ehci-hcd等驱动模块。<br>USB驱动程序分两类：USB主机控制器驱动程序（Host Controller Drivers）、USB设备驱动程序（USB device drivers）。它们在内核中的层次如图所示。<br><img src="/2022/10/19/LCD%E5%92%8CUSB%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/5.jpeg" alt="img not found"><br>USB主机控制器驱动程序提供访问USB设备的接口，它只是一个“数据通道”，至于这些数据有什么用，这要靠上层的USB设备驱动程序来解释。USB设备驱动程序使用下层驱动提供的接口来访问USB设备，不需要关心传输的具体细节。</p>
<h2 id="配置内核支持USB键盘、USB鼠标和USB硬盘"><a href="#配置内核支持USB键盘、USB鼠标和USB硬盘" class="headerlink" title="配置内核支持USB键盘、USB鼠标和USB硬盘"></a>配置内核支持USB键盘、USB鼠标和USB硬盘</h2><p>S3C2410&#x2F;S3C2440的USB控制器有如下特性<br><strong>符合OHCI1.0规范</strong><br><strong>支持USB1.1版本</strong><br><strong>有两个插口</strong><br><strong>支持低速设备和全速设备</strong></p>
<p>Linux内核中对OHCI主机控制器支持完善，并有多种USB设备驱动程序。Linux2.6.22.6也已经支持S3C2410&#x2F;S3C2440的USB控制器，只不过第二个插口上电后默认为USB Device插口，如果要将它改为USB Host插口（比如没有USB集线器，却需要同时接入USB键盘、USB鼠标时），只要设置MISCCR寄存器的位3即可，所有的修改都在文件<code>drivers/usb/host/ohci-s3c2410.c</code>中完成，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch/regs-gpio.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">usb_hcd_s3c2410_probe</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> hc_driver *driver,</span></span><br><span class="line"><span class="params">                <span class="keyword">struct</span> platform_device *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">usb_hcd</span> *<span class="title">hcd</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 2 host port */</span>    </span><br><span class="line">    writel(readl(S3C2410_MISCCR) | S3C2410_MISCCR_USBHOST, S3C2410_MISCCR);</span><br><span class="line"></span><br><span class="line">    s3c2410_usb_set_power(dev-&gt;dev.platfrom_data,<span class="number">1</span>,<span class="number">1</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在只需要配置内核启用它们：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">    SCSI device support ---&gt;</span><br><span class="line">        &lt;*&gt; SCSI device support         //要支持USB磁盘，这项要选上</span><br><span class="line">        [*] legacy /proc/scsi/ support  //在/proc/scsi 目录下提供以下信息</span><br><span class="line">        &lt;*&gt; SCSI disk support           //SCSI硬盘，要支持U盘等，这项要选上</span><br><span class="line">    </span><br><span class="line">    USB support ---&gt;</span><br><span class="line">        &lt;*&gt; Support for Host-side USB   //USB主机控制器</span><br><span class="line">        [*] USB device filesystem       //在/proc文件系统中提供一些信息，调试用</span><br><span class="line">        &lt;*&gt; OHCI HCD support            //OHCI主机控制器驱动程序</span><br><span class="line">        &lt;*&gt; USB mass Storage support    //USB存储设备</span><br><span class="line"></span><br><span class="line">    HID Devices ---&gt;</span><br><span class="line">        &lt;*&gt; USB Human Interface Device (full HID) support   //USB键盘、USB鼠标等HID设备</span><br><span class="line">        [*] /dev/hiddev raw HID device support              //以原始（raw）的方式访问HID设备</span><br></pre></td></tr></table></figure>
<p>USB控制器的时钟是在U-Boot中设置的，UCLK必须设为48MHZ。</p>
<h2 id="USB设备的使用"><a href="#USB设备的使用" class="headerlink" title="USB设备的使用"></a>USB设备的使用</h2><p>连接USB设备时需要注意：S3C2410&#x2F;S3C2440既可以作为USB主机，也可以作为USB设备。作为USB主机时对外提供两个接口，对应板上叠起来的两个USB接口，下面的称为HOST1，上面的称为HOST2；作为USB设备时，对外也提供一个接口，对应板上的USB_DEVICE接口。<br>HOST2和USB_DEVICE在S3C2410&#x2F;S3C2440上的引脚是复用的。要在开发板上使用两个USB设备时，除HOST1外，可以设置跳线使用HOST2；要使用更多的USB设备，必须通过USB集线器来连接。</p>
<h3 id="使用LCD和USB键盘作为终端"><a href="#使用LCD和USB键盘作为终端" class="headerlink" title="使用LCD和USB键盘作为终端"></a>使用LCD和USB键盘作为终端</h3><p>现有的内核已经支持LCD和USB键盘，可以使用它们来作为控制台、终端了。前面说过，在命令行参数中增加“console&#x3D;tty1”就可以在LCD上显示内核信息，不过要想使用它们来登录系统，需要修改&#x2F;etc&#x2F;inittab文件，增加以下6行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tty1::askfirst:-/bin/sh</span><br><span class="line">tty2::askfirst:-/bin/sh</span><br><span class="line">tty3::askfirst:-/bin/sh</span><br><span class="line">tty4::askfirst:-/bin/sh</span><br><span class="line">tty5::askfirst:-/bin/sh</span><br><span class="line">tty6::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure>
<p>它们在6个虚拟终端上启动shell程序，接上USB键盘和LCD后，可以看到如下字样的提示信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Please press Enter to activate this consorl</span><br></pre></td></tr></table></figure>
<p>在键盘上按回车键，就可以像在串口终端上一样使用USB键盘、LCD来控制系统了。</p>
<h3 id="使用U盘"><a href="#使用U盘" class="headerlink" title="使用U盘"></a>使用U盘</h3><p>首先在开发板上创建如下设备文件</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod /dev/sda b 8 0</span><br><span class="line">mknod /dev/sda1 b 8 1</span><br><span class="line">mknod /dev/sda2 b 8 2</span><br><span class="line">mknod /dev/sda3 b 8 3</span><br><span class="line">mknod /dev/sda4 b 8 4</span><br></pre></td></tr></table></figure>
<p>接U盘后，即可像前面使用硬盘、SD卡一样来使用U盘了。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">fdsik /dev/sda              //进入菜单，对U盘进行分区，修改分了一个主分区/dev/sda1</span><br><span class="line">mkdosfs -F 32 /dev/sda1     //格式化为FAT32文件系统</span><br><span class="line">mount /dev/sda1 /mnt        //挂接</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第4篇第24章 LCD和USB驱动程序移植</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux内核简介</title>
    <url>/2022/10/24/Linux%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>这一章将带我们从Unix的历史视角来认识Linux内核与Linux操作系统的前世今生。今天Unix系统业已演化成一个具有相似应用程序编程接口（API），并且基于相似设计理念的操作系统家族。但它又是一个别具特色的操作系统，从萌芽至今已经有40余年的历史。若要了解Linux，我们必须首先认识Unix系统。</p>
<span id="more"></span>
<h1 id="Unix的历史"><a href="#Unix的历史" class="headerlink" title="Unix的历史"></a>Unix的历史</h1><p>Unix虽然已经使用了40年，但计算机科学家仍然认为它是现存操作系统中最强大和最优秀的系统。从1969诞生以来，由Dennis Ritchie和Ken Thompson的灵感火花点亮的这个Unix产物已经成为一种传奇，它历经的时间的考验依然声明不坠。<br>Unix是从贝尔实验室的一个失败的多用户操作系统Multics中涅槃而生。Multics项目被终止后，贝尔实验室计算机科学研究中心的人们发现自己处于一个没有交互式操作系统可用的境地。在这种情况下，1969年的夏天，贝尔实验室的程序员们设计了一个文件系统原型，而这个原型最终演化成了Unix。Thompson首先在一台无人问津的PDP-7型机上实现了这个全新的操作系统。1971年，Unix被移植到PDP-11型机上。1973年，整个Unix操作系统用C语言进行了重写，正是这个不太引人注目的操作，给后来的的Unix系统的广泛移植铺平了道路。第一个在贝尔实验室以外被广泛使用的Unix版本是第6版，称为V6。<br>许多其他公司也把Unix移植到新的机型上。伴随着这些移植，开发者们按照自己的方式不断增强系统的功能，并由此产生了若干变体。1977年，贝尔实验室综合各种变体推出了Unix System III；1983年AT&amp;T推出了SystemV。<br>由于Unix系统设计简洁并且在发布时提供源代码，所以许多其他组织和团体都对它进行了进一步的开发。加州大学伯克利分校便是其中影响最大的一个。他们推出的变体叫Berkeley Software Distibutions（BSD）。伯克利的第一个Unix演化版是1977年推出的1BSD系统，它的实现基于贝尔实验室的Unix版本，不但在其中加入了许多修正补丁，而且还集成了不少额外的软件；1978年伯克利继续推出了2BSD系统，其中包含我们如今仍在使用的csh、vi等应用软件。而伯克利真正独立开发的Unix系统是于1979年推出的3BSD系统，该系统引入了一系列令人振奋的新特性，支持虚拟内存便是其一大亮点。在3BSD以后，伯克利又相继推出了4BSD系列，包括4.0BSD、4.1BSD、4.2BSD、4.3BSD等众多分支。这些Unix演化版实现了任务管理、换页机制、TCP&#x2F;IP等新的特性。最终伯克利大学在1994年重写了虚拟内存子系统（VM），并推出了伯克利Unix系统的最终官方版，即我们熟知的4.4BSD。现在多亏了BSD的开放性许可，BSD的开发才得以由Darwin、FreeBSD、NetBSD和OpenBSD继续。<br>20世纪80和90年代，许多工作站和服务厂商推出了他们的Unix，这个Unix大部分是在AT&amp;T或伯克利发行版的基础上加上一些满足他们特定体系结构需要的特性。这其中就包括Digital的Tru64、HP的HP-UX、IBM的AIX、Sequent的DYNIX&#x2F;ptx、SGI的IRIX和Sun的Solaris和SunOS。<br>由于最初一流的设计和以后多年的创新与逐步提高，Unix系统称成为一个强大、健壮和稳定的操作系统。下面的几个特点是使Unix强大的根本原因。首先，Unix很简洁：不像其他动辄数千个系统调用并且设计目的不明确的系统，Unix仅仅提供几百个系统调用并且有一个非常明确的设计目的。第二，在Unix中，所有的东西都被当作文件对待。这种抽象使得对数据和对设备的操作是通过一套相同的系统调用接口来进行的：open()、read()、write()、lseek()和close()。第三，Unix的内核与相关的系统工具软件是用C语言编写而成的–正是这个特点使得Unix在各种硬件体系结构面前都具备惊人的移植能力，并且使得广大的开发人员很容易就能接受它。第四，Unix的进程创建非常迅速，并且有一个非常独特的fork()系统调用。最后，Unix提供了一套非常简单但又非常稳定的进程间通信元语，快速简洁的进程创建过程使Unix的程序把目标放在<strong>一次执行保质保量的完成一个任务上</strong>，而简单稳定的进程间通信机制又可以保证这些单一目的的简单程序可以方便地组合在一起，去解决现实中越来越复杂的任务。正是由于这种策略和机制分离的设计理念，确保了Unix系统具备清晰的层次化结构。<br>今天，Unix已经发展成为一个支持抢占式多任务、多线程、虚拟内存、换页、动态链接和TCP&#x2F;Ip网络的现代化操作系统。Unix的不同变体被应用在大到数百个CPU的集群、小到嵌入式设备的各种系统中。尽管Unix已经不再被认为是一个实验室项目了，但它仍然伴随着操作系统设计技术的进步而继续成长，人们仍然可以把它作为一个通用的操作系统来使用。<br>Unix的成功归功于其简洁和一流的设计。它能拥有今天的能力和成就应该归功于Dennis Ritchie和Ken Thompson和其他早期设计人员的最初决策，同时也要归功于那些永不妥协于成见，从而赋予Unix无穷活力的设计选择。</p>
<h1 id="追寻Linus足迹：Linux简洁"><a href="#追寻Linus足迹：Linux简洁" class="headerlink" title="追寻Linus足迹：Linux简洁"></a>追寻Linus足迹：Linux简洁</h1><p>1991年，Linus Torvalds为当时新推出的、使用Intel 80386微处理器的计算机开发了一款全新的操作系统，Linux由此诞生。那时，作为芬兰赫尔辛基大学的一名学生的Linus，正为不能随心所欲的使用强大而自由的Unix系统而苦恼。对于Torvalds而言，使用当时流行的Microsoft的DOS系统，除了玩波斯王子游戏外，别无他用。Linus热衷于使用Minix，一种教学用的廉价Unix，但是，他不能轻易修改和发布该系统的源代码（由于Minix的许可证），也不能对Minix开发者所作的设计轻举妄动，这让他耿耿于怀并由此对作者的设计理念感到失望。<br>Linus像任何一名生机勃勃的大学生一样决心走出这种困境：开发自己的操作系统。他开始写了一个简单的终端仿真程序，用于连接到本校的大型Unix系统上。他的终端仿真程序经过一学年的研发，不断改进和完善。不久，Linus手上就有了虽不成熟但是五脏俱全的Unix。1991年底，他在Internet上发布了早期版本。<br>从此Linux便启航了，最初的Linux发布者很快赢得了众多用户。而实际上，它成功的重要因素是，Linux很快吸引了很多开发者、黑客对其代码进行修改和完善。由于其许可证条款的约定，Linux迅速成为多人的合作开发项目。<br>到现在，Linux早已羽翼丰满，它被广泛移植到Alpha、ARM、PowerPC、SPARC、x86-64等许多其他体系结构之上。如今Linux既然被安装在最轻小的消费电子设备上，比如手表，同时也在服务规模最庞大的服务数据中心上，如超级计算机集群。今天，Linux的商业前景也越来越被看好，不管是新成立的Linux专业公司RedHat还是闻名遐迩的计算机巨头IBM，都提供林林总总的解决方案，从嵌入式系统、桌面环境一直到服务器。<br>Linux是类Unix系统。但它不是Unix。需要说明的是，尽管Linux借鉴了Unix许多设计并且实现了Unix的API，但Linux没有像其他Unix变种那样直接使用Unix的源代码。必要的时候，它的实现可能和其他Unix的实现大相径庭，但它没有抛弃Unix的设计目标并且保证了应用程序编程接口的一致。<br>Linux是一个非商业化的产品，这是它最让人感兴趣的特征。实际上Linux是一个互联网上的协作开发项目。尽管Linus被认为是Linux之父，并且现在依然是一个内核维护者，但开发工作其实是由一个结构松散的工作组协力完成的。事实上，任何人都可以开发内核。和该系统的大部分一样，Linux内核也是<strong>自由（公开）软件</strong>。当然，也不是无限自由的。它使用GNU的GPL第2版作为限制条款。这样做的结果是，你就可以自由的获取内核的代码并随意修改它，但如果你希望发布你修改过的内核，你也得保证让得到你的内核的人同时享有你曾经享受过的权利，当然，包括所有的源代码。<br>Linux用途广泛，包含的东西也名目繁多。Linux系统的基础是内核、C库、工具集和系统的基本工具，如登录程序和Shell。Linux系统也支持现代的X Windows系统，这样就可以使用完整的图形用户桌面环境，如GNOME。可以在Linux上使用的商业和自由软件数以千计。</p>
<h1 id="操作系统和内核简介"><a href="#操作系统和内核简介" class="headerlink" title="操作系统和内核简介"></a>操作系统和内核简介</h1><p>由于一些现代商业操作系统日趋庞杂及其设计上的缺陷，操作系统地精确定义并没有一个统一的标准，许多用户把他们在显示器屏幕上看到的东西理所当然的认为就是操作系统。通常，当然在本书上也这么认为，<strong>操作系统</strong>是指在整个系统中负责完成最基本功能和系统管理的那部分。这些部分应该包括内核、设备驱动程序、启动引导程序、命令行Shell或者其他种类的用户界面、基本的文件管理工具和系统工具。系统这个词其实还包含了操作系统和所有运行在它之上的应用程序。<br>用户界面是操作系统的外在表象，内核才是操作系统的内在核心。系统其他部分必须依靠内核这部分软件提供的服务，像管理硬件设备、分配系统资源等。内核有时候还被称为<strong>管理者</strong>或者是<strong>操作系统核心</strong>。通常一个内核由负责响应中断的中断服务程序，负责管理多个进程从而分享处理器时间的调度程序，负责管理进程地址空间的内存管理程序和网络、进程间通信等系统服务共同组成。对于提供保护机制的现代系统来说，内核独立于普通应用程序，它一般处于系统态，拥有受保护的内存空间和访问硬件设备的所有权限。这种系统态和被保护起来的内存空间，统称为内核空间。相对的，应用程序在用户空间执行。它们只能看到允许它们使用的部分系统资源，并且只使用某些特定的系统功能，不能直接访问硬件，也不能访问内核划给别人的内存范围，还有其他一些使用限制。当内核运行时，系统以内核态进入内核空间执行。而执行一个普通用户程序时，系统将用户态进入用户空间执行。<br>在系统中运行的应用程序通过系统调用来与内核通信。应用程序通常调用库函数（比如C库函数）再由库函数通过系统调用界面，让内核代其完成各种不同任务。一些库调用提供了系统调用不具备的许多功能，在那些较为复杂的函数中，调用内核的操作通常只是整个工作的一个步骤而已。举个例子，拿printf()函数来说，它提供了数据的缓存和格式化等操作，而调用write()函数将数据写到控制台只不过是其中的一个动作罢了。不过，也有一些库函数和系统调用即使一一对应的关系，比如，open()库函数除了调用open()系统调用之外，几乎什么也不做。还有一些C库函数，像strcpy()，根本就不需要直接调用系统级的操作。当一个应用程序执行一条系统调用，我们说<strong>内核正在代其执行</strong>。如果进一步理解，在这种情况下，应用程序被称为通过系统调用在<strong>内核空间运行</strong>，而内核空间被称为运行于<strong>进程上下文中</strong>。这种交互关系–应用程序通过系统调用界面陷入内核–是应用程序完成其工作的基本行为方式。<br>内核还要负责管理系统的硬件设备。现有的几乎所有的体系结构，包括全部的Linux支持的体系结构，都提供了中断机制。当硬件设备想要和系统通信的时候，它首先要发出一个异步的中断信号去打断处理器的执行，继而打断内核的执行。中断通常对应着一个中断号，内核通过这个中断号查询相应的<strong>中断服务程序</strong>，并调用这个程序响应和处理中断。举个例子，当你敲击键盘的时候，键盘控制器发送一个中断信号告知系统，键盘缓冲区有数据到来。内核注意到这个中断对应的中断号，调用相应的中断服务程序。该服务程序处理键盘数据然后通知键盘控制器可以继续输入数据。为了保证同步，内核可以停用中止–既可以停止所有的中断也可以有选择的某个中断号对应的中断。许多操作系统的中断服务程序，包括Linux的，都不在进程上下文中执行。它们在一个与所有进程都无关的、专门的中断上下文中运行。之所以存在这样一个专门的环境，就是为了保证中断服务程序能够在第一时间响应和处理中断请求，然后快速的退出。<br>这些上下文代表着内核活动的范围。实际上我们可以将每个处理器在任何指定的时间点上的活动必然概括为下列三者之一：<br><img src="/2022/10/24/Linux%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B/1.jpeg" alt="img not found"></p>
<ol>
<li>运行于用户空间，执行用户进程</li>
<li>运行于内核空间，处于进程上下文，代表某个特定的进程执行</li>
<li>运行于内核空间，处于中断上下文，与任何进程无关，处理某个特定的中断<br>以上所列几乎包括所有情况，即使边边角角的情况也不例外，例如，当CPU空闲时，内核就运行一个空进程，处于进程上下文，但运行于内核空间。</li>
</ol>
<h1 id="Linux内核和传统Unix内核的比较"><a href="#Linux内核和传统Unix内核的比较" class="headerlink" title="Linux内核和传统Unix内核的比较"></a>Linux内核和传统Unix内核的比较</h1><p>由于所有的Unix内核都同宗同源。并且提供相同的API，现代的Unix内核存在许多设计上的相似之处。Unix内核几乎毫不例外的都是一个不可分割的静态执行库。也就是说，它们必须以巨大、单独的可执行块的形式在一个单独的地址空间中运行。Unix内核通常需要硬件系统提供页机制（MMU）以管理内存。这种页机制可以加强对内存空间的保护，并保证每个进程都可以运行于不同的虚地址空间上。初期的Linux系统也需要MMU支持，但有一些特殊版本并不依赖于此。这无疑是一个简洁的设计，因为它可以使Linux系统运行在没有MMU的小型嵌入式系统上。不过现实之中，即便很简单的嵌入式系统都开始具备内存管理单元这种高级功能了。我们会重点关注支持MMU的Linux系统。</p>
<h2 id="单内核与微内核设计之比较"><a href="#单内核与微内核设计之比较" class="headerlink" title="单内核与微内核设计之比较"></a>单内核与微内核设计之比较</h2><p>操作系统内核可以分为两大阵营：单内核和微内核（第三阵营是外内核，主要用在科研系统中）。<br>单内核是两大阵营中一种较为简单的设计，在1980年之前，所有的内核都设计成单内核。所谓单内核就是把它从整体上作为一个单独的大过程来实现，同时也运行在一个单独的地址空间上。因此，这样的内核通常以单个静态二进制文件的形式存放于磁盘中。所有的内核服务都在这样的一个大内核地址空间中运行。内核之间的通信是微不足道的，因为大家都运行在内核态，并身处同一地址空间：内核可以直接调用函数，这与用户空间应用程序没有什么区别。这种模式的支持者认为单模块具有简单和性能高的特点。大多数Unix都设计为单模块。<br>另一方面，微内核并不作为一个单独的大过程来实现，相反，微内核的功能被划分为多个独立的过程，每个过程叫做一个服务器。理想情况下，只有强烈请求特权服务的服务器才运行在特权模式下，其他服务器都运行在用户空间。不过，所有的服务器都保持独立并运行在各自的地址空间上。因此，就不可能像单内核模块那样直接调用函数，而是通过<strong>消息传递</strong>处理微内核通信：系统采用了进程间通信（IPC）机制，因此，各个服务器之间通过IPC机制互通消息，互换“服务”。服务器的各自独立有效避免了一个服务器的失效祸及另一个。同样，模块化的系统允许另一个服务器为了另一个服务器而换出。<br>因为IPC机制的开销多于函数调用，又因为会涉及内核空间与用户空间的上下文切换，因此，消息传递需要一定的周期，而单内核中简单的函数调用没有这些开销。结果，所有实际应用的基于微内核的系统都让大部分或全部服务器位于内核，这样，就可以直接调用函数，消除频繁的上下文切换。Windows NT内核（Windows XP、Windows Vista和Windows 7等基于此）和Mach（Mac OS X的组成部分）是微内核的典型实例。不管是Windows NT还是Mac OS X，都在其新近版本中不让任何微内核服务器运行在用户空间，这违背了微内核设计的初衷。<br>Linux是一个单内核，也就是说,Linux运行在单独的内核地址空间上。不过，Linux汲取了微内核的精华：其引以为豪的是模块化设计、抢占式内核、支持内核线程以及动态装载内核模块的能力。不仅如此，Linux还避其微内核设计上性能损失的缺陷，让所有事情都运作在内核态，直接调用函数，无需消息传递。至今，Linux是模块化的、多线程的以及内核本身可调度的操作系统，实用主义再次占了上风。<br>当Linus和其他内核开发者设计Linux内核时，他们并没有完全彻底的与Unix诀别。他们充分的认识到，不能忽视Unix的底蕴（特别是Unix的API）。而由于Linux没有基于某种特定的Unix，Linus和他的伙伴对每个特定的问题都可以选择已知最理想的解决方案–在有些时候，当然也可以创造一些新的方案。Linux内核与传统的Unix系统之间存在一些显著的差异。</p>
<ol>
<li>Linux支持动态加载内核模块。尽管Linux内核也是单内核，可是允许在需要的时候动态地卸载和加载部分内核代码。</li>
<li>Linux支持对称多处理机制（SMP），尽管许多Unix的变体也支持SMP，但传统的Unix并不支持这种机制。</li>
<li>Linux内核可以抢占（preemptive）。与传统的Unix变体不同，Linux内核具有允许在内核运行的任务优先执行的能力。在其他各种Unix产品中，只有Solaris和IRIX支持抢占，但是大多数Unix内核不支持抢占。</li>
<li>Linux对线程的支持比较有意思：内核并不区分线程和其他的一般线程。对于内核来说，所有的进程都是一样的–只不过是其中的一些共享资源而已。</li>
<li>Linux提供具有设备类的面向对象的设备模型、热插拔事件，以及用户空间的设备文件系统（sysfs）。</li>
<li>Linux忽略了一些被认为是设计得很拙劣的Unix特性，像STREAMS，它还忽略了那些难以实现过时标准。</li>
<li>Linux体现了自由这个词的精髓。现有的Linux特性集就是Linux公开开发模型自由发展的结果。如果一个特性没有任何价值或者创意很差，没有任何人会被迫去实现它。相反的，针对变革，Linux已经形成了一种值得称赞的态度：任何改变都必须要能通过简洁的设计以及正确可靠的实现来解决现实中确实存在的问题。于是，许多出现在某些Unix变种系统中，那些出于市场宣传目的或没有普遍意义的一些特性，如内核换页机制等都被毫不迟疑地摒弃了。</li>
</ol>
<p>不管Linux和Unix有多大的不同，它身上都深深的打上了Unix烙印。</p>
<h1 id="Linux内核版本"><a href="#Linux内核版本" class="headerlink" title="Linux内核版本"></a>Linux内核版本</h1><p>Linux内核有两种：稳定的和处于开发中的。稳定的内核具有工业级的强度，可以广泛的应用和部署。新推出的稳定内核大部分都支持修正了一些Bug或者加入了一些新的设备驱动程序。另一方面处于开发中的内核许多东西变化的很快。而且由于开发者不断实验新的解决方案，内核常常发生剧烈的变化。<br>Linux通过一个简单的命名机制来区分稳定的和处于开发中的内核。这种机制使用三个或者四个“.”分隔的数字来代表不同内核版本，第一个数字是主版本号，第二个数字是从版本号，第三个数字是修订版本号，第四个可选的数字为稳定版本号（stable version）。从副版本号可以反映出该内核是一个稳定版本还是一个处于开发中的版本：该数字如果是偶数那么内核版本就是稳定版本；如果是奇数，那么它就是开发版。<br><img src="/2022/10/24/Linux%E5%86%85%E6%A0%B8%E7%AE%80%E4%BB%8B/2.jpeg" alt="img not found"><br>处于开发中的内核一般要经历几个阶段。最开始，内核开发者们开始实验新的特性，这时候出现错误和混乱是在所难免的。经过一段时间，系统渐渐成熟，最终会有一个特性审定的声明。这时候，Linus就不再接收新的特性了，而对已有特性所进行的后续工作会继续进行。当Linus认为这个新内核确实是趋于稳定之后，就开始审定代码。这以后就只允许再向其中加入修改bug的代码了。在经过一个短暂的准备期后，Linus会将这个内核作为一个新的稳定版推出。<br>在一个特定的系列下，Linus会定期发布新内核。每个新内核都是一个新的修订版本。比如2.6内核系列的第一个版本就是2.6.0，第二个版本是2.6.1.这些修订版包含了BUG修复、新的驱动和一些新特性。但是，像2.6.3和2.6.4修订版本之间的差异是很微小的。<br>这种开发方式一直持续到2004年，当时在受邀参加的Linux开发者峰会上，内核开发者们确定延长2.6内核系列，从而推迟进入到2.7的步伐。原因是2.6的版本的内核已经被广泛接受、其已经证明了稳定成熟，而那些还不成熟的新特性其实并非人们所需。如今看来2.6版本内核的稳定出色无疑证明了该方针是多么英明。<br>为了解决版本发布周期的变长的副作用，内核开发者们引入了上面提到的<strong>稳定版本号</strong>，这个稳定版本号（如2.6.32.8中的8）包含了关键性bug的修改，并且常会向前移植处于开发板内核（如2.6.33）的重要修改。依靠这种方式，以前版本保证了仍能将重点放在稳定性上。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>这是一本关于Linux内核的书：内核的目标，为达到目标所进行的设计以及设计的实现。这本书侧重实用，同时讲述工作原理时会结合理论联系实践。我的目标是让你从一个业内人士的视角来欣赏和理解Linux内核的设计和实现之美。力求以一种有趣的方式（伴随我个人在开发过程中收集的种种奇闻轶事和方法技巧）引导你走过跌跌撞撞的起步阶段。无论是你立志于开发内核代码。或者是进行驱动开发，甚至只是希望能更好的了解Linux操作系统，你都将从本书受益。<br>当你阅读本书时，我希望你有一台装有Linux的机器，我希望你能够看到内核代码。其实这就很理想了，因为这意味着你是一名Linux的使用者，并且早已开始拿起手术刀对着源代码进行探索了，只不过需要一份结构图以便对这个经脉有个总体把握罢了。相反你可能没有使用过Linux，只是在好奇心的驱使下希望了解一些内核设计的秘密而已。但是，如果你的目的只是撰写自己的代码，那么源代码的作用无可替代。而且，你不需要付出任何代价，尽管用吧。<br>好了，最重要的是，在其中寻找快乐吧。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第1章 Linux内核简介</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>从内核出发</title>
    <url>/2022/10/25/%E4%BB%8E%E5%86%85%E6%A0%B8%E5%87%BA%E5%8F%91/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在这一章，我们将介绍Linux内核的一些基本常识：从何处获取源代码，如何编译它，又如何安装新代码。那么，让我们考察一下内核程序与用户应用空间程序的差异，以及内核中所使用的通用编程结构。虽然内核在很多方面有其独特性，但从现在来看，它和其他大型软件项目并无多大差别。</p>
<span id="more"></span>
<h1 id="获取内核源码"><a href="#获取内核源码" class="headerlink" title="获取内核源码"></a>获取内核源码</h1><p>登录Linux内核官方网站<a href="http://www.kernel.org,可以随时获取当前版本的linux源代码,可以是完整的压缩形式(使用tar创建的一个压缩文件),也可以是增量补丁形式./">http://www.kernel.org，可以随时获取当前版本的Linux源代码，可以是完整的压缩形式（使用tar创建的一个压缩文件），也可以是增量补丁形式。</a><br>除特殊情况下需要Linux源码的旧版本之外，一般都希望拥有最新的代码。kernel.org是源代码的库存之处，那些领导潮流的内核开发者所发布的增量补丁也放在这里。</p>
<h2 id="使用Git"><a href="#使用Git" class="headerlink" title="使用Git"></a>使用Git</h2><p>在过去的几年中，Linus和他领导的内核开发者们开始使用一个新版本的控制系统来管理Linux内核源代码。Linus创造的这个系统称为Git。与CSV这样的传统的版本控制系统不同，Git是分布式的，它的用法和工作流程对许多开发者来说很陌生。我强烈建议使用Git来下载和管理Linux内核源代码。<br>你可以使用Git来获取最新提交到Linus版本树的一个副本：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone git://git.kernel.org/pub/scm/linux/kernel/git/torvalds/linux-2.6.git</span><br></pre></td></tr></table></figure>
<p>当下载代码后，你可以更新你的分支到Linus的最新分支</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git pull</span><br></pre></td></tr></table></figure>
<p>有了这两个命令，就可以获取并随时保持与内核官方的代码树一致。</p>
<h2 id="安装内核源代码"><a href="#安装内核源代码" class="headerlink" title="安装内核源代码"></a>安装内核源代码</h2><p>内核压缩以GNU zip（gzip）和bzip2两种形式发布。bzip2是默认和首选形式，因为它在压缩上比gzip更具优势。以bzip2形式发布的Linux内核叫做linux-x.y.z.tar.bz2，这里x.y.z是内核源码的具体版本。下载了源代码之后，就可以轻而易举的对其解压。如果压缩形式是bzip2，则运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xvjf linux-x.y.z.tar.bz2</span><br></pre></td></tr></table></figure>
<p>如果压缩形式是GNU的zip，则运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xvzf linux-x.y.z.tar.gz</span><br></pre></td></tr></table></figure>
<p>解压后的源代码位于linux-x.y.z目录下。如果你是使用git获取和管理内核源代码，那么就不需要下载压缩文件，只要像前面描述的那样运行git clone命令，git就会下载并且解压最新的源代码。</p>
<p><em><strong>何处安装并触及源码</strong></em><br>内核源码一般安装在&#x2F;usr&#x2F;src&#x2F;linux目录下。但是请注意，不要把这个源码树用于开发，因为编译你的C库所用的内核版本就链接到这棵树。此外，不要以root身份对内核进行修改，而应当建立自己的主目录，仅以root身份安装新内核。即使在安装新内核时，&#x2F;usr&#x2F;src&#x2F;linux目录都应当原封不动。</p>
<h2 id="使用补丁"><a href="#使用补丁" class="headerlink" title="使用补丁"></a>使用补丁</h2><p>在Linux内核社区中，补丁是通用语。你可以以补丁的形式发布对代码的修改，也可以以补丁的形式接收其他人所做的修改。增量补丁可以作为版本转移的桥梁。你不需要再下载庞大的内核源码的全部压缩，则只需要给旧版本打上一个增量补丁，让其旧貌换新颜。这不仅节约带宽，还省了时间。要应用增量补丁，从你的内部源码树开始，只需运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">patch -p1 &lt; ../patch-x.y.z</span><br></pre></td></tr></table></figure>
<p>一般来说，一个给定版本的内核补丁总是打在前一个版本上。<br>有关创建和应用补丁更深入的讨论会在后续章节进行。</p>
<h1 id="内核源码树"><a href="#内核源码树" class="headerlink" title="内核源码树"></a>内核源码树</h1><p>内核源码树由很多目录组成，而大多数目录又包含更多的子目录。源码树的根目录及其子目录如下表所示：</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>特定体系结构的源码</td>
</tr>
<tr>
<td>block</td>
<td>块设备I&#x2F;O层</td>
</tr>
<tr>
<td>crypto</td>
<td>加密API</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核源码文档</td>
</tr>
<tr>
<td>drivers</td>
<td>设备驱动程序</td>
</tr>
<tr>
<td>firmware</td>
<td>使用某些驱动程序而需要的设备固件</td>
</tr>
<tr>
<td>fs</td>
<td>VFS和各种文件系统</td>
</tr>
<tr>
<td>include</td>
<td>内核头文件</td>
</tr>
<tr>
<td>init</td>
<td>内核引导和初始化</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间通信代码</td>
</tr>
<tr>
<td>kernel</td>
<td>像调度程序这样的核心子系统</td>
</tr>
<tr>
<td>lib</td>
<td>通用内核函数</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理子系统和VM</td>
</tr>
<tr>
<td>net</td>
<td>网络子系统</td>
</tr>
<tr>
<td>samples</td>
<td>示例，示范代码</td>
</tr>
<tr>
<td>scripts</td>
<td>编译内核所用的脚本</td>
</tr>
<tr>
<td>sound</td>
<td>语音子系统</td>
</tr>
<tr>
<td>usr</td>
<td>早期用户空间代码（所谓的initramfs）</td>
</tr>
<tr>
<td>tools</td>
<td>在Linux开发中有用的工具</td>
</tr>
<tr>
<td>virt</td>
<td>虚拟化基础结构</td>
</tr>
</tbody></table>
<p>在源码树根目录的很多文件中值得提及。COPYING文件是内核许可证（GNU GPL v2）。CREDITS是开发了很多内核代码的开发者列表。MAINTAINERS是维护者列表，他们负责维护内核子系统和驱动程序。Makefile是基本内核的Makefile。</p>
<h1 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h1><p>便于内核易如反掌。让人叹为观止的是，这实际上比编译和安装像glibc这样的系统级组件还要简单。2.6内核提供了一套新工具，是编译内核更加容易，比早期发布的内核有了长足的进步。</p>
<h2 id="配置内核"><a href="#配置内核" class="headerlink" title="配置内核"></a>配置内核</h2><p>因为Linux源码随手可得，那就意味着在编译它之前可以配置和定制。的确，你可以把自己需要的特定功能和驱动程序编译进内核。在编译内核之前，首先你必须配置它。由于内核提供了数不胜数的功能，支持了难以计数的硬件，因而有许多东西需要配置。可以配置的各种选项，以CONFIG_FEATURE形式表示，其前缀为CONFIG。例如，对称多处理器（SMP）的配置选项为CONFIG_SMP。如果设置了该选项，则SMP启用，否则，SMP不起作用。配置选择既可以用来决定哪些文件编译进内核，也可以通过预处理命令处理代码。<br>这些配置项要么是二选一，要么是三选一。二选一就是yes或no。比如CONFIG_PREEMPT就是二选一，表示内核抢占功能是否开启。三选一可以是yes、no或module。module意味着该配置项被选定了，但编译的的时候这部分功能的实现代码是以模块（一种可以动态安装的独立代码段）的形式生成。在三选一的情况下，显然yes选项表示把代码编译进主内核映像中，而不是作为一个模块。驱动程序一般选用三选一的配置。<br>配置选项也可以是字符串或整数。这些选项并不控制编译过程，而只是指定内核源码可以访问的值，一般以预处理宏的形式表示。比如，配置选项可以指定静态分配数组的大小。<br>销售商提供的内核，像Canonical的Ubuntu或者Red Hat的Fedora，他们的发布版中包含了预编译的内核，这样的内核使得所需的内核得以充分利用，并几乎把所有的驱动程序都编译成模块。这就为大多数硬件作为独立的模块提供了坚实的内核支持。但是，话又说回来，如果你是一个内核黑客，你应当编译自己的内核，并且按照自己的意愿决定包括或者不包含哪一模块。<br>内核提供了各种不同的工具来简化内核配置。最简单的一种是一个字符界面下的命令行工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make config</span><br></pre></td></tr></table></figure>
<p>该工具会逐一遍历所有配置项，要求用户选择yes、no或者是module。由于这个过程往往要耗费掉很长时间，所以，除非你的工作是按小时计费的，否则应该多利用基于ncurse库编制的图形界面工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make menuconfig</span><br></pre></td></tr></table></figure>
<p>或者，是用基于gtk+的图形工具：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make gconfig</span><br></pre></td></tr></table></figure>
<p>这三种工具将所有配置项分门别类放置，比如按“处理器类型和特点”。你可以按类移动、浏览内核选项，当然也可以修改其值。<br>这条命令会基于默认的配置为你的体系结构创建一个配置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make defconfig</span><br></pre></td></tr></table></figure>
<p>尽管这些缺省值有点随意性（在i386上，据说那就是Linus的配置），但是，如果你从未配置过内核，那它们会提供一个良好的开端。<br>这些配置项会被存放在内核代码树根目录下的.config文件中。你很容易就能找到它，并且可以直接修改它。在这里面查找和修改内核选项也很容易。在你修改过配置文件之后，或者在用已有的配置文件配置新的代码树的时候，你应该验证和更新配置。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make oldconfig</span><br></pre></td></tr></table></figure>
<p>事实上，在编译内核之前你都应该这么做。<br>配置选项CONFIG_IKCONFIG_PROC把完整的压缩过的内核配置文件存放在&#x2F;proc&#x2F;config.gz下，这样当你编译一个新内核的时候就可以方便地克隆当前的配置。如果你目前的内核已经启用了此选项，就可以从&#x2F;proc下复制出配置文件并且使用它来编译一个新内核：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">zcat /proc/config.gz &gt; .config</span><br><span class="line">make oldconfig</span><br></pre></td></tr></table></figure>
<p>一旦内核配置好了，就可以使用一个简单的命令来编译它了：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>这跟2.6以前的版本不同，你不用在每次编译内核之前都运行make dep了–代码之间的依赖关系会自动维护。你也无须再指定像老版本中bzImage这样的编译方式或独立的编译模块，默认的Makefile规则会打点这一切。</p>
<h2 id="减少编译的垃圾信息"><a href="#减少编译的垃圾信息" class="headerlink" title="减少编译的垃圾信息"></a>减少编译的垃圾信息</h2><p>如果你想尽量少地看到垃圾信息，却又不希望错误错误报告和警告信息的话，你可以用以下命令来对输出进行重定向：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &gt; ../detritus</span><br></pre></td></tr></table></figure>
<p>一旦你需要查看编译的输出信息，你可以查看这个文件。不过，因为错误和警告都会在屏幕上显示，所以你需要查看这个文件的可能性不大。事实上，我只不过输出如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>就可把无用的输出信息重定向到永无返回值得黑洞&#x2F;dev&#x2F;null。</p>
<h2 id="衍生多个编译作业"><a href="#衍生多个编译作业" class="headerlink" title="衍生多个编译作业"></a>衍生多个编译作业</h2><p>make程序能把编译过程拆分成多个并行的作业。其中的每个作业独立并发的运行，这有助于极大的加快多处理器系统上的编译过程，也有利于改善处理器的利用率，因为编译大型源代码树也包括I&#x2F;O等待所花费的时间（也就是处理器空下来等待I&#x2F;O请求完成所花费的时间）。<br>默认情况下，make只衍生一个作业，因为Makefiles常会出现不正确的依赖信息。对于不正确的依赖，多个作业可能会互相踩踏，导致编译过程出错。当然，内核的Makefiles没有这样的编码错误，因此衍生出的多个作业编译不会导致失败。为了以多个作业编译内核，使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -jn</span><br></pre></td></tr></table></figure>
<p>这里，n是要衍生出来的作业数。在实际中，每个处理器上一般衍生出一个或者两个作业。例如，在一个16核的处理器上，你可以输入如下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make -j32 &gt; /dev/null</span><br></pre></td></tr></table></figure>
<p>利用出色的distcc或者ccache工具，也可以动态的改善内核的编译时间。</p>
<h2 id="安装新内核"><a href="#安装新内核" class="headerlink" title="安装新内核"></a>安装新内核</h2><p>在内核编译好之后，你还需要安装它。怎么安装就和体系结构以及启动引号工具（bootloader）息息相关了–查阅启动引导工具的说明，按照它的指导将内核映像拷贝到合适的位置，并且按照启动要求按照它。一定要保证随时有一个或两个可以启动的内核，以防新编译的内核出现问题。<br>例如，在使用grub的x86系统上，可能需要把<code>arch/i386/boot/bzImage</code>拷贝到&#x2F;boot目录下，像vmlinuz-version这样命名它，并且编辑<code>/etc/grub/grub.conf</code>文件，为新内核建立一个新的启动项。使用LILO启动的系统应当编辑<code>/etc/lilo.conf</code>，然后运行lilo。<br>所幸，模块的安装是自动的，也是独立于体系结构的。以root身份，只要运行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<p>就可以把所有已编译的模块安装到正确的主目录<code>/lib/modules</code>下。<br>编译时也会在内核代码树的根目录下创建一个System.map的文件。这是一份符号对照表，用以将内核符号和它们的起始地址对应起来。调试的时候，如果需要把内存地址翻译成容易理解的函数名以及变量名，这就会很有用。</p>
<h1 id="内核开发的特点"><a href="#内核开发的特点" class="headerlink" title="内核开发的特点"></a>内核开发的特点</h1><p>相对于用户空间内应用程序的开发，内核开发有一些独特之处。尽管<code>这些差异并不会使开发内核代码的难度超过开发用户代码，但它们依然有很大不同</code>。<br>这些特点使内核成为了一只性格迥异的猛兽。一些常用的准则被颠覆了，而又必须建立许多全新的准则。尽管有许多差异一目了然（人人都知道内核可以做它想做的任何事），但还是有一些差异晦暗不明。最重要的差异包括以下几种：</p>
<ol>
<li>内核编程时既不能访问C库也不能访问标准的C头文件。</li>
<li>内核编程时必须使用GNU C。</li>
<li>内核编程时缺乏像用户空间那样的内存保护机制。</li>
<li>内核编程时难以执行浮点运算。</li>
<li>内核给每个进程只有一个很小的定长堆栈。</li>
<li>由于内核支持异步中断、抢占和SMP，因此时刻注意同步和并发。</li>
<li>要考虑可移植的重要性。</li>
</ol>
<p>以上要点所有的内核开发者必须牢记。</p>
<h2 id="无libc库抑或无标准头文件"><a href="#无libc库抑或无标准头文件" class="headerlink" title="无libc库抑或无标准头文件"></a>无libc库抑或无标准头文件</h2><p>与用户空间的应用程序不同，内核不能链接使用标准C函数库–或者其他的那些库也不行。造成这种情况的原因有很多，其中就包括先有鸡还是先有蛋这个悖论。不过最主要的原因还是速度和大小。对内核来说，完整的C库–哪怕是它的一个子集，都太大且太低效了。<br>别着急，大部分常用的C库函数在内核中都已经得到了实现。比如操作字符串的函数组就位于<code>lib/string.c</code>中。只要包含&lt;linux&#x2F;string.h&gt;头文件，就可以使用它们。</p>
<p><strong>头文件</strong><br><em>当我在谈及头文件时，都指的是组成内核源代码树的内核头文件。内核源代码文件不能包含外部头文件，就像它们不能用外部库一样。<br>基本的头文件位于内核源代码树顶级目录下的include目录中。例如，头文件&lt;linux&#x2F;inotify.h&gt;对应内核源代码树的<code>include/linux/inotify.h</code>。<br>体系结构相关的头文件集位于内核源代码树的<code>arch/&lt;architecture&gt;/include/asm</code>目录下。例如，如果编译的是x86体系结构，则体系结构相关的头文件就是<code>arch/x86/include/asm</code>。内核代码通过以<code>asm/</code>为前缀的方式包含这些头文件，例如&lt;asm&#x2F;ioctl.h&gt;。</em></p>
<p>在所有没有实现的函数中，最著名的就数printf()函数了。内核代码虽然无法调用printf()，但它提供的printk()函数几乎与printf()相同。printk()函数负责把格式化好的字符串拷贝到内核缓冲区中，这样syslog程序就可以通过读取该缓冲区来获取内核信息。printk()的用法很像printf()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk(<span class="string">&quot;Hello world! A string:&#x27;%s&#x27; and an integer:&#x27;%d&#x27;\n&quot;</span>,str,i);</span><br></pre></td></tr></table></figure>
<p>printk()和printf()之间的一个显著区别在于，printk()允许你通过指定一个标志来设置优先级。syslogd会根据这个优先级标志来决定在什么地方显示这条系统消息。下面是一个使用这种优先级标志的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk(KERN_ERR<span class="string">&quot;this is an error!\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong><br><em>在KERN_ERR和要打印的消息之间没有逗号，这样写是别有用意的。优先级标志是预处理定义的一个描述性字符串，在编译时优先级标志就与要打印的消息绑在一起。贯穿整本书，我们会使用printk()。</em></p>
<h2 id="GNU-C"><a href="#GNU-C" class="headerlink" title="GNU C"></a>GNU C</h2><p>像所有自视清高的Unix内核一样，Linux内核是用C语言编写的。让人略感惊讶的是，内核并不完全符合ANSI C标准。实际上，只要有可能，内核开发者总是要用到gc<br>c提供的许多语言的扩展部分。gcc是多种GNU编译器的集合，它包含的C编译器既可以编译内核，也可以编译Linux系统上用C语言写的其他代码。<br>内核开发者使用的C语言涵盖了ISO C99标准和GNU C扩展特性。这其中的这种变化把Linux内核推向了gcc的怀抱，尽管目前出现了一些新的编译器如Intel C，已经支持了足够多的gcc扩展特性，完全可以用来编译Linux内核了。最早支持gcc的版本是3.2，但是推荐使用gcc4.4或者之后的版本。Linux内核用到的ISO C99标准的扩展没有什么特别之处，而且C99作为C语言官方标准的修订本，不可能有大的或者是激进的变化。让人感兴趣的是，与标准C语言有区别的，通常也是那些人们不熟悉的变化，多数集中在GNU C上。就让我们研究一下内核代码中所使用到的C语言扩展中让人感兴趣的那部分吧，这些变化使内核代码有别于你所熟悉的其他项目。</p>
<h3 id="内联函数"><a href="#内联函数" class="headerlink" title="内联函数"></a>内联函数</h3><p>C99和GNU C均支持内联函数。inline这个名称就可以反映出它的工作方式，函数会在它所调用的位置上展开。这么做可以消除函数调用和返回所带来的开销（寄存器存储和恢复）。而且，由于编译器会把调用函数的代码和函数本身放在一起进行优化，所以也有进一步优化代码的可能。不过这么做是有代价的，代码会变长，这也就意味着占用更多的内存空间或者占用更多的指令缓存。内核开发者通常把那些对时间要求比较高，而本身长度又比较短的函数定义成内联函数。如果一个函数较大，会被反复调用，且没有特别的时间上的限制，我们不赞成将它做成内联函数。<br>定义一个内联函数的时候，需要使用static作为关键字，并且用inline限定它。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wolf</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> tail_size)</span>;</span><br></pre></td></tr></table></figure>
<p>内联函数必须在使用之前就定义好，否则编译器就没法把这个函数展开。实践中一般在头文件中定义内联函数。由于使用了static作为关键字进行限制，所以编译时不会为内联函数单独建立一个函数体。如果一个内联函数仅仅在某个源文件中使用，那么也可以把它定义在该文件开始的地方。<br><code>在内核中，为了类型安全和易读性，优先使用内联函数而不是复杂的宏。</code></p>
<h3 id="内联汇编"><a href="#内联汇编" class="headerlink" title="内联汇编"></a>内联汇编</h3><p>gcc编译器支持在C函数中嵌入汇编指令。当然，在内核编程的时候，只有知道对应的体系结构，才能使用这个功能。<br>我们通常使用asm()指令嵌入汇编代码。例如，下面这条内联汇编用于执行x86处理器的rdtsc指令，返回时间戳(tsc)寄存器的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> low,high;</span><br><span class="line"><span class="keyword">asm</span> <span class="title function_">volatile</span><span class="params">(<span class="string">&quot;rdtsc&quot;</span> : <span class="string">&quot;=a&quot;</span>(low), <span class="string">&quot;=d&quot;</span>(high))</span>;</span><br><span class="line"><span class="comment">/* low和high分别包含64位时间戳的低32位和高32位 */</span></span><br></pre></td></tr></table></figure>
<p>Linux的内核混合使用了C语言和汇编语言。在偏近体系结构的底层或对执行时间要求严格的地方，一般使用汇编语言。而内核其他部分的大部分代码是用C语言编写的。</p>
<h3 id="分支声明"><a href="#分支声明" class="headerlink" title="分支声明"></a>分支声明</h3><p>对于条件选择语句，gcc内建了一条指令用于优化，在一个条件经常出现，或者该条件很少出现的时候，编译器可以根据这条指令对条件分支选择进行优化。内核把这条指令封装成了宏，比如likely()和unlikely()，这样使用起来比较方便。<br>例如，下面是一个条件选择语句：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(error) &#123;</span><br><span class="line">    <span class="comment">/*....*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果想要把这个选择标记成绝少发生的分支：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 我们认为error绝大多数时间都会是0 */</span></span><br><span class="line"><span class="keyword">if</span>(unlikely(error)) &#123;</span><br><span class="line">    <span class="comment">/* ... */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>相反，如果我们想把一个分支标记为通常为真的选择：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 如果我们认为success通常不会为0 */</span></span><br><span class="line"><span class="keyword">if</span>(likely(success)) &#123;</span><br><span class="line">    <span class="comment">/*...*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在你想要对某个条件选择语句进行优化之前，一定要搞清楚其中是不是存在那么个条件，在绝大多数情况下都会成立。这点十分重要：如果你的判断正确，确实是这个条件占压倒性的地位，那么性能会得到提升；如果你搞错了，性能反而会下降。正如上面这些例子所示，通常在对一些错误条件进行判断的时候会用到unlikely()和likely()。你可以猜到，unlikely()在内核中会得到更广泛的使用，因为if语句往往判断一种特殊情况。</p>
<h3 id="没有内存保护机制"><a href="#没有内存保护机制" class="headerlink" title="没有内存保护机制"></a>没有内存保护机制</h3><p>如果一个用户进程试图进行一次非法的内存访问，内核就会发现这个错误，发送SIGSEGV信号，并结束整个进程。然而，如果是内核自己发生非法内存访问，那后果就很难控制了。毕竟又有谁能照顾内核呢？内核中发生错误就会直接导致Oops，这时内核中出现的最常见的一类错误。在内核中，不应该去做访问非法的内存地址，引用空指针之类的事情，否则它可能会因此死掉，却根本不告诉你一声–在内核里面，风险常常会比外面大一些。<br>此外，内核中的内存都不分页。也就是说，你每用掉一个字节，物理内存就会减少一个字节。所以，在你想往内核中加入什么新功能的时候，要记住这一点。</p>
<h3 id="不要轻易在内核中使用浮点数"><a href="#不要轻易在内核中使用浮点数" class="headerlink" title="不要轻易在内核中使用浮点数"></a>不要轻易在内核中使用浮点数</h3><p>在用户空间的进程内进行浮点操作的时候，内核会完成从整数操作到浮点数操作的模式转化。在执行浮点指令时到底会做些什么，因体系结构不同，内核的选择也不同，但是，内核通常捕获陷阱并着手于整数到浮点方式的转变。<br>与用户空间进程不同，内核并不能完美的支持浮点操作，因为它本身不能陷入。在内核中使用浮点数时，除了要人工保存和恢复浮点寄存器，还有其他一些琐碎的事情要做。如果要直截了当地回答，那就是：别这么做了，除了一些极少的情况，不要在内核中使用浮点操作。</p>
<h3 id="容积小而固定的栈"><a href="#容积小而固定的栈" class="headerlink" title="容积小而固定的栈"></a>容积小而固定的栈</h3><p>用户空间的程序可以从栈上分配大量的空间来存放变量，甚至巨大的结构体或者是包含数以千计的数据项的数组都没有问题。之所以可以这么做，是因为用户空间的栈本身就比较大，而且还动态增长（在DOS的那个年代，即使在用户空间也只有固定大小的栈）。<br>内核栈的准确大小岁体系结构而变。在x86上，栈的大小在编译时配置，可以是4KB也可以是8KB。从历史上说，内核栈的大小是两页，这就意味着，32位机的内核栈是8KB，而64位机是16KB，这是固定不变的。每个处理器都有自己的栈。</p>
<h3 id="同步和并发"><a href="#同步和并发" class="headerlink" title="同步和并发"></a>同步和并发</h3><p>内核很容易产生竞争条件。和单线程的用户空间程序不同，内核的许多特性都要求能够并发地访问共享数据，这就要求有同步机制以保证不出现竞争条件，特别是：</p>
<ol>
<li>Linux是抢占多任务操作系统。内核的进程调度程序即兴地对进程进行调度和重新调度。内核必须和这些任务同步。</li>
<li>Linux内核支持对称多处理系统（SMP）。所以，如果没有适当的保护，同时在两个或两个以上的处理器上执行的内核代码很可能会同时访问共享的同一个资源。</li>
<li>中断是异步到来的，完全不顾及当前正在执行的代码。也就是说，如果不加以适当的保护，中断完全有可能在代码访问资源的时候到来，这样，中断处理程序就有可能访问同一资源。</li>
<li>Linux内核可以抢占。所以，如果不加以适当的保护，内核中一段正在执行的代码可能会被另外一段代码抢占，从而有可能导致几段代码同时访问相同的资源。</li>
</ol>
<p>常用的解决竞争的办法就是自旋锁和信号量。</p>
<h3 id="可移植性的重要性"><a href="#可移植性的重要性" class="headerlink" title="可移植性的重要性"></a>可移植性的重要性</h3><p>尽管用户空间的应用程序不太注意移植问题，然而Linux却是一个可移植的操作系统，并且要一直保持这种特点。也就是说，大部分C代码应该与体系结构无关，在许多不同体系结构的计算机上都能保持编译和执行，因此，必须把与体系结构相关的代码从内核代码树的特定目录中适当的分离出来。<br>诸如保持字节序、64位对齐、不假定字长和页面长度等一系列准则都有助于移植性。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>毫无疑义，内核有独一无二的特质。它实施自己的规则和奖罚措施，拥有整个系统的最高管理权。当然，Linux内核的复杂性和高门槛与其他大型软件项目并无差异。在内核开发之路上最重要的步骤是要意识到内核并没有那么可怕。陌生是肯定的，但真的就不可逾越？事实并非如此。<br>本章和以前的章节为贯穿本书剩余章节所讨论的主题奠定了基础。在后续的每一章中，我们都会涵盖内核的一个具体概念或子系统。在探索的征途中，最重要的是要阅读和修改内核源代码，只有通过实际的阅读和实践才会理解内核。内核的源代码是可以免费获取的，直接用就可以。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第2章 从内核出发</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>系统调用</title>
    <url>/2022/11/02/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在现代操作系统中，内核提供了用户进程与内核进行交互的一组接口。这些接口让应用程序受限地访问硬件设备，提供了创建新进程并与已有进程进行通信的机制，也提供了申请操作系统其他资源的能力。这些接口在应用程序和内核之间扮演了使者的角色，应用程序发出各种请求，而内核负责满足这些请求（或者无法满足时返回一个错误）。实际上提供这些接口主要是为了保证系统稳定可靠，避免应用程序恣意妄为。</p>
<span id="more"></span>

<h1 id="与内核通信"><a href="#与内核通信" class="headerlink" title="与内核通信"></a>与内核通信</h1><p>系统调用在用户空间和硬件设备之间添加了一个中间层。该层主要作用有3个。首先，它为用户空间提供了一种硬件的抽象接口。举例来说，当需要读写文件的时候，应用程序就可以不去管磁盘类型和介质，甚至不用去管文件所在的文件系统到底是哪种类型。第二，系统调用保证了系统的稳定和安全。作为硬件设备和应用程序之间的中间人，内核可以基于权限、用户类型和其他的一些规则对需要进行的访问进行裁决。举例来说，这样可以避免应用程序不正确的使用硬件设备，窃取其他进程的资源，或做出其他危害系统的事情。第三，每个进程都运行在虚拟系统中，而在用户空间和系统的其余部分提供这样一层公共接口，也是出于这种考虑。如果应用程序可以随意的访问硬件而内核有对此一无所知的话，几乎就没法实现多任务和虚拟内存，当然也不可能实现良好的稳定性和安全性。在Linux中，系统调用是用户空间访问内核空间的唯一手段；除异常和陷入外，它们是内核唯一的合法入口。实际上，其他的像设备文件和&#x2F;proc之类的的方式，最终也还是要通过系统调用进行访问的。而有趣的是，Linux提供的系统调用却比大部分操作系统都少的多。本章重点强调Linux系统调用的规则和实现方法。</p>
<h1 id="API、POSIX和C库"><a href="#API、POSIX和C库" class="headerlink" title="API、POSIX和C库"></a>API、POSIX和C库</h1><p>一般情况下，应用程序通过在用户空间实现的应用程序接口API而不是直接通过系统调用来编程。这点很重要，因为应用程序使用的这种编程接口实际上并不需要和内核提供的系统调用对应。一个API定义了一组应用程序使用的编程接口。它们可以实现成一个系统调用，也可以通过调用多个系统调用来实现，而完全不使用任何系统调用也不存在问题。实际上，API可以在各种不同的操作系统上面实现，给应用程序提供完全相同的接口，而它们本身在这些系统上的实现却可能迥异。下图给出POSIX、API、C库以及下图调用之间的关系。<br><img src="/2022/11/02/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/1.jpeg" alt="img not found"></p>
<p><em>x86系统上大概有250个系统调用（每种体系结构都会定义一些独特的系统调用）。尽管有些系统还没有完全公布所有的系统调用，但据估计某些操作系统的系统调用数有数千个</em></p>
<p>在Unix世界中，最流行的应用编程接口是基于POSIX标准的。从纯技术的角度看，POSIX是由IEEE的一组标准组成的，其目标是提供一套大体上基于Unix的可移植的操作系统标准，其目标是提供一套基于Unix的可移植操作系统标准。在应用场合，Linux尽力与POSIX和SUSv3兼容。<br>POSIX是说明API与系统调用之间关系的一个极好例子。在大多数Unix系统上，根据POSIX定义的API函数和系统调用之间有着直接关系。实际上，POSIX标准就是仿照早期Unix系统的接口建立的。另一方面，许多操作系统，像微软的Windows，尽管是非Unix系统，也提供了与POSIX兼容的库。<br>Linux的系统调用像大多数Unix系统一样，作为C库的一部分提供。C库实现了Unix系统的主要API，包括标准C库函数和系统调用接口。所有的C程序都可以使用C库，而由于C语言本身的特点，其他语言也可以很方便地把它们封装起来使用。此外，C库提供了POSIX地绝大部分API。<br>从程序员的角度看，系统调用无关紧要，他们只需要跟API打交道就可以了。相反，内核只跟系统调用打交道；库函数以及应用程序是怎么使用系统调用，不是内核所关心的。但是，内核必须时刻牢记系统调用所有潜在的用途，并保证它们具有良好的通用性和灵活性。<br>关于Unix的接口设计有一句格言–提供机制而不是策略。换句话说，Unix的系统调用抽象出了用于完成某种确定的目的的函数。至于这些函数怎么用完全不需要内核去关心。</p>
<h1 id="系统调用"><a href="#系统调用" class="headerlink" title="系统调用"></a>系统调用</h1><p>要访问系统调用（在Linux中常称作syscall），通常通过C库定义的函数调用来进行。它们通常都需要定义零个、一个或几个参数（输入）而且可能产生一些副作用，例如，写某个文件或向给定的指针拷贝数据等。系统调用还会通过一个long类型的返回值来表示成功或者错误。通常，但也不绝对，用一个负的返回值来表明错误。返回一个0通常表明成功。系统调用在出现错误的时候C库会把错误码写入errno全局变量。通过调用perror()库函数，可以把该变量翻译成用户可以理解的错误字符串。<br>当然，系统调用最终具有一种明确地操作。例如getpid()系统调用，根据定义它会返回当前进程的PID。内核中它的实现非常简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE0(getpid)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> task_tgid_vnr(current);<span class="comment">//return current-&gt;tgid</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，定义中并没有规定它要如何实现。内核必须提供系统调用所希望完成的功能，但它完全可以按照自己预期的方式去实现，只要最后的结果正确就行。当然，上面的系统调用太简单，也没有什么更多的实现手段。<br>SYSCALL_DEFINE0是只是一个宏，它定义了一个无参数的系统调用（因此这里是数字0），展开后的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_getpid</span><span class="params">(<span class="type">void</span>)</span></span><br></pre></td></tr></table></figure>
<p>我们看一下如何定义系统调用。首先，注意函数声明中的asmlinkage限定词，这是一个编译指令，通知编译器仅从栈中提取该函数的参数。所有的系统调用都需要用到这个限定词。其次，函数返回long。为了保证32位和64位系统的兼容，系统调用在用户空间和内核空间有不同的返回值类型，在用户空间为int，在内核空间为long。最后，注意系统调用get_pid()在内核中被定义成sys_getpid()。这是Linux中所有系统调用都应该遵守的命名规则，系统调用bar()在内核中也实现为sys_bar()函数。</p>
<h2 id="系统调用号"><a href="#系统调用号" class="headerlink" title="系统调用号"></a>系统调用号</h2><p>在Linux中，每个系统调用被赋予一个系统调用号。这样，通过这个独一无二的号就可以关联系统调用。当用户空间的进程执行一个系统调用的时候，这个系统调用号就用来指明到底要执行哪个系统调用；进程不会提及系统调用的名称。<br>系统调用号相当重要，一旦分配就不能再有任何变更，否则编译好的应用程序就会崩溃。此外，如果一个系统调用被删除，它所占用的系统调用号也不允许被回收利用，否则，以前编译过的代码会调用这个系统调用，但事实上调用的是另一个系统调用。Linux有一个“未实现”系统调用sys_ni_syscall()，它除了返回-ENOSYS外不做任何其他工作，这个错误号就是专门针对无效的系统调用而设置的。虽然很罕见，但如果一个系统调用被删除，或变得不可用，这个函数就要负责“填补空缺”。<br>内核记录了系统调用表中的所有已注册过的系统调用的列表，存储在sys_call_table中。每一种体系结构中，都明确定义了这个表，在x86-64中，它定义于<code>arch/i386/kernel/syscall_64.c</code>文件中。这个表为每一个有效的系统调用指定了唯一的系统调用号。</p>
<h2 id="系统调用的性能"><a href="#系统调用的性能" class="headerlink" title="系统调用的性能"></a>系统调用的性能</h2><p>Linux系统调用比其他许多操作系统执行的要快，Linux很短的上下文切换时间是一个很重要的原因，进出内核的都被优化的简洁高效。另外一个原因就是系统调用处理程序和每个系统调用本身也都非常简洁。</p>
<h1 id="系统调用处理程序"><a href="#系统调用处理程序" class="headerlink" title="系统调用处理程序"></a>系统调用处理程序</h1><p>用户空间的程序无法直接执行内核代码。它们不能直接调用内核空间的函数，因为内核驻留在受保护的地址空间上。如果进程可以直接在内核的地址空间上读写的话，系统的安全性和稳定性将不复存在。<br>所以，应用程序应该以某种方式通知系统，告诉内核自己需要执行一个系统调用，希望系统切换到内核态，这样内核就可以代表应用程序在内核空间执行系统调用。<br>通知内核的机制是靠软中断实现的：通过引发一个异常来促使系统切换到内核态去执行异常处理程序。此时的异常处理程序实际上就是系统调用处理程序。在x86系统上预定义的软中断是中断号128，通过int$0x80指令触发该中断。这条指令会触发一个异常导致系统切换到内核态并执行第128号异常处理程序，而该程序正是系统调用处理程序。这个处理程序名字起的很贴切，叫<code>system_call()</code>。它与硬件体系结构紧密相关，x86-64的系统上在entry_64.S文件中用汇编语言编写。最近，x86处理器增加了一条叫做sysenter的指令。与int中断指令相比，这条指令提供了更快、更专业的陷入内核执行系统调用的方式。对这条指令的支持很快被加入内核。且不管系统调用处理程序如何被调用，用户空间引起异常或陷入内核就是一个重要的概念。</p>
<h2 id="指定恰当的系统调用"><a href="#指定恰当的系统调用" class="headerlink" title="指定恰当的系统调用"></a>指定恰当的系统调用</h2><p>因为所有的系统调用用陷入内核的方式都一样，所以仅仅是陷入内核空间是不够的。因此必须把系统调用号一并传给内核。在x86上，系统调用号是通过eax寄存器传递给内核的。在陷入内核之前，用户空间就把相应系统调用对应的号放入eax中。这样系统调用处理程序一旦运行，就可以从eax中得到数据。其他体系结构上的实现也都类似。<br>system_call()函数通过将给定的系统调用号与NR_syscalls做比较来检查其有效性。如果它大于或者等于NR_syscalls，函数就返回-ENOSYS。否则，就执行相应的系统调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">call *<span class="title function_">sys_call_table</span><span class="params">(,%rax,<span class="number">8</span>)</span></span><br></pre></td></tr></table></figure>
<p>由于系统调用表的表项是以64位（8字节）类型存放的，所以内核需要将给定的系统调用号乘以4，然后用所得的结果在该表中查询其位置。在x86-32位系统上，代码很类似，只是用4代替8。</p>
<h2 id="参数传递"><a href="#参数传递" class="headerlink" title="参数传递"></a>参数传递</h2><p>除了系统调用号之外，大部分系统调用还需要一些外部的参数输入。所以，在发生陷入的时候，应该把这些参数从用户空间传给内核。最简单的办法就是像传递系统调用号那样，把这些参数也存放在寄存器里面。在x86-32系统上，ebx、ecx、edx、esi和edi按照顺序存放前五个参数。需要六个或六个以上参数的情况不多见，此时，应该用一个单独的寄存器存放指向所有这些参数在用户空间地址的指针。<br><img src="/2022/11/02/%E7%B3%BB%E7%BB%9F%E8%B0%83%E7%94%A8/2.jpeg" alt="img not found"><br>给用户空间的返回值也通过寄存器传递。在x86系统上，它存放在eax寄存器中。</p>
<h1 id="系统调用的实现"><a href="#系统调用的实现" class="headerlink" title="系统调用的实现"></a>系统调用的实现</h1><p>实际上，一个Linux的系统调用在实现时并不需要太关心它和系统调用处理程序之间的关系。给Linux添加一个新的系统调用是件相对容易的工作。怎样设计和实现一个系统调用是难题所在，而把它加到内核里却无需太多周折。让我们关注一下实现一个新的Linux系统调用所需的步骤。</p>
<h2 id="实现系统调用"><a href="#实现系统调用" class="headerlink" title="实现系统调用"></a>实现系统调用</h2><p>实现一个新的系统调用的第一步是决定它的用途。它要做些什么？每个系统调用都应该有一个明确的用途。在Linux中不提倡采用多用途的系统调用（一个系统调用通过传递不同的参数值来选择完成不同的工作）。ioctl()就是一个很好的例子，告诉了我们不应当去做什么。<br>新系统调用的参数、返回值和错误码又该是什么呢？系统调用的接口应该力求简洁，参数尽可能少。系统调用的语义和行为非常关键：因为应用程序依赖于它们，所以它们应力求稳定，不做改动。设想一下，如果功能多次改变会怎样。新的功能是否可以追加到系统调用亦或是否某个改变将需要一个全新的函数？是否可以容易地修订错误而不破坏向后兼容？很多系统调用提供了标志参数以确保向前兼容。标志并不是用来让单个系统调用具有多个不同的行为。而是为了即使增加新的功能和选项，也不破坏向后兼容或不需要增加新的系统调用。<br>设计接口的时候要尽量为将来多做考虑。你是不是对函数做了不必要的限制？系统调用设计的越通用越好。不要假设这个系统调用现在这么用将来也是这么用。系统调用的目的可能不变，但它的用法却可能改变。这个系统调用可移植吗？别对机器的字节长度和字节序作假设。要确保不对系统调用做错误的假设，否则将来这个调用就可能会崩溃。记住Unix的格言：“提供机制而不是策略”。<br>当你写一个系统调用的时候，要时刻注意可移植性和健壮性，不但要考虑当前，还要为将来做打算。基本的Unix系统调用经受住了时间的考验；它们中很大一部分到现在都还和30年前一样适用和有效。</p>
<h2 id="参数验证"><a href="#参数验证" class="headerlink" title="参数验证"></a>参数验证</h2><p>系统调用必须仔细检查它们所有的参数是否合法有效。系统调用在内核空间执行，如果任由用户将不合法从输出传递给内核，那么系统的安全和稳定将面临极大的考验。<br>举例来说，与文件I&#x2F;O相关的系统调用必须检查文件描述符是否有效。与进程相关的系统调用必须检查提供的PID是否有效。必须检查每个参数，保证它们不但合法有效，而且正确。进程不应当让内核去访问那些它无权访问的资源。<br>最重要的一种检查就是检查用户提供的指针是否有效。试想，如何一个进程可以给内核传递指针而又无需检查，那么它就可以给出一个它根本就没有权限访问的指针，哄骗内核去为它拷贝本不允许访问的数据，如原本属于其他进程的数据或者不可读的映射数据。在接收一个用户空间的指针之前，内核必须保证：</p>
<ol>
<li>指针指向的内存区域属于用户空间。进程绝不能哄骗内核去读内核空间的数据。</li>
<li>指针指向的内存区域属于用户空间，进程绝不能哄骗内核去读其他进程的数据。</li>
<li>如果是读，该内存应当被标记为可读；如果是写，该内存应当被标记为可写。如果是可执行，该内存应当被标记为可执行。进程绝不能绕过内存访问限制。</li>
</ol>
<p>内核提供了两个方法来完成必须的检查和内核空间与用户空间之间的数据来回拷贝。注意，内核无论何时都不能轻率的接受来自用户空间的指针！这两个方法之中必须经常有一个被使用。<br>为了向用户空间写入数据，内核提供了copy_to_user()，它需要3个参数。第一个参数是进程空间中的目的内存地址，第二个是内核空间的源地址，最后一个参数是需要拷贝的数据长度（字节数）。<br>为了从用户空间读取数据，内核提供了copy_from_user()，它和copy_to_user()相似。该函数把第二个参数指定的位置上的数据拷贝到第一个参数指定的位置上，拷贝的数据长度由第三个参数决定。<br>如果执行失败，这两个函数返回的都是没能完成拷贝的数据的字节数。如果成功，则返回0。当出现上述错误时，系统调用返回标准-EFAULT。<br>让我们以一个既用了copy_to_user()又用了copy_from_user()的系统调用做例子进行参考。这个系统调用silly_copy()毫无实际用处，它从第一个参数里拷贝数据到第二个参数。这种用途让人无法理解，它毫无必要的让内核空间作为中转站，把用户空间的数据从一个位置复制到另外一个位置。但它却能演示上述函数的用法。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    silly_copy没有实际价值的系统调用，它把len字节的数据从“src”拷贝到“dst”，毫无理由的让内核空间作为中转站。但这确实是个好例子</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">SYSCALL_DEFINE3(silly_copy,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> *,src,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> *,dst,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">long</span> len)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> buf;</span><br><span class="line">    <span class="comment">//将用户地址空间中的src拷贝进buf</span></span><br><span class="line">    <span class="keyword">if</span>(copy_from_user(&amp;buf,src,len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="comment">//将buf拷贝进用户地址空间中的dst</span></span><br><span class="line">    <span class="keyword">if</span>(copy_to_user(dst,&amp;buf,len))</span><br><span class="line">        <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    <span class="comment">//返回拷贝的数据量</span></span><br><span class="line">    <span class="keyword">return</span> len;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，copy_to_user()和copy_from_user()都有可能引起阻塞。当包含用户数据的页被换出到硬盘上而不是在物理内存上的时候，这种情况就会发生。此时，进程就会休眠，直到缺页处理程序将该页从硬盘重新换回物理内存。<br>最后一项检查针对是否有合法权限。在老版本的Linux内核中，需要超级用户权限的系统调用才可以通过suser()函数这个标准动作来完成检查。这个函数只能检查用户是否为超级用户；现在它已经被一个更细粒度的“权能”机制代替。新的系统允许检查针对特定资源的特殊权限。调用者可以使用capable()函数来检查是否有权能对指定的资源进行操作，如果它返回非0值，调用者就有权进行操作，返回0则无权操作。举个例子，capable(CAP_SYS_NICE)可以检查调用者是否有权改变其他进程的nice值。默认情况下，属于超级用户的进程拥有所有权利而非超级用户没有任何权利。例如，下面是reboot()系统调用，注意，第一步是如何确保调用进程具有CAP_SYS_REBOOT权能。如果那样一个条件语句被删除，任何进程都可以启动系统了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SYSCALL_DEFINE4(reboot,</span><br><span class="line">                <span class="type">int</span>,magic1,</span><br><span class="line">                <span class="type">int</span>,magic2,</span><br><span class="line">                <span class="type">unsigned</span> <span class="type">int</span>,cmd,</span><br><span class="line">                <span class="type">void</span> __user *,arg)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> buffer[<span class="number">256</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//我们只信任启动系统的系统管理员</span></span><br><span class="line">    <span class="keyword">if</span>(!capable(CAP_SYS_BOOT))</span><br><span class="line">        <span class="keyword">return</span> -EPERM;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//为了安全起见，我们需要magic参数</span></span><br><span class="line">    <span class="keyword">if</span>(magic1 != LINUX_REBOOT_MAGIC1 ||</span><br><span class="line">       (magic2 != LINUX_REBOOT_MAGIC2 &amp;&amp;</span><br><span class="line">       magic2 != LINUX_REBOOT_MAGIC2A &amp;&amp;</span><br><span class="line">       magic2 != LINUX_REBOOT_MAGIC2B &amp;&amp; </span><br><span class="line">       magic2 != LINUX_REBOOT_MAGIC2C))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//当未设置pm_power_off时，请不要试图让power_off的代码看起来像是可以停机，而应该采用更简单的方式</span></span><br><span class="line">    <span class="keyword">if</span>((cmd == LINUX_REBOOT_CMD_POWER_OFF) &amp;&amp; !pm_power_off)</span><br><span class="line">        cmd = LINUX_REBOOT_CMD_HALT;</span><br><span class="line"></span><br><span class="line">    lock_kernel();</span><br><span class="line">    <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART:</span><br><span class="line">            kernel_restatrt(<span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LINUX_REBOOT_CMD_CAD_ON:</span><br><span class="line">            C_A_D = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LINUX_REBOOT_CMD_CAD_OFF:</span><br><span class="line">            C_A_D = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">case</span> LINUX_REBOOT_CMD_HALT:</span><br><span class="line">            kernel_halt();</span><br><span class="line">            unlock_kernel();</span><br><span class="line">            do_exit(<span class="number">0</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> LINUX_REBOOT_CMD_RESTART2:</span><br><span class="line">            <span class="keyword">if</span>(strncpy_from_user(&amp;buffer[<span class="number">0</span>],arg,<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                unlock_kernel();</span><br><span class="line">                <span class="keyword">return</span> -EFAULT;</span><br><span class="line">            &#125;</span><br><span class="line">            buffer[<span class="keyword">sizeof</span>(buffer) - <span class="number">1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line"></span><br><span class="line">            kernel_restart(buffer);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            unlock_kernel();</span><br><span class="line">            <span class="keyword">return</span> -EINVAL;</span><br><span class="line">        &#125;</span><br><span class="line">        unlock_kernel();</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>参见&lt;linux&#x2F;capability.h&gt;，其中包含一份所有这些权能和其对应的权限的列表。</p>
<h1 id="系统调用上下文"><a href="#系统调用上下文" class="headerlink" title="系统调用上下文"></a>系统调用上下文</h1><p>内核在执行系统调用的时候处于进程上下文。current指针指向当前任务，即引发系统调用的那个进程。<br>在进程上下文中，内核可以休眠（比如在系统调用阻塞或显式调用schedule()的时候）并且可以被抢占。这两点很重要。首先，能够休眠说明系统调用可以使用内核提供的绝大部分功能。在后面第7章我们会看到，休眠的能力会给内核编程带来极大的便利。在进程上下文中能够被抢占其实表明，像用户空间的进程一样，当前的进程同样可以被其他进程抢占。因为新的进程可以使用相同的系统调用，所以必须小心，保证该系统调用是可重入的。当然，这也是在对称多处理中必须同样关心的问题。<br>当系统调用返回的时候，控制权仍在system_call()中，它最终会负责切换到用户空间，并让用户进程继续执行下去。</p>
<h2 id="绑定一个系统调用的最后步骤"><a href="#绑定一个系统调用的最后步骤" class="headerlink" title="绑定一个系统调用的最后步骤"></a>绑定一个系统调用的最后步骤</h2><p>当编写完一个系统调用之后，把它注册成一个正式的系统调用是件琐碎的工作：</p>
<ol>
<li>首先，在系统调用表的最后加入一个表项。每种支持该系统调用的硬件体系都必须做这样的工作（大部分的系统调用都针对所有的体系结构）。从0开始算起，系统调用在该表中的位置就是它的系统调用号。如第10个系统调用被分配到的系统调用号是9。</li>
<li>对于所支持的各种体系结构，系统调用号都必须定义于&lt;asm&#x2F;unistd.h&gt;中。</li>
<li>系统调用必须被编译进内核映像（不能被编译成模块）。这只要把它放进kernel&#x2F;下的一个相关文件中就可以了，比如sys.c，它包含了各种各样的系统调用。</li>
</ol>
<p>让我们通过一个虚构的系统调用foo()来仔细观察一下这些步骤。首先，我们要把sys_foo加入到系统调用表中去。对于大多数体系结构来说，该表位于entry.S文件中，形式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(sys_call_table)</span><br><span class="line">    .long sys_restart_syscall   /*0*/</span><br><span class="line">    .long sys_exit</span><br><span class="line">    .long sys_fork</span><br><span class="line">    .long sys_read</span><br><span class="line">    .long sys_write</span><br><span class="line">    .long sys_open              /*5*/</span><br><span class="line">    ...</span><br><span class="line">    .long sys_eventfd2</span><br><span class="line">    .long sys_epoll_create1</span><br><span class="line">    .long sys_dup3              /*330*/</span><br><span class="line">    .long sys_pipe2</span><br><span class="line">    .long sys_inotify_init1</span><br><span class="line">    .long sys_preadv</span><br><span class="line">    .long sys_pwritev</span><br><span class="line">    .long sys_rt_tgsigqueueinfo /*335*/</span><br><span class="line">    .long sys_perf_event_open</span><br><span class="line">    .long sys_recvmmsg</span><br></pre></td></tr></table></figure>
<p>我们把新的系统调用加到这个表达末尾：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.long sys_foo</span><br></pre></td></tr></table></figure>
<p>虽然没有明确地指定编号，但我们加入的这个系统调用被按照次序分配给了338这个系统调用号。<code>对于每种需要支持的体系结构，我们都必须将自己的系统调用加入到其系统调用表中去</code>。每种体系结构不需要对应相同的相同调用号。系统调用号是专属于体系结构ABI（应用程序二进制接口）的部分。通常，你需要让系统调用适用每种体系结构。你可以注意一下，每隔5个表项就加入一个调用号的注释的习惯，这可以在查找系统调用对应的调用号时提供方便。<br>接下来，我们把系统调用号加入到&lt;asm&#x2F;unistd.h&gt;中，它的格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    本文件包含系统调用号</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_restart_syscall    0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_exit               1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_fork               2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_read               3</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_write              4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_open               5</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_signalfd4          327</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_eventfd2           328</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_epoll_create1      329</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_dup3               330</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pipe2              331</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_inotify_init1      332</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_preadv             333</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_pwritev            334</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_rt_tgsigqueueinfo  335</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_perf_event_open    336</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_recvmmsg           337</span></span><br></pre></td></tr></table></figure>
<p>然后我们在该列表中加入下面这行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_foo                338</span></span><br></pre></td></tr></table></figure>
<p>最后，我们来实现foo()系统调用。无论何种配置，该系统调用都必须编译到核心的内核映像中去，所以在这个例子中我们把它放进<code>kernel/sys.c</code>文件中。你也可以将其放到与其功能联系最紧密的代码中去，假如它的功能与调度相关，那么你也可以把它放到<code>kernel/sched.c</code>中去。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/page.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    sys_foo 每个人喜欢的系统调用</span></span><br><span class="line"><span class="comment">    返回每个进程的内核栈大小</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_foo</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> THREAD_SIZE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>就是这样！现在就可以启动内核并在用户空间调用foo()系统调用了。</p>
<h2 id="从用户空间访问系统调用"><a href="#从用户空间访问系统调用" class="headerlink" title="从用户空间访问系统调用"></a>从用户空间访问系统调用</h2><p>通常，系统调用靠C库支持。用户程序通过包含标准头文件并和C库链接，就可以使用系统调用（或者调用库函数，再由库函数实际调用）。但如果你仅仅写出系统调用，glibc库恐怕并不提供支持。<br>指定庆幸的是，Linux本身提供了一组宏，用于直接对系统调用进行访问。它会设置好寄存器并调用陷入指令。这些宏是_syscalln()，其中n的范围从0到6，代表需要传递给系统调用的参数个数，这是由于该宏必须了解到底有多少个参数按照什么次序压入寄存器。举个例子，open()系统调用的定义是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">long</span> <span class="title function_">open</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *filename,<span class="type">int</span> flag,<span class="type">int</span> mode)</span></span><br></pre></td></tr></table></figure>
<p>而不靠库支持，直接调用此系统调用的宏的形式为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NR_open 5</span></span><br><span class="line">_syscall3(<span class="type">long</span>,open,<span class="type">const</span> <span class="type">char</span> *,filename,<span class="type">int</span>,flags,<span class="type">int</span>,mode)</span><br></pre></td></tr></table></figure>
<p>这样，应用程序就可以直接使用open()。<br>对于每个宏来说，都有2+2*n个参数。第一个参数对应着系统调用的返回值类型。第二个参数是系统调用的名称。再以后是按照系统调用参数的顺序排列的每个参数的类型和名称。_NR_open在&lt;asm&#x2F;unistd.h&gt;中定义，是系统调用号。该宏会被扩展成为内嵌汇编的C函数；由汇编语言执行前面内容中所讨论的步骤，将系统调用号和参数压入寄存器并触发软中断来陷入内核。调用open()系统调用直接把上面的宏放置在应用程序中就可以了。<br>让我们写一个宏来使用前面编写的foo()系统调用，然后再写出测试代码炫耀一下我们所作的努力。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __NR_foo 283</span></span><br><span class="line">__syscall0(<span class="type">long</span>,foo)</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">long</span> stack_size;</span><br><span class="line"></span><br><span class="line">    stack_size = foo();</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The kernel stack size is %ld\n&quot;</span>,stack_size);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="为什么不通过系统调用的方式实现"><a href="#为什么不通过系统调用的方式实现" class="headerlink" title="为什么不通过系统调用的方式实现"></a>为什么不通过系统调用的方式实现</h2><p>前面的内容已经告诉了大家，建立一个新的系统调用非常容易，但却绝不提倡这么做。的确，你应该多练习如何给一个新的系统调用加警告与限制。通常都会有更好的办法用来代替新建一个系统调用以作实现。让我们看看采用系统调用作为实现方式的利弊与替代的方法。<br>建立一个新的系统调用的好处：</p>
<ol>
<li>系统调用创建容易且使用方便。</li>
<li>Linux系统调用的高性能显而易见。</li>
</ol>
<p>问题是：</p>
<ol>
<li>你需要一个系统调用号，而这需要一个内核处于开发版本的时候由官方分配给你。</li>
<li>系统调用被加入稳定内核后就被固化了，为了避免应用程序的崩溃，它的接口不允许做改动。</li>
<li>需要将系统调用分别注册到每个需要支持的体系结构中去。</li>
<li>在脚本中不容易调用系统调用，也不能从文件系统直接访问系统调用。</li>
<li>由于你需要系统调用号，因此在主内核树之外是很难维护和使用系统调用的。</li>
<li>如果仅仅进行简单的信息交换，系统调用就大才小用了。</li>
</ol>
<p>替代方法：<br>实现一个设备节点，并对此实现read()和write()。使用ioctl()对特定的设置进行操作或者对特定的信息进行检索。</p>
<ol>
<li>像信号量这样的某些接口，可以用文件描述符来表示，因此也就可以按上述方式对其进行操作。</li>
<li>把增加的信息作为一个文件放在sysfs的合适位置。</li>
</ol>
<p>对于许多接口来说，系统调用都被视为正确的解决之道。但Linux系统尽量避免没出现一种新的抽象就简单的加入一个新的系统调用。这使得它的系统调用接口简洁的令人叹为观止，也就避免了许多后悔和反对意见（系统调用再也不被使用或支持）。新系统调用增添频率很低也反映出Linux是一个相对较为稳定并且功能已经较为完善的操作系统。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在本章，我们描述了系统调用到底是什么，它们与库函数和应用程序接口（API）有怎样的关系。然后，我们考察了Linux内核如何让实现系统调用，以及执行系统调用的连锁反应：陷入内核，传递系统调用号和参数，执行正确的系统调用函数，并把返回值带回用户空间。<br>然后我们讨论了如何增加系统调用，并提供了从用户空间调用系统调用的简单例子。整个过程相当容易！增加一个新的系统调用没什么难的，这一过程也就是系统调用的实现过程。本书的其余部分讨论了编写规范的、最优化的、安全的系统调用所遵循的概念和内核接口规范。<br>最后，我们通过讨论实现系统调用的优缺点以及列举其替代方案的形式对全章内容进行了总结。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第5章 系统调用</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内核同步介绍</title>
    <url>/2022/11/16/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%BB%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在使用共享内存的应用程序中，程序员必须特别留意保护共享资源，防止共享资源并发访问。内核也不例外。共享资源之所以要防止并发访问，是因为如果多个执行线程同时访问和操作数据，就有可能发生各线程之间相互覆盖共享数据的情况，造成被访问数据处于不一致的状态。并发访问共享数据是造成系统不稳定的一类隐患，而且这种错误一般难以跟踪和调试–所以首先要认识到这个问题的重要性。<br>要做到对共享资源的恰当保护往往很困难。多年之前，在Linux还未支持对称多处理器的时候，避免并发访问数据的方法相对来说比比较简单。在单一处理器的时候，只有在中断发生的时候，或在内核代码明确请求调度、执行另一个任务的时候，数据才有可能被并发访问。因此早期内核开发工作相比如今要简单许多！<br>但当年的太平日子一区不复返了，从2.0版开始，内核就开始支持对称多处理器了，而且从那以后对它的支持不断地加强和完善。支持多处理器意味着内核代码可以同时运行在两个或者更多的处理器上。因此如果不加保护运行在两个不同处理器上的内核代码完全可能在同一时间并发访问共享数据。随着2.6版本内核的出现，Linux内核已经发展成抢占式内核，这意味着调度程序可以在任何时刻抢占正在运行的内核代码，重新调度其他的进程执行。现在，内核代码中有不少部分都能够同步执行，而它们都必须妥善的保护起来。<br>本章我们将提纲挈领式地讨论操作系统内核中的并发和同步问题。下一章我们将详细介绍Linux内核为解决同步问题和防止产生竞争条件而提供的机制及接口。</p>
<span id="more"></span>

<h1 id="临界区和竞争条件"><a href="#临界区和竞争条件" class="headerlink" title="临界区和竞争条件"></a>临界区和竞争条件</h1><p>所谓临界区即使访问和操作共享数据的代码段。多个执行线程并发访问同一资源通常是不安全的，为了避免在临界区中并发访问，编程者必须保证这些代码原子的执行–也就是说，操作在执行结束之前不可被打断，就如同整个临界区是一个不可分割的指令一样。如果两个执行线程有可能处于同一临界区中同时执行，那么这就是程序包含的一个bug。如果这种情况确实发生了，我们就称它是竞争条件（race conditions），这样命名是因为这里会存在线程竞争。这种情况出现的机会往往非常小–就是因为竞争引起的错误非常不易重现，所以调试这种错误才会非常困难。避免并发和防止竞争条件称为同步（synchronization）。</p>
<h2 id="为什么我们需要保护"><a href="#为什么我们需要保护" class="headerlink" title="为什么我们需要保护"></a>为什么我们需要保护</h2><p>为了认清同步的必要性，我们首先要明白临界区无处不在。作为第一个例子，让我考察一下现实世界的情况：ATM自动取款机。<br>自动提款机所进行的主要操作就是从个人银行账户取钱。某人走到机器前，插入ATM卡，输入密码作为验证，选择取款，输入金额，敲确认，取出钱，然后发信息通知本人。<br>当用户要求取，某一特定的金额后，提款机需要确保在其账户上的确那么有钱。如果有，取款机就要从现有的金额中扣除取款额。实现这一描述的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> total = get_total_from_account();       <span class="comment">//账户上的总额</span></span><br><span class="line"><span class="type">int</span> withdrawal = get_withdrawal_amount();   <span class="comment">//用户要求的取款额</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//检查用户账户上是否有足够的金额</span></span><br><span class="line"><span class="keyword">if</span>(total &lt; withdrawal) &#123;</span><br><span class="line">    error(<span class="string">&quot;You do not have that much money!&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//好啦，用户有足够的金额，从总额中扣除取款项</span></span><br><span class="line">total -= withdrawal;</span><br><span class="line">update_total_funds(total);</span><br><span class="line"></span><br><span class="line"><span class="comment">//把钱给用户</span></span><br><span class="line">spit_out_money(withdrawal);</span><br></pre></td></tr></table></figure>
<p>现在让我们假定在用户账户上的另一个扣款操作同时发生。看看扣款是如何同时发生的：假设用户的配偶在另一台ATM上开始另外的取款；而这和上述扣款同时进行–或者以电子形式从账户转出资金，或者是银行从账户上扣除某一费用，或者是其他形式的扣款。<br>正在取款的两个系统都会执行我们刚刚看到的代码：首先检查扣款是否有可能，然后计算新的总额，最后进行实际的扣款。现在让我们虚拟一些数字。假定第一次从ATM扣款额是100，第二次扣除银行申请费10。假定客户在银行总共有105。显然，如果账户不出现赤字，这两个操作中有一个就无法完成。<br>你可能希望发生的顺序是这样的：收费事务先发生。10小于105，因此从105中减去10得到新的金额95。之后，ATM取款发生，但未取到，因为95小于100。<br>在竞争的环境下，实际生活可能更有趣。假定两个事务几乎同时开始。两个事务都验证是否有足够的金额存在：105既大于100，也大于10，所以两个条件都满足。于是，取款过程从105减去100，剩余5。收费事务也如法炮制，从105减去10，剩余95。此刻，收费事务也更新新的总额，结果得到95。<br>显而易见，金融机构必须确保类似情况绝不发生，他们必须在某些操作期间对账户加锁，确保每个事务相对其他任何事务的操作是原子性的。这样的事务必须完整的发生，要么干脆不发生，但是绝不能打断。</p>
<h2 id="单个变量"><a href="#单个变量" class="headerlink" title="单个变量"></a>单个变量</h2><p>现在，让我们看一个特殊计算的例子。考虑一个非常简单的共享资源：一个全局整形变量和一个简单的临界区，其中的操作仅仅是将整形变量的值增加1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">i++;</span><br></pre></td></tr></table></figure>
<p>该操作可以转化成类似于下面动作的机器指令序列：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">得到当前变量i的值并且拷贝到一个寄存器中</span><br><span class="line">将寄存器中的值加1</span><br><span class="line">把i的新值写回到内存中</span><br></pre></td></tr></table></figure>
<p>现在假定有两个执行线程同时进入这个临界区，如果i的初始值是7，那么，我们所期望的结果应该像下面这样（每一行代表一个时间单元）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1               线程2</span><br><span class="line">获得i(7)            ---</span><br><span class="line">增加i(7-&gt;8)         ---</span><br><span class="line">写回i(8)            ---</span><br><span class="line">---                 获得i(8)</span><br><span class="line">---                 增加i(8-&gt;9)</span><br><span class="line">---                 写回i(9)</span><br></pre></td></tr></table></figure>
<p>正如所期望的，7被两个线程分别加1变为9。但是，实际的执行序列却可能如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1               线程2</span><br><span class="line">获得i(7)            获得i(7)</span><br><span class="line">增加i(7-&gt;8)         ---</span><br><span class="line">---                 增加i(7-&gt;8)</span><br><span class="line">写回i(8)            ---</span><br><span class="line">---                 写回i(8)</span><br></pre></td></tr></table></figure>
<p>如果两个执行线程都在变量i值增加前读取它的初值，进而又分别增加变量i的值，最后再保存该值，那么变量i的值就变成了8，而变量i的值本该是9的。这是最简单的临界区例子，幸好对于这种简单竞争条件的解决办法也同样简单–我们仅仅需要将这些指令作为一个不可分割的整体来执行就完事大吉了。多数处理器都提供了指令来原子地读变量、增加变量，然后再写回变量，使用这样的指令就能解决一些问题。使用这些原子指令唯一可能地的结果是：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1                线程2</span><br><span class="line">增加i(7-&gt;8)          ----</span><br><span class="line">---                  增加i(8-&gt;9)</span><br><span class="line">或者是相反</span><br><span class="line">线程2                线程1</span><br><span class="line">增加i(7-&gt;8)          ----</span><br><span class="line">---                  增加i(8-&gt;9)</span><br></pre></td></tr></table></figure>
<p>两个原子操作交错执行根本就不可能发生，因为处理器会从物理上确保这种不可能。使用这样的指令会缓解这种问题，内核也提供了一组实现这些原子操作的接口，我们将在下一章中讨论它们。</p>
<h1 id="加锁"><a href="#加锁" class="headerlink" title="加锁"></a>加锁</h1><p>现在我们来讨论一个更为复杂的竞争条件，相应的解决办法也更为复杂。假设需要处理一个队列上的所有请求。我们假定该队列是通过链表得以实现，链表中的每个节点就代表一个请求。有两个函数可以用来操作此队列：一个函数将新请求添加到队列尾部，另一个函数从队列头部删除请求，然后处理它。内核各个部分都会调用这老两个函数，所以内核会不断地在队列中加入请求，从队列中删除和处理请求。对请求队列的操作无疑是要用到多条指令。如果一个线程试图读取队列，而这时正好另一个线程正在处理该队列，那么读取线程就会队列此刻正处于不一致状态。很明显，如果允许并发访问队列，就会产生危害。当共享资源是一个复杂的数据结构时，竞争条件往往会使该数据结构遭到破坏。<br>表面上看，这种情况好像没有一个好的方法来解决，一个处理器读取队列的时候，我们怎么能禁止另一个处理器更新队列呢？虽然有些体系结构提供了简单的原子指令，实现算术运算比较之类的原子操作，但让体系结构提供专门的指令，对像上例中那样的不定长度的临界区进行保护，就强人所难了。我们需要一种方法确保一次有且只有一个线程对数据结构进行操作，或者当另一个线程在对临界区标记时，就禁止（或者说锁定）其他访问。<br>锁提供的就是这种机制：它如同一把门锁，门后的房间可想象成一个临界区。在一个指定的时间内，房间里面只能有一个执行线程存在，当一个线程进入房间之后，它会锁住身后的房门；当它结束对共享数据的操作后，就会走出房间，打开门锁。如果另一个线程在房门上锁时来了，那么它就必须等待房间内的线程出来并打开门锁后，才能进入房间。这样，线程持有锁，而锁保护了数据。<br>前面例子中讲到的请求队列，可以使用一个单独的锁进行保护。每当一个新请求要加入队列，线程会首先占住锁，然后就可以安全地将请求加入到队列中，结束操作后再释放该锁；同样当一个线程想从请求队列删除一个请求时，也需要先占住锁，然后才能从队列中读取和删除请求，而且在完成操作后也必须释放锁。任何要访问队列的其他线程也类似，必须占住锁后才能进行操作。因为在一个时刻只能有一个线程持有锁，所以在一个时刻只有一个线程可以操作队列。如果一个线程正在更新队列时。另一个线程出现了，则第二个线程必须等待第一个线程释放锁，它才能继续进行。由此可见锁机制可以防止并发执行，并且保护队列不受竞争条件的影响。<br>任何要访问队列的代码首先都需要占住相应的锁，这样该锁就能阻止来自其他执行线程的并发访问：<br><img src="/2022/11/16/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E4%BB%8B%E7%BB%8D/1.jpeg" alt="img not found"><br>请注意锁的使用是自愿的、非强制的，它完全属于一种编程者自选的编程手段。没有什么可以强制编程者在操作我们虚构的队列时必须使用锁。当然，如果不这么做，无疑会造成竞争条件而破坏队列。<br>锁有多种多样的形式，而且加锁的粒度范围也各不相同–Linux自身实现了几种不同的锁机制。各种锁机制之间的区别主要在于：当锁已经被其他线程持有，因而不可用时的行为表现–一些锁被争用时会简单地执行忙等待，而另外一些锁会使用当前任务睡眠直到锁可用为止。下一章我们将讨论Linux中不同锁之间的行为差别以及它们的接口。<br>机灵的读者此时会尖叫起来，锁根本解决不了什么问题，它只不过是把临界区缩小到加锁和开锁之间（也许更小）的代码，但是仍然有潜在的竞争！所幸，锁是采用原子操作实现的，而原子操作不存在竞争。单一指令可以验证它的关键部分是否抓住，如果没有的话，就抓住它。其实现是与具体的体系结构密切相关的，但是，几乎所有的处理器都实现了测试和设置指令，这一指令测试整数的值，如果其值为0，就设置一新值。0意味着开锁。在流行的x86体系结构中，锁的实现也不例外，它使用了称为compare和exchange的类似指令。</p>
<h2 id="造成并发执行的原因"><a href="#造成并发执行的原因" class="headerlink" title="造成并发执行的原因"></a>造成并发执行的原因</h2><p>用户空间之所以需要同步，是因为用户程序会被调度程序抢占和重新调度。由于用户进程可能在任何时刻被抢占，而调度程序完全可能选择另一个高优先级的进程到处理器上执行，所以就会使得一个程序正处于临界区，被非自愿地抢占了。如果新调度的进程随后也进入了同一临界区（比如说，这两个进程要操作共享的内存，或者向同一文件描述符中写入），前后两个进程相互之间就会产生竞争。另外，因为信号处理是异步发生的，所以，即使是单线程的多个进程共享文件，或者在一个程序内部处理信号，也有可能产生竞争条件。这种类型的并发操作–这里其实两者并不真是同时发生，但它们相互交叉进行，所以也可称作伪并发执行。<br>如果你有一台支持对称都处理器的机器，那么两个进程就可以真正地在临界区中同时执行了，这种类型称为真并发。虽然真并发和伪并发的原因和含义不同，但它们都同样会造成竞争条件，而且也需要同样的保护。<br>内核中有类似可能造成并发执行的原因。它们是：</p>
<ol>
<li>中断–中断几乎可以在任何时刻异步发生，也就可能随时打断当前正在执行的代码。</li>
<li>软中断和tasklet–内核能在任何时刻唤醒或调度软中断和tasklet，打断当前正在执行的代码。</li>
<li>内核抢占–因为内核具有抢占性，所以内核中的任务可能会被另一任务抢占。</li>
<li>睡眠及与用户空间的同步–在内核执行的过程可能会睡眠，就会唤醒调度程序，从而导致调度另一个新的用户进程执行。</li>
<li>对称多处理–两个或多个处理器可以同时执行代码。</li>
</ol>
<p>对内核开发者来说，必须理解上述这些并发执行的原因，并且为它们事先做足准备工作。如果在一段内核代码操作某资源的时候系统产生了一个中断，而且该中断的处理程序还要访问这一资源，这就是一个bug；类似的，如果一段内核代码在访问一个共享资源期间可以被抢占，这也是一个bug；还有，如果内核代码在临界区里睡眠，那简直就是鼓掌欢迎竞争条件的到来。最后还要注意，两个处理器绝对不能同时访问同一共享数据。当我们清除什么样的数据需要保护时，提供锁来保护系统稳定也就不能做到了。然而，真正困难的就是发现上述的潜在并发执行的可能，并有意识地采取某些措施来防止并发执行。<br>我们要重申这点，因为它实在是很重要。其实，真正用锁来保护共享资源并不困难，尤其是在设计代码的早期就这么做了，事情就更简单了。辨认出真正需要共享的数据和相应的临界区，才是真正具有挑战的地方。要记住，最开始设计代码的时候就要考虑加入锁，而不是事后才想到。如果代码已经写好了，再在其中找到需要上锁的部分并向其中追加锁，是非常困难的，结果也往往不尽人意。所以，避免这种亡羊补牢的做法是：在编写代码的开始阶段就要设计恰当的锁。<br>在中断处理程序中能避免并发访问的安全代码称作中断安全代码（interrupt-safe），在对称多处理的机器中能避免并发访问的安全代码称为SMP安全代码（SMP-safe），在内核抢占时能避免并发访问的安全代码称为抢占安全代码（preempt-safe）。</p>
<h2 id="了解要保护什么"><a href="#了解要保护什么" class="headerlink" title="了解要保护什么"></a>了解要保护什么</h2><p>找出哪些数据需要保护是关键所在。由于任何可能被并发访问的代码几乎无例外地需要保护，所以寻找哪些代码不需要保护反而相对容易些，我们也就从这里入手。执行线程的局部数据仅仅被它本身访问，显然不需要保护，比如，局部自动变量（还有动态分配的数据结构，其地址仅存放在堆栈中）不需要任何形式的锁，因为它们独立存在于执行线程的栈中。类似的，如果数据只会被特定的进程访问，那么也不需要加锁（因为进程一次只在一个处理器上执行）。<br>到底什么数据需要加锁呢？大多数内核数据结构都需要加锁！有一条很好的经验可以帮助我们判断：如果有其他执行进程可以访问这些数据，那么就给这些数据加上某种形式的锁；如果任何其他什么东西都能看到它，那么就要锁住它。<code>记住：要给数据而不是给代码加锁。</code><br><strong>配置选项</strong><br>因为Linux内核可在编译时配置，所以你可以针对指定机器进行内核裁剪。更重要的是，CONFIG_SMP配置选项控制内核是否支持SMP。许多加锁问题在单处理器上是不存在的，因而当CONFIG_SMP没被设置时，不必要的代码就不会被编入针对单处理器的内核映像中。这样做可以使单处理器机器避免使用自旋锁带来的开销。同样的技巧也适用于CONFIG_PREEMPT（允许内核抢占的配置选项）。这种设计真的很优越–内核只用维护一些简洁的基础资源，各种各样的锁机制当需要时可随时被编译进内核使用。在不同的体系结构上，CONFIG_SMP和CONFIG_PREEMPT设置不同，实际编译时包含的锁就不同。<br>在代码中，要为大多数糟糕的情况提供适当的保护，例如具有内核抢占的SMP，并且要考虑到所有的情况。</p>
<p>在编写内核代码时，你要问自己下面这些问题：</p>
<ol>
<li>这个数据是不是全局的？除了当前线程外，其他线程能不能访问它？</li>
<li>这个数据会不会在进程上下文和中断上下文中共享？它是不是要在两个不同的中断处理程序中共享？</li>
<li>进程在访问数据时可不可能被抢占？被调度的新程序会不会访问统一数据？</li>
<li>当前进程是不是会睡眠（阻塞）在某些资源上，如果是，它会让共享数据处于何种状态？</li>
<li>怎样防止数据失控？</li>
<li>如果这个函数又在另一个处理器上被调度将会发生什么呢？</li>
<li>如何确保代码远离并发威胁呢？</li>
</ol>
<h1 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h1><p>死锁的产生需要一定条件：要有一个或多个执行线程和一个或多个资源，每个线程都在等待其中的一个资源，但所有的资源都已经被占用了。所有线程都在相互等待。但它们永远不会释放已经占用的资源。于是任何线程都无法继续，这便意味着死锁的发生。<br>一个很好的死锁例子就是四路交通堵塞问题。如果每一辆停止的车都决心等待其他的车开动后自己再启动，那么就没有任何一辆车能启动，于是就造成了交通死锁的发生。<br>最简单的死锁例子就是自死锁：如果一个执行线程试图去获得一个自己已经持有的锁，它将不得不等待锁被释放，但因为它正忙着等待这个锁，所以自己永远无法有机会释放锁，最终的结果就是死锁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">获得锁</span><br><span class="line">再次试图获得锁</span><br><span class="line">等待锁重新可用</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>同样道理，考虑有n个线程和个锁，如果每个线程都持有一把其他线程需要得到的锁，那么所有线程都将阻塞地等待它们希望得到的锁重新可用。最常见的例子是有两个线程和两把锁，它们通常被叫做ABBA死锁。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1               线程2</span><br><span class="line">获得锁A             获得锁B</span><br><span class="line">试图获得锁B         试图获得锁A</span><br><span class="line">等待锁B             等待锁A</span><br></pre></td></tr></table></figure>
<p>每个线程都在等待其他线程持有的锁，但是绝没有一个线程会释放它们一开始就持有的锁，所以没有任何锁会会在释放后被其他线程使用。<br>预防死锁的发生非常重要，虽然很难证明代码不会发生死锁，但是可以写出避免死锁的代码，一些简单的规则对避免死锁大有帮助：</p>
<ol>
<li>按顺序加锁。使用嵌套的锁时必须保证以相同的顺序获取锁，这样可以阻止致命拥抱类型的死锁。最好能记录下锁的顺序，以便其他人也能照此顺序使用。</li>
<li>防止发生饥饿。试问，这个代码的执行是否一定会结束？如果“张”不发生？“王”要一直等下去吗？</li>
<li>不要重复请求同一个锁。</li>
<li>设计应力求简单–越复杂的加锁方案越有可能造成死锁。</li>
</ol>
<p>最值得强调的是第一点，它最为重要。如果有两个或多个锁曾在同一时间里面被请求，那么以后其他函数请求它们也必须按照前次的加锁顺序进行。假设有cat、dog和fox这几个锁来保护某同名的多个数据结构，同时假设有一个函数对这三个锁保护的数据结构进行操作–可能在它们之间进行拷贝。不管哪种情况，这些数据结构都需要保护才能被安全访问。如果有一个函数以cat、dog，然后以fox的顺序获得了锁，那么其他任何函数都必须以同样的顺序来获得这些锁（或是它们的子集）。如果其他函数首先获得了锁fox，然后获得锁dog（因为锁dog总是应该先于锁fox被获得），就有死锁的可能（所以是个bug）。为更直观的说明，下面给出一个造成死锁的例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1               线程2</span><br><span class="line">获得锁cat           获得锁fox</span><br><span class="line">获得锁dog           试图获得锁dog</span><br><span class="line">试图获得锁fox       等待锁dog</span><br><span class="line">等待锁fox           ......</span><br></pre></td></tr></table></figure>
<p>线程1在等待锁fox，而该锁此刻被线程2持有；同样线程2正在等待锁dog，而该锁此刻又被线程1持有。任何一方都不会放弃自己已持有的锁，于是双方都会永远等待下去–也就是死锁。但是，只要线程都按照相同的顺序去获取这些锁，就可以避免上述的死锁情况。<br>只要嵌套地使用多个锁，就必须按照相同的顺序去获取它们。在代码中使用锁的地方，对锁的获取顺序加上注释是个良好习惯。下面的例子就做得很不错：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    cat_lock---用于保护访问cat数据结构的锁，总是要在获得锁dog前先获得</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>尽管释放锁的顺序和死锁是无关的，但最好还是以获得锁的相反顺序来释放锁。<br>防止死锁很重要，所以Linux内核提供了一些简单易用的调试工具，可以在运行时检测死锁。</p>
<h1 id="争用和扩展性"><a href="#争用和扩展性" class="headerlink" title="争用和扩展性"></a>争用和扩展性</h1><p>锁的争用（lock contention），或简称争用，是指当锁正在被占用时，有其他线程试图获得该锁。说一个锁处于高度争用状态，就是指有多个其他线程在等待获得该锁。由于锁的作用是使程序以串行方式对资源进行访问，所以使用锁无疑会降低相同的性能。被高度争用（频繁被持有，或者长时间持有–两者都有就更糟糕）的锁会成为系统的瓶颈，严重降低系统性能。即使是这样，相比于被几个相互抢夺共享资源的线程撕成碎片，搞得内核崩溃，还是这种同步保护来得更好一点。当然，如果有办法能解决高度争用问题，就更好不过了。<br>扩展性（scalability）是对系统可扩展程度的一个量度。对于操作系统，我们在谈及可扩展性时就会和大量进程、大量处理器或是大量内存等联系起来。其实任何可以被计量的计算机组件都可以涉及这种扩展性。理想情况下，处理器的数量加倍应该会使系统处理性能翻倍。而实际上，这是不可能达到的。<br>自从2.0版内核引入多处理支持后，Linux对集群处理器的可扩展性大大提高了。在Linux刚加入对多处理器支持的时候，一个时刻只能有一个任务在内核中执行；在2.2版本中，当加锁机制发展到细粒度（fine-grained）加锁后，便取消了这种限制，而在2.4和后续版本中，内核加锁的粒度变得越来越精细。如今，在Linux2.6内核中，内核加的锁是非常细的粒度，可扩展性也很好。<br>加锁粒度用来描述加锁保护的数据规模。一个过粗的锁保护大块数据—比如，一个子系统用到的所有的数据结构；相反，一个过于精细的锁保护很小的一块数据—比如，一个大数据结构中的一个元素。在实际使用中，绝大多数锁的加锁范围都处于上述两种极端之间，保护的既不是一个完整的子系统也不是一个独立元素，而可能是一个单独的数据结构。许多锁的设计在开始阶段都很粗，但是当锁的争用问题问题变得严重时，设计就向更加精细的加锁方向进化。<br>在之前讨论过的运行队列，就是一个锁从粗到精细化的实例。在2.4版和更早的内核中，调度程序有一个单独的调度队列（回忆一下，调度队列是一个由可调度进程组成的链表），在2.6版本内核系列的早期版本中，O(1)调度程序为每个处理器单独配备一个运行队列，每个队列拥有自己的锁，于是加锁由一个全局锁精化到了每个处理器拥有各自的锁。这是一种重要的优化，因为运行队列锁在大型机器上被争着用，本质上就是要在调度程序上每次都把整个调度进程下放到单个处理器上执行。在2.6版内核系列的新近版本中，CFS调度器进一步提升了锁的可扩展性。<br>一般来说，提高可扩展性是件好事，因为它可以提高Linux在更大型的、处理能力更强大的系统上的性能。但是一味的“提高”可扩展性，却会导致Linux在小型SMP和UP机器上的性能降低，这是因为小型机器可能用不到特别精细的锁，锁的过细只会增加复杂度，并加大开销。考虑一个链表，最初的加锁方案可能就是用一个锁来保护链表，后来发现，在拥有集群处理器机器上，当各个处理器需要频繁访问该链表的时候，只用单独一个锁却成了扩展性的瓶颈。为解决这个瓶颈，我们将原来加锁的整个链表变成为链表中的每一个节点都加入自己的锁，这样一来，如果要对节点进行读写，必须先得到这个节点对应的锁。将加锁粒度变细后，多处理器访问同一个节点的时候，只会争用一个锁。可是这时锁的争用仍然没有完全避免，那么，能不能为每个节点中的每个元素都提供一个锁呢？答案是不能。严格的讲，即使这么细的锁可以在大规模SMP机器上执行的很好，但它在双处理器机器上的表现又会怎样？如果在双处理器机器锁争用表现得并不明显，那么多余的锁会加大系统开销，造成很大的浪费。<br>不管怎么说，可扩展性都是很重要的，需要慎重考虑。<code>关键在于，在设计锁的开始阶段就应该考虑到要保证良好的扩展性。</code>因为即使在小型机器上，如果对重要资源锁得太粗，也很容易造成系统性能瓶颈。锁加得过粗或过细，差别往往只在一线之间。<code>当锁争用严重时，加锁太粗会降低可扩展性；而锁争用不明显时，加锁过细会加大系统开销，带来浪费，这两种情况都会造成系统性能下降</code>。但要记住：设计初期加锁方案应该力求简单，仅当需要时再进一步细化加锁方案。精髓在于力求简单。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>要编写SMP安全代码，不能等到编码完成后才考虑如何加锁。恰当的同步（也就是加锁）（既要满足不死锁、可扩展，而且还要清晰、简洁）需要从头到尾，在整个编码过程中不断考虑与完善。无论你在编写哪种内核代码，是新的系统调用也好，还是重写驱动程序也好，首先应该考虑的就是保护数据不被并发访问，记住，加锁你的代码。<br>下一章将讨论如何为SMP、内核抢占和其他各种情况提供充分的同步保护，确保数据在任何机器和配置中的安全。<br>了解了同步、并发和加锁的基本原理之后，让我们现在潜心钻研Linux内核提供的实际工具，以确保你的代码有竞争力但免于死锁。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第9章 内核同步介绍</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式编程基础知识</title>
    <url>/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第1篇第3章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解交叉编译工具链的各种选项</li>
<li>掌握连接脚本的编译方法</li>
<li>了解Makefile文件中常用的函数</li>
<li>了解几个常用的ARM汇编指令</li>
<li>了解汇编程序调用C函数所遵循的ATPCS规则</li>
</ol>
<h1 id="交叉编译工具选项说明"><a href="#交叉编译工具选项说明" class="headerlink" title="交叉编译工具选项说明"></a>交叉编译工具选项说明</h1><p>源文件需要经过编译才能生成可执行文件。在Windows上进行开发时，只需要单击几个按钮即可编译，集成开发环境已经将各种编译工具的使用封装好了。Linux下也有很多优秀的集成开发工具，但是更多的是时候是直接使用编译工具；即使使用集成开发工具，也需要掌握一些编译选项。<br>PC上的编译工具链为gcc、ld、objcopy、objdump等，它们编译出来的程序在x86平台上运行。要编译出在ARM平台上运行的程序，必须要使用交叉编译工具arm-linux-gcc、arm-linux-ld。</p>
<h2 id="arm-linux-gcc选项"><a href="#arm-linux-gcc选项" class="headerlink" title="arm-linux-gcc选项"></a>arm-linux-gcc选项</h2><p>一个c&#x2F;c++文件需要经过预处理，编译，汇编，链接等4步才能变成可执行文件。</p>
<ol>
<li>预处理<br>c&#x2F;c++源文件中，以”#“开头的命令被称为预处理命令。如包含命令”#include“，宏定义命令”#define“，条件编译命令”#if“，”#ifdef“等。预处理就是将要包含的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些代码输入到一个”.i“文件中等待进一步处理。预处理将要用到arm-linux-cpp工具。</li>
<li>编译<br>编译就是把c&#x2F;c++代码”翻译“汇编代码，所用到的工具为ccl（它的名字就是ccl，而不是arm-linux-ccl）。</li>
<li>汇编<br>汇编就是将第二步输出的汇编代码翻译成一定格式的机器代码，在Linux系统上一般表现为ELF（OBJ文件），用到的工具为arm-linux-as。”反汇编“是指将机器代码转换为汇编代码，这在调试程序时常常用到。</li>
<li>连接<br>连接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件连接起来，最终生成可以在特定平台运行的可执行文件，用到的工具是arm-linux-ld。<br>编译器利用这4个步骤中的一个或者多个来处理输入文件，源文件的后缀名表示源文件所用的语言，后缀名控制着编译器的默认动作。</li>
</ol>
<table>
<thead>
<tr>
<th>后缀名</th>
<th>语言种类</th>
<th>后期操作</th>
</tr>
</thead>
<tbody><tr>
<td>.c</td>
<td>c源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.C</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cc</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cxx</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.m</td>
<td>Object-C 源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.i</td>
<td>预处理后的c文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.ii</td>
<td>预处理后的c++文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.s</td>
<td>汇编语言源程序</td>
<td>汇编</td>
</tr>
<tr>
<td>.S</td>
<td>汇编语言源程序</td>
<td>预处理、汇编</td>
</tr>
<tr>
<td>.h</td>
<td>预处理器文件</td>
<td>通常不出现在命令行上</td>
</tr>
</tbody></table>
<p>其他后缀名的文件被传递给连接器（linker），通常包括一下两种：<br>.o：目标文件（Object file，OBJ文件）。<br>.a：归档库文件（Archive file）。<br>在编译过程中，除非使用了”-c“，”-S“,或者”-E“选项，或者编译错误组织了完整的编译过程，否则最后的步骤总是连接。在连接阶段中，所有对应于源程序的.o文件、”-l“选项指定的库文件、无法识别的文件名（包括指定的”.o“目标文件和”.a“库文件）按命令行中的顺序传递给连接器。<br>以一个简单的”Hello World“C程序为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*File : hello.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用arm-linux-gcc，只需要一个命令就可以生成可执行文件hello，它包含了4个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>加上”-v“选项，可以查看编译的细节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ccl hello.c -o /tmp/cctETob7.s</span><br><span class="line">as -o /tmp/ccvv2KbL.o /tmp/cctETob7.s</span><br><span class="line">collect2 -o hello   crtl.o  crti.o  crtbegin.o /tmp/ccvv2KbL.o crtend.o crtn.o</span><br></pre></td></tr></table></figure>
<p>以上三个命令分别对应于编译步骤中的预处理+编译、汇编和连接，ld被collect2调用来连接程序。预处理和编译被放在了一个命令中（ccl）进行，可以把它再次拆分为一下两步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp -o hello.i hello.c</span><br><span class="line">ccl hello.i -o /tmp/cctETob7.s</span><br></pre></td></tr></table></figure>
<p>可以通过各种选项来控制arm-linux-gcc的动作，下面介绍一些常用的选项。</p>
<h3 id="总体选项"><a href="#总体选项" class="headerlink" title="总体选项"></a>总体选项</h3><ol>
<li>-c<br>预处理、编译和汇编源文件，但是不作连接，编译器根据源文件生成OBJ文件。默认情况下，GCC通过用”.o“替换文件名的后缀”.c“，”.i“，”.s“等，产生OBJ文件名。可以使用”-o“选项选择其他名字。GCC忽略”-c“选项后面任何无法识别的输入文件。</li>
<li>-S<br>编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。默认情况下，GCC通过用”.s“替换源文件名后缀”.c“，”.i“等，产生汇编文件名。可以使用”-o“选项选择其他名字。GCC忽略任何不需要汇编的输入文件。</li>
<li>-E<br>预处理后即停止，不进行编译。预处理后的代码送往标准输出。GCC忽略任何不需要预处理的输入文件。</li>
<li>-o file<br>指定输出文件为file。无论下是预处理、编译、汇编还是连接，这个选项都可以使用，</li>
<li>-v<br>显示制作GCC工具自身时的配置命令；同时显示编译器驱动程序、预处理器、编译器的版本号。<br>以一个程序为例，它包含三个文件：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">File:main.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main fun\n&quot;</span>);</span><br><span class="line">    sub_fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File:sub.h</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">File:sub.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pintf(<span class="string">&quot;Sub fun\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用上述命令进行编译：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
其中，main.o、sub.o是经过了预处理、编译、汇编后生成的OBJ文件，它们还没有被连接成可执行文件；最后一步将它们连接成可执行文件test，可以直接运行以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Main fun</span><br><span class="line">Sub fun</span><br></pre></td></tr></table></figure>
现在试试其他选项，以下命令生成的main.s是main.c的汇编语言文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -S -o main.s  main.c</span><br></pre></td></tr></table></figure>
以下命令对main.c进行预处理，并将得到的结果打印出来，里面包含了所有包含的文件、所有定义的宏。在编写程序时，有时候查找某个宏定义是非常繁琐的事情，可以使用”-dM-E“选项来查看。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -E main.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="警告选项"><a href="#警告选项" class="headerlink" title="警告选项"></a>警告选项</h3><p>”-Wall“选项基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明前就使用的函数、局部变量除了声明就没有再使用等。<br>编译上面的main.c文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -Wall -c main.c</span><br></pre></td></tr></table></figure>
<p>得到的警告信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.c:In function &quot;main&quot;</span><br><span class="line">main.c:6 warning: unused variable &quot;i&quot;</span><br></pre></td></tr></table></figure>
<p>这个警告虽然对程序没有坏的影响，但是有些警告需要加以关注，比如匹配类型的警告等。</p>
<h3 id="调试选项"><a href="#调试选项" class="headerlink" title="调试选项"></a>调试选项</h3><p>-g: 加入只有GDB才使用的额外调试信息。</p>
<h3 id="优化选项"><a href="#优化选项" class="headerlink" title="优化选项"></a>优化选项</h3><ol>
<li>-O或者-O1<br>优化：对于大多数函数，优化编译的过程将占用较长的时间和相当大的内存。不使用”-O“选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的。如果在两条语句之间用断点中止程序，可以对任何变量进行赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确获取所期待的结果。<br>不使用”-O“或者”-O1“选项时，只有声明了register的变量才分配使用寄存器。<br>使用了”-O“或者”-O1“选项时，编译器会试图减少目标码的大小和执行时间。如果指定了”-O“或者”-O1“选项，”-fthread-jumps“和”-fdefer-pop“选项被打开。在有delay slot的机器上，”-fdelayed-branch“选项将被打开。在既没有帧指针又支持调试的机器上，”-fomit-frame-pointer“选项将被打开。某些机器上还可能打开其他选项。</li>
<li>-O2<br>多优化一些。除了涉及空间和速度的优化选项，执行几乎所有的优化工作。例如不进行循环展开和函数内嵌。和”-O“选项相比，这个选项既增加了编译时间，也提高了生成代码的运行效果。</li>
<li>-O3<br>优化的更多，除了打开”-O2“所做的一切，它还打开了”-finline-functions“选项。</li>
<li>-O0<br>不优化。<br>如果指定了多个”-O0“选项，不管带不带数字，生效的是最后一个选项。</li>
</ol>
<h3 id="链接器选项"><a href="#链接器选项" class="headerlink" title="链接器选项"></a>链接器选项</h3><p>下面的选项用于连接OBJ文件，输出可执行文件或者库文件。</p>
<ol>
<li>object-file-name<br>如果某些文件没有特别明确的后缀。GCC就认为它是OBJ文件或者库文件。如果GCC执行连接操作，这些OBJ文件就会成为连接器的输入文件。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
main.o和sub.o就是输入的文件。</li>
<li>-llibrary<br>连接名为library的库文件。<br>连接器在搜索标准目录中寻找这个库文件，库文件的真正名字”liblibrary.a“。搜索目录除了一些系统标准目录外，还包括用户以”-L“选项指定的路径。一般来说用这个方法找到的文件就是<code>库文件---即由OBJ文件组成的归档文件</code>。连接器处理归档文件的方法是：扫面归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义。但是，如果连接器普通的OBJ文件，而不是库文件，就把这个OBJ文件按照平常方式连接进来。指定”-l“选项和指定文件名的唯一区别是，”-l“选项用”lib“和”.a“把library包裹起来，而且搜索一些目录。<br>即使不明显的使用”-llibrary“选项，一些默认的库也被连接进去，可以使用”-v“选项看到这点。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker /lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtl.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../ctri.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtbegin.o</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o</span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtend.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtn.o</span><br></pre></td></tr></table></figure>
可以看见，除了main.o、sub.o两个文件外，还连接了启动文件crtl.o、crti.o、crtend.o、crtn.o，还有一些库文件（-lgcc、-lgcc_eh、-lc、-lgcc、-lgcc_eh）。</li>
<li>-nostartfiles<br>不连接系统标准启动文件，而标准库文件依然正常使用：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -nostartfiles -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/ld:warning:cannot find entry symbol _start;defaulting to 08048184</span><br></pre></td></tr></table></figure>
可以看见启动文件ctll.o、ctri.o、crtend.o、crtn.o没有被连接进去。需要说明的是，对于一般应用程序，这些启动文件是必须的，这里仅是作为例子（这样编译出来的test文件无法执行）。在编译bootloader、内核时，将用到这个选项。</li>
<li>-nostdlib<br>不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器，这个选项常用于编译内核，bootloader等程序，它们不需要启动文件，标准库文件。仍以options程序作为例子：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">/usr/bin/ld:warning:cannot find entry symbol _start;defaulting to 08048074</span><br><span class="line">main.o(.text + 0x19):In function &quot;main&quot;:</span><br><span class="line">:undefined referendce to &quot;printf&quot;</span><br><span class="line">sub.o(.text + 0xf):In function &quot;sub_fun&quot;:</span><br><span class="line">:undefined reference to &quot;printf&quot;</span><br><span class="line">collect2:ld returned 1 exit status</span><br></pre></td></tr></table></figure>
出现了一大堆错误，因为printf等函数是在库文件中实现的。在编译bootloader、内核时，用到这个选项，它们用的很多函数都是自包含的。</li>
<li>-static<br>在支持动态连接的的系统上阻止连接共享库。<br>仍以options程序作为例子,使用和不使用”-static“选项编译出来的可执行程序大小相差巨大：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.c</span><br><span class="line">$ gcc -c -o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br><span class="line">$ gcc -o test_static mian.o sub.o -static </span><br><span class="line">$ ls -l test test_static</span><br><span class="line">6591 test</span><br><span class="line">546479 test_static</span><br></pre></td></tr></table></figure>
其中test文件为6591字节，test_static为546479字节。当不使用”-static“编译文件时，程序执行前要连接共享库文件，所以还需要将共享库文件放入文件系统中。</li>
<li>-shared<br>生成一个共享OBJ文件，它可以和其他OBJ文件连接产生可执行文件。只有部分系统支持该选项。<br>当不想以源代码发布程序时，可以使用”-shared“选项生成库文件，比如对于options程序，可以如下制作库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure>
以后要使用sub.c中的sub_fun时，在连接程序时，将sub.a加入即可。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure>
可以将多个文件制作为一个库文件，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub.o sub2.o sub3.o</span><br></pre></td></tr></table></figure></li>
<li>-Xlinker option<br>把选项option传递给连接器。可以用来传递系统特定的连接选项，GCC无法识别这些选项。如果需要传递携带参数的选项，必须使用两次”-Xlinker“，一次传递选项，另一次传递其参数。例如，如果传递”-arsset-definitions“，要写成”-Xlinker -assert -Xlinker definitions“，而不能写成”-Xlinker -assert definitions“。因为这样会把整个字符串当作一个参数传递，显然不是连接器期待的。</li>
<li>-Wl，option<br>把选项option传递给连接器 。如果option中含有逗号，就在逗号处分割成多个选项。连接器通常都是通过gcc，arm-linux-gcc等命令间接启动的，要向他传入参数时，参数前面加上”-Wl,“。</li>
<li>-u symbol<br>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义。可以使用多个”-u“选项，各自跟上不同的符号，使得连接器调入附加的模块。</li>
</ol>
<h3 id="目录选项"><a href="#目录选项" class="headerlink" title="目录选项"></a>目录选项</h3><p>下列选项指定搜索路径，用于查找头文件，库文件或者编译器的某些成员。</p>
<ol>
<li>-Idir<br>在头文件的搜索路径列表添加dir目录。头文件的搜索方法为：如果以”#include &lt;&gt;“包含文件，则只会在标准库目录开始搜索（包括使用-Idir选项定义的目录）；如果以”#include “包含文件，则先从用户的工作目录开始搜索，再搜索标准库目录。</li>
<li>-I-<br>任何在”-I-“前面用”-I“选项指定的搜索路径只适用于”#include ’file‘“这种情况；它们不能用来搜索”#include&lt;&gt;“包含的头文件。如果用”-I“选项指定的搜索路径位于”-I-“选项后面，就可以在这些路径中搜索所有的”#include“指令。”-I-“选项能够阻止当前目录成为搜索”#include ’file‘“的第一选择。</li>
<li>-Ldir<br>在”-L“选项的搜索路径中添加dir目录，仍然使用options程序进行说明，先制作库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o libsub.a sub.o</span><br></pre></td></tr></table></figure>
编译main.c：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br></pre></td></tr></table></figure>
连接程序，下面的指令将会出错，提示找不到库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o -lsub</span><br><span class="line">/usr/bin/ld: cannot find lsub</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
可以使用”-Ldir“选项将当前目录加入搜索路径，如下则连接成功：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -L. -o test main.o -lsub</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-ld选项"><a href="#arm-linux-ld选项" class="headerlink" title="arm-linux-ld选项"></a>arm-linux-ld选项</h2><p>arm-linux-ld将用于多个目标文件、库文件连接成可执行文件。</p>
<h3 id="直接指定代码段、数据段、bss段的起始地址"><a href="#直接指定代码段、数据段、bss段的起始地址" class="headerlink" title="直接指定代码段、数据段、bss段的起始地址"></a>直接指定代码段、数据段、bss段的起始地址</h3><p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure>
<p>其中的”startaddr“分别代表代码段、数据段和bss段的起始地址，它是一个十六进制数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure>
<p>它代表的代码段的运行地址为0x00000000，<code>由于没有定义数据段、bss段的起始地址，它们被依次放在代码段的后面</code>。<br>以一个例子来说明”-Ttext“选项的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text </span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">  b step1</span><br><span class="line">step1:</span><br><span class="line">  ldr pc, =step2</span><br><span class="line">step2:</span><br><span class="line">  b step2 </span><br></pre></td></tr></table></figure>
<p>使用下面的命令编译、连接、反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -c -o link.o link.s</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 link.o -o  link_elf_0x00000000</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 link.o -o  link_elf_0x30000000</span><br><span class="line">arm-lihux-objdump -D link_elf_0x00000000 &gt; link_0x00000000.dis</span><br><span class="line">arm-lihux-objdump -D link_elf_0x30000000 &gt; link_0x30000000.dis</span><br></pre></td></tr></table></figure>
<p>例子中用到了两种跳转方法：b跳转指令、直接向pc寄存器赋值。先列出不同“-Ttext”选项下生成的反汇编文件，在详细分析由于不同运行地址带来的差异及影响。两个反汇编文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_0x00000000.dis                       link_0x30000000.dis</span><br><span class="line">0: eaffffff b 0x4                         0: eaffffff b 0x4</span><br><span class="line">4: e59ff000 ldr pc, [pc, #0]              4: e59ff000 ldr pc, [pc, #0]</span><br><span class="line">8: eafffffe b 0x8                         8: eafffffe b 0x8</span><br><span class="line">c: 00000008 andeq r0, r0, r8              c: 30000008 tsteq r0, #8 ; 0x8</span><br></pre></td></tr></table></figure>
<p>“b step1”是个相对跳转指令，其机器码的格式如下：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpeg" alt="img not found"></p>
<ol>
<li>[31:28]位是条件码。</li>
<li>[27:24]位为“1010”时，表示b跳转指令；为“1011”时，表示b1跳转指令。</li>
<li>[23::0]表示偏移地址。<br>使用“b”或者“b1”跳转时，下一条指令的地址是这样计算的：将指令中24位带符号的补码扩展为32位（扩展其符号位），将此32位数左移两位，将得到的值加到pc寄存器中，将得到跳转的目标地址。</li>
</ol>
<p>“b step1”的机器码为eaffffff。</p>
<ol>
<li>24位带符号的补码为0xffffff，将它扩展为32位得到0xffffffff。</li>
<li>将此32位数左移两位得到0xfffffffc，其值就是-4.</li>
<li>pc的值是当前指令下的下两条指令的地址，加上步骤2得到的-4，这恰好是第二条指令step1的地址。<br>请不要被反汇编代码的“b 0x4”迷惑。它不是指跳转到0x4处执行，绝对地址需要按照上述3个步骤计算。可以发现，b跳转指令依赖于当前PC寄存器的值，这个特性使得使用b指令的程序不依赖于代码存储的位置—即不管这条代码放在什么位置，b指令都可以跳到正确的位置。这类指令称为位置无关码。使用不同的“-Ttext”选项，生成的代码仍旧是一样的。<br>“ldr pc, &#x3D;step2”，从汇编码“ldr pc, [pc, #0]”可以看出，这条指令从内存中的某个位置读出数据，并赋值给PC寄存器。这个位置的地址是当前pc寄存器的值加上偏移量0。其中存放的值依赖于连接命令的“-Ttext”选项。执行这条指令之后，对于link_0x00000000.dis，pc &#x3D; 0x0000000；对于link_0x30000000.dis，pc &#x3D; 0x30000008。执行第三条指令“b step2”后，程序的运行地址就不同了：分别是0x00000008、0x30000008。<br>Bootloader、内核程序刚开始执行时，它们所处的地址通常不等于运行地址。在程序的开头，先使用b、bl、mov等“位置无关”的指令将代码从Flash等设备复制到内存的“运行地址”处，然后再跳转到“运行地址”去执行。</li>
</ol>
<h3 id="使用连接脚本设置地址"><a href="#使用连接脚本设置地址" class="headerlink" title="使用连接脚本设置地址"></a>使用连接脚本设置地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-ld -Ttimer.lds -o timer_elf head.o init.o interrupt.o main.o</span><br></pre></td></tr></table></figure>
<p>它使用连接脚本timer.lds来设置可执行文件timer_elf的地址信息，timer.lds文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  . = 0x30000000;</span><br><span class="line">  .text             : &#123;   *(.text)    &#125;</span><br><span class="line">  .rodata ALIGN(4)  : &#123;   *(rodata)   &#125;</span><br><span class="line">  .data   ALIGN(4)  : &#123;   *(data)     &#125;</span><br><span class="line">  .bss    ALIGN(4)  : &#123;   *(bss)  *(COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析timer.lds文件之前，先讲解连接脚本的格式。连接脚本的基本命令是SECTIONS命令，它描述了输出文件的映射图：输出文件中各段、各文件怎么怎么放置。一个SECTIONS命令内部包含一个或者多个段。段（Section）是连接脚本的基本单元，它表示输入文件中的某部分怎么放置。<br>完整的连接脚本格式如下，它的核心部分是段（Section）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">secname start ALIGN(align)  (NOLOAD)  : AT(ldadr)</span><br><span class="line">  &#123; contents  &#125; &gt; region :phdr =fill</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>secname 和 contents是必需的，前者用来命名这个段。后者用来确定代码中的什么部分放在这个段中。<br>start是这个段重定位地址，也称为运行地址。如果代码中有位置无关的指令，程序在运行时，这个段必须放在这个地址上。<br>ALIGN(align)：虽然start指定了运行地址，但是仍然可以使用BLOCK（align）来指定对齐的要求—这个对齐的地址才是真正的运行地址。<br>（NOLOAD）：用来告诉加载器，在运行时不用加载这个段。显然，这个选项只有在操作系统的情况下才有意义。<br>AT（ldadr）：指定这个段在编译出来的映像文件中的地址—加载地址。如果不使用这个选项，则加载地址等于运行地址。通过这个选项，可以控制各段分别保存输出文件中不同的位置，便于把文件保存到单板上：A段放在A处，B段放在B处，运行前再把A、B段分别读出来组装成一个完整的执行程序。<br>现在开始分析下timer.lds文件：</p>
<ol>
<li>第2行表示设置“当前运行地址”为0x30000000。</li>
<li>第3行定义了一个名为“.text”的段，它的内容为“* （.text）”，表示所有输入文件的代码段。这些代码段被集合在一起，起始运行地址为0x30000000。</li>
<li>第4行定义了一个名为“.rodata”的段，在输出文件timer_elf中，它紧挨着“.text”段存放。其中“ALIGN（4）”表示起始运行地址为4字节对齐。假设前面“.text”段的地址范围是0x30000000-0x300003f1，则“.rodata”段的地址为4字节对齐后的0x300003f4。</li>
<li>第5、6行的含义与第4行类似。</li>
</ol>
<h2 id="arm-linux-objcopy选项"><a href="#arm-linux-objcopy选项" class="headerlink" title="arm-linux-objcopy选项"></a>arm-linux-objcopy选项</h2><p>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可以使用不同于源文件的格式来输出目的文件，即可以进行格式转换。<br>这本书中，常用arm-linux-objcopy来将ELF格式的可执行文件转换为二进制文件。下面讲解常用的选项：</p>
<ol>
<li>input-file、outfile<br>参数input-file和outfile分别表示输入目标文件和输出目标文件。</li>
<li>-I bfdname 或 –input-target&#x3D;bfdname<br>用来指明源文件的格式，bfdname是BFD库中描述的标准格式名。如果不指明源文件格式，arm-linux-objcopy会自己去分析源文件的格式，然后去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</li>
<li>-O bfdname 或 –output-target&#x3D;bfdname<br>使用指定的格式来输出文件，bfdname是BFD库中描述的的标准格式名。</li>
<li>-F bfdname 或 –target&#x3D;bfdname<br>同时指明源文件和目的文件的格式。将源文件的内容复制到目的文件的过程中，只进行复制而不做格式转换，源文件是什么格式，目的目标文件就是什么格式。</li>
<li>-R sectionname 或 –remove-section&#x3D;sectionname<br>从输出文件中删除掉所有名为sectionname的段。这个选项可以多次使用。</li>
<li>-S 或 –strip-all<br>不从源文件复制重定位信息和符号信息到目标文件中去。</li>
<li>-g 或 –strip-debug<br>不从源文件中复制调试符号到目标文件中去。<br>在编译bootloader、内核时，常用arm-linux-objcopy命令将ELF格式的生成结果转换为二进制文件，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-objcopy -O binary -S elf_file bin_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-objdump选项"><a href="#arm-linux-objdump选项" class="headerlink" title="arm-linux-objdump选项"></a>arm-linux-objdump选项</h2><p>arm-linux-objdump用于显示二进制文件信息，本书中常用来查看反汇编代码。下面讲解常用的选项：</p>
<ol>
<li>-b bfdname 或 –target&#x3D;bfdname<br>指定目标码格式。这不是必须的，arm-linux-objdump能自动识别许多格式。可以使用“arm-linux-objdump -i”命令查看支持的目标码格式。</li>
<li>–disassemble 或 -d<br>反汇编可执行段。</li>
<li>–disassemble 或 -D<br>反汇编所有段。</li>
<li>-EB或-EL或–endian&#x3D;{big|little}<br>指定字节序。</li>
<li>–file-headers或-f<br>显示文件的整体头部摘要信息。</li>
<li>–section-headers、–header或-h<br>显示目标文件各个段的头部摘要信息。</li>
<li>–info或-i<br>显示支持的目标文件格式和CPU架构，它们在“-b”、“-m”选项中用到。</li>
<li>–section&#x3D;name或-j name<br>仅显示指定section的信息。</li>
<li>–architecture&#x3D;machine或-m machine<br>指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候，这个选项很有用。可以用“-i”选项列出这里能够指定的架构。<br>在调试程序时，常用arm-linux-objdump命令来得到汇编代码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将ELF格式的文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D elf_file &gt; dis_file</span><br><span class="line">/*将二进制文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D -b binary -m arm bin_file &gt; dis_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="汇编代码、机器码和存储器的关系以及数据的表示"><a href="#汇编代码、机器码和存储器的关系以及数据的表示" class="headerlink" title="汇编代码、机器码和存储器的关系以及数据的表示"></a>汇编代码、机器码和存储器的关系以及数据的表示</h2><p>即使使用C&#x2F;C++或者其他高级语言编程，最后也会被编译工具转换为汇编代码，并最终作为机器码存储在内存、硬盘或者其他存储器上。在调试程序时，经常需要阅读它的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4bc:        e3a0244e: mov r2, #1308622848;</span><br><span class="line">4c0:        e3a0344e: mov r3, #1308622848;</span><br><span class="line">4c4:        e5933000: ldr r3, [r3];</span><br></pre></td></tr></table></figure>
<p>4bc、4c0、4c4是这些代码的运行地址，就是说运行前，这些指令必须位于内存中的这些地址上；e3a0244e、e3a0344e、e5933000是机器码。运行地址、机器码都是十六进制表示。CPU用到的、内存中保存的都是机器码示意如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*内存中的示意图*/</span><br><span class="line">/*地址:机器码*/</span><br><span class="line">···</span><br><span class="line">0x4bc:0xe3a0244e</span><br><span class="line">0x4c0:0xe3a0344e</span><br><span class="line">0x4c4:0xe5933000</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>“mov r2, #1308622848”、“mov r3, #1308622848”、“ldr r3, [r3]”是上述几个机器码的汇编代码。所谓汇编代码仅仅是为了方便读写而引入的，机器码和汇编代码之间也仅仅是简单的转换关系。参考CPU的数据手册，ARM的数据处指令格式为：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.jpeg" alt="img not found"><br>以机器码0xe3a0244e为例：</p>
<ol>
<li>[31:28] &#x3D; 0b1110，表示这条指令无条件执行。</li>
<li>[25] &#x3D; 0b1，表示Operand2是一个立即数。</li>
<li>[24:21] &#x3D; 0b1101，表示这是MOV指令。</li>
<li>[20] &#x3D; 0b0，表示这条指令执行时不影响状态位。</li>
<li>[15:12] &#x3D; 0b0010，表示Rd就是r2寄存器。</li>
<li>[11:0] &#x3D; 0x44e，这是一个立即数。<br>立即数占据机器码的低12位表示：最低8位的值称为immed_8，高4位称为rotate_imm。立即数的数值计算方法为：<value> &#x3D; immed_8 循环右移 （2 * rotate_imm）。对于”[11:0] &#x3D; 0x44e“，其中immed_8 &#x3D; 0x4e、rotate_imm&#x3D;0x4，所以此立即数为0x4e000000。</value></li>
</ol>
<h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>在Linux中使用Make命令来编译程序，特别是大程序；而make命令所执行的动作依赖与Makefile文件。最简单的Makefile文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello：hello.c</span><br><span class="line">  gcc -o hello hello.c</span><br><span class="line">clean:</span><br><span class="line">  rm -rf hello</span><br></pre></td></tr></table></figure>
<p>将上述4行存为Makefile文件（注意必须以Tab键来进行缩进第2、4行，不能以空格来进行缩进），执行make即可编译程序，执行make clean即可清除编译出来的结果。<br>make命令根据文件更新的时间戳来决定哪些文件需要重新编译，这使得可以避免编译已经编译过的、没有变化的程序，大大提高编译效率。</p>
<h2 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h2><p>一个简单的Makefile文件包含一系列”规则“，其样式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标（target）...：依赖（prerequiries）...</span><br><span class="line">&lt;Tab&gt;命令（command）</span><br></pre></td></tr></table></figure>
<p>目标（target）通常是要生成的文件的名称，可以是可执行文件或者OBJ文件，也可以是一个执行的动作名称，诸如”clean“。<br>依赖是用来产生目标的材料（比如源文件），一个目标通常有几个依赖。<br>命令是生成目标时的动作，一个规则可以含有几个命令，每个命令占一行。<br>通常，如果一个依赖发生了变化，就需要规则调整命令以更新或者创建目标。但是并非所有的目标都有依赖，例如，目标”clean“的作用就是清除文件，它没有依赖。<br>规则一般是用于解释怎样和何时重建目标。make首先调用命令处理依赖，进而才能创建或者更新目标。当然，一个规则也可以是用于解释怎样和何时执行一个动作，即打印提示信息。<br>一个Makefile文件可以包含规则以外的其他文本，但一个简单的Makefile文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但是格式是完全一样的。<br>对于上述Makefile，执行”make“命令时，仅当hello.c文件比hello文件新，才会执行命令”arm-linux-gcc -o hello hello.c“生成可执行文件hello；如果还没有hello文件，这个命令也会执行。<br>运行”make clean“，由于目标没有依赖项，它的命令“rm -f hello”将被强制执行。</p>
<h2 id="Makefile文件里的赋值方法"><a href="#Makefile文件里的赋值方法" class="headerlink" title="Makefile文件里的赋值方法"></a>Makefile文件里的赋值方法</h2><p>变量的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">immediate = deferred</span><br><span class="line">immediate ?= deferred</span><br><span class="line">immediate := immediate</span><br><span class="line">immediate += deferred or immediate</span><br><span class="line">define immediate</span><br><span class="line">deferred</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>在GNU make中对变量的赋值有两种方式：延时变量、立即变量。区别在于它们的定义方式和扩展时的方式不同，前者在这个变量使用时才会扩展开，意思就是当真正使用这个变量时才会确定；后者在定义时它的值就已经确定了。使用“&#x3D;”、“?&#x3D;”定义或者使用define指定定义的变量是延时变量；使用“：&#x3D;”定义的变量是立即变量。需要注意一点的的是“?&#x3D;”仅仅在变量没有定义的情况下有效，即“?&#x3D;”用来定义第一次出现的延时变量。对于附加操作符“+&#x3D;”，右边变量如果在前面使用（：&#x3D;）定义为立即变量则它也是立即变量，否则均为延时变量。</p>
<h2 id="Makefile常用函数"><a href="#Makefile常用函数" class="headerlink" title="Makefile常用函数"></a>Makefile常用函数</h2><p>函数调用的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(function arguments)</span><br></pre></td></tr></table></figure>
<p>这里“function”是函数名，“arguments”是该函数的参数。参数与函数名之间用空格或者Tab隔开，如果有多个参数，它们之间用逗号隔开。这些空格和逗号不是参数值的一部分。下面介绍一些常用的Makefile函数。</p>
<h3 id="字符串替换和分析函数"><a href="#字符串替换和分析函数" class="headerlink" title="字符串替换和分析函数"></a>字符串替换和分析函数</h3><ol>
<li>$ (subst from,to,text)<br>在文本“text”中使用“to”替换每一处“from”。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (subst ee,EE,feet on the street)</span><br><span class="line">==&gt;fEEt on the strEEt</span><br></pre></td></tr></table></figure></li>
<li>$ (patsubst pattern,replacement,text)<br>寻找“text”中符合格式“pattern”的字，用“replacement”替换它们。“pattern”和“replacement”中可以使用通配符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (patsubst %.c,%.o,x.c.c bar.c)</span><br><span class="line">==&gt;x.c.o bar.o</span><br></pre></td></tr></table></figure></li>
<li>$ (strip string)<br>去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (strip a   b c )</span><br><span class="line">==&gt;a b c</span><br></pre></td></tr></table></figure></li>
<li>$ (findstring find,in)<br>在字符串“in”中查找“find”，如果找到，则返回值是“find“，否则返回值为空。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(findstring a,a b c)</span><br><span class="line">==&gt;a</span><br><span class="line">$(findstring a,b c)</span><br><span class="line">==&gt;</span><br></pre></td></tr></table></figure></li>
<li>$(filter pattern…,text)<br>返回在”text“中由空格隔开且匹配格式”pattern…“的字，去除不符合格式”pattern…“的字。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;foo.c bar.c baz.s</span><br></pre></td></tr></table></figure></li>
<li>$(filter-out pattern…,text)<br>返回在”text“中由空格隔开并且不匹配格式”pattern…“的字，去除符合格式”pattern…“的字。它是函数filter的反函数。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;ugh.h</span><br></pre></td></tr></table></figure></li>
<li>$(sort list)<br>将”list“中的字按照字母顺序排列，并去掉重复的字。输出由单个空格隔开的字的列表。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(sort foo bar lose)</span><br><span class="line">==&gt;bar foo lose</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文件名函数"><a href="#文件名函数" class="headerlink" title="文件名函数"></a>文件名函数</h3><ol>
<li>$(dir names…)<br>抽取”names…“中每一个文件名的路径部分，文件名的路径部分包括从文件名的首字符到最后一个斜杠之前的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/ ./</span><br></pre></td></tr></table></figure></li>
<li>$(notdir names…)<br>抽取”names…“中每一个文件名的除路径之外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;foo.c hacks</span><br></pre></td></tr></table></figure></li>
<li>$(suffix names…)<br>抽取”names…“中每一个文件名的后缀。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;.c</span><br></pre></td></tr></table></figure></li>
<li>$(basename names…)<br>抽取”names…“中每一个文件名除后缀以外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/foo hacks</span><br></pre></td></tr></table></figure></li>
<li>$(addsuffix suffix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；suffix是一个后缀名。将suffix（后缀）的值附加在每一个独立文件的后面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(addsuffix .c,foo bar)</span><br><span class="line">==&gt;foo.c bar.c</span><br></pre></td></tr></table></figure></li>
<li>$(addprefix prefix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；prefix是一个前缀名。将prefix（前缀）的值附加在每一个独立文件的前面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line">==&gt;src/foo  src/bar</span><br></pre></td></tr></table></figure></li>
<li>$(wildcard pattern)<br>参数”pattern“是一个文件名格式，包含有通配符（通配符和shell的用法一样）。函数wildcard的结果是一列和格式匹配且真实存在的文件的名称，文件名之间用一个空格隔开。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_src := $(wildcard *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ol>
<li>$(foreach var,list,text)<br>前两个参数，”var“和”list“将首先扩展，最后一个参数”text“此时不扩展；接着，”list“扩展得到的每个字都赋值给”var“变量；然后，”text“引用该变量进行扩展，因此”text“每次扩展都不相同。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirs := a b c d</span><br><span class="line">files := $(foreach dir,$(dir),$(wildcard $(dir)/*))</span><br><span class="line">==&gt;</span><br><span class="line">$(wildcard a/*)</span><br><span class="line">$(wildcard b/*)</span><br><span class="line">$(wildcard c/*)</span><br><span class="line">$(wildcard d/*)</span><br></pre></td></tr></table></figure></li>
<li>$(if condition,then-part[,else-part])<br>首先把第一个参数”condition“的前导空格、结尾空格去掉，然后扩展。如果扩展为非空字符产，则条件”condition“为真，那么计算第二个参数”then-part“的值，并将之作为函数的返回值。如果condition为假，并且第三个参数存在，则计算第三个参数”else-part“的值，并将该值作为函数得返回值。如果第三个参数不存在，则返回空。</li>
<li>$(origin variable)<br>变量”variable“是一个查询变量的名称，不是对改变量的引用。所以不能采用”$“和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。函数的返回值如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined                     :变量”variable“从未被定义；</span><br><span class="line">default                       :变量”variable“是默认定义；</span><br><span class="line">environment                   :变量”variable“作为环境变量定义，选项”-e“没有打开；</span><br><span class="line">environment override          :变量”variable“作为环境变量定义，选项”-e“已打开；</span><br><span class="line">file                          :变量”variable“在Makefile中定义；</span><br><span class="line">command line                  :变量”variable“在命令行中定义；</span><br><span class="line">override                      :变量”variable“在Makefile中用override指令定义；</span><br><span class="line">automatic                     :变量”variable“是自动变量。</span><br></pre></td></tr></table></figure></li>
<li>$(shell command arguments)<br>函数shell是Makefile与外部环境通信的工具。函数shell的执行结果和在控制台上执行”command arguments“的结果相似。不过如果”command arguments“的结果含有换行符，则在函数shell的返回结果中将它们处理为单个空格，若返回结果最后是换行符或者回车符则被去掉。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_src := $(shell ls *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure>
下面以一个Makefile为例进行演示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File:Makefiel</span><br><span class="line">src :=  $(shell ls *.c)</span><br><span class="line">objs := $(patsubst  %.c,%.o,$(src))</span><br><span class="line"></span><br><span class="line">test: $(objs)</span><br><span class="line">  gcc -o  $@  $^</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">  gcc -c -o $@  $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -rf test *.o</span><br></pre></td></tr></table></figure>
上述Makefile中”$@“、”$^“、”$&lt;“称为自动变量。”$@“表示规则的目标文件名；”$^“表示所有依赖的名字，名字中间用空格隔开；”$&lt;“表示第一个依赖的文件名。<br>已知当前目录下的所有文件为Makefile、main.c、sub.c、sub.h。<br>第一行src变量的值为”main.c sub.c“。<br>第二行objs变量的值为”main.o sub.o“。<br>第四行实际上就是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test  : main.o sub.o</span><br></pre></td></tr></table></figure>
目标test的依赖项是main.o sub.o。开始时这两个文件还没有生成，在执行文件生成test的命令前先将main.o、sub.o作为目标查找合适的规则，以生成main.o、sub.o。<br>第七八行就是用来生成main.o、sub.o的规则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.o : main.c</span><br><span class="line">  gcc -c -o main.o main.c</span><br><span class="line"></span><br><span class="line">sub.o : sub.c</span><br><span class="line">  gcc -c -o sub.o sub.c</span><br></pre></td></tr></table></figure>
这样，test的依赖main.o和sub.o就生成了。</li>
</ol>
<h1 id="常用ARM汇编指令及ATPCS规则"><a href="#常用ARM汇编指令及ATPCS规则" class="headerlink" title="常用ARM汇编指令及ATPCS规则"></a>常用ARM汇编指令及ATPCS规则</h1><p>在嵌入式开发中，汇编程序常常用于非常关键的地方，比如系统启动时的初始化，进出中断时的环境保存、恢复，对性能要求非常苛刻的函数等。</p>
<ol>
<li>相对跳转指令b、bl<br>这两条指令的不同之处在于bl指令除了跳转之外，还将返回地址（bl的下一条指令的地址）保存在lr寄存器中。<br>这两条指令的可跳转范围是当前指令的前后32M。<br>它们是位置无关的指令。<br>使用示例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  b fun1</span><br><span class="line">  ...</span><br><span class="line">fun1:</span><br><span class="line">  bl fun2</span><br><span class="line">  ...</span><br><span class="line">fun2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>数据传送指令mov，地址读取伪指令ldr<br>mov指令可以把一个寄存器的值赋值给另一个寄存器赋给另一个寄存器，或者把一个常数赋值给寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*r1 = r2*/</span><br><span class="line">mov r1,r2</span><br><span class="line"></span><br><span class="line">/*r1 = 4096*/</span><br><span class="line">mov r1,#4096</span><br></pre></td></tr></table></figure>
mov传送的常数必须能用立即数来表示。<br>当不知道一个数能否用”立即数“来表示时，可以使用ldr命令来赋值。ldr是伪指令，它不是真实存在的指令，编译器会把它扩展成真正的指令：如果该常数能用”立即数“来表示，则使用mov指令；否则编译时将该常数保存在某个位置，使用内存读取指令把它读出来。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*r1 = 4097*/</span><br><span class="line">ldr r1, =4097</span><br><span class="line"></span><br><span class="line">/*r1 = label的绝对地址*/</span><br><span class="line">ldr r1, =label</span><br><span class="line">label:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>内存访问指令:ldr,str,ldm,stm<br>ldr指令从内存中读取数据到寄存器，str指令把寄存器的值存储到内存，它们操作的数据都是32位的。示例如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将地址为r2+4的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2,#4]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1,然后r2 = r2 + 4*/</span><br><span class="line">ldr r1,[r2],#4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*将r1的数据保存到地址为r2 + 4的内存单元*/</span><br><span class="line">str r1,[r2,#4]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元*/</span><br><span class="line">str r1,[r2]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元，然后r2 = r2 + 4*/</span><br><span class="line">str r1,[r2],#4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ldm和stm属于批量内存访问指令，只用一条指令就可以读写多个数据。它们的格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br><span class="line">stm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br></pre></td></tr></table></figure>
其中{cond}表示地址变化模式，有以下4种模式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ia (Increment After):事后递增模式</span><br><span class="line">ib (Increment Before):事先递增模式</span><br><span class="line">da (Decrement After):事后递减模式</span><br><span class="line">db (Decrement Before):事先递减模式</span><br></pre></td></tr></table></figure>
<rn>中保存内存的地址，如果在后面加上了感叹号，指令执行后，rn的值会更新，等于下一个内存单元的地址。<br><register list>表示寄存器列表，对于ldm指令，从<rn>所对应的内存块取出数据。写入这些寄存器；对于stm指令，把这些寄存器的值写入<rn>所对应的内存块中。<br>{^}有两种含义：如果<register list>中有PC寄存器，它表示指令执行后，spsr寄存器的值将自动复制到cpsr寄存器中—这常用于从中断处理函数返回；如果<register list>中没有pc寄存器，它表示操作的是用户模式下的寄存器，而不是当前特权模式的寄存器。<br>指令中寄存器列表和内存单元的对应关系为：编号低的寄存器对应内存中的低地址单元，编号高的寄存器对应内存中的高地址单元。</register></register></rn></rn></register></rn></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HandleIRQ:                @中断入口函数</span><br><span class="line">  sub lr,lr,#4            @计算返回地址</span><br><span class="line">  stmdb sp!,&#123;r0-r12,lr&#125;   @保存使用到的寄存器，r0-r12,lr被保存在sp表示的内存中，”!“使得指令执行后sp=sp-14*4</span><br><span class="line">  ldr lr, =int_return     @设置调用Handle_IRQ函数后的返回地址</span><br><span class="line">  ldr pc, =IRQ_Handle     @调用中断返回函数</span><br><span class="line"></span><br><span class="line">int_return:</span><br><span class="line">  ldmia sp!,&#123;r0-r12,pc&#125;^  @中断返回，”^“表示将spsr的值复制到cpsr，于是从irq模式返回被中断的工作模式。”!“使得指令执行后sp = sp + 14*4</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加减指令：add、sub<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add r1,r2,#1 /*表示r1 = r2 + 1,即寄存器r1的值等于r2的值加上1*/</span><br><span class="line">sub r1,r2,#1 /*表示r1 = r2 - 1*/</span><br></pre></td></tr></table></figure></li>
<li>程序状态字寄存器的访问指令：msr、mrs<br>ARM处理器有一个程序状态字寄存器cpsr，它用来控制处理器的工作模式、设置中断的总开关。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msr cpsr,r0 /*复制r0到cpsr中*/</span><br><span class="line">mrs r0,cpsr /*复制cpsr到r0中*/</span><br></pre></td></tr></table></figure></li>
<li>其他伪指令<br>在本书的汇编程序中，常常见到如下语句：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.extern main</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure>
”.extern“定义一个外部符号（可以是变量也可以是函数），上面的代码表示本文件中引用的main是一个外部函数。<br>”.text“表示下面的语句都属于代码段。<br>”.global“将本文件的某个程序标号定义为全局的，比如下面的代码表示_start是个全局函数。</li>
<li>汇编指令的执行条件<br>大多数ARM指令都可以条件执行，即根据cpsr寄存器中的条件标志决定执行该指令：如果条件不满足，该指令相当于一条nop指令。<br>每条ARM指令包含4位的条件域码，这表明可以定义16个执行条件。可以将这些执行条件的助记符附加在汇编指令后，如moveq，movgt等。</li>
</ol>
<table>
<thead>
<tr>
<th>条件码</th>
<th>助记符</th>
<th>含义</th>
<th>cpsr中条件标志位</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>eq</td>
<td>相等</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>0001</td>
<td>ne</td>
<td>不相等</td>
<td>Z&#x3D;0</td>
</tr>
<tr>
<td>0010</td>
<td>cs&#x2F;hs</td>
<td>无符号数大于&#x2F;等于</td>
<td>C&#x3D;1</td>
</tr>
<tr>
<td>0100</td>
<td>mi</td>
<td>负数</td>
<td>N&#x3D;1</td>
</tr>
<tr>
<td>0101</td>
<td>pl</td>
<td>非负数</td>
<td>N&#x3D;0</td>
</tr>
<tr>
<td>0110</td>
<td>vs</td>
<td>上溢出</td>
<td>V&#x3D;1</td>
</tr>
<tr>
<td>0111</td>
<td>vc</td>
<td>没有上溢出</td>
<td>V&#x3D;0</td>
</tr>
<tr>
<td>1000</td>
<td>hi</td>
<td>无符号数大于</td>
<td>C&#x3D;1 &amp;&amp; Z&#x3D;0</td>
</tr>
<tr>
<td>1001</td>
<td>ls</td>
<td>无符号数小于等于</td>
<td>C&#x3D;0</td>
</tr>
<tr>
<td>1010</td>
<td>ge</td>
<td>带符号数大于等于</td>
<td>N&#x3D;1,V&#x3D;1</td>
</tr>
<tr>
<td>1011</td>
<td>lt</td>
<td>带符号数小于</td>
<td>N&#x3D;1,V&#x3D;0</td>
</tr>
<tr>
<td>1100</td>
<td>gt</td>
<td>带符号数大于</td>
<td>Z&#x3D;0 &amp;&amp; N&#x3D;V</td>
</tr>
<tr>
<td>1101</td>
<td>le</td>
<td>带符号数小于&#x2F;等于</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>1110</td>
<td>al</td>
<td>无条件执行</td>
<td>-</td>
</tr>
<tr>
<td>1111</td>
<td>nv</td>
<td>从不执行</td>
<td>-</td>
</tr>
</tbody></table>
<p>表中的cpsr条件标志位N、Z、C、V分别表示Negative、Zero、Cary、Overflow。影响条件标志位的因素比较多，比如比较指令cmp、cnm、teq及tst等。</p>
<h2 id="ARM-THUMB子程序调用规则ATPCS"><a href="#ARM-THUMB子程序调用规则ATPCS" class="headerlink" title="ARM-THUMB子程序调用规则ATPCS"></a>ARM-THUMB子程序调用规则ATPCS</h2><p>为了使C语言程序和汇编程序之间能够相互调用，必须为子程序之间的调用制定规则，在ARM处理器中，这个规则被称为ATPCS：ARM程序和Thumb程序中子程序的调用的规则。<br>基本的ATPCS规则包括寄存器使用规则、数据栈使用规则、参数传递规则等。</p>
<h3 id="寄存器使用规则"><a href="#寄存器使用规则" class="headerlink" title="寄存器使用规则"></a>寄存器使用规则</h3><p>ARM处理器中有r0-r15共16个寄存器，它们的用途有一些约定的习惯，并依据这些这些用途定义了别名。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>别名</th>
<th>使用规则</th>
</tr>
</thead>
<tbody><tr>
<td>r15</td>
<td>pc</td>
<td>程序计数器</td>
</tr>
<tr>
<td>r14</td>
<td>lr</td>
<td>连接寄存器</td>
</tr>
<tr>
<td>r13</td>
<td>sp</td>
<td>数据栈指针</td>
</tr>
<tr>
<td>r12</td>
<td>ip</td>
<td>子程序内部调用的scratch寄存器</td>
</tr>
<tr>
<td>r11</td>
<td>v8</td>
<td>ARM状态局部变量寄存器8</td>
</tr>
<tr>
<td>r10</td>
<td>v7、sl</td>
<td>ARM状态局部变量寄存器7、在支持数据栈检查的ATPCS中为数据栈限定指针</td>
</tr>
<tr>
<td>r9</td>
<td>v6、sb</td>
<td>ARM状态局部变量寄存器6、在支持RWPI的ATPCS中为静态基址寄存器</td>
</tr>
<tr>
<td>r8</td>
<td>v5</td>
<td>ARM状态局部变量寄存器5</td>
</tr>
<tr>
<td>r7</td>
<td>v4、wr</td>
<td>ARM状态局部变量寄存器4、Thumb状态工作寄存器</td>
</tr>
<tr>
<td>r6</td>
<td>v3</td>
<td>ARM状态局部变量寄存器3</td>
</tr>
<tr>
<td>r5</td>
<td>v2</td>
<td>ARM状态局部变量寄存器2</td>
</tr>
<tr>
<td>r4</td>
<td>v1</td>
<td>ARM状态局部变量寄存器1</td>
</tr>
<tr>
<td>r3</td>
<td>a4</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器4</td>
</tr>
<tr>
<td>r2</td>
<td>a3</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器3</td>
</tr>
<tr>
<td>r1</td>
<td>a2</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器2</td>
</tr>
<tr>
<td>r0</td>
<td>a1</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器1</td>
</tr>
</tbody></table>
<p>寄存器的使用规则总结如下：</p>
<ol>
<li>子程序间通过寄存器r0-r3来传递参数，这时可以使用它们的别名a0-a3。被调用的子程序返回前无须恢复r0-r3的内容。</li>
<li>在子程序中，使用r4-r11来保存局部变量，这时可以使用它们的别名v1-v8。如果在子程序中使用了它们的某些寄存器，子程序进入时需要保存这些寄存器的值，在返回时需要恢复它们；对于子程序没有使用到的寄存器，则不必进行这些操作。在Thumb程序中，通常只能使用寄存器r4-r7来保存局部变量。</li>
<li>寄存器r12用作子程序间scratch寄存器，别名ip。</li>
<li>寄存器r13用作数据栈指针，别名sp。在子程序中寄存器r13不能用作其他用途。它的值在进入、退出子程序时必须相等。</li>
<li>寄存器r14称为连接寄存器，别名lr。它用于保存子程序的返回地址。如果在子程序中保存了返回地址（比如将lr的值保存到数据栈中），r14可以用作其他用途。</li>
<li>寄存器r15是程序计数器，别名pc。它不能用作其他用途。</li>
</ol>
<h3 id="数据栈使用规则"><a href="#数据栈使用规则" class="headerlink" title="数据栈使用规则"></a>数据栈使用规则</h3><p>数据栈有两个增长方向：向内存地址减小的方向增长时，称为DESCENDING栈；向内存增加的方向增长时，称为ASCENDING栈。<br>所谓数据栈的增长就是移动栈指针。当栈指针指向栈顶元素时，称为FULL栈；当栈指针指向栈顶元素相邻的一个空的数据单元时，称为EMPTY栈。<br>使用stmdb命令往数据栈保存内容时，先递减sp指针，再保存数据，使用ldmia命令从数据栈恢复数据时，先获得数据，再递增sp指针，sp指针总是指向栈顶元素。</p>
<h3 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h3><p>一般来说，当参数个数不超过4个时，使用r0-r3这4个寄存器来传递参数；如果参数超过4个，剩余的参数通过数据栈来传递。<br>对于一般的返回结果，通常使用a0-a3来传递。示例：<br>假设CopyCode2SDRAM函数是用C语言实现的，它的数据原型如下：<br>int CopyCode2SDRAM(unsigned char *buf,unsigned long start_addr,int size);<br>在汇编代码中，使用下面的代码调用它，并判断返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldr r0,=0x30000000</span><br><span class="line">mov r1,#0</span><br><span class="line">mov r2,#16*1024</span><br><span class="line">bl CopyCode2SDRAM</span><br><span class="line">cmp a0,#0</span><br></pre></td></tr></table></figure>
<p>第一行将r0设为0x30000000，则CopyCode2SDRAM函数执行时，它的第一个参数buf的指向的内存地址是0x30000000。<br>第二行将r1设为0，CopyCode2SDRAM函数的第二个参数start_addr等于0。<br>第三行将r2设为16x1024，CopyCode2SDRAM函数的第三个参数size等于16x1024。<br>第五行判断返回值。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第3章 嵌入式编程基础知识</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>MMU</title>
    <url>/2022/08/15/MMU/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第7章总结归纳</p>
<span id="more"></span>
<h1 id="本章要点"><a href="#本章要点" class="headerlink" title="本章要点"></a>本章要点</h1><ol>
<li>了解虚拟地址和物理地址的关系</li>
<li>掌握如何通过设置MMU来控制虚拟地址到物理地址的转化</li>
<li>了解MMU的内存访问权限机制</li>
<li>了解TLB、Cache、Write Buffer的原理，使用时的注意事项</li>
<li>实例</li>
</ol>
<h1 id="内存管理单元MMU介绍"><a href="#内存管理单元MMU介绍" class="headerlink" title="内存管理单元MMU介绍"></a>内存管理单元MMU介绍</h1><h2 id="S3C2410-x2F-S3C2440-MMU特性"><a href="#S3C2410-x2F-S3C2440-MMU特性" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU特性"></a>S3C2410&#x2F;S3C2440 MMU特性</h2><p>内存管理单元（Memory Management Unit）简称MMU，它负责虚拟地址收到物理地址的映射，并提供硬件机制的内存访问权限检查。现代的多用户多进程操作系统通过MMU使得各个用户进程都拥有自己独立的地址空间：地址映射功能使得各进程拥有看起来一样的地址空间，而内存访问权限的检查可以保护每个进程所用的内存不会被其他破坏。</p>
<ol>
<li>与ARM V4兼容的映射长度、域、访问权限检查机制。</li>
<li>4种映射长度：段（1MB）、大页（64KB）、小页（4KB）、极小页（1KB）。</li>
<li>对每段都可以设置访问权限。</li>
<li>大页、小页的每个子页（sub-page，被映射页的1&#x2F;4）都可以设置单独的访问权限。</li>
<li>硬件实现的16个域。</li>
<li>指令TLB（含64个条目）、数据TLB（含64个条目）。</li>
<li>硬件访问页表（地址映射、权限检查有硬件自动进行）。</li>
<li>TLB条目中替换采用round-robin算法（也称cyclic算法）。</li>
<li>可以使无效整个TLB。</li>
<li>可以单独使无效某个TLB。</li>
<li>可以在TLB中锁定某个条目，指令TLB、数据TLB相互独立。<br>重点在于页表的结构与建立、映射的过程。</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-MMU地址变换过程"><a href="#S3C2410-x2F-S3C2440-MMU地址变换过程" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU地址变换过程"></a>S3C2410&#x2F;S3C2440 MMU地址变换过程</h2><h3 id="地址的分类"><a href="#地址的分类" class="headerlink" title="地址的分类"></a>地址的分类</h3><p>以前的程序是非常小的，可以全部装入内存。随着技术的发展，出现了以下两种情况：</p>
<ol>
<li>有的程序很大，它所要求的内存，超过了内存总容量，不能一次性装入内存。</li>
<li>多道系统中有很多程序需要同时执行，它们要求的内存超过了内存总容量，不能把所有程序都装入内存。<br>实际上，一个程序在运行前，没有必要全部装入内存，而仅需要将那些当前需要运行的部分先装入内存，其余部分在用到时再从磁盘调入，而当内存耗光时再将暂时不用的部分调出到磁盘。这使得一个大程序可以在较小的内存空间中运行，这也使得内存中可以同时装入更多的程序并发执行，从用户的角度看，该系统所具有的内存容量将比实际内存容量大得多，人们把这样的存储器称为虚拟存储器。<br>虚拟存储器从逻辑上对内存容量进行了扩充，用户看到的大容量只是一种感觉，是虚的，在32位的CPU系统中，这个虚拟内存地址范围为0-0xFFFFFFFF，我们把这个地址范围称为虚拟地址空间，其中某个地址称为虚拟地址。与虚拟地址空间、虚拟地址对应的是物理地址空间、物理地址，它们对应实际的内存。<br>虚拟地址空间最终需要转化为物理地址才能读写实际的数据，这通过将虚拟地址空间、物理地址空间划分为同样大小的一块块小空间（段或页），然后为这两类小空间建立映射关系。由于虚拟地址空间远大于物理空间，有可能多块虚拟地址空间映射到同一块物理地址空间，或者有些虚拟地址空间没有映射到具体的物理地址空间上去（可以使用到时再映射）。<br><img src="/2022/08/15/MMU/1.jpeg" alt="img not found"></li>
</ol>
<p>ARM CPU上的地址转换涉及3个概念：虚拟地址（Virtual Address）、变换后的虚拟地址（Modified Virtual Address）、物理地址（Physical Address）。<br>没启动MMU时，CPU核、cache、MMU、外设等所有部件使用的都是物理地址。<br>启动MMU后，CPU核对外发出虚拟地址VA；VA被转换为MVA供cache、MMU使用，再这里MVA被转换为PA；最后使用PA读写实际设备（S3C2410&#x2F;S3C2440内部寄存器或外界的设备）：</p>
<ol>
<li>CPU看到的、用到的只是虚拟地址VA，至于VA如何最终落实到物理地址PA上，CPU核是不理会的。</li>
<li>而caches和MMU也是看不到VA的，它们利用有MVA转换得到PA。</li>
<li>而实际设备看不到VA，MVA，它们读写时使用的是物理地址PA。<br>MVA是除CPU核外的其他部分看见的虚拟地址，VA与MVA之间的变化关系如图所示：<br><img src="/2022/08/15/MMU/2.jpeg" alt="img not found"><br>如果VA&lt;32M，需要使用进程标识号（PID）通过读CP15的c13获得来转换MVA。VA与MVA的转换方式如下（这是硬件自动完成的）：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span> (VA &lt; <span class="number">32</span>M) then</span><br><span class="line">    MVA = VA | (PID &lt;&lt; <span class="number">25</span>)</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    MVA = VA</span><br></pre></td></tr></table></figure>
利用PID生成MVA的目的是为了减少切换进程时的代价；不使用MVA而直接使用VA的话，当两个进程使用的虚拟地址空间VA有重叠时，在切换进程时为了把重叠的VA映射到不同的PA上去，需要重建页表、使无效caches和TLBS等，代价很大。使用MVA后，进程切换就省事多了：假设两个进程1、2运行时的VA都是0-32M，但是它们的MVA并不重叠，分别是0x02000000-0x03FFFFFF、0x04000000-0x05FFFFFF，这样就不必进行重建页表工作了。</li>
</ol>
<h3 id="虚拟地址到物理地址的转换过程"><a href="#虚拟地址到物理地址的转换过程" class="headerlink" title="虚拟地址到物理地址的转换过程"></a>虚拟地址到物理地址的转换过程</h3><p>将一个虚拟地址转换为物理地址，一般有两个办法：用一个确定的数学公式进行转换或用表格存储虚拟地址对应的物理地址。这类表格称为页表（Page Table），页表由一个个条目（Entry）组成；每个条目存储了一段虚拟地址对应的物理地址及其访问权限，或者下一级页表地址。<br>在AMR CPU中使用的第二种方法。S3C2410&#x2F;S3C2440最多会用到两级页表：以段（1MB）的方式进行转换时只用到一级页表，以页（Page）的方式进行转换时用到两级页表。页的大小由3种：大页（64KB）、小页（4KB）、极小页（1KB）。条目也称为”描述符“（Descriptor），有段描述符、大页描述符、小页描述符、极小页描述符–它们保存段、大页、小页或极小页的起始物理地址：粗页表描述符、细页表描述符–它们保存二级页表的物理地址。<br>大概的转换过程如下：</p>
<ol>
<li>根据给定的虚拟地址找到一级页表中的条目。</li>
<li>如果此条目是段描述符，则返回物理地址，转换结束。</li>
<li>否则如果此条目是二级页表描述符，继续利用虚拟地址在此二级页表找到下一个条目。</li>
<li>如果第二个条目是页描述符，则返回物理地址，转换结束。</li>
<li>其他情况出错。</li>
</ol>
<p><img src="/2022/08/15/MMU/3.jpeg" alt="img not found"><br>图中的“TTB base”代表一级页表的地址，将它写入协处理器CP15的寄存器C2（页表基址寄存器）即可。一级页表的地址必须是16K对应的（[14:0]为0）。<br><img src="/2022/08/15/MMU/4.jpeg" alt="img not found"><br>先介绍一级页表，32位的CPU的虚拟地址空间达到4GB，一级页表使用4096个描述符来表示这4GB空间—每个描述符对应1MB的虚拟地址，要么存储了它对应的1MB物理空间的起始地址，要么存储了下一级页表的地址。使用MVA[31:20]来索引一级页表，得到一个描述符，每个描述符占用4字节，如下图所示：<br><img src="/2022/08/15/MMU/5.jpeg" alt="img not found"><br>根据一级页表描述符的最低两位，可分为以下4种：</p>
<ol>
<li>0b00：无效。</li>
<li>0b01：粗页表（Coarse page table）<br>位[31:10]称为粗页表基址（Coarse page table base address），此描述符的低10位填充0后就是一个二级页表的物理地址。此二级页表含256个条目（所以大小为1KB），称为粗页表。其中每个条目表示大小为4KB的物理地址空间，所以一个粗页表表示1MB的物理地址空间。</li>
<li>0b10：段（Section）<br>位[31:20]称为段基址（Section Base），此描述符的低20位填充0后就是一块1MB的物理地址空间的起始地址。MVA[19:0]用来在这1MB的空间中寻址。所以，描述符的位[31:20]和MVA[19:0]就构成了这个虚拟地址MVA对应的物理地址。<br>以段的方式进行映射时，虚拟地址MVA到物理地址PA的转换过程如下：<br><img src="/2022/08/15/MMU/6.jpeg" alt="img not found"><br>①页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到段描述符。<br>②取出段描述符的位[31:20]—段基址，它和MVA[19:0]组成一个32位的物理地址–这就是MVA对应的PA。</li>
<li>0b11：细页表（Fine page table）<br>位[32：12]称为细页表基址（Fine page table base address），此描述符的低12位填充0后就是一个二级页表的物理地址。此二级页表含1024个条目（所以大小为4KB），称为细页表。其中每个条目表示大小为1KB的物理地址空间，所以一个细页表表示1MB的物理地址空间。<br>以大页（64KB）、小页（4KB）或极小页（1KB）进行地址映射时，需要用到两级页表。二级页表有粗页表、细页表两种，二级页表中描述符的格式如下：<br><img src="/2022/08/15/MMU/7.jpeg" alt="img not found"><br>根据二级描述符的最低两位，可分为以下4种情况：<br>①0b00：无效。<br>②0b01：大页描述符。<br>位[31:16]称为大页基址（Large page base address），此描述符的低16位填充0后就是一块64KB物理地址空间的起始地址。粗页表每个条目只能表示4KB的物理空间，如果大页描述符保存在粗页表中，则连续16个条目都保存同一个大页描述符。类似的，细页表中每个条目只能表示1KB的物理空间，如果大页描述符保存在细页表中，则连续64个条目都保存同一个大页描述符。<br>下面以保存在粗页表中的大页描述符为例，说明地址转换的过程：<br><img src="/2022/08/15/MMU/8.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到粗页表描述符。</span><br><span class="line">2. 取出粗页表描述符的位[31:10]--即粗页表基址，它和MVA[19:12]组成一个低两位为0的32位物理地址---据此即可找到大页描述符。</span><br><span class="line">3. 取出大页描述符的位[31:16]--即大页基址，它和MVA[15:0]组成一个32位的物理地址---这就是MVA对应的PA。</span><br><span class="line"></span><br><span class="line">上面的步骤2和3中，用于在粗页表中索引的MVA[19:12]、用于在大页内寻址的MVA[15:0]有重合的位：位[15:12]。当位[15:12]从0b0000变化到0b1111时，步骤2返回的大页描述符相同，所以粗页表中连续16个条目都保存同一个大页描述符。</span><br></pre></td></tr></table></figure>
③0b10：小页描述符<br>位[31:12]称为小页基址，此描述符的低12位填充0后就是一块4KB物理地址空间的起始地址。粗页表中每个条目表示4KB的物理空间，如果小页描述符保存在粗页表中，则只需要用一个条目来保存一个小页描述符。类似的，细页表中每个条目只能表示1KB的物理空间，如果小页表描述符保存在细页表中，则连续4个条目都保存同一个小页描述符。<br><img src="/2022/08/15/MMU/9.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到粗页表描述符。</span><br><span class="line">2. 取出粗页表描述符的位[31:10]--即粗页表基址，它和MVA[19:12]组成一个低两位为0的32位物理地址---据此即可找到小页描述符。</span><br><span class="line">3. 取出小页描述符的位[31:12]--即小页基址，它和MVA[11:0]组成一个32位的物理地址---这就是MVA对应的PA。</span><br><span class="line"></span><br><span class="line">小页描述符保存在细页表中，地址转换过程与上面类似，不在赘述。</span><br></pre></td></tr></table></figure>
④0b11：极小页描述符<br>位[31:10]被称为极小页基址，此描述符的低10位填充0后就是一块1KB的物理地址空间的起始地址。极小页描述符只能保存在细页表中，用一个条目来保存一个极小页描述符。<br><img src="/2022/08/15/MMU/10.jpeg" alt="img not found"><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">1. 页表基址寄存器位[31:14]和MVA[31:20]组成一个低两位为0的32位地址，MMU利用这个地址找到细页表描述符。</span><br><span class="line">2. 取出细页表描述符的位[31:12]---即细页表基址。它和MVA[19:10]组成一个低两位为0的32位物理地址--据此即可找到极小页描述符。</span><br><span class="line">3. 取出极小页描述符的位[31:10]---即极小页基址，它和MVA[9:0]组成一个32位的物理地址---这是MVA对应的PA。</span><br></pre></td></tr></table></figure></li>
</ol>
<p>从段、大页、小页、极小页的地址转换过程可知。</p>
<ol>
<li>以段进行映射时，通过MVA[31:20]结合页表得到一段（1MB）的起始物理地址，MVA[19:0]用来在段中寻址。</li>
<li>以大页进行映射时，通过MVA[31:16]结合页表得到一个大页（64KB）的起始物理地址，MVA[15:0]用来在大页中寻址。</li>
<li>以小页进行映射时，通过MVA[31:12]结合页表得到一个小页（4KB）的起始物理地址，MVA[11:0]用来在大页中寻址。</li>
<li>以极小页进行映射时，通过MVA[31:10]结合页表得到一个极小页（1KB）的起始物理地址，MVA[9:0]用来在极小页中寻址。</li>
</ol>
<h2 id="内存的访问权限检查"><a href="#内存的访问权限检查" class="headerlink" title="内存的访问权限检查"></a>内存的访问权限检查</h2><p>内存的访问权限检查是MMU的主要功能之一，简单的说，它就是决定一块内存是否允许读、是否允许写。这由CP15寄存器C3（域访问控制）、描述符的域（Domain）、CP15寄存器C1的R&#x2F;S&#x2F;A位。描述符的AP位等联合作用。<br>CP15寄存器C1中的A位表示是否对地址进行对齐检查。所谓对齐检查就是，访问字（4字节的数据）时地址是否为4字节对齐。访问半字（2字节的数据）时地址是否2字节对齐，如果地址不对齐则产生”Alignment Fault“异常。无论MMU是否被开启，都可以进行对齐检查。CPU读取指令时不进行对齐检查，以字节为单位访问时也不进行对其检查。对其检查在MMU的权限检查，地址映射前进行。<br>内存的访问权限检查可以概括为一下两点：</p>
<ol>
<li>”域“决定是否对某块内存进行权限检查。</li>
<li>”AP“决定如何对某块内存进行权限检查。</li>
</ol>
<p>如图所示，S3C2410&#x2F;S3C2440有16个域，CP15寄存器C3中每两位对应一个域，用来表示这个域是否进行权限检查。图中表示CP15寄存器C3中哪两位对应哪个域，表中给出了CP15寄存器C3中这些”两位数据“的含义。<br><img src="/2022/08/15/MMU/11.jpeg" alt="img not found"></p>
<table>
<thead>
<tr>
<th>值</th>
<th>含义</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>无访问权限</td>
<td>任何访问都将导致”Domain Fault“ 异常</td>
</tr>
<tr>
<td>01</td>
<td>客户模式</td>
<td>使用段描述符、页描述符进行权限检查</td>
</tr>
<tr>
<td>10</td>
<td>保留</td>
<td>保留，目前相当于”无访问权限“</td>
</tr>
<tr>
<td>11</td>
<td>管理模式</td>
<td>运行任何访问</td>
</tr>
</tbody></table>
<p>下图中的”Domain“占4个字节，用来表示这块内存属于上面定义的16个域中哪一个。<br><img src="/2022/08/15/MMU/12.jpeg" alt="img not found"></p>
<ol>
<li>段描述符中的”Domain“为0b0000时，表示这1MB内存属于域0，如果域访问控制寄存器的位[1:0]等于0b00，则访问这1MB空间时都会产生”Domain fault“的异常，如果域访问控制器寄存器的位[1:0]等于0b11，则使用描述符中的”AP“位进行权限检查。</li>
<li>粗页表中的”Domain“为0b1111时，表示这1MB内存属于域15，如果域访问控制寄存器的位[31:30]等于0b00，则访问这1MB空间时都会产生”Domain fault“的异常，如果域访问控制寄存器的位[31:30]等于0b11时，则使用二级页表中的大页&#x2F;小页描述符中的”ap3“、”ap2“、”ap1“、”ap0“进行位权限检查。</li>
</ol>
<p>图中的”AP“、”ap3“、”ap2“、”ap1“、”ap0”结合CP15寄存器C1的R&#x2F;S位，决定如何进行访问权限检查。首先说明，段描述符中的“AP”控制整个段（1MB）的访问权限；大页描述符中的每个“apx”（x为0-3）控制一个大页（64KB）中1&#x2F;4内存的访问权限，即“ap3”对应大页高端的16KB，“ap0”对应大页低端的16KB；小页描述符与大页描述符相似，每个“apx”控制一个小页（4KB）的1&#x2F;4内存的访问权限；极小页中的“ap”就控制着整个极小页（1KB）的访问权限。<br>如下表所示，AP位、S位和R位的组合，可以产生多种访问权限。需要指出的是，ARM CPU有7种工作模式，其中6种属于特权模式，一种属于用户模式。在特权模式的用户模式下，相同的AP位、S位和R位的组合，其访问权限也不相同。</p>
<table>
<thead>
<tr>
<th>AP</th>
<th>S</th>
<th>R</th>
<th>特权模式</th>
<th>用户模式</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>00</td>
<td>0</td>
<td>0</td>
<td>无访问权限</td>
<td>无访问权限</td>
<td>任何访问都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>00</td>
<td>1</td>
<td>0</td>
<td>只读</td>
<td>无访问权限</td>
<td>在超级权限下进行读操作</td>
</tr>
<tr>
<td>00</td>
<td>0</td>
<td>1</td>
<td>只读</td>
<td>只读</td>
<td>任何写操作都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>00</td>
<td>1</td>
<td>1</td>
<td>保留</td>
<td>–</td>
<td>–</td>
</tr>
<tr>
<td>01</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>无访问权限</td>
<td>只允许在超级模式下访问</td>
</tr>
<tr>
<td>10</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>只读</td>
<td>在用户模式下进行写操作都将产生“Permission fault”异常</td>
</tr>
<tr>
<td>11</td>
<td>x</td>
<td>x</td>
<td>读&#x2F;写</td>
<td>读&#x2F;写</td>
<td>在任何模式下都允许访问</td>
</tr>
<tr>
<td>xx</td>
<td>1</td>
<td>1</td>
<td>保留</td>
<td>–</td>
<td>–</td>
</tr>
</tbody></table>
<h2 id="TLB的作用"><a href="#TLB的作用" class="headerlink" title="TLB的作用"></a>TLB的作用</h2><p>从虚拟地址到物理地址的转换过程可得知：使用一级页表进行地址转换时，每次读写数据时需要访问两次内存。第一次访问一级页表获取物理地址，第二次才是真正的读写数据。使用两级页表时，每次读写数据需要访问三次内存，访问两次页表（一级页表和二级页表）获得物理地址，第三次才是真正的读写数据。<br>上述地址的转换过程大大降低了CPU的性能，有没有说明办法改进呢？程序执行过程中，所用到的指令、数据的地址往往集中在一个很小的范围内，其中的地址数据经常多次使用，这称为程序访问的局部性。由此，通过使用一个高速、容量相对较小的存储器来存储近期用过的页表条目（段、大页、小页、极小页描述符），以避免每次地址转换都需要到主存去查找，这样可以大幅度的提高性能。这个存储器用来帮助快速的进行地址转换，称为“转译查找缓存（Translation Lookaside Buffers，TLB）”。<br>当CPU发出一个虚拟地址时，MMU首先访问TLB。如果TLB中含有能转换这个虚拟地址的描述符，则直接利用此描述符进行地址转换和权限检查；否则MMU访问页表找到描述符后再进行地址转化和权限检查，并将这个描述符填入TLB中（如果TLB已满，则利用round-robin算法找到一个条目，然后覆盖他），下次再使用这个虚拟地址时就可以直接使用TLB中的描述符了。<br>使用TLB需要保证TLB的内容与页表一致，在启动MMU之前，在页表中的内容发生变化后，尤其要注意这点。S3C2410&#x2F;S3C2440可以使无效（Invalidate）整个TLB，或者通过某个虚拟地址使无效TLB中某个条目。一般的做法是：在启动MMU之前使无效整个TLB，改变页表时，使无效所涉及的虚拟地址对应的TLB中的条目。</p>
<h2 id="Cache的作用"><a href="#Cache的作用" class="headerlink" title="Cache的作用"></a>Cache的作用</h2><p>同样基于程序访问的局部性，在主存和CPU通用寄存器之间设置一个高速的、容量相对较小的存储器，把正在执行的指令地址附近的一部分指令或数据从主存调入这个存储器，供CPU在一段时间内使用，这对提高程序的运行速度有很大的作用。这个介于主存和CPU之间的高速小容量存储器称作高速缓存存储器（Cache）。<br>启用Cache后，CPU读取数据时，如果Cache中有这个数据的复本则直接返回，否则从主存中读入数据，并存入Cache中，下次再使用（读&#x2F;写）这个数据时，可以直接使用Cache中的复本。<br>启用Cache后，CPU写数据时有写穿式和写回式两种方式：</p>
<ol>
<li>写穿式（Write Through）<br>任一从CPU发出的写信号送到Cache的同时，也写入主存，以保证主存的数据能同步更新。它的优点是操作简单，但是由于主存的慢速，降低了系统的写速度并占用总线时间。</li>
<li>回写式<br>为了克服写穿式每次写数据时都要访问主存，从而导致系统写速度降低并占用总线时间，尽量减少对主存的访问次数，又有了回写式。<br>它的工作方式：数据一般只写到Cache，这样有可能出现Cache中的数据得到更新而主存数据不变（数据陈旧）的情况。但此时可在Cache中设一标志及数据陈旧的信息，只有当Cache中的数据被换出或强制进行“清空”操作时，才将原更新的数据写入主存相应的单元中。这样保证了Cache和主存的数据一致性。</li>
</ol>
<p>下面介绍Cache的两个操作：</p>
<ol>
<li>“清空”（clean）：把Cache或Write Buffer中已经脏的（修改过，但是还未写入主存）数据写入主存。</li>
<li>“使无效”（Invalidate）：使之不能再使用，并不将脏的数据写入主存。</li>
</ol>
<p>S3C2410&#x2F;S3C2440内置了指令Cache（ICache）、数据Cache（DCache）、写缓存（Write Buffer）。下面的内容需要用到页表中描述符的C、B位，为了方便读者，先把这些描述符用下图表示出来。下文中，描述符的C位称为Ctt，B位称为Btt。<br><img src="/2022/08/15/MMU/13.jpeg" alt="img not found"></p>
<h3 id="指令Cache（ICache）"><a href="#指令Cache（ICache）" class="headerlink" title="指令Cache（ICache）"></a>指令Cache（ICache）</h3><p>ICache的使用比较简单。系统刚上电或复位时，ICache中的内容是无效的，并且ICache功能是关闭着的。往Icr位（即CP15写处理器中寄存器1的第12位）写1可以启动ICache，写0可以停止ICache。<br>ICache一般在MMU开启之后被使用，此时页表中描述符的C位用来表示一段内存是否可以被Cache。若C&#x3D;1，则允许Cache，否则不允许被Cache。但是，即使MMU没有开启，ICache也是可以被使用的，这时CPU读取指令（取指）时所涉及的内存都被当作是允许Cache的。<br>ICache被关闭时，CPU每次取指都是需要读取主存，性能非常低，所以需要尽早启动ICache。<br>ICache被开启后，CPU每次取指都会在ICache中查看是否能找到所要的指令，而不管C&#x3D;0还是C&#x3D;1。如果找到了，称为Cache命中，如果找不到，称为Cache缺失。ICache被开启后，CPU的取指分为如下三种情况：</p>
<ol>
<li>Cache命中且C&#x3D;1时，从ICache取出指令，返回CPU。</li>
<li>Cache缺失且C&#x3D;1时，CPU从主存读出指令。同时，一个称为“8-word linefill”的动作将发生，这个动作把该指令所处区域的8个word写进ICache的某个条目中。这有可能会覆盖某个条目。</li>
<li>C&#x3D;0时，CPU从主存读取指令。</li>
</ol>
<h3 id="数据Cache（DCache）"><a href="#数据Cache（DCache）" class="headerlink" title="数据Cache（DCache）"></a>数据Cache（DCache）</h3><p>与ICache相似，系统刚复位或者上电时，DCache中的内容也是无效的，并且DCache功能也是关闭的，而Write Buffer中的内容也是被废弃不用的。往Ccr（Cp15协处理器中寄存器1的第2位）写1可以启动DCache，写0可以停止DCache。Write Buffer与DCache紧密结合，没有专门的控制位来开启、停止它。<br>与ICache不同的是，DCache功能必须在MMU开启之后才能被使用，因为开启MMU之后，才能使用页表的描述符来定义一块内存如何使用DCache和Write Buffer。<br>DCache被关闭时，CPU每次读写数据时都会先在DCache中查看是否能找到所要的数据，而不管C&#x3D;0还是C&#x3D;1。找到了，称为Cache命中，没找到，称为Cache缺失。<br>下表描述了DCache和Write Buffer在CCr、Ctt、Btt的各种取值下如何工作。表中“Ctt and Ccr”一项的值是Ctt与Ccr进行逻辑与之后的值（Ctt &amp;&amp; Ccr）。</p>
<table>
<thead>
<tr>
<th>Ctt and Ccr</th>
<th>Btt</th>
<th>DCache、Write Buffer和主存的访问方式</th>
</tr>
</thead>
<tbody><tr>
<td>0</td>
<td>0</td>
<td>Non-Cached、Non-buffered（NCNB）；读写数据都是直接操作内存，并且可以被外设中止；写数据时不使用Write Buffer，CPU会等待操作完成；不会出现Cache命中</td>
</tr>
<tr>
<td>0</td>
<td>1</td>
<td>Non-Cached、buffered（NCB）；读写数据都是直接操作主存，不会出现Cache命中；写数据时，数据先存入Write Buffer，随后写入主存；数据存入WriteBuffer后，CPU立立即继续执行；读数据时，可以被外设中止；写数据时，无法被外设中止</td>
</tr>
<tr>
<td>1</td>
<td>0</td>
<td>Cached，write-through（WT，写通）mode；读数据时，如果Cache命中则从Cache中返回数据，不读取主存；读数据时，如果Cache确实则从读主存中返回数据，并导致“linefill”的动作；写数据时，数据先存入Write Buffer，并在随后写入主存；数据存入Write Buffer后，CPU立即继续执行；写数据时，如果Cache命中则新数据也写入Cache中；写数据时，无法被外设中止</td>
</tr>
<tr>
<td>1</td>
<td>1</td>
<td>Cached，write-back（WB，写回）mode；读数据时，如果Cache命中则从Cache中返回数据，不读取主存；读数据时，如果Cache确实则从读主存中返回数据，并导致“linefill”的动作；写数据时，如果Cache缺失则将数据先存入Write Buffer，存储完毕后CPU立即继续执行，这些数据随后写入主存；写数据时，如果Cache命中则在Cache中更新数据，并设置这些数据为“脏”，但是不会写入主存；无论Cache命中与否，写数据都无法被外设中止。</td>
</tr>
</tbody></table>
<p>与TLB类似，使用Cache需要保证Cache、WriteBuffer的内容和主存保持一致，需要遵循以下两个原则：</p>
<ol>
<li>清空DCache，使得主存数据得到更新。</li>
<li>使无效ICache，使得CPU取值时重新读取主存。</li>
</ol>
<p>在实际编写程序前，需要注意以下几点：</p>
<ol>
<li>开启MMU之前，使无效ICache、DCache、WriteBuffer。</li>
<li>关闭MMU之前，清空ICache、DCache，即将“脏”数据写入主存。</li>
<li>如果代码有变，使无效ICache，这样CPU取指时会重新读取主存。</li>
<li>使用DMA操作可以被Cache的主存时：将内存的数据发送出去时，要清空Cache；将内存的数据读入时，要使无效Cache。</li>
<li>改变页表中地址映射关系时，也要慎重考虑。</li>
<li>开启ICache和DCache时，要考虑ICache或DCache中的内容是否与主存保持一致。</li>
<li>对于I&#x2F;O空间，不使用Cache和Write Buffer。所谓I&#x2F;O空间，就是对于其中的地址连续两次的写操作不能合并在一起，每次读写都必须直接访问设备，否则程序的运行结果无法预料。比如寄存器、非内存的外设（扩展串口、网卡等）。<br>S3C2410&#x2F;S3C2440提供了相关指令来操作Cache和Write buffer，可以使无效整个ICache或其中的条目，可以清空使无效整个DCache或其中的条目。</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440-MMU、TLB、Cache的控制指令"><a href="#S3C2410-x2F-S3C2440-MMU、TLB、Cache的控制指令" class="headerlink" title="S3C2410&#x2F;S3C2440 MMU、TLB、Cache的控制指令"></a>S3C2410&#x2F;S3C2440 MMU、TLB、Cache的控制指令</h3><p>S3C2410&#x2F;S3C2440中，除了有一个ARM920T的CPU核之外，还有若干协处理器。协处理器也是一个微处理器，它被用来帮助主CPU来完成一些特殊功能，如浮点运算等。对MMU、TLB、Cache等的操作就涉及协处理器。CPU核与协处理器间传送数据时使用这两条指令：MRC和MCR，它们的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;MCR | MRC&gt;&#123;cond&#125; p#,&lt;expression1&gt;,Rd,cn,cm,&#123;,&lt;expression2&gt;&#125;</span><br><span class="line">MRC             //从协处理器获得数据，传给ARM920T CPU核的寄存器</span><br><span class="line">MCR             //数据从ARM920T CPU核的寄存器传给协处理器</span><br><span class="line">&#123;cond&#125;          //执行条件  为空时表示无条件执行</span><br><span class="line">p#              //协处理器序号</span><br><span class="line">&lt;expression1&gt;  //一个常数</span><br><span class="line">Rd              //ARM920T核的寄存器</span><br><span class="line">cn和cm          //协处理器中的寄存器</span><br><span class="line">&lt;expression2&gt;   //一个常数</span><br></pre></td></tr></table></figure>
<p>其中，expression1、expression2、cn、cm仅供协处理器使用，它们的作用如何取决于具体的协处理器。</p>
<h1 id="MMU使用实例"><a href="#MMU使用实例" class="headerlink" title="MMU使用实例"></a>MMU使用实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本开发板的SDRAM的物理地址范围处于0x30000000-0x33ffffff，S3C2410&#x2F;S3C2440的寄存器地址范围都处于0x48000000-0x5FFFFFFF。在第五章中，通过往GPBCON和GPBDAT这两个寄存器的物理地址0x56000000、0x56000014写入特定的数据来驱动4个LED。<br>本章的实例将开启MMU，并将虚拟地址空间0xA0000000-0xA0100000映射到物理地址空间0x56000000-0x56100000上，这样，就可以通过操作地址0xA0000010、0xA0000014来达到驱动者4个LED的同样效果。<br>另外，将虚拟地址空间0xB0000000-0xB3FFFFFFF映射到物理地址空间0x30000000-0x33FFFFFF上，并在连接程序时将一部分代码的运行地址指定为0xB0004000，看看程序能否跳转到0xB0004000运行。<br>实例程序只是用一级页表，以段的方式进行地址映射。32位的CPU的虚拟地址空间达到4GB，一级页表中使用4096个描述符来表示这4GB（每个描述符对应1MB的虚拟地址），每个描述符占用4字节，所以一级页表占16KB。SDRAM的开始16KB来存放一级页表，所以剩下的内存开始物理地址为0xB0004000。<br>将程序代码分为两部分：第一部分的运行地址为0，它用来初始化SDRAM、复制第二部分的代码到SDRAM中（存放在0x30004000开始处），设置页表，启动MMU，最后跳转到SDRAM中（地址0xB0004000）去执行；第二部分的运行地址设为0xB0004000，它用来驱动LED。程序流程图如下：<br><img src="/2022/08/15/MMU/14.jpeg" alt="img not found"></p>
<h2 id="代码详解"><a href="#代码详解" class="headerlink" title="代码详解"></a>代码详解</h2><h3 id="第一部分代码分析"><a href="#第一部分代码分析" class="headerlink" title="第一部分代码分析"></a>第一部分代码分析</h3><p>程序源码分3个文件：head.S、init.c、leds.c。</p>
<ol>
<li>head.S代码详解<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:head.S</span></span><br><span class="line"><span class="comment">功能：设置SDRAM，将第二部分代码复制到SDRAM，设置页表，启动MMU，然后跳到SDRAM继续执行。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_satrt:</span><br><span class="line">  ldr sp,=<span class="number">4096</span>            @设置栈指针，以下都是C函数，调用前需要设置好栈</span><br><span class="line">  bl  disable_watch_dog   @关闭WATCHDOG，否则CPU会不断重启</span><br><span class="line">  bl  memsetup            @设置控制存储器以使用SDRAM</span><br><span class="line">  bl  copy_2th_to_sdram   @将第二部分代码复制到SDRAM</span><br><span class="line">  bl  create_page_table   @设置页表</span><br><span class="line">  bl  mmu_init            @启动MMU</span><br><span class="line">  bl  sp,=<span class="number">0xB4000000</span>      @重设栈指针，指向SDRAM顶端（使用虚拟地址）</span><br><span class="line">  bl  pc,=<span class="number">0xB0004000</span>      @跳到SDRAM中继续执行第二部分代码</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">  b halt_loop</span><br></pre></td></tr></table></figure>
head.S调用的函数都在init.c中实现。<br>值得注意的是，在第15行开启MMU之后，无论是CPU取指还是CPU读写数据，使用的都是虚拟地址。<br>在第14行设置页表时，在create_page_table函数中令head.S、init.c程序所在的内存的虚拟地址和物理地址一样，这使得head.S和init.c中的代码在开启MMU后能够没有任何障碍的继续运行。</li>
<li>init.c代码详解<br>disable_watch_dog、memsetup两个接口已经在前两章讨论过，下面不再赘述。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">init.c：进行一些初始化，在Steppingstone中运行</span></span><br><span class="line"><span class="comment">它和head.S同属第一部分程序，此时MMU尚未开启，使用物理地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//WATCHDOG寄存器</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WTCON (*(volatile unsigned long *)0x53000000)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//存储控制器的寄存器起始地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MEM_CTL_BASE  0x48000000</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//关闭WATCHAOG，否则CPU会不断重启</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_watch_dog</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  WTCON = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//设置存储控制器以使用SDRAM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">memsetup</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="comment">//SDRAM 13个寄存器的值</span></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> <span class="type">const</span> mem_cfg_val[]=&#123;<span class="number">0x22011110</span>,<span class="comment">//BWSCON</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON0</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON1</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON2</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON3</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON4</span></span><br><span class="line">                                    <span class="number">0x00000700</span>,<span class="comment">//BANKCON5</span></span><br><span class="line">                                    <span class="number">0x00018005</span>,<span class="comment">//BANKCON6</span></span><br><span class="line">                                    <span class="number">0x00018005</span>,<span class="comment">//BANKCON7</span></span><br><span class="line">                                    <span class="number">0x008C07A3</span>,<span class="comment">//REFRESH</span></span><br><span class="line">                                    <span class="number">0x000000B1</span>,<span class="comment">//BANKSIZE</span></span><br><span class="line">                                    <span class="number">0x00000030</span>,<span class="comment">//MRSRB6</span></span><br><span class="line">                                    <span class="number">0x00000030</span><span class="comment">//MRSRB7</span></span><br><span class="line">                                    &#125;;</span><br><span class="line">  <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *p = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">long</span> *)MEM_CTL_BASE;</span><br><span class="line">  <span class="keyword">for</span>(;i &lt; <span class="number">13</span>;i++)</span><br><span class="line">    p[i] = mem_cfg_val[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
copy_2th_to_sdram函数用来将第二部分代码（即由leds.c编译得来的代码）从Steppingstone复制到SDRAM中。在连接程序时，第二部分代码的加载地址被指定为2048，重定位地址为0xB0004000。所以系统从NAND Flash启动后，第二部分代码Steppingstone中地址2048之后，需要把它复制到0x30004000处（此时尚未开启MMU，虚拟地址0xB0004000对应的物理地址在后面设为0x30004000）。Steppingstone总大小为4KB，不妨把地址2048后的所有数据复制到SDRAM中，所以源数据的结束地址为4096。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将第二部分代码复制到SDRAM</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">copy_2th_to_sdram</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *pdwSrc = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">2048</span>;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">int</span> *pdwDest = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x30004000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(pdwSrc &lt; (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">4096</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *pdwDest = *pdwSrc;</span><br><span class="line">    pdwDest++;</span><br><span class="line">    pdwSrc++;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
剩下的create_page_table、mmu_init就是本章的重点了。前者用来设置页表，后者用来开启MMU。<br>先看看create_page_table函数，它用于设置3个区域的地址映射关系。<br>①将虚拟地址0-（1M-1）映射到同样的物理地址去，Steppingstone（从0地址开始的4KB内存）就处于这个范围中。使虚拟地址等于物理地址，可以让Steppingstone中的程序（head.S和init.c）在开启MMU前后不需要考虑太多的事情。<br>②GPIO寄存器的起始物理地址范围为0x56000000，将虚拟地址0xA0000000-（0xA0000000+1M-1）映射到物理地址0x56000000-（0x56000000+1M-1）。<br>③本开发板中SDRAM的物理地址范围为0x30000000-0x33fffffff，将虚拟地址0xB0000000-0xB3fffffff映射到物理地址0x30000000-0x33fffffff。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//设置页表</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">create_page_table</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="comment">//用于段描述符的一些宏定义</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_FULL_ACCESS (3 &lt;&lt; 10)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_DOMAIN (0 &lt;&lt; 5)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SPECIAL (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_CACHEABLE (1 &lt;&lt; 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_BUFFERABLE (1 &lt;&lt; 2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECTION (2)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | MMU_SECTION)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC_WB (MMU_FULL_ACCESS | MMU_DOMAIN | MMU_SPECIAL | MMU_SECTION | MMU_BUFFERABLE | MMU_CACHEABLE)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMU_SECDEDSC_SIZE (0x00100000)</span></span><br><span class="line"></span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> virtualaddr,physicaladdr;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> *mmu_tlb_base = (<span class="type">unsigned</span> <span class="type">long</span> *)<span class="number">0x30000000</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  Steppingstone的起始物理地址为0，第一部分程序的起始运行地址也是0，</span></span><br><span class="line"><span class="comment">  为了在开启MMU后仍能运行第一部分的程序，</span></span><br><span class="line"><span class="comment">  将0-1M的虚拟地址空间映射到同样的物理地址</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0</span>;</span><br><span class="line">  physicaladdr = <span class="number">0</span>;</span><br><span class="line">  *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  0x56000000是GPIO寄存器的起始物理地址</span></span><br><span class="line"><span class="comment">  GPBCON和GPBDAT这两个寄存器的物理地址0x56000010、0x56000014，</span></span><br><span class="line"><span class="comment">  为了在第二部分程序中能以地址0xA0000010、0xA0000014来操作GPBCON和GPBDAT这两个寄存器，</span></span><br><span class="line"><span class="comment">  把从0xA0000000开始的1MB虚拟地址空间映射到0x56000000开始的1MB物理地址空间</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0xA0000000</span>;</span><br><span class="line">  physicaladdr = <span class="number">0x56000000</span>;</span><br><span class="line">  *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*</span></span><br><span class="line"><span class="comment">  SDRAM的物理地址范围是0x3000000-0x33FFFFFF，</span></span><br><span class="line"><span class="comment">  将虚拟地址0xB0000000-0xB3fffffff映射到物理地址0x30000000-0x33fffffff上</span></span><br><span class="line"><span class="comment">  总共64MB，涉及64个段描述符</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line">  virtualaddr = <span class="number">0xB0000000</span>;</span><br><span class="line">  physicaladdr = <span class="number">0x30000000</span>;</span><br><span class="line">  <span class="keyword">while</span>(virtualaddr &lt; <span class="number">0xB4000000</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    *(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line">    virtualaddr += <span class="number">0x100000</span>;</span><br><span class="line">    virtualphysicaladdraddr += <span class="number">0x100000</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
mmu_tlb_base被定义为unsigned long 指针，所指向的内存为4字节，刚好是一个描述符的大小。在SDRAM的开始存放页表—第81行令mmu_tlb_base指向SDRAM的起始地址0x3000000。其中最能体现页表结构的代码是下列代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC;</span><br><span class="line">*(mmu_tlb_base + (virtualaddr &gt;&gt; <span class="number">20</span>)) = (physicaladdr &amp; <span class="number">0xFFF00000</span>) | MMU_SECDESC_WB;</span><br></pre></td></tr></table></figure>
虚拟地址的位[31:20]用于索引一级页表，找到它所对应的描述符，对应于“(virtualaddr &gt;&gt; 20)”。<br>段描述符中位[31:20]中保存段的物理地址，对应于“(physicaladdr &amp; 0xFFF00000)”。<br>位[11:0]中用来设置段的访问权限，包括所属的域、AP位、C位（是否可Cache）、B位（是否使用Write buffer）—这对应“MMU_SECDESC”或“MMU_SECDESC_WB”，它们的域都被设为0，AP位被设为0b11（进行权限检查，读写操作都被允许）。“MMU_SECDESC”中C&#x2F;B位都没有设置，表示不使用Cache和Write Buffer，所以映射寄存器空间时使用“MMU_SECDESC”。“MMU_SECDESC_WB”中C&#x2F;B都设置了，表示使用Cache和Write Buffer，即所谓的回写式。在映射Steppingstone和SDRAM等内存时使用“MMU_SECDESC_WB”。<br>现在看看mmu_init函数。Create_page_table函数设置好了页表，还需要把页表地址告诉CPU，并且在开启MMU之前做好一些准备工作，比如使无效ICache、DCache，设置域访问控制寄存器等。代码的注释就可以帮助读者很好的理解mmu_init函数。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">启动MMU</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">mmu_init</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> ttb <span class="number">0x30000000</span>;</span><br><span class="line"></span><br><span class="line">  __asm__(</span><br><span class="line">    <span class="string">&quot;mov  r0,  #0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c7,  c7,   0\n&quot;</span>                  <span class="comment">//使无效ICache和DCache</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c7,  c10,  4\n&quot;</span>                  <span class="comment">//drain write buffer on v4</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,  c8,  c7,   0\n&quot;</span>                  <span class="comment">//使无效指令、数据TLB</span></span><br><span class="line">    <span class="string">&quot;mov  r4,   %0\n&quot;</span>                                     <span class="comment">//r4 = 页表基址</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r4,   c2,   c0,   0\n&quot;</span>                <span class="comment">//设置页表基址寄存器</span></span><br><span class="line">    <span class="string">&quot;mvn  r0,   #0\n&quot;</span></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,   c3,   c0,   0\n&quot;</span>                <span class="comment">//域访问控制寄存器设为0xFFFFFFFFF，不进行权限检查</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    对于控制寄存器，先读出其值，在这基础上修改感兴趣的位</span></span><br><span class="line"><span class="comment">    然后再写入</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">&quot;mrc  p15,  0,  r0, c1, c0, 0\n&quot;</span>                      <span class="comment">//读出控制寄存器的值</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    控制寄存器的低16位含义为：.RVI ..RS B... .CAM</span></span><br><span class="line"><span class="comment">    R：表示换出Cache中的条目时使用的算法，0 = Random repalcement；1 = Round robin replacement</span></span><br><span class="line"><span class="comment">    V：表示异常向量表所在的位置；0 = Low address = 0x00000000；1 = High address = 0xFFFF0000</span></span><br><span class="line"><span class="comment">    I：0 = 关闭ICache；1 = 开启ICache；</span></span><br><span class="line"><span class="comment">    R、S：用来与页表中的描述符一起确定内存的访问权限；</span></span><br><span class="line"><span class="comment">    B：0 = CPU为小字节序；1 = CPU为大字节序；</span></span><br><span class="line"><span class="comment">    C：0 = 关闭DCache；1 = 开启DCache；</span></span><br><span class="line"><span class="comment">    A：0 = 数据访问时不进行地址对齐检查；1 = 数据访问时进行地址对齐检查；</span></span><br><span class="line"><span class="comment">    M：0 = 关闭MMU；1 = 开启MMU；</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    先清除不需要的位，往下若需要则重新设置它们</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="comment">/*.RVI ..RS B... .CAM*/</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x3000\n&quot;</span>                             <span class="comment">//..11 .... .... .... 清除V、I位</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x0300\n&quot;</span>                             <span class="comment">//.... ..11 .... .... 清除R、S位</span></span><br><span class="line">    <span class="string">&quot;bic  r0,  r0,   #0x0087\n&quot;</span>                             <span class="comment">//.... .... 1... .111 清除B/C/A/M位</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">    设置需要的位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0002\n&quot;</span>                                <span class="comment">//.... .... .... ..1. 开启对齐检查</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0004\n&quot;</span>                                <span class="comment">//.... .... .... .1.. 开启DCache</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x1000\n&quot;</span>                                <span class="comment">//...1 .... .... .... 开启ICache</span></span><br><span class="line">    <span class="string">&quot;orr  r0, r0, #0x0001\n&quot;</span>                                <span class="comment">//.... .... .... ...1 使能MMU</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;mcr  p15,  0,  r0,   c1,   c0,   0\n&quot;</span>                  <span class="comment">//将修改的值写入到控制寄存器</span></span><br><span class="line">    :<span class="comment">/*无输出*/</span></span><br><span class="line">    :<span class="string">&quot;r&quot;</span>(ttb));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="第二部分代码分析"><a href="#第二部分代码分析" class="headerlink" title="第二部分代码分析"></a>第二部分代码分析</h3><p>第二部分代码leds.c中只有两个函数：wait和main。wait函数用来延时，main函数用来循环点亮4个LED。</p>
<ol>
<li>操作GPBCON、GPBDAT两个寄存器时使用虚拟地址0xA0000010、0xA0000014。在init.c中已经把虚拟地址0xA0000000-（0xA0000000 + 1M-1）映射到物理地址0x56000000-（0x56000000+1M-1）；</li>
<li>在定义wait函数时使用了一点小技巧，将它定义成“static inline”类型，原因在代码中给出：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">  leds.c：循环点亮4个LED</span></span><br><span class="line"><span class="comment">  属于第二部分程序，此时MMU已开启，使用虚拟地址</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (* (unsigned long *) 0xA0000010)             <span class="comment">//物理地址0x56000010</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (* (unsigned long *) 0xA0000014)             <span class="comment">//物理地址0x56000014</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LED1-LED4对应GPB5、GPB6、GPB7、GPB8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">wait函数加上“static inline”是有原因的，</span></span><br><span class="line"><span class="comment">这样可以使得编译leds.c时，wait嵌入main中，编译结果只有main一个函数。</span></span><br><span class="line"><span class="comment">于是在连接时，main函数的地址就是由连接文件指定的运行地址。</span></span><br><span class="line"><span class="comment">而连接文件mmu.lds中，指定了leds.o的运行时装载地址为0xB0004000，</span></span><br><span class="line"><span class="comment">这样，head.s中的“ldr pc,=0xB0004000“就是跳去执行main函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">wait</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> dly)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">for</span>(;dly &gt; <span class="number">0</span>;dly--)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//将LED1NLED4对应的GPB5GPB8引脚设置为输出</span></span><br><span class="line">  GPBCON = GPB5out | GPB6_out | GPB7_out | GPB8_out;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">  &#123;</span><br><span class="line">    wait(<span class="number">3000000</span>);</span><br><span class="line">    GPBDAT = (~(i&lt;&lt;<span class="number">5</span>));</span><br><span class="line">    <span class="keyword">if</span>(++i == <span class="number">16</span>)</span><br><span class="line">      i = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="Makefile和连接脚本mmu-lds"><a href="#Makefile和连接脚本mmu-lds" class="headerlink" title="Makefile和连接脚本mmu.lds"></a>Makefile和连接脚本mmu.lds</h3><p>Makefile内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">objs := head.o init.o leds.o</span><br><span class="line"></span><br><span class="line">mmu.bin:  $(objs)</span><br><span class="line">  arm-linux-ld -Tmmu.lds -o mmuj_elf $^</span><br><span class="line">  arm-linux-objcopy -O binary -S mmu_elf $@</span><br><span class="line">  arm-linux-objdump -D -m arm mmu_elf &gt; mmu.dis</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">  arm-linux-gcc -Wall -O2 -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">%.o:%.s</span><br><span class="line">  arm-linux-gcc -Wall -O2 -c -o $@ $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -f mmu.bin mmu_elf mmu.lds *.o</span><br></pre></td></tr></table></figure>
<p>Makefile第4行命令用来连接程序，它使用连接脚本mmu.lds来控制连接器的行为。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS  &#123;</span><br><span class="line">    first <span class="number">0x00000000</span>  : &#123;head.o init.o&#125;</span><br><span class="line">    second  <span class="number">0xB0004000</span>  : AT(<span class="number">2048</span>)  &#123;leds.o&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>连接脚本mmu.lds将程序分为两个段：first和second。前者由head.o和init.o组成，它的加载地址和运行地址都是0，所以运行前不需要重新移动代码。后者由leds.o组成，它的加载地址为2048，重定位地址为0xB0004000，这表明段second存放在编译所得映像文件地址2048处，在运行前需要将它复制到0xB0004000处，这由init.c中的copy_2th_to_sdram函数完成（此函数将代码复制到开始地址为0x30004000的内存中，这是开启MMU后虚拟地址0xB0004000对应的物理地址）。<br>实例程序涉及了代码的复制、开启MMU前使用物理地址寻址，开启MMU后使用虚拟地址寻址，相对复杂。下图更形象的演示了代码的执行。<br><img src="/2022/08/15/MMU/15.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/16.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/17.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/18.jpg" alt="img not found"><br><img src="/2022/08/15/MMU/19.jpg" alt="img not found"></p>
<h1 id="实例测试结果"><a href="#实例测试结果" class="headerlink" title="实例测试结果"></a>实例测试结果</h1><p>程序烧入NAND Flash后，复位启动系统。可以看到4个LED被循环点亮，闪烁速度比SDRAM实验快，那是因为开启了Cache。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第7章 MMU</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>MMU</tag>
      </tags>
  </entry>
  <entry>
    <title>LCD控制器</title>
    <url>/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>《嵌入式Linux应用完全开发手册》第2篇第13章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解LCD显示器的接口及时序</li>
<li>掌握S3C2410&#x2F;S3C2440LCD控制器的使用方法</li>
<li>了解帧缓冲区的概念，掌握如何设置帧缓冲区来显示图像</li>
</ol>
<h1 id="LCD和LCD控制器"><a href="#LCD和LCD控制器" class="headerlink" title="LCD和LCD控制器"></a>LCD和LCD控制器</h1><h2 id="LCD显示器"><a href="#LCD显示器" class="headerlink" title="LCD显示器"></a>LCD显示器</h2><h3 id="LCD的种类"><a href="#LCD的种类" class="headerlink" title="LCD的种类"></a>LCD的种类</h3><p>LCD（Liquid Crystal Display），即液晶显示器，是一种采用了液晶控制透光度技术来实现色彩的显示器。它与传统的CRT显示器相比有很多优点：轻薄、能耗低、辐射小等，市场占有率越来越大。LCD有很多种类，比如STN、TFT、LTPS TFT、OLED等，各有优缺点。<br>STN（Super Twisted Nematic，超扭曲向列），有CSTN和DSTN之分，是4种LCD屏中最低端的一种，仅有的优点就是功耗低，在色彩鲜艳度和画面亮度上相对于TFT和其他LCD屏存在明显不足，在日光下几乎不能显示，而且响应时间长达200ms左右，播放动画或视频拖影明显不足。<br>TFT（Thin Film Transistor，薄膜晶体管）可以大大缩短屏幕响应时间，其响应时间已经小于80ms，并改善了STN连续显示时屏幕闪烁模糊，有效提供了动态画面的播放力，呈现画面色彩饱和度、真实效果和对比度都很不错，完全超越STN，只是功耗稍高，是目前最为主流的液晶显示器类型。在MP3、MP4产品上大量应用，在桌面液晶显示器、笔记本电脑、手机等产品上的应用也非常普遍。<br>LTPS（Low Temperature Polycrystalline Silicon，低温多晶硅）由TFT衍生的新一代的技术产品，可以获得更高的分辨率和更丰富的色彩。LTPS LCD可以提供170°的水平和垂直可视角度，显示响应仅12ms，显示亮度达到500Cd&#x2F;m²，对比度可达500：1，这就是一些桌面液晶屏性能越来越出色的原因。虽然LTPS LCD已经出现很多年了，但由于LTPS TFT液晶屏的制造需要高于制造传统TFT屏的技术水平，目前仅有少数知名大厂能制造。<br>OLED（Organic Light Emitted Diode，有机发光二极管）各种物理特性都具备领先优势，色彩明亮、可视角度超大、非常省电，是未来发展的主流，只是目前受技术与成本限制，未能广泛普及。目前，彩色OLED比较广泛的存在中低端产品中。</p>
<h3 id="LCD的接口"><a href="#LCD的接口" class="headerlink" title="LCD的接口"></a>LCD的接口</h3><p>CPU或显卡发出的图像是TTL信号，LCD本身接收的也是TTL信号。但是由于TTL信号高速率的长距离传输性能不佳，抗干扰能力也比较差，后来又提出了多种接口，比如LVDS、TDMS、GVIF、P&amp;D、DVI和DFP等。它们实际上只是将CPU或显卡发出的TTL信号编码成各种信号以便传输，在LCD那边将接收到的信号进行解码得到TTL信号。<br>由于数字接口标准尚未统一，所以使用LCD时需要根据其手册了解具体接口定义。也是基于数字接口标准尚未统一的原因，市场上大多LCD都采用模拟接口信号，LCD先通过ADC将模拟信号转换为数字信号才能显示。<br>但是不管采用何种数字接口，本质的TTL信号是一样的。</p>
<ol>
<li><p>对于STN LCD<br>STN LCD 的数据传输方式有3种：4位单扫（4-bit single scan）、4位双扫（4-bit dual scan）、8位单扫（8-bit single scan）。所谓“单扫”是指对于一整屏的数据，从上到下、从左到右，一个一个的发送出来；“双扫”是指将一整屏的数据分为上下两部分，同时从上到下、从左到右，一个一个的发送出来。“4位”、“8位”是指发送数据时使用多少个数据线；需要注意的是，4位双扫方式也是用到8根数据线，其中4根用于上半屏数据，另外4根用于下半屏数据。<br>除数据信号外，还有其他控制信号，所有TTL信号如下表所示：</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>VFRAME</td>
<td>帧同步信号</td>
</tr>
<tr>
<td>VLINE</td>
<td>行同步信号</td>
</tr>
<tr>
<td>VCLK</td>
<td>像素时钟信号</td>
</tr>
<tr>
<td>VD[7:0]</td>
<td>数据信号</td>
</tr>
<tr>
<td>VM</td>
<td>AV偏置信号</td>
</tr>
<tr>
<td>PWREN</td>
<td>电源开关信号</td>
</tr>
</tbody></table>
</li>
<li><p>对于TFT LCD<br>TFT LCD的信号与STN类似，只是其数据信号多达24根，对应像素值的每一位。</p>
<table>
<thead>
<tr>
<th>信号名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>VSYNC</td>
<td>垂直同步信号</td>
</tr>
<tr>
<td>HSYNC</td>
<td>水平同步信号</td>
</tr>
<tr>
<td>HCLK</td>
<td>像素时钟信号</td>
</tr>
<tr>
<td>VD[23:0]</td>
<td>数据信号</td>
</tr>
<tr>
<td>LEND</td>
<td>行结束信号</td>
</tr>
<tr>
<td>PWREN</td>
<td>电源开关信号</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="S3C2410-x2F-S3C2440-LCD控制器介绍"><a href="#S3C2410-x2F-S3C2440-LCD控制器介绍" class="headerlink" title="S3C2410&#x2F;S3C2440 LCD控制器介绍"></a>S3C2410&#x2F;S3C2440 LCD控制器介绍</h2><h3 id="S3C2410-x2F-S3C2440-LCD控制器的特性与结构"><a href="#S3C2410-x2F-S3C2440-LCD控制器的特性与结构" class="headerlink" title="S3C2410&#x2F;S3C2440 LCD控制器的特性与结构"></a>S3C2410&#x2F;S3C2440 LCD控制器的特性与结构</h3><p>S3C2410&#x2F;S3C2440 LCD控制器被用来向LCD传输图像数据，并提供必要的控制信号，比如VFRAME、VLINE、VCLK、VM等。可以支持STN LCD、TFT LCD，其特性如下（BPP 表示bit per pixel，即每个颜色像素点用多少位来表示）。<br>STN LCD</p>
<ol>
<li>支持3种扫描方式：4位单扫，4位双扫和8位单扫</li>
<li>支持单色（1BPP）、4级灰度（2BPP）、16级灰度屏（4BPP）</li>
<li>支持256色（8BPP）和4096色（12BPP）彩色STN屏（CSTN）</li>
<li>支持分辨率为640x480、320x240、160x160以及其他规格的多种LCD</li>
<li>虚拟屏幕最大可达4MB</li>
<li>对于256色，分辨率有4094x1024、2048x2048、1024x4096等多种</li>
</ol>
<p>TFT LCD</p>
<ol>
<li>支持单色（1BPP）、4级灰度（2BPP）、16级灰度（4BPP）、256色（8BPP）的调色板显示模式</li>
<li>支持64K（16BPP）和16M（24BPP）色非调色板显示模式</li>
<li>支持分辨率为640x480、320x320及其他多种规格的LCD</li>
<li>虚拟屏幕最大可达4MB</li>
<li>对于64K色，分辨率有2048x1024等多种</li>
</ol>
<p>S3C2410&#x2F;S3C2440 LCD控制器提供了驱动STN LCD、TFT LCD所需的所有信号，另外，还特别提供额外的信号以支持SEC公司生产的TFT LCD。这3类信号中很大部分是复用的。<br>S3C2410&#x2F;S3C2440 LCD控制器的内部结构如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"><br>REGBANK是LCD控制器的寄存器组，含17个寄存器及一块256x16的调色板内存，用来设置各项参数。而LCDCDMA则是LCD控制器专用的DMA通道，可以自动地从系统总线（System Bus）上取到图像数据，这使得显示图像时不需要CPU的干涉。VIDPRCS将LCDCDMA中的数据组合成特定的格式，然后从VD[23:0]发送给LCD屏。同时TIMEGEN和LPC3600负责产生LCD屏所需要的控制时序，例如VSYNC、HSYNC、VCLK、VDEN，然后从VIDEO MUX送给LCD屏。其中LPC3600专用于SEC TFT LCD。<br>LCDCDMA中有2个FIFO：FIFOH容量为16（1个字为4个字节）个字，FIFOL容量为12个字。当使用“双扫”方式时，FIFOH、FIFIL分别用于传输上半屏、下班屏数据；当使用“单扫”方式时，只用到FIFOH。当FIFO为空或者其中的数据已经减少到设定的阈值时，LCDCDMA自动的发起DMA传输从内存中获得图像数据。</p>
<h3 id="显示器上数据的组织格式"><a href="#显示器上数据的组织格式" class="headerlink" title="显示器上数据的组织格式"></a>显示器上数据的组织格式</h3><p>一幅图像被称为一帧，每帧由多行组成，每行由多个像素组成，每个像素的颜色用若干位的数据表示。对于单色显示器，每个像素用1位来表示，称为1BPP，对于256色显示器，每个像素使用8位来表示，称为8BPP。<br>显示器从屏幕的左上方开始，一行一行的取得每个像素的数据并显示出来，当显示当一行的最右边时，跳到下一行的最左边开始显示下一行；当显示完所有行后，跳到左上方开始显示下一帧。显示器沿着“Z”字行的路线进行扫描，使用HSYNC、VSYNC信号来控制扫描路线的跳转。HSYNC表示“是时候跳到最左边了”，VSYNC表示“是时候跳到最上边了”。<br>在工作中的显示器上，可以在四周看到黑色的边框。上方的黑框是因为显示完所有行的数据时，显示器还没有扫描到最下边（VSYNC信号还未发出），这时数据已经无效。左边的黑框是因为当发出HSYNC信号时，需要经过若干像素之后第一列数据才有效；右边的黑框是因为显示完一行的数据时，显示器还每扫描到最右边（HSYNC信号还没有发出），这时数据已经无效。显示器只会依据VSYNC、HSYNC信号来取得、显示数据，并不理会该数据是否有效，何时发出有效数据由显卡决定。<br>VSYNC信号出现的频率表示1秒内能显示多少帧的图像，称为垂直频率或者场频率，这就是我们常说的“显示器的频率”；HSYNC信号出现的频率称为水平频率。<br>显示器上，一帧数据的存放位置与VSYNC、HSYNC信号的关系如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>有效数据的行数、列数即分辨率，它与VSYNC、HSYNC信号之间的“距离”等，都是可以设置的，这由显卡完成。</p>
<h3 id="TFT-LCD的操作"><a href="#TFT-LCD的操作" class="headerlink" title="TFT LCD的操作"></a>TFT LCD的操作</h3><p>目前市场上主流的LCD为TFT LCD，先了解TFT LCD的时序，这使得我们在设置各个寄存器时有个形象的概念。每个VSYNC信号表示一帧数据的开始；每个HSYNC信号表示一行数据的开始，无论这些数据是否有效；每个VCLK信号表示正在传输一个像素的数据，无论它是否有效。数据是否有效只是对CPU的LCD控制器来说的，LCD根据VSYNC、HSYNC、VCLK不停的读取总线数据、显示。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/3.jpeg" alt="img not found"></p>
<ol>
<li>VSYNC信号有效时，表示一帧数据的开始。</li>
<li>VSPW表示VSYNC信号的脉冲宽度为（VSPW + 1）个HSYNC信号周期，即（VSPW + 1）行，这（VSPW + 1）行数据无效。</li>
<li>VSYNC信号脉冲之后，还要经过（VBPD + 1）个HSYNC信号周期，有效的行数据才出现。所以在VSYNC信号有效之后，总共还要经过（VSPW + 1 + VBPD + 1）个无效的行，它对应图13.2上方的边框，第一个有效的行才出现。</li>
<li>随后即连续发出（LINEVAL + 1）行的有效数据。</li>
<li>最后是（VFPD + 1）个无效的行，它对应图13.2下方的边框，完整的一帧结束，紧接着就是下一帧的数据了（即下一个VSYNC信号）。</li>
</ol>
<p>现在深入到一行像素的传输过程。类似于行数据的传输过程。</p>
<ol>
<li>HSYNC信号有效时，表示一行数据的开始。</li>
<li>HSPW表示HSYNC信号的脉冲宽度为（HSPW + 1）个VCLK信号周期，即（HSPW + 1）个像素，这（HSPW + 1）个像素的数据无效。</li>
<li>HSYNC信号脉冲无效之后，还要经过（HBPD + 1）个VCLK信号周期，有效的像素数据才出现。所以，在HSYNC信号有效之后，总共还要经过（HSPW + 1 + HBPD + 1）个无效的像素，它对应图13.2的左边框，第一个有效像素才出现。</li>
<li>随后即连续发出（HOZVAL + 1）个像素的有效数据。</li>
<li>最后是（HFPD + 1）个无效的像素，它对应图13.2的右边框，完整的一行结束，紧接着就是下一行的数据了（即下一个HSYNC信号）。</li>
</ol>
<p>时序图中各信号的时间参数都可以在LCD控制寄存器中设置，VCLK作为时序图的基准信号，它的频率可由此计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VCLK(hz) = HCLK / [(CLKVAL + <span class="number">1</span> x <span class="number">2</span>)]</span><br></pre></td></tr></table></figure>
<p>VSYNC信号的频率又称为帧频率、垂直频率、场频率、显示器的频率，它可以如下计算：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Frame Rate = <span class="number">1</span>/[&#123;(VSPW+<span class="number">1</span>)+(VBPD+<span class="number">1</span>)+(LINEVAL+<span class="number">1</span>)+(VFPD+<span class="number">1</span>)&#125; x &#123; (HSPW+<span class="number">1</span>)+(HBPD+<span class="number">1</span>)+(HFPD+<span class="number">1</span>)+(HOZVAL+<span class="number">1</span>) &#125; x &#123; <span class="number">2</span> x ( CLKVAL+<span class="number">1</span>) / (HCLK)&#125;]</span><br></pre></td></tr></table></figure>
<p>将VSYNC、HSYNC、VCLK等信号的时间参数设置好之后，并将帧内存（frame memory）的地址告诉LCD控制器，它即可自动发起DMA传输从帧内存得到图像数据，最终在上述信号的控制下出现在数据总线VD[23:0]上。用户只需要把要显示的图像数据写入帧内存中。<br>下面介绍各种图像的格式数据在内存中如何存储。<br>显示器上的每个像素的颜色都是由3个部分组成：红、绿、蓝。它们被称为三原色，这三者的混合几乎可以表示人眼所能识别到的所有颜色。比如可以根据颜色的浓烈程度将三原色都分为256个级别（0-255）。可以使用255级的红色、255级的绿色、255级的蓝色可以组成白色。0级的红色、0级的绿色、0级的蓝色可以组成黑色。<br>LCD控制器可以支持单色（1BPP）、4级灰度（2BPP）、16级灰度（8BPP）、256色（8BPP）的调色板显示模式，支持64K（16BPP）和16M（24BPP）非调色板显示模式。下面只介绍256色（8pp）、64K（16BPP）和16M（24BPP）色显示模式下，图像数据的存储格式。</p>
<ol>
<li>16M（24BPP）色<br>16M（24BPP）色的显示模式就是使用24位的数据来表示一个像素的颜色，每种原色使用8位。LCD控制器从内存中获得某个像素的24位颜色值后，直接通过VD[23:0]数据线发送给LCD。为了方便DMA传输，在内存中使用4个字节（32）位来表示一个像素，其中的3个字节从高到低分别表示红、绿、蓝，剩余的1个字节数据无效。是最低字节还是最高字节无效，这时可以选择的。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/4.jpeg" alt="img not found"></li>
<li>64K（16BPP）色<br>64K（16BPP）色的显示模式就是使用16位的数据来表示一个像素的颜色。这16位数据的格式又分为两种：5：6：5、5：5：5：1，前者使用高5位来表示红色，中间的6位来表示绿色，低5位来表示蓝色；后者的高15位从高到低分成3个5位来表示红色、绿色、蓝色，最低位表示透明度。5：5：5：1的格式也被称为RGBA（A表示Alpha，指代透明度）。<br>一个4字节可以表示两个16BPP的像素，使用高2字节还是低2字节来表示第一个像素，这也是可以选择的。<br>显示模式为16BPP时，内存数据与像素位置的关系如图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/5.jpeg" alt="img not found"><br>在5：5：5：1的格式下，VD[18]、VD[10]、VD[2]数据线上的值是一样的，都表示透明度。图中的NC表示没有连接（not connect）。</li>
<li>256（8BPP）色<br>256（8BPP）色的显示模式就是使用8位的数据来表示一个像素的颜色，但是对三种原色平均下来，每个原色只能使用不到3位的数据来表示，即每个原色最多不过8个级别，这不足以表示更丰富的颜色。<br>为了解决8BPP模式显示能力太弱的问题，需要使用调色板。每个像素对应8位数据不再用来表示RGB三原色，而是表示它在调色板中的索引值；要显示这个像素时，使用这个索引值从调色板中取得其RGB颜色值。所谓调色板就是一块内存，可以对每个索引值设置其颜色，可以使用24BPP或16BPP。S3C2410&#x2F;S3C2440中，调色板是一块256x16的内存，使用16BPP的格式来表示256色（8BPP）显示模式下各个索引值的颜色。这样即使使用256色（8BPP）的显示模式，最终在LCD数据总线上的仍是16BPP的数据。<br>一个4字节可以表示4个8BPP的像素，字节与像素的对应顺序是可以选择的，如下图所示：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/6.jpeg" alt="img not found"><br>调色板中数据的存放格式与16BPP显示模式类似，也分为两种：5：6：5、5：5：5：1。调色板中数据的格式及与LCD数据线VD[23:0]的对应关系，如下表所示：</li>
</ol>
<p>5：6：5格式下调色板的数据格式</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>00H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D000400</td>
</tr>
<tr>
<td>01H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D000404</td>
</tr>
<tr>
<td>… …</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>… …</td>
</tr>
<tr>
<td>FFH</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G5</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>0X4D0007FC</td>
</tr>
<tr>
<td>VD引脚号</td>
<td>23</td>
<td>22</td>
<td>21</td>
<td>20</td>
<td>19</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>10</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td></td>
</tr>
</tbody></table>
<p>5：5：5：1格式下调色板的数据格式</p>
<table>
<thead>
<tr>
<th>序号</th>
<th>15</th>
<th>14</th>
<th>13</th>
<th>12</th>
<th>11</th>
<th>10</th>
<th>9</th>
<th>8</th>
<th>7</th>
<th>6</th>
<th>5</th>
<th>4</th>
<th>3</th>
<th>2</th>
<th>1</th>
<th>0</th>
<th>地址</th>
</tr>
</thead>
<tbody><tr>
<td>00H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D000400</td>
</tr>
<tr>
<td>01H</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D000404</td>
</tr>
<tr>
<td>… …</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td>… …</td>
</tr>
<tr>
<td>FFH</td>
<td>R4</td>
<td>R3</td>
<td>R2</td>
<td>R1</td>
<td>R0</td>
<td>G4</td>
<td>G3</td>
<td>G2</td>
<td>G1</td>
<td>G0</td>
<td>B4</td>
<td>B3</td>
<td>B2</td>
<td>B1</td>
<td>B0</td>
<td>–</td>
<td>0X4D0007FC</td>
</tr>
<tr>
<td>VD引脚号</td>
<td>23</td>
<td>22</td>
<td>21</td>
<td>20</td>
<td>19</td>
<td>15</td>
<td>14</td>
<td>13</td>
<td>12</td>
<td>11</td>
<td>7</td>
<td>6</td>
<td>5</td>
<td>4</td>
<td>3</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>注：</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>①0X4D000400是调色板的起始地址。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>②5：5：5：1格式下，VD18、VD10和VD2三个数据线中都是亮度值1，即最低位的值。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
<tr>
<td>③当LCDCCON5寄存器中的VSTATUS、HSTATUS有效时，不能读写调色板。</td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
<td></td>
</tr>
</tbody></table>
<p>各模式下用来传输红、绿、蓝三种原色的颜色值VD数据线如下表所示：</p>
<table>
<thead>
<tr>
<th>24BPP</th>
<th>16BPP&#x2F;8BPP 5：6：5格式</th>
<th>16BPP&#x2F;8BPP 5：5：5：1格式</th>
</tr>
</thead>
<tbody><tr>
<td>红色</td>
<td>VD[23:16]</td>
<td>VD[23:19]</td>
</tr>
<tr>
<td>绿色</td>
<td>VD[15:8]</td>
<td>VD[15:10]</td>
</tr>
<tr>
<td>蓝色</td>
<td>VD[7:0]</td>
<td>VD[7:3]</td>
</tr>
</tbody></table>
<p>没有用到的数据线其电平为0，从这个观点来看，无论是24BPP模式还是16BPP、8BPP模式，24根数据线VD[23:0]都被用到了。事实上，一个TFT LCD能处理的像素位宽是固定的，即它的数据线的数目是固定的。红、绿、蓝3类信号线总是连接到各字节中的高位；软件设置24BPP、16BPP、8BPP以及调色板等，只会影响到色值的精度。</p>
<h3 id="使用TFT-LCD时LCD控制器的寄存器设置"><a href="#使用TFT-LCD时LCD控制器的寄存器设置" class="headerlink" title="使用TFT LCD时LCD控制器的寄存器设置"></a>使用TFT LCD时LCD控制器的寄存器设置</h3><p>LCD控制器中REGBANK的17个寄存器可以分为6种，如下表所示：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDCON1-LCDCON5</td>
<td>用于选择LCD类型，设置各类控制信号的时间特性等</td>
</tr>
<tr>
<td>LCDSADDR1-LCDSADDR3</td>
<td>用于设置帧内存的地址</td>
</tr>
<tr>
<td>TPAL</td>
<td>临时调色板寄存器，可以快速的输出一帧单色的图像</td>
</tr>
<tr>
<td>LCDINTPND<br>LCDSRCPND<br>LCDINTMSK</td>
<td>用于LCD的中断，在一般应用中无需中断</td>
</tr>
<tr>
<td>REDLUT <br> GREENLUT <br> BLUELUT <br> DITHMODE</td>
<td>专用于STNLCD</td>
</tr>
<tr>
<td>TCONSEL</td>
<td>专用于SEC TFT LCD</td>
</tr>
</tbody></table>
<p>对于TFT LCD，一般情况下只需要设置前两种寄存器；在8BPP模式下，如果想快速的输出一帧单色图，可以借助TPAL寄存器。</p>
<ol>
<li><p>LCD控制寄存器LCDCON1<br>用于选择LCD类型、设置像素时钟、使能LCD信号的输出等，格式如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LINECNT</td>
<td>[27:18]</td>
<td>只读，每输出一个有效行其值减一，从LINEVAL减到0</td>
</tr>
<tr>
<td>CLKVAL</td>
<td>[17:8]</td>
<td>用于设置VCLK（时钟）<br> 对于TFT LCD，VCLK &#x3D; HCLK &#x2F; [(CLKVAL + 1) x 2](CLKVAL &gt;&#x3D; 0)</td>
</tr>
<tr>
<td>MMODE</td>
<td>[7]</td>
<td>设置VM信号的反转效率，用于STN LCD</td>
</tr>
<tr>
<td>PNRMODE</td>
<td>[6:5]</td>
<td>设置LCD的类型，对于TFT LCD 设为0b11</td>
</tr>
<tr>
<td>BPPMODE</td>
<td>[4:1]</td>
<td>设置BPP，对于TFT LCD：<br>0b1000 &#x3D; 1bpp <br> 0b1001 &#x3D; 2bpp <br> 0b1010 &#x3D; 4bpp <br> 0b1011 &#x3D; 8bpp <br> 0b1100 &#x3D; 16bpp <br> 0b1101 &#x3D; 24bpp</td>
</tr>
<tr>
<td>ENVID</td>
<td>[0]</td>
<td>LCD信号输出使能位，0：禁止，1：使能</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制寄存器LCDCON2<br>用于设置垂直方向各信号的时间参数，格式如下表：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VBPD</td>
<td>[31:24]</td>
<td>VSYNC信号脉冲之后，还要经过（VBPD + 1）个HSYNC信号周期，有效的行数据才出现</td>
</tr>
<tr>
<td>LINEVAL</td>
<td>[23:14]</td>
<td>LCD的垂直宽度：（LINEVAL + 1）行</td>
</tr>
<tr>
<td>VFPD</td>
<td>[13:6]</td>
<td>一帧中的有效行数据完结后，到下一个VSYNC信号有效前的无效行数目：VFPD + 1</td>
</tr>
<tr>
<td>VSPW</td>
<td>[5:0]</td>
<td>表示VSYNC信号的脉冲宽度为（VSPW + 1）个HSYNC信号周期，即（VSPW + 1）行，这（VSPW + 1）行的数据无效</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制器LCDCON3<br>用于设置水平方向信号的时间参数，格式如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>HBPD</td>
<td>[25:19]</td>
<td>HSYNC信号脉冲之后，还要经过（HBPD + 1）个VCLK信号周期，有效的行数据才出现</td>
</tr>
<tr>
<td>HOZVAL</td>
<td>[18:8]</td>
<td>LCD的水平宽度：（HOZVAL + 1）列（像素点）</td>
</tr>
<tr>
<td>HFPD</td>
<td>[7:0]</td>
<td>一行中的有效数据完结后，到下一个HSYNC信号有效前的无效像素数目：HFPD + 1</td>
</tr>
</tbody></table>
</li>
<li><p>LCD控制寄存器LCDCON4<br>对于TFT LCD，这个寄存器只用来设置HSYNC信号的脉冲宽度，位[7:0]的数值称为HSPW，表示脉冲宽度为（HSPW + 1）个VCLK周期。</p>
</li>
<li><p>LCD控制寄存器LCDCON5<br>用于设置各个控制信号的极性，并可以从中读到一些状态信息。如下表所示：</p>
<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>VSTATUS</td>
<td>[16:15]</td>
<td>只读，垂直状态。<br> 00:正处于VSYNC信号脉冲期间 <br> 01:正处于VSYNC信号结束到行有效期间 <br>10:正处于行有效期间 <br>11:正处于行有效结束到下一个VSYNC之间</td>
</tr>
<tr>
<td>HSTATUS</td>
<td>[14:13]</td>
<td>只读，水平状态。<br> 00:正处于HSYNC信号脉冲期间 <br> 01:正处于HSYNC信号结束到像素有效期间 <br>10:正处于像素有效期间 <br>11:正处于像素有效结束到下一个HSYNC之间</td>
</tr>
<tr>
<td>BPP24BL</td>
<td>[12]</td>
<td>设置TFT LCD的显示模式为24BPP时，一个4字节中哪3个字节有效。<br> 0:LSB有效（低地址的3字节）；1：MSB（高地址的3字节）；</td>
</tr>
<tr>
<td>FRM565</td>
<td>[11]</td>
<td>设置TFT LCD的显示模式为16BPP时，使用的数据格式。<br> 0表示5：5：5：1格式；1表示5：6：5 格式</td>
</tr>
<tr>
<td>INVVCLK</td>
<td>[10]</td>
<td>设置VCLK信号有效沿的极性。 <br> 0：在VCLK的下降沿读取数据；1：在VCLK的上升沿读取数据。</td>
</tr>
<tr>
<td>INVVLINE</td>
<td>[9]</td>
<td>设置VLINE&#x2F;HSYNC脉冲的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVFRAME</td>
<td>[8]</td>
<td>设置VFRAME&#x2F;VSYNC脉冲的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVD</td>
<td>[7]</td>
<td>设置VD数据线表示数据（0&#x2F;1）的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVVDEN</td>
<td>[6]</td>
<td>设置VDEN信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVPWREN</td>
<td>[5]</td>
<td>设置PWREN信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>INVLEND</td>
<td>[4]</td>
<td>设置LEND信号的极性。<br> 0：正常的极性；1：反转的极性</td>
</tr>
<tr>
<td>PWREN</td>
<td>[3]</td>
<td>LCD_PWREN信号输出使能。<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>ENLEND</td>
<td>[2]</td>
<td>LEND信号输出使能。<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>BSWP</td>
<td>[1]</td>
<td>字节交换使能<br> 0：禁止；1：输出</td>
</tr>
<tr>
<td>HWSWP</td>
<td>[1]</td>
<td>半字（2字节）交换使能<br> 0：禁止；1：输出</td>
</tr>
</tbody></table>
</li>
<li><p>帧内存地址寄存器LCDSADDR1-LCDSADDR3<br>帧内存可以很大，而真正要显示的区域被称为视口（view point），它处于帧内存之内。这3个寄存器用于确定帧内存的起始地址，定位视口在帧内存的位置。下图给出了帧内存和视口之间的关系：<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/7.jpeg" alt="img not found"><br>各寄存器格式如下表所示：</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>LCDSADDR1 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDBANK</td>
<td>[29:21]</td>
<td>用来保存帧内存起始地址A[30:22]，帧内存起始地址为4MB对齐。</td>
</tr>
<tr>
<td>LCDBASEU</td>
<td>[20:0]</td>
<td>对于TFT LCD，用来保存视口（view point），所对应的内存起始地址A[21:1]，这块内存地址也称为LCD的帧缓冲区（frame buffer）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>LCDSADDR2 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>LCDBASEL</td>
<td>[20:0]</td>
<td>对于TFT LCD，用来保存LCD的帧缓冲区结束地址A[21:1]，其值可如下计算：LCDBASEL &#x3D; LCDBASEU + （PAGEWIDTH + OFFSICE）x （LINEVAL + 1）</td>
</tr>
</tbody></table>
<p>注：可以修改LCDBASEU、LCDBASEL的值来实现图像的移动，不过不能在一帧图像的结束阶段（LCDCON1寄存器的LINECNT为0时）进行修改，因为此时LCD控制器会优先取得下一帧的数据，之后才会改变这些值，这样的话，这些数据就与新的帧缓冲区不一致。</p>
<table>
<thead>
<tr>
<th>LCDSADDR3 功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>OFFSIZE</td>
<td>[21:11]</td>
<td>表示上一行最后一个数据与下一行第一个数据间地址差值的一半，即以半字为单位的地址差（0表示两行数据是紧接着的，1表示它们之间相差2个字节，依次类推）</td>
</tr>
<tr>
<td>PAGEWIDTH</td>
<td>[10:0]</td>
<td>视口的宽带，以半字为单位</td>
</tr>
</tbody></table>
<p>注：OFFSIZE、PAGEWIDTH的值只能在ENVID（LCDCON1寄存器的信号输出使能）为0时修改。</p>
<ol start="7">
<li>临时调色板寄存器TPAL<br>如果要输出一帧单色的图像，可以在TPAL寄存器中设定这个颜色值，然后使能TPAL寄存器，这种方法可以避免修改整个调色板或帧缓冲区。TPAL寄存器格式如下表所示：<table>
<thead>
<tr>
<th>功能</th>
<th>位</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>TPALEN</td>
<td>[24]</td>
<td>调色板寄存器使能位。<br> 0：禁止 1：使能</td>
</tr>
<tr>
<td>TPALVAL</td>
<td>[23:0]</td>
<td>颜色值。 <br> TPALVAL[23:16]：红色 <br> TPALVAL[15:8]：绿色 <br> TPALVAL[7:0]：蓝色</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：临时调色板寄存器TPAL可以用在任何显示模式下，并非只能用在8BPP模式下。</p>
<h1 id="TFT-LCD显示实例"><a href="#TFT-LCD显示实例" class="headerlink" title="TFT LCD显示实例"></a>TFT LCD显示实例</h1><h2 id="程序设计"><a href="#程序设计" class="headerlink" title="程序设计"></a>程序设计</h2><p>本实例的目的是从串口输出一个菜单，从中选择各种方法进行测试，比如画线、画圆、显示单色、使用调色板等。</p>
<h2 id="代码设计"><a href="#代码设计" class="headerlink" title="代码设计"></a>代码设计</h2><p>与LCD相关的文件有3个：lcddrv.c、framebuffer.c和lcdlib.c（及相应的头文件）。<br><img src="/2022/08/27/LCD%E6%8E%A7%E5%88%B6%E5%99%A8/8.jpeg" alt="img not found"></p>
<ol>
<li>lcddrv.c封装了对LCD控制器、调色板的访问函数，可以设置LCD的显示模式、开启&#x2F;关闭LCD、设置调色板等。</li>
<li>framebuffer.c直接操作帧缓冲区（frame buffer），实现了画点、画线、画圆、清屏等操作。</li>
<li>lcdlib.c调用前两个文件提供的函数在LCD上进行各种操作。</li>
</ol>
<h3 id="main-c"><a href="#main-c" class="headerlink" title="main.c"></a>main.c</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span>(getc())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;1&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_8Bit_240320();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;2&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_16Bit_240320();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;3&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_8Bit_640480();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;4&#x27;</span>:</span><br><span class="line">    &#123;</span><br><span class="line">        Test_Lcd_Tft_16Bit_640480();</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它根据串口的输入选择是以”240x320、8bpp“、”240x320、16bpp“、”640x480、8bpp“或”640x480、16bpp“的显示模式来操作LCD，所调用的4个函数都在lcdlib.c中实现。</p>
<h3 id="lcdlib-c"><a href="#lcdlib-c" class="headerlink" title="lcdlib.c"></a>lcdlib.c</h3><p>8BPP模式将用到调色板，其操作比16BPP模式稍为复杂，但是大部分仍是相似的。下面以<code>Test_Lcd_Tft_8Bit_240320()</code>为例进行说明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">以240x320、8bpp的显示模式测试TFT LCD</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Test_Lcd_Tft_8Bit_240320</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    Lcd_Port_Init();                        <span class="comment">//设置LCD引脚</span></span><br><span class="line">    Tft_Lcd_Init(MODE_TFT_8BIT_240320);     <span class="comment">//初始化LCD控制器</span></span><br><span class="line">    Lcd_PowerEnable(<span class="number">0</span>,<span class="number">1</span>);                   <span class="comment">//设置LCD_PWREN有效，它用于打开LCD的电源</span></span><br><span class="line">    Lcd_EnvidOnOff(<span class="number">1</span>);                      <span class="comment">//使能LCD控制器输出信号</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6行所涉及的GPIO引脚用于LCD功能。<br>第7行调用Tft_Lcd_Init函数初始化LCD控制器，即设置各个控制信号的时间特性、设置LCD的显示模式、设置帧缓冲区的地址等，它是lcddrv.c中最复杂的函数，在后面会详细分析这个函数。<br>进行第6、7行的初始化之后，只要打开LCD，帧缓冲区中的数据就会被LCD控制器自动地发送到LCD上去显示。打开操作由8、9行来完成。<br>第8行发出LCD_PWREN信号。对于有电源开关控制引脚的LCD，可以使用LCD_PWREN来打开或关闭LCD。LCD_PWREN信号的极性可以设置。<br>第9行使能LCD控制器输出信号，这时，帧缓冲区中的数据就开始在LCD上显示出来了。<br>接下来就是按照设定的流程进行各类操作了，比如画线、清屏等，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Lcd_Palette8Bit_Init();                     <span class="comment">//初始化调色板</span></span><br><span class="line">ClearScr(<span class="number">0x0</span>);                              <span class="comment">//清屏</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">0</span>,<span class="number">0</span>);                     <span class="comment">//颜色为DEMO256pal[0]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">10</span>,<span class="number">1</span>);                    <span class="comment">//颜色为DEMO256pal[1]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">20</span>,<span class="number">2</span>);                    <span class="comment">//颜色为DEMO256pal[2]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">40</span>,<span class="number">4</span>);                    <span class="comment">//颜色为DEMO256pal[4]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">80</span>,<span class="number">8</span>);                    <span class="comment">//颜色为DEMO256pal[8]</span></span><br><span class="line">Draw_Line(<span class="number">0</span>,<span class="number">0</span>,<span class="number">100</span>,<span class="number">160</span>,<span class="number">16</span>);                  <span class="comment">//颜色为DEMO256pal[16]</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Mire();                                     <span class="comment">//画圆</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">ClearScr(<span class="number">128</span>);                              <span class="comment">//输出单色图像，颜色为DEMO256pal[128]</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">ClearScrWithTmpPlt(<span class="number">0x0000ff</span>);               <span class="comment">//输出单色图像，颜色为蓝色</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">DisableTmpPlt();                            <span class="comment">//关闭临时调色板寄存器</span></span><br><span class="line">ChangePalette(<span class="number">0xffff00</span>);                    <span class="comment">//改变整个调色板为黄色，输出单色图像</span></span><br><span class="line"></span><br><span class="line">getc();</span><br><span class="line">Lcd_EnvidOnOff(<span class="number">0</span>);                          <span class="comment">//停止</span></span><br></pre></td></tr></table></figure>
<p>上述函数分3类：</p>
<ol>
<li>清屏函数ClearScr、画线函数DrawLine，都是通过framebuffer.c中的PutPixel函数来设置帧缓冲区中的数据，以像素为单位修改颜色来实现的。</li>
<li>Lcd_Palette8Bit_Init函数设置调色板，ChangePalette函数通过设置调色板来实现清屏功能，不涉及帧缓冲区，它在lcddrv.c中实现。</li>
<li>ClearScrWithTmpPlt函数则是通过临时调色板寄存器来快速的输出单色的图像，也不涉及帧缓冲区，它在lcddrv.c中实现。<br>lcddrv.c、framebuffer.c文件中的各个函数才是本实例的关键。可以认为lcddrv.c是对操作各寄存器的封装，framebuffer.c则是对操作图像数据的封装。先看lcddrv.c文件。</li>
</ol>
<h3 id="lcddrv-c"><a href="#lcddrv-c" class="headerlink" title="lcddrv.c"></a>lcddrv.c</h3><p>这个文件的重点在于Tft_Lcd_Init、Lcd_Palette8Bit_Init。</p>
<ol>
<li><p>Lcd_Port_Init函数<br>设置所涉及的GPIO引脚用于LCD功能。GPIO功能的设置对读者来说已经很熟悉了，不再赘述。</p>
</li>
<li><p>Tft_Lcd_Init函数<br>用于初始化LCD控制器，即设置各个控制信号的时间特性、设置LCD的显示模式、设置帧缓冲区的地址等。<br>首先是对5个控制寄存器LCDCON1-LCDCON5的设置，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">初始化LCD控制器</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">type：显示模式</span></span><br><span class="line"><span class="comment">    MODE_TFT_8BIT_240320 : 240*320 8bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_16BIT_240320 : 240*320 16bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_8BIT_640480 : 640*480 8bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">    MODE_TFT_16BIT_640480 : 640*480 16bpp 的TFT LCD</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Tft_Lcd_Init</span><span class="params">(<span class="type">int</span> type)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">switch</span>(type)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> MODE_TFT_8BIT_240320:</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置LCD控制器的控制寄存器LCDCON1-LCDCON5</span></span><br><span class="line"><span class="comment">        1. LCDCON1</span></span><br><span class="line"><span class="comment">            设置VCLK的频率：VCLK（Hz）= HCLK/[(CLKVAL+1)x2]</span></span><br><span class="line"><span class="comment">            选择LCD类型：TFT LCD</span></span><br><span class="line"><span class="comment">            设置显示模式：8BPP</span></span><br><span class="line"><span class="comment">            先禁止LCD信号输出</span></span><br><span class="line"><span class="comment">        2. LCDCON2/3/4</span></span><br><span class="line"><span class="comment">            设置控制信号的时间参数</span></span><br><span class="line"><span class="comment">            设置分辨率，即行数及列数</span></span><br><span class="line"><span class="comment">        现在，可以根据公式计算出显示器的频率</span></span><br><span class="line"><span class="comment">        当HCLK = 100MHz时，</span></span><br><span class="line"><span class="comment">        Frame Rate = 1/[&#123;(VSPW+1)+(VBPD+1)+(LINEVAL+1)+(VFPD+1)&#125; x &#123; (HSPW+1)+(HBPD+1)+(HFPD+1)+(HOZVAL+1) &#125; x &#123; 2 x ( CLKVAL+1) / (HCLK)&#125;] = 60Hz</span></span><br><span class="line"><span class="comment">        3. LCDCON5</span></span><br><span class="line"><span class="comment">            设置显示模式为8BPP时，调色板中的数据格式为5：6：5</span></span><br><span class="line"><span class="comment">            设置HSYNC、VSYNC脉冲的极性：反转字节交换使能</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        LCDCON1 = (CLKVAL_TFT_240320 &lt;&lt; <span class="number">8</span>) | (LCDTYPE_TFT &lt;&lt; <span class="number">5</span>) | (BPPMODE_8BPP &lt;&lt; <span class="number">1</span>) | (ENVID_DISABLE &lt;&lt; <span class="number">0</span>);</span><br><span class="line">        LCDCON2 = (VBPD_240320 &lt;&lt; <span class="number">24</span>) | (LINEVAL_TFT_240320 &lt;&lt; <span class="number">14</span>) | (VFPD_240320 &lt;&lt; <span class="number">6</span>) | (VSPW_240320);</span><br><span class="line">        LCDCON3 = (HBPD_240320 &lt;&lt; <span class="number">19</span>) | (HOZVAL_TFT_240320 &lt;&lt; <span class="number">8</span>) | (HFPD_240320);</span><br><span class="line">        LCDCON4 = (HSPW_240320);</span><br><span class="line">        LCDCON5 = (FORMAT8BPP_565 &lt;&lt; <span class="number">11</span>) | (HSYNC_INV &lt;&lt; <span class="number">9</span>) | (VSYNC_INV &lt;&lt; <span class="number">8</span>) | (BSWP &lt;&lt; <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码中的注释可以帮助读者理解这些代码，比较困难的是时间参数VSPW、VBPD、VFPD、HSPW、HBPD、HFPD、CLKVAL的设置。对于CRT显示器，当它的频率在60Hz时，人眼会感到明显的闪烁；而对于LCD，在60Hz时显示效果就很好。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Frame Rate = <span class="number">1</span>/[&#123;(VSPW+<span class="number">1</span>)+(VBPD+<span class="number">1</span>)+(LINEVAL+<span class="number">1</span>)+(VFPD+<span class="number">1</span>)&#125; x &#123; (HSPW+<span class="number">1</span>)+(HBPD+<span class="number">1</span>)+(HFPD+<span class="number">1</span>)+(HOZVAL+<span class="number">1</span>) &#125; x &#123; <span class="number">2</span> x ( CLKVAL+<span class="number">1</span>) / (HCLK)&#125;];</span><br></pre></td></tr></table></figure>
<p>接下来是对地址寄存器LCDSADDR1-LCDSADDR3的设置。本程序中，帧内存与视图吻合，即图中的OFFSIZE为0，LCDBANK、LCDBASEU指向同一个地址（同一地址的不同位）。<br>需要注意的是，8BPP的显示模式要用到调色板，帧缓冲区中的数据不是像素的颜色值，而是调色板中的索引值，真正的颜色值在调色板中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置LCD控制器的地址寄存器LCDSADDR1-LCDSADDR3</span></span><br><span class="line"><span class="comment">帧内存与视口（view point）完全吻合，</span></span><br><span class="line"><span class="comment">图像数据格式如下（8BPP时，帧缓存区中的数据为调色板中的索引值）：</span></span><br><span class="line"><span class="comment">            |----width----|</span></span><br><span class="line"><span class="comment">        y/x 0   1    2   239</span></span><br><span class="line"><span class="comment">         0  idx idx  idx idx</span></span><br><span class="line"><span class="comment">         1  idx idx  idx idx</span></span><br><span class="line"><span class="comment">1. LCDSADDR1</span></span><br><span class="line"><span class="comment">    设置LCDBANK、LCDBASEU</span></span><br><span class="line"><span class="comment">2. LCDSADDR2</span></span><br><span class="line"><span class="comment">    设置LCDBASEL：帧缓冲区的结束地址A[21:1]</span></span><br><span class="line"><span class="comment">3. LCDSADDR3</span></span><br><span class="line"><span class="comment">    OFFSIZE等于0，PAGEWIDTH等于（240/2）</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">LCDSADDR1 = ((LCDFRAMEBUFFER &gt;&gt; <span class="number">22</span>) &lt;&lt; <span class="number">21</span>) | LOWER21BITS(LCDFRAMEBUFFER &gt;&gt; <span class="number">1</span>);</span><br><span class="line">LCDSADDR2 = LOWER21BITS((LCDFRAMEBUFFER + (LINEVAL_TFT_240320 + <span class="number">1</span>) x (HOZVAL_TFT_240320+<span class="number">1</span>) x1) &gt;&gt; <span class="number">1</span>);</span><br><span class="line">LCDSADDR3 = (<span class="number">0</span> &lt;&lt;<span class="number">11</span> ) | (LCD_XSIZE_TFT_240320/<span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>第16行将帧缓冲区的起始地址写入LCDSADDR1寄存器。<br>第17行先计算帧缓冲区的结束地址，再取其位[21:1]存入LCDSADDR2中。这个地址值在本实例中即是“LCDFRAMEBUFFER + 320 x 240 x 1”,其中的“x1”表示在8BPP中一个像素使用1个字节来表示（对于16BPP，则是“x2”）。<br>在设置寄存器的最后，禁止临时调色板寄存器，现在还没有用到它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*禁止临时调色板寄存器*/</span></span><br><span class="line">TPAL = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>
<p>最后，将显示模式的主要参数记录下来，在framebuffer.c中需要用到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">fb_base_addr = LCDFRAMEBUFFER;</span><br><span class="line">bpp = <span class="number">8</span>;</span><br><span class="line">xsize = <span class="number">240</span>;</span><br><span class="line">ysize = <span class="number">320</span>;</span><br></pre></td></tr></table></figure>
<p>需要说明的是，显示模式为8BPP时，LCDCON5中BSWAP位设为1，表示“字节交换使能”，这时帧缓存区中的数据与屏幕上的像素位置关系如上图13.6所示；显示模式为16BPP时，LCDCON5中HWSWAP位设为1，表示“半字交换使能”，这时帧缓冲区的数据与屏幕上的像素位置关系如图13.5所示。他们都是“低地址的数据”对应“位置靠前”的像素。</p>
</li>
<li><p>Lcd_Palette8Bit_Init函数<br>设置调色板中的数据：调试板大小为256x16，而8BPP模式中每个像素的索引值占据8位，刚好有256个索引值。代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置调色板</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_Palette8Bit_Init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *palette;</span><br><span class="line"></span><br><span class="line">    LCDCON5 |= (FORMAT8BPP_565 &lt;&lt; <span class="number">11</span>);              <span class="comment">//设置调色板中数据格式为5：6：5</span></span><br><span class="line"></span><br><span class="line">    palette = (<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)PALETTE;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">        *palette++ = DEMO256pal[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调色板中用16BPP的格式来表示颜色，第9行设置调色板中数据的格式为5：6：5。<br>第12、13行将数组DEMO256pal中的数据写入调色板中。</p>
</li>
<li><p>ChangePalette函数<br>以给定的颜色填充整个调色板。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">改变调色板为一种颜色</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    color：颜色值，格式为0xRRGGBB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">ChangePalette</span><span class="params">(UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">char</span> red,green,blue;</span><br><span class="line">    UNT32 *palette;</span><br><span class="line"></span><br><span class="line">    palette = (UINT32 *)PALETTE;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">256</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        red = (color &gt;&gt; <span class="number">19</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        green = (color &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">        blue = (color &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">        color = (red &lt;&lt; <span class="number">11</span>) | (greee &lt;&lt; <span class="number">5</span>) | (blue);                <span class="comment">//格式5：6：5</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>((LCDCON5 &gt;&gt; <span class="number">16</span>) == <span class="number">2</span>);                                <span class="comment">//等待直到VSTATUS不为“有效”</span></span><br><span class="line">        *palette++ = color;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第15-19行从0xRRGGBB格式的变量中，提取8位红色值的高5位，8位绿色值的高6位，8位蓝色值的高5位组成5：6：5格式的16BPP颜色值。<br>第21行检测当前VSYNC信号的状态，如果它处于有效的状态，则等待。前面说过，读写调色板时，VSTATUS、HSTATUS不能处于有效状态。这里当VSTATUS不是“有效”状态时，HSTATUS也不能是“有效”状态。<br>第22行将新数据写入调色板。</p>
</li>
<li><p>Lcd_PowerEnable函数<br>用于是否控制发出LCD_PWREN信号。对于有电源开关控制引脚的LCD，可以使用LCD_PWREN来打开或关闭LCD。LCD_PWREN信号的极性可以设置。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置是否输出LCD电源开关信号LCD_PWREN</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    invpwren：</span></span><br><span class="line"><span class="comment">        0表示LCD_PWREN有效时为正常极性</span></span><br><span class="line"><span class="comment">        1表示LCD_PWREN有效时为反转极性</span></span><br><span class="line"><span class="comment">    pwren：</span></span><br><span class="line"><span class="comment">        0表示LCD_PWREN输出有效</span></span><br><span class="line"><span class="comment">        1表示LCD_PWREN输出无效</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_PowerEnable</span><span class="params">(<span class="type">int</span> invpwren,<span class="type">int</span> pwren)</span></span><br><span class="line">&#123;</span><br><span class="line">    GPGCON = (GPGCON &amp; (~ (<span class="number">3</span> &lt;&lt; <span class="number">8</span>))) | (<span class="number">3</span> &lt;&lt; <span class="number">8</span>);                <span class="comment">//GPG4用作LCD_PWREN</span></span><br><span class="line">    GPGUP = (GPGUP &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">4</span>))) | (<span class="number">1</span> &lt;&lt; <span class="number">4</span>);                  <span class="comment">//禁止内部上拉</span></span><br><span class="line"></span><br><span class="line">    LCDCON5 = (LCDCON5 &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">5</span>))) | (invpwrwen &lt;&lt; <span class="number">5</span>);      <span class="comment">//设置LCD_PWREN的极性：正常/反转</span></span><br><span class="line">    LCDCON5 = (LCDCON5 &amp; (~ (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))) | (pwren &lt;&lt; <span class="number">3</span>);          <span class="comment">//设置是否输出LCD_PWREN</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>Lcd_EnvidOnOff函数<br>用于控制是否使能LCD控制器输出各个LCD信号，当设置如控制寄存器、地址寄存器之后，即可调用此函数输出各个LCD信号，这样，帧缓冲区中的数据即发送给LCD。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">设置LCD控制器是否输出信号</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">onoff：</span></span><br><span class="line"><span class="comment">    0：关闭</span></span><br><span class="line"><span class="comment">    1：打开</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">Lcd_EnvidOnOff</span><span class="params">(<span class="type">int</span> onoff)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(onoff == <span class="number">1</span>)</span><br><span class="line">        LCDCON1 |= <span class="number">1</span>;           <span class="comment">//ENVID ON</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        LCDCON1 &amp;= <span class="number">0x3fffe</span>;     <span class="comment">//ENVID OFF</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>ClearScrWithTmpPlt、DisableTmpPlt函数<br>ClearScrWithTmpPlt函数设置颜色值并使能TPAL寄存器，这使得LCD上显示单一颜色的图像。DisableTmpPlt函数停止TPAL寄存器的功能，继续输出帧缓存区的图像。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">使用临时调色板寄存器输出单色图像</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    color：颜色值，格式为0xRRGGBB</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">ClearScrWithTmpPlt</span><span class="params">(UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    TPAL = (<span class="number">1</span> &lt;&lt; <span class="number">24</span>) | ((color &amp; <span class="number">0xffffff</span>) &lt;&lt; <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">停止使用临时调色板寄存器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DisableTmpPlt</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    TPAL = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="framebuffer-c"><a href="#framebuffer-c" class="headerlink" title="framebuffer.c"></a>framebuffer.c</h3><p>此文件中有4个函数：画点函数PutPixel、画线函数DrawLine、绘制同心圆函数Mire、清屏函数ClearScr。后3个函数都是基于PutPixel函数实现的。PutPixel函数是framebuffer.c的核心，它在缓冲区中找到给定坐标的像素的内存，然后修改它的值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> fb_base_addr;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> bpp;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> xsize;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">int</span> ysize;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">画点</span></span><br><span class="line"><span class="comment">输入参数：</span></span><br><span class="line"><span class="comment">    x,y：像素坐标</span></span><br><span class="line"><span class="comment">    color：颜色值</span></span><br><span class="line"><span class="comment">    对于16BPP：color的格式为0xAARRGGBB  AA是透明度，0-256，需要转换为5:6:5格式</span></span><br><span class="line"><span class="comment">    对于8BPP：color为调色板的索引值，颜色取决于调色板中的数值</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">PutPixel</span><span class="params">(UINT32 x,UINT32 y,UINT32 color)</span></span><br><span class="line">&#123;</span><br><span class="line">    UINT8 red,green,blue;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(bpp)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">16</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            UINT16 *addr = (UINT16 *)fb_base_addr + (y * xsize + x);</span><br><span class="line">            red = (color &gt;&gt; <span class="number">19</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            green = (color &gt;&gt; <span class="number">10</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line">            blue = (color &gt;&gt; <span class="number">3</span>) &amp; <span class="number">0xff</span>;</span><br><span class="line"></span><br><span class="line">            color = (red &lt;&lt; <span class="number">11</span>) | (greee &lt;&lt; <span class="number">5</span>) | (blue);                <span class="comment">//格式5：6：5</span></span><br><span class="line">            *addr = (UINT16) color;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">        &#123;</span><br><span class="line">            UINT8 *addr = (UINT8 *)fb_base_addr + (y * xsize + x);</span><br><span class="line">            *addr = (UINT8) color</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第1-4行的4个变量在lcddrv.c中的Tft_Lcd_Init函数中设置，PutPixel函数根据它们来确定给定坐标的像素在缓冲区中的地址。<br>第22、34行分别计算16BPP、8BPP模式下给定坐标的像素在帧缓冲中的地址。对于16BPP模式，每个像素占据2字节；对于8BPP模式，每个像素占据1字节。<br>对于16BPP的显示模式，第22-25行从0xAARRGGBB中提取8位红色值的高5位，8位绿色值的高6位，8位蓝色值的高5位组成5：6：5格式的16BPP颜色值。<br>最后，第28、35行将颜色值（8BPP模式下为调色板索引值）写入帧缓冲区中，这样下一次显示的时候，新颜色就可以显示出来了。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第2篇第13章 LCD控制器</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>LCD</tag>
      </tags>
  </entry>
  <entry>
    <title>构建Linux根文件系统</title>
    <url>/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统移植之构建Linux根文件系统</p>
<p>《嵌入式Linux应用完全开发手册》第3篇第17章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解Linux的文件系统层次标准（FHS）</li>
<li>了解根文件系统下各目录的作用</li>
<li>掌握构建根文件系统的的方法：移植Busybox、构造各个目录、文件等</li>
<li>掌握制作yaffs、jffs2文件系统映像的方法</li>
</ol>
<h1 id="Linux文件系统概述"><a href="#Linux文件系统概述" class="headerlink" title="Linux文件系统概述"></a>Linux文件系统概述</h1><h2 id="Linux文件系统的特点"><a href="#Linux文件系统的特点" class="headerlink" title="Linux文件系统的特点"></a>Linux文件系统的特点</h2><p>类似于Windows下的C、D、E等各个盘，Linux系统也可以将磁盘、Flash等存储设备划分为若干个分区，在不同分区存放不同类别的文件。与Windows的C盘类似，Linux一样要在一个分区上系统启动必须的文件，比如内核映像文件（在嵌入式系统中，内核一般单独存放在一个分区中）、内核启动后运行的第一个程序（init）、给用户提供操作界面的shell程序、应用程序所依赖的库等。这些必需、基本的文件合称为根文件系统。它们存放在一个分区中。Linux系统启动后首先挂载这个分区，称为挂载根文件系统。其他分区上所有目录、文件的集合，也称为文件系统。<br>Linux中没有C、D、E盘符的概念，它以树状结构管理所有目录，文件。其他分区挂载在某个目录上，这个命令称为挂载点，然后就可以通过访问这个目录来访问这个分区上的文件了。比如<code>根文件系统挂载在“/”</code>上之后，根目录下就有根文件系统的各个目录、文件：&#x2F;bin、&#x2F;sbin、&#x2F;mnt等；再将其他分区挂接到&#x2F;mnt目录上，&#x2F;mnt下目录下就有这个分区的目录、文件了。<br>在一个分区下存储文件时，需要遵循一定的格式，这种格式称为文件系统类型，比如<code>fat16</code>、<code>fat32</code>、<code>ntfs</code>、<code>ext2</code>、<code>ext3</code>、<code>jffs2</code>、<code>yaffs</code>等。除这些拥有实实在在的存储分区的文件系统类型外，Linux还有几种虚拟的文件系统类型，比如<code>proc</code>、<code>sysfs</code>等，它们的文件并不存储在实际的设备上，而是在访问它们时由内核临时生成。比如<code>proc</code>文件系统下的uptime文件，读取它时可以得到两个时间值（用来表示系统启动后运行的秒数、空闲的秒数），每次读取时都由内核即刻生成，每次读取结果都不一样。</p>
<h2 id="Linux根文件系统目录结构"><a href="#Linux根文件系统目录结构" class="headerlink" title="Linux根文件系统目录结构"></a>Linux根文件系统目录结构</h2><p><img src="/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/1.jpeg" alt="img not found"></p>
<h3 id="x2F-bin-目录"><a href="#x2F-bin-目录" class="headerlink" title="&#x2F;bin 目录"></a>&#x2F;bin 目录</h3><p>该目录下存放所有用户都可以使用的、基本的命令，这些命令在挂接其他文件系统之前就可以使用，所以&#x2F;bin目录必须和根文件系统在同一个分区中。<br>&#x2F;bin目录下常用的命令有：cat、chgrp、chmod、cp、ls、sh、kill、mount、umount、mkdir、mknod、[、test等。“[”命令就是test命令，在脚本文件中“[ expr ]”等价于“test expr”。</p>
<h3 id="x2F-sbin目录"><a href="#x2F-sbin目录" class="headerlink" title="&#x2F;sbin目录"></a>&#x2F;sbin目录</h3><p>该目录下存放系统目录，即只有管理员能够使用的命令，系统命令话可以存放在&#x2F;usr&#x2F;sbin、&#x2F;usr&#x2F;local&#x2F;sbin目录下。&#x2F;sbin目录中存放的是基本的系统命令，它们用于启动系统、修复系统等。与&#x2F;bin目录相似，在挂载其他文件系统之前就可以使用&#x2F;sbin，所以&#x2F;sbin目录必须和根文件系统在同一个分区中。<br>&#x2F;sbin下常用的命令有：shutdown、reboot、fdisk、fsck等。<br>不是急迫需要使用的系统命令存放在&#x2F;usr&#x2F;sbin目录下。本地安装的系统命令存放在&#x2F;usr&#x2F;local&#x2F;sbin目录下。</p>
<h3 id="x2F-dev目录"><a href="#x2F-dev目录" class="headerlink" title="&#x2F;dev目录"></a>&#x2F;dev目录</h3><p>该目录下存放的是设备文件。设备文件是Linux中特有的文件类型，在Linux系统下，以文件的方式访问各种外设，即通过读写某个设备文件操作某个具体硬件。比如通过“&#x2F;dev&#x2F;ttySAC0”文件可以操作串口0，通过“&#x2F;dev&#x2F;mtdblcok1”可以访问MTD设备（NAND Flash、NOR Flash等）的第2个分区。<br>设备文件有两种：字符设备和块设备。在PC上执行命令“ls &#x2F;dev&#x2F;ttySAC0 &#x2F;dev&#x2F;hda1 -l”可以看到如下结果：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">brwxrwxr-x  1   root    49      3,  1   Oct 9   2005 /dev/hda1</span><br><span class="line">crwxrwxr-x  1   root    root    4,  64  Sep 24  2007 /dev/ttySAC0</span><br></pre></td></tr></table></figure>
<p>其中字母“b”、“c”表示这是一个块设备文件或字符设备文件；“3，1”、“4，64”表示设备文件的主、次设备号；主设备号用来表示这是哪类设备，次设备号用来表示这是这类设备中的哪个。<br>设备文件可以使用mknod命令创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod /dev/ttySAC0 c 4 64</span><br><span class="line">mknod /dev/hda1 b 3 1</span><br></pre></td></tr></table></figure>
<p>&#x2F;dev 的创建有3种方法。</p>
<ol>
<li>手动创建<br>在制作根文件系统的时候，就在&#x2F;dev目录下创建好要使用的设备文件，比如ttySAC0等。系统挂接根文件系统后就可以使用&#x2F;dev下的设备文件了。</li>
<li>使用devfs文件系统（这种方法已经过时）<br>以前的内核中有一个配置选项CONFIG_DEVFS_FS，它用来将虚拟文件系统devfs挂接在&#x2F;dev目录上，各个驱动程序注册时会在&#x2F;dev下目录下自动生成各种设备文件。就免去了手动创建设备文件的麻烦，在制作根文件系统时，&#x2F;dev目录可以为空。<br>使用devfs比手动创建设备节点更便利，但是它仍有一些无法克服的缺点<br>①不确定的设备映射<br>比如USB接口连接两台打印机A、B。都开机的情况下以&#x2F;dev&#x2F;usb&#x2F;lp0访问A，以&#x2F;dev&#x2F;usb&#x2F;lp1访问B。但是假如A没有上电，则系统启动时会根据扫描到的设备的顺序，以&#x2F;dev&#x2F;usb&#x2F;lp0访问B。<br>②没有足够的主&#x2F;次设备号<br>主次设备号是两个8位的数字，它们不足以与日益增加的外设一一对应。<br>③命名不够灵活<br>由于devfs由内核创建设备节点，当想重新修改某个设备的名字时需要修改编译内核。<br>④devfs消耗大量内存<br>由于上述缺点，Linux在2.3.46引入devfs之后，又在Linux2.6.13后面版本移除了devfs，而使用udev机制代替。</li>
<li>udev<br>udev是个用户程序（userspace device），它能够根据系统中硬件设备的状态动态的更新设备文件，包括设备文件的创建和删除等。<br>使用udev机制也不需要在&#x2F;dev目录下创建设备节点，他需要一些用户程序的支持，并且内核要支持sysfs文件系统。它的操作相对复杂，但是灵活性很高。</li>
</ol>
<h3 id="x2F-etc-目录"><a href="#x2F-etc-目录" class="headerlink" title="&#x2F;etc 目录"></a>&#x2F;etc 目录</h3><p>如下表所示，该目录下存放各种配置文件。对于PC上的Linux系统，&#x2F;etc目录下目录、文件非常多。这些目录、文件都是可选的，它们依赖于系统中所拥有的应用程序，依赖于这些程序是否需要配置文件。在嵌入式系统中，这些内容可以大为精减。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>opt</td>
<td>用来配置&#x2F;opt下的程序 （可选）</td>
</tr>
<tr>
<td>X11</td>
<td>用来配置X Window （可选）</td>
</tr>
<tr>
<td>sgml</td>
<td>用来配置SGML （可选）</td>
</tr>
<tr>
<td>xml</td>
<td>用来配置XML （可选）</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>export</td>
<td>用来配置NFS文件系统 （可选）</td>
</tr>
<tr>
<td><code>fstab</code></td>
<td>用来指明当执行“mount -a”时，需要挂接的文件系统 （可选）</td>
</tr>
<tr>
<td>mtab</td>
<td>用来显示已经加载的文件系统，通常是&#x2F;proc&#x2F;mounts的链接文件 （可选）</td>
</tr>
<tr>
<td>ftpusers</td>
<td>启动FTP服务时，用来配置用户的访问权限 （可选）</td>
</tr>
<tr>
<td>group</td>
<td>用户的组文件 （可选）</td>
</tr>
<tr>
<td>inittab</td>
<td>init进程的配置文件 （可选）</td>
</tr>
<tr>
<td>ld.so.conf</td>
<td>其他共享库的路径 （可选）</td>
</tr>
<tr>
<td>passwd</td>
<td>密码文件 （可选）</td>
</tr>
</tbody></table>
<h3 id="x2F-lib-目录"><a href="#x2F-lib-目录" class="headerlink" title="&#x2F;lib 目录"></a>&#x2F;lib 目录</h3><p>该目录下存放共享库和可加载模块（驱动程序），共享库用于启动系统、运行根文件系统中的可执行程序，比如&#x2F;bin、&#x2F;sbin目录下的程序。其他不是根文件系统所必须的库文件可以放在其他目录，比如&#x2F;usr&#x2F;bin、&#x2F;usr&#x2F;X11R6&#x2F;lib、、var&#x2F;lib等。</p>
<table>
<thead>
<tr>
<th>目录&#x2F;文件</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>libc.so.*</td>
<td>动态连接C库（可选）</td>
</tr>
<tr>
<td>ld*</td>
<td>连接器、加载器（可选）</td>
</tr>
<tr>
<td>modules</td>
<td>内核可加载模块存放的目录（可选）</td>
</tr>
</tbody></table>
<h3 id="x2F-home-目录"><a href="#x2F-home-目录" class="headerlink" title="&#x2F;home 目录"></a>&#x2F;home 目录</h3><p>用户目录，它是可选的。对于每个普通用户，在&#x2F;home目录下都有一个以用户命名的子目录，里面存放用户相关的配置文件。</p>
<h3 id="x2F-root-目录"><a href="#x2F-root-目录" class="headerlink" title="&#x2F;root 目录"></a>&#x2F;root 目录</h3><p>根用户（用户名为root）的目录，与此对应，普通用户的目录是&#x2F;home下的某个子目录。</p>
<h3 id="x2F-usr-目录"><a href="#x2F-usr-目录" class="headerlink" title="&#x2F;usr 目录"></a>&#x2F;usr 目录</h3><p>&#x2F;usr 目录的内容可以存放在另一个分区中，在系统启动后再挂接到根文件系统的&#x2F;usr目录下。里面存放的是共享、只读的程序和数据，这表明&#x2F;usr目录下的内容可以在多个主机间共享，这些主机也符合FHS标准，&#x2F;usr中的文件应该也是只读的，其他相关、可变的文件也应该保存在其他目录下，比如&#x2F;var。</p>
<table>
<thead>
<tr>
<th>目录</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>bin</td>
<td>很多用户命令存放在这个目录下</td>
</tr>
<tr>
<td>include</td>
<td>C程序的头文件，这在PC下进行开发时才用到，在嵌入式系统中不需要</td>
</tr>
<tr>
<td>lib</td>
<td>库文件</td>
</tr>
<tr>
<td>local</td>
<td>本地目录</td>
</tr>
<tr>
<td>sbin</td>
<td>非必需的系统命令（必需的系统命令放在&#x2F;sbin目录下）</td>
</tr>
<tr>
<td>share</td>
<td>架构无关的数据</td>
</tr>
<tr>
<td>X11R6</td>
<td>XWindows系统</td>
</tr>
<tr>
<td>games</td>
<td>游戏</td>
</tr>
<tr>
<td>src</td>
<td>源代码</td>
</tr>
</tbody></table>
<h3 id="x2F-var-目录"><a href="#x2F-var-目录" class="headerlink" title="&#x2F;var 目录"></a>&#x2F;var 目录</h3><p>与&#x2F;usr目录相反，&#x2F;var目录下存放可变的数据，比如&#x2F;spool目录，log文件、临时文件。</p>
<h3 id="x2F-proc"><a href="#x2F-proc" class="headerlink" title="&#x2F;proc"></a>&#x2F;proc</h3><p>这是一个空目录，常作为proc文件系统的挂接点。proc文件系统是个虚拟的文件系统，它没有实际的存储设备，里面的目录、文件都是由内核临时生成的，用来表示系统的运行状态，也可以操作里面的文件控制系统。<br>系统启动后，使用以下命令挂接proc文件系统（常在&#x2F;etc&#x2F;fstab进行设置以自动挂接）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mount -t proc none /proc</span><br></pre></td></tr></table></figure>

<h3 id="x2F-mnt-目录"><a href="#x2F-mnt-目录" class="headerlink" title="&#x2F;mnt 目录"></a>&#x2F;mnt 目录</h3><p>用于临时挂接某个文件系统的挂接点，通常是空目录；也可以在里面创建一些空的子目录，比如&#x2F;mnt&#x2F;cdram、&#x2F;mnt&#x2F;hda1等，用来临时挂接光盘、硬盘。</p>
<h3 id="x2F-tmp-目录"><a href="#x2F-tmp-目录" class="headerlink" title="&#x2F;tmp 目录"></a>&#x2F;tmp 目录</h3><p>用于存放临时文件，通常是空目录。一些需要临时生成文件的程序要用到&#x2F;tmp目录，所以&#x2F;tmp目录必须存在并可以访问。<br>为减少对Flash的操作，当在&#x2F;tmp目录上挂接内存文件系统时，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># mount -t tmpfs none /tmp</span><br></pre></td></tr></table></figure>

<h2 id="Linux-文件属性介绍"><a href="#Linux-文件属性介绍" class="headerlink" title="Linux 文件属性介绍"></a>Linux 文件属性介绍</h2><table>
<thead>
<tr>
<th>文件类型</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>普通文件</td>
<td>最常见的文件类型</td>
</tr>
<tr>
<td>目录文件</td>
<td>目录也是文件</td>
</tr>
<tr>
<td>字符设备文件</td>
<td>用来访问字符设备</td>
</tr>
<tr>
<td>块设备文件</td>
<td>用来访问块设备</td>
</tr>
<tr>
<td>FIFO</td>
<td>用于进程间通信，也称为命名管道</td>
</tr>
<tr>
<td>套接字</td>
<td>用于进程间的网络通信</td>
</tr>
<tr>
<td>连接文件</td>
<td>指向另一个文件，有软连接、硬连接</td>
</tr>
</tbody></table>
<p>使用“ls -lih”命令可以看到各个文件的具体信息，下面选取这几种文件，列出它们的信息。<br><img src="/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/2.jpeg" alt="img not found"><br>除设备文件ttySAC0、mtdblock0外，这些信息都分为8个字段，比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">228883  -rw-r--r--  2   root    root    6   Sep 27  22:10   readme.txt</span><br><span class="line">字段1       2       3     4       5      6       7           8</span><br></pre></td></tr></table></figure>
<ol>
<li>字段1：文件的索引节点inode<br>索引节点存放一个文件的上述信息，比如文件大小、属主、归属的用户组、读写权限等，并指明文件的实际数据存放的位置。</li>
<li>字段2：文件种类和权限<br>这字段共分10位，格式如下：<br>文件类型有7种，“-”表示普通文件，“d”表示目录，“c”表示字符设备，“b”表示块设备，“p”表示FIFO，“l”表示软连接，“s”表示套接字。<br>没有专门的符号来表示“硬连接”类型，硬连接也是普通文件，只不过文件的实际内容只有一个副本，连接文件、被连接文件都指向它。比如上面的ln_hard文件时是使用命令“ln readme.txt ln_hard”创建出来的到readme.txt文件的硬连接，readme.txt和ln_hard的地位完全一致，它们都指向文件系统中的同一位置，它们的“硬连接个数”都是2，表示这个文件的实际内容被引用两次，可以看到这两个文件的inode都是228883。<br>硬连接文件的引入的另一个作用是使得可以用别名来引用一个文件，避免文件被误删—只有当硬链接个数为1时，对一个文件执行删除操作时才会真正删除文件的副本。它的缺点是不能创建到目录的连接，被连接的文件和连接文件都必须在同一个文件系统中。对此，引入软连接，也称符号连接，软连接只是简单的指向一个文件（可以是目录），并不增加它的硬连接个数。比如上面的ln_soft文件就是使用命令“ln -s readme.txt ln_hard”创建出来的到readme.txt文件的软连接，它使用另一个inode。<br>剩下的9位分为3组，分别表示文件拥有者、同一个群组的用户、其他用户对这个文件的访问权限。每组权限由rwx三位组成，表示可读、可写、可执行。如果某一位被设为“-”，则表示没有相应的权限，比如“rw-”表示只有读写权限，没有可执行权限。</li>
<li>字段3：硬链接个数</li>
<li>字段4：文件拥有者</li>
<li>字段5：所属群组</li>
<li>字段6：文件或目录大小</li>
<li>字段7：最后访问或修改时间</li>
<li>字段8：文件名</li>
</ol>
<p>对于设备文件，字段6表示主设备号，字段7表示次设备号。</p>
<h1 id="移植-Busybox"><a href="#移植-Busybox" class="headerlink" title="移植 Busybox"></a>移植 Busybox</h1><p>所谓制作根文件系统，就是创建各种目录，并且在里面创建各种文件，比如在&#x2F;bin、&#x2F;sbin目录下存放各种可执行程序，在&#x2F;etc目录下存放配置文件，在&#x2F;lib目录下存放库文件。这节讲述如何使用Busybox来创建&#x2F;bin、&#x2F;sbin等目录下的可执行文件。</p>
<h2 id="Busybox-概述"><a href="#Busybox-概述" class="headerlink" title="Busybox 概述"></a>Busybox 概述</h2><p>Busybox是一个遵循GPL v2协议的开源项目。Busybox将众多的UNIX命令集合进一个很小的可执行程序中，可以用来替换GNU fileutils、shellutils等工具集。Busybox中各种命令与相应的GNU工具相比，所能提供的选项较少，但是能够满足一般应用。Busybox为各种小型的或者嵌入式系统提供了一个比较完全的工具集。<br>Busybox在编写过程中对文件大小进行优化，并考虑了系统有限的资源的情况。与一般的GNU工具集动辄几MB的体积相比，动态连接的Busybox只有几百KB，即使静态链接也只有几MB左右。Busybox按模块进行设计，可以很容易的加入、去除某些命令，或增减命令的某些选项。<br>在创建一个最小的根文件系统时，使用Busybox的话，只需要在&#x2F;dev目录下创建必要的设备节点、在&#x2F;etc目录下创建一些配置文件就可以了，如果Busybox使用动态连接，还要在&#x2F;lib目录下包含库文件。<br>Busybox支持uClibc库和glibc库，对Linux 2.2.x之后的内核支持良好。<br>Busybox的官方网站时 <code>http://www.busybox.net/</code>，源码可以从<code>http://www.busybox.net/downloads</code>下载。</p>
<h2 id="init进程介绍及用户程序启动过程"><a href="#init进程介绍及用户程序启动过程" class="headerlink" title="init进程介绍及用户程序启动过程"></a>init进程介绍及用户程序启动过程</h2><p>init进程是由内核启动的第一个用户进程，进程ID为1，它根据配置文件决定启动哪些程序，比如执行脚本、启动shell、运行用户指定的程序等。init进程是后续所有进程的发起者，比如init进程启动&#x2F;bin&#x2F;sh之后，才能够在控制台输入各种命令。<br><code>init进程的执行程序通常是/sbin/init</code>，上面讲述的init进程的作用只不过是&#x2F;sbin&#x2F;init这个程序的功能。我们完全可以编写自己的&#x2F;sbin&#x2F;init程序，或者传入命令行参数“init&#x3D;xxxxx”指定某个程序作为init进程运行。<br>一般而言，在Linux系统中有两种init程序：BSD init和System V init。BSD和System V 是两种版本的UNIX系统。这两种init程序各有优缺点，现在大多数Linux的发行版本使用System V init。但是在嵌入式领域，通常使用Busybox集成init程序。</p>
<h3 id="内核如何启动init进程"><a href="#内核如何启动init进程" class="headerlink" title="内核如何启动init进程"></a>内核如何启动init进程</h3><p>内核启动的最后一步就是启动init进程，代码在<code>init/main.c</code>文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> noinline <span class="title function_">init_post</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (sys_open((<span class="type">const</span> <span class="type">char</span> __user *) <span class="string">&quot;/dev/console&quot;</span>, O_RDWR, <span class="number">0</span>) &lt; <span class="number">0</span>)</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Warning: unable to open an initial console.\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line">	(<span class="type">void</span>) sys_dup(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (ramdisk_execute_command) &#123;</span><br><span class="line">		run_init_process(ramdisk_execute_command);</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Failed to execute %s\n&quot;</span>,</span><br><span class="line">				ramdisk_execute_command);</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (execute_command) &#123;</span><br><span class="line">		run_init_process(execute_command);</span><br><span class="line">		printk(KERN_WARNING <span class="string">&quot;Failed to execute %s.  Attempting &quot;</span></span><br><span class="line">					<span class="string">&quot;defaults...\n&quot;</span>, execute_command);</span><br><span class="line">	&#125;</span><br><span class="line">	run_init_process(<span class="string">&quot;/sbin/init&quot;</span>);</span><br><span class="line">	run_init_process(<span class="string">&quot;/etc/init&quot;</span>);</span><br><span class="line">	run_init_process(<span class="string">&quot;/bin/init&quot;</span>);</span><br><span class="line">	run_init_process(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line"></span><br><span class="line">	panic(<span class="string">&quot;No init found.  Try passing init= option to kernel.&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码不复杂，其中的run_init_process函数使用它的参数所指定的程序来创建一个用户进程。需要注意，一旦run_init_process函数创建进程成功，它将不会返回。<br>内核启动init进程的过程如下：</p>
<ol>
<li>打开标准输入、标准输出、标准错误设备。<br>Linux最先打开的3个文件分别称为标准输入（stdin）、标准输出（stdout）、标准错误（stderr），它们对应的文件描述符分别为0、1、2。所谓标准输入就是在使用scanf()、fscan()获取数据时，从哪个文件（设备）读取数据；标准输出、标准错误都是输出设备，前者对应printf()、fprintf(stdout)，后者对应发fprintf(stderr)。<br>第[4]行尝试打开&#x2F;dev&#x2F;console设备文件，如果成功，它就是init进程标准输入设备。<br>第[7]、[8]行将文件描述符0复制给文件描述符1、2，所以标准输入、标准输出、标准错误都对应同一个文件（设备）。<br>在移植Linux内核时，如果发现打印出“Warning：unable to open an initial console.”，其原因大多是：根文件系统虽然被正确挂接了，但是里面的内容不正确，要么就是没有&#x2F;dev&#x2F;console这个文件，要么它没有对应的设备。</li>
<li>如果ramdisk_execute_command变量指定了要运行的程序，启动它。<br>ramdisk_execute_command的取值（代码也在init&#x2F;main.c中）分3种情况。<br>①如果命令行参数指定了“rdinit&#x3D;…”，则ramdisk_execute_command等于这个参数指定的程序。<br>②否则，如果&#x2F;init程序存在，ramdisk_execute_command就等于“&#x2F;init”。<br>③否则，ramdisk_execute_command为空。<br>本书所用的命令行没有设定“rdinit&#x3D;…”，根文件系统中也没有&#x2F;init程序，所以ramdisk_execute_command为空,所以第[11]-[13]行代码不执行。</li>
<li>如果execute_command变量指定了要运行的程序，启动它。<br>如果命令行参数中指定了“init&#x3D;…”，则execute_command等于这个参数指定的程序，否则为空。<br>本书所用的命令行没有设定“init&#x3D;…”，所以第[17]-[19]行代码不执行。</li>
<li>依次尝试执行&#x2F;sbin&#x2F;init、&#x2F;etc&#x2F;init、&#x2F;bin&#x2F;init、&#x2F;bin&#x2F;sh。<br>第[21]行执行&#x2F;sbin&#x2F;init程序，这个程序在我们的根文件系统中是存在的，所以init进程所用的程序就是&#x2F;sbin&#x2F;init。从此系统的控制器交给&#x2F;sbin&#x2F;init，不再返回init_post函数中。<br>run_init_process函数也在init&#x2F;main.c中，代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> * argv_init[MAX_INIT_ARGS+<span class="number">2</span>] = &#123; <span class="string">&quot;init&quot;</span>, <span class="literal">NULL</span>, &#125;;</span><br><span class="line"><span class="type">char</span> * envp_init[MAX_INIT_ENVS+<span class="number">2</span>] = &#123; <span class="string">&quot;HOME=/&quot;</span>, <span class="string">&quot;TERM=linux&quot;</span>, <span class="literal">NULL</span>, &#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">run_init_process</span><span class="params">(<span class="type">char</span> *init_filename)</span></span><br><span class="line">&#123;</span><br><span class="line">	argv_init[<span class="number">0</span>] = init_filename;</span><br><span class="line">	kernel_execve(init_filename, argv_init, envp_init);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
所以执行&#x2F;sbin&#x2F;init程序时，它的环境参数为“HOME&#x3D;&#x2F;”，“TERM&#x3D;linux”。</li>
</ol>
<h2 id="Busybox-init-进程的启动过程"><a href="#Busybox-init-进程的启动过程" class="headerlink" title="Busybox init 进程的启动过程"></a>Busybox init 进程的启动过程</h2><p>Busybox init 程序对应的代码在<code>init/init.c</code>文件中，下面以busybox-1.7.0为例进行讲解。<br>先概述其流程，再结合一个&#x2F;etc&#x2F;inittab文件讲述init进程的启动过程。</p>
<ol>
<li>Busybox init程序流程<br>流程图如下所示，其中与构建根文件系统关系密切的是控制台的初始化、对inittab文件的解释和执行。<br><img src="/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/3.jpeg" alt="img not found"><br>内核启动init进程时已经打开“dev&#x2F;console”设备作为控制台，一般情况下Busybox init 程序就使用&#x2F;dev&#x2F;console。但是如果内核启动init进程的同时设置了环境变量CONSOLE或console，则使用环境变量所指的的设备。在Busybox init 程序中，还会检查这个设备是否可以打开，如果不能打开则使用“&#x2F;dev&#x2F;null”。<br>Busybox init 只是作为其他进程的发起者和控制者，并不需要控制台与用户交互，所以init进程会把它关掉，系统启动后运行命令“ls &#x2F;proc&#x2F;1&#x2F;fd”可以看到该目录为空。init进程创建其他子进程时，如果没有在&#x2F;etc&#x2F;inittab中指明它的控制台，则使用前面确定的控制台。<br>&#x2F;etc&#x2F;inittab文件的相关文档和示例代码都在Busybox的example&#x2F;inittab文件中。<br>如果存在&#x2F;etc&#x2F;inittab文件，Busybox init程序解析它，然后按照它的指示创建各种子进程；否则使用默认的配置创建子进程。<br>&#x2F;etc&#x2F;inittab文件中每个条目用来定义一个子进程，并确定它的启动方法，格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&lt;id&gt;:&lt;runlevels&gt;:&lt;action&gt;:&lt;process&gt;</span><br></pre></td></tr></table></figure>
例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ttySAC0::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure>
对于Busybox init 程序，上述字段作用如下。<br>①<id>：表示这个子进程要使用的控制台（即标准输入、标准输出、标准错误设备）。如果省略，则使用与init进程一样的控制台。<br>②<runlevels>：对于Busybox init 程序，这个字段没有意义。<br>③<action>：表示init进程如何控制这个子进程，有如下8种取值。<br>④<process>：要执行的程序，它可以是可执行程序，也可以是脚本。<br>如果<process>字段前面有“-”字符，这个程序被称为“交互的”。<table>
<thead>
<tr>
<th>action名称</th>
<th>执行条件</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>sysinit</td>
<td>系统启动后最先执行</td>
<td>只执行一次，init进程等待它结束才继续执行其他动作</td>
</tr>
<tr>
<td>wait</td>
<td>系统执行完sysinit进程后</td>
<td>只执行一次，init进程等待它结束才继续执行其他动作</td>
</tr>
<tr>
<td>once</td>
<td>系统执行完wait进程后</td>
<td>只执行一次，init进程不等待它结束</td>
</tr>
<tr>
<td>respawn</td>
<td>启动完once进程后</td>
<td>init进程检测发现子进程退出时，重新启动它</td>
</tr>
<tr>
<td>askfirst</td>
<td>启动完respawn进程后</td>
<td>与respawn类似，不过init进程先输出“Please press Enter to activate this console.”，等用户输入回车键之后才启动子进程</td>
</tr>
<tr>
<td>shutdown</td>
<td>当系统关机时</td>
<td>即重启、关闭系统命令时</td>
</tr>
<tr>
<td>restart</td>
<td>Busybox中配置了CONFIG_FEATURE_USE_INITTAB，并且init进程接收到SIGHUP信号时</td>
<td>先重新读取、解析&#x2F;etc&#x2F;inittab文件，再执行restart程序</td>
</tr>
<tr>
<td>ctrlaltdel</td>
<td>按下Ctrl + Alt + Del组合键时</td>
<td>—</td>
</tr>
</tbody></table>
</process></process></action></runlevels></id></li>
</ol>
<p>在&#x2F;etc&#x2F;inittab文件的控制下，init进程的行为总结如下。<br>①在系统启动前期，init进程首先启动<action>为sysinit、wait、once的3类子进程。<br>②在系统正常运行期间，init进程首先启动<action>为respawn、askfirst的两类子进程，并监视他们，发现某个子进程退出时重新启动它们。<br>③在系统退出时，执行<action>为shutdown、restart、ctrlaltdel的3类子进程<br>如果根文件系统中没有&#x2F;etc&#x2F;inittab文件，Busybox init程序将使用如下默认的inittab条目。</action></action></action></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">::askfirst:/bin/sh</span><br><span class="line">ttys2::askfirst:/bin/sh</span><br><span class="line">ttys3::askfirst:/bin/sh</span><br><span class="line">ttys4::askfirst:/bin/sh</span><br><span class="line">::ctrlaltdel:/sbin/swapoff -a</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br><span class="line">::restart:/sbin/init</span><br></pre></td></tr></table></figure>
<ol start="2">
<li>&#x2F;etc&#x2F;inittab 实例<br>仿照Busybox的example的examples&#x2F;inittab文件，创建一个inittab文件，内容如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/inittab</span><br><span class="line"># 这是init进程启动的第一个子进程，它是一个脚本，可以在里面指定用户想执行的操作</span><br><span class="line"># 比如挂接其他文件系统、配置网络等</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line"></span><br><span class="line"># 启动shell，以/dev/ttySAC0作为控制台</span><br><span class="line">ttySAC0:askfirst:-/bin/sh</span><br><span class="line"></span><br><span class="line"># 按下Ctrl + Alt + Del之后执行的程序</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line"></span><br><span class="line"># 重启、关机前执行的程序</span><br><span class="line">::shutdown:/bin/umount -a -r</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="编译-x2F-安装-Busybox"><a href="#编译-x2F-安装-Busybox" class="headerlink" title="编译&#x2F;安装 Busybox"></a>编译&#x2F;安装 Busybox</h2><p>从<code>http://www.busybox.net/downloads</code>下载busybox-1.7.0.tar.bz2。<br>使用如下命令解压得到busubux-1.7.0目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar xjf busybox-1.7.0.tar.bz2</span><br></pre></td></tr></table></figure>
<p>Busybox 集合了几百个命令，在一般系统中并不需要全部使用。可以通过配置Busybox来选择这些命令、定制某些命令的功能（选项）、指定Busybox的连接方法、指定Busybox的安装路径。</p>
<h3 id="配置-Busybox"><a href="#配置-Busybox" class="headerlink" title="配置 Busybox"></a>配置 Busybox</h3><p>在 busybox-1.7.0 目录下执行“make menuconfig”命令即可进入配置界面。Busybox将所有配置项分类存放，如下表所示：</p>
<table>
<thead>
<tr>
<th>配置项类型</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>Busybox Settings —&gt; <br> General Configuration</td>
<td>一些通用的设置，一般不需要理会</td>
</tr>
<tr>
<td>Busybox Settings —&gt; <br> Build Options</td>
<td>连接方式、编译选项等</td>
</tr>
<tr>
<td>Busybox Settings —&gt; <br> Debugging Options</td>
<td>调试选项，使用Busybox时将打印一些调试信息，一般不选</td>
</tr>
<tr>
<td>Busybox Settings —&gt; <br> Installation Options</td>
<td>Busybox的安装路径，不需要设置，可以在命令行中指定</td>
</tr>
<tr>
<td>Busybox Settings —&gt; <br> Busybox Library Tuning</td>
<td>Busybox的性能微调，比如设置在控制台上可以输入的最大字符个数，一般使用默认值</td>
</tr>
<tr>
<td>Archival Utilities</td>
<td>各种压缩、解压缩工具，根据需要选择相关命令</td>
</tr>
<tr>
<td>Coreutils</td>
<td>核心的命令，比如ls、cp等</td>
</tr>
<tr>
<td>Console Utilities</td>
<td>控制台相关的命令，比如清屏命令clear等。</td>
</tr>
<tr>
<td>Debian Utilities</td>
<td>Debian（Linux的一种发行版本）命令</td>
</tr>
<tr>
<td>Editors</td>
<td>编辑命令，一般都选中Vi</td>
</tr>
<tr>
<td>Finding Utilities</td>
<td>查找命令</td>
</tr>
<tr>
<td>Init Utilities</td>
<td>init程序的配置选项，比如是否读取inittab文件</td>
</tr>
<tr>
<td>Login&#x2F;Password Management Utilities</td>
<td>登录、用户账号&#x2F;密码等方面的命令</td>
</tr>
<tr>
<td>Linux Ext2 FS Progs</td>
<td>Ext2文件系统的一些工具</td>
</tr>
<tr>
<td>Linux Module Utilities</td>
<td>加载&#x2F;卸载模块的命令</td>
</tr>
<tr>
<td>Linux System Utilities</td>
<td>一些系统命令，比如打印内核信息的dmesg、分区命令fdisk</td>
</tr>
<tr>
<td>Miscellaneous Utilities</td>
<td>一些不好分类的命令</td>
</tr>
<tr>
<td>Networking Utilities</td>
<td>网络方面的命令，可以选择一些方便调试的命令，比如telnetd、ping、tftp等</td>
</tr>
<tr>
<td>Process Utilities</td>
<td>进程相关的命令，如ps、free、kill、top等</td>
</tr>
<tr>
<td>Shells</td>
<td>有多种shell，比如msh、ash等，一般选择ash</td>
</tr>
<tr>
<td>System Logging Utilities</td>
<td>系统记录方面的命令</td>
</tr>
<tr>
<td>ipsvd Utilities</td>
<td>监听TCP、DPB端口</td>
</tr>
</tbody></table>
<ol>
<li>Busybox的性能微调<br>设置“TAB”键补全，如下配置：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Busybox Settings ---&gt;</span><br><span class="line">    Busybox Library Tuning ---&gt;</span><br><span class="line">        [*] Tab completion</span><br></pre></td></tr></table></figure></li>
<li>连接&#x2F;编译选项<br>以下选项指定是否使用静态连接：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Build Options ---&gt;</span><br><span class="line">    [] Build Busybox as a static binary (no shared libs)</span><br></pre></td></tr></table></figure>
使用glibc时，如果静态编译Busybox 会提示以下警告信息，表示会出现一些奇怪的问题。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># warning Static linking against glibc produces buggy executable</span><br></pre></td></tr></table></figure>
所以，本书使用动态连接的Busybox，在构造根文件系统时需要在&#x2F;lib目录下放置glibc库文件。</li>
<li>Archival Utilities 选项<br>选择tar命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Archival Utilities ---&gt;</span><br><span class="line">    [*] tar</span><br><span class="line">    [*] Enable archive creation</span><br><span class="line">    [*] Enable -j option to handle .tar.bz2 files</span><br><span class="line">    [*] Enable -X and -T options</span><br><span class="line">    [*] Enable -z option</span><br><span class="line">    [*] Enable -Z option</span><br><span class="line">    [*] Enable support for old tar  header format</span><br><span class="line">    [*] Enable support for some GNU tar extensions</span><br><span class="line">    [*] Enable long options</span><br></pre></td></tr></table></figure></li>
<li>Linux Module Utilities 选项<br>要使用可加载模块，下面的配置选上。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux Module Utilities ---&gt;</span><br><span class="line">    [*] insmode</span><br><span class="line">    [*] Module version checking</span><br><span class="line">    [*] Add module symbols to kernel symbol table</span><br><span class="line">    [*] In kernel memory optimization (uClinux only)</span><br><span class="line">    [*] Enable load map (-m) option</span><br><span class="line">    [*] Symbols in load map</span><br><span class="line">    [*] rmmod</span><br><span class="line">    [*] lsmod</span><br><span class="line">    [*] Support version 2.6.x Linux kernels</span><br></pre></td></tr></table></figure></li>
<li>Linux System Utilities 选项<br>支持mdev，这可以很方便的构造&#x2F;dev目录，并且可以支持热插拔设备。另外，为方便调试，选中mount、unmount 命令，并让mount命令支持NFS。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux System Utilities ---&gt;</span><br><span class="line">    [*] mdev</span><br><span class="line">    [*] Support /etc/mdev.conf</span><br><span class="line">    [*] Support command execution at device addtion/removal</span><br><span class="line">    [*] mount</span><br><span class="line">    [*] Suuport mounting NFS file system</span><br><span class="line">    [*] unmount</span><br><span class="line">    [*] unmount -a option</span><br></pre></td></tr></table></figure></li>
<li>Networking Utilities 选项<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Linux System Utilities ---&gt;</span><br><span class="line">    [*] ifconfig</span><br><span class="line">    [*] Enable status reporting output (+7k)</span><br><span class="line">    [] Enable slip-specific options &quot;keepalive&quot; and &quot;outfill&quot;</span><br><span class="line">    [] Enable options &quot;mem_start&quot;,&quot;io_addr&quot; and &quot;irq&quot;</span><br><span class="line">    [*] Enable option &quot;hw&quot; (ether only)</span><br><span class="line">    [*] Enable set the broadcast automatically</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="编译和安装-Busybox"><a href="#编译和安装-Busybox" class="headerlink" title="编译和安装 Busybox"></a>编译和安装 Busybox</h3><p>编译之前，先修改Busybox根目录的Makefile，使用交叉编译器。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line">ARCH ?= $(SUBARCH)</span><br><span class="line">CROSS_COMPILE ?= </span><br><span class="line">修改后：</span><br><span class="line">ARCH ?= arm</span><br><span class="line">CROSS_COMPILE ?= arm-linux-</span><br></pre></td></tr></table></figure>
<p>然后执行“make”命令编译Busybox。<br>最后是安装，执行“make CONFIG_PREFIX&#x3D;dir_path install”就可以将Busybox安装在dir_name指定的目录下。执行以下命令在&#x2F;work&#x2F;nfs_root&#x2F;fs_mini目录下安装Busybox。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ make CONFIG_PREFIX=/work/nfs_root/fs_mini install</span><br></pre></td></tr></table></figure>
<p>一切完成后，将在&#x2F;work&#x2F;nfs_root&#x2F;fs_mini目录下生成如下文件、目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drwxr-xr-x  2   book    book    4096    2008-01-22  06:56   bin </span><br><span class="line">lrwxrwxrwx  1   book    book    11      2008-01-22  06:56   linuxrc -&gt;  bin/busybox</span><br><span class="line">drwxr-xr-x  2   book    book    4096    2008-01-22  06:56   sbin </span><br><span class="line">drwxr-xr-x  4   book    book    4096    2008-01-22  06:56   usr</span><br></pre></td></tr></table></figure>
<p>其中linuxrc和上面分析的&#x2F;sbin&#x2F;init程序功能完全一样；其他目录下是各种命令，不过它们都是到&#x2F;bin&#x2F;busybox的符号链接，比如&#x2F;work&#x2F;nfs_root&#x2F;fs_mini&#x2F;sbin目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   halt -&gt;  ../bin/busybox</span><br><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   ifconfig -&gt;  ../bin/busybox</span><br><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   init -&gt;  ../bin/busybox</span><br><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   insmod -&gt;  ../bin/busybox</span><br><span class="line">lrwxrwxrwx  1   book    book    14        2008-01-22  06:56   klogd -&gt;  ../bin/busybox</span><br></pre></td></tr></table></figure>
<p>除bin&#x2F;busybox外，其他文件都是到bin&#x2F;busybox的符号链接。busybox是所有命令的集合体，这些符号链接文件可以直接运行。在开发板上，运行“ls”和“busybox ls”是一样的。</p>
<h1 id="使用-glibc-库"><a href="#使用-glibc-库" class="headerlink" title="使用 glibc 库"></a>使用 glibc 库</h1><p>在制作交叉编译工具链时，已经生成了glibc库，可以直接使用它来构建根文件系统。</p>
<h2 id="glibc-库的组成"><a href="#glibc-库的组成" class="headerlink" title="glibc 库的组成"></a>glibc 库的组成</h2><p>glibc库的位置是&#x2F;work&#x2F;tools&#x2F;gcc-3.4.5-glibc-2.3.6&#x2F;arm-linux&#x2F;lib。<br>这个目录下的文件并非属于glibc库，比如crtl.o、libstdc++.a等文件是GCC工具本身生成的。本书不区分它们的来源，统一处理。<br>里面的目录、文件可以分为8类。<br>①加载器ld-2.3.6.so、ld-linux.so.2。<br>动态程序启动前，它们被用来加载动态库。<br>②目标文件(.o)<br>比如crtl.o、crti.o、crtn.o、gcrtl.o、Mcrtl.o、Scrtl.o等。在生成应用程序时，这些文件像一般的目标一样被连接。<br>③静态库文件(.a)<br>比如静态数学库libm.a、静态c++库libstdc++.a等，编译静态程序时会连接它们。<br>④动态库文件(.so，.so.[0-9]*)<br>比如动态数学库libm.so、动态c++库libstdc++.so等，它们可能是一个链接文件。编译动态库时会用到这些文件，但是不会连接它们，运行时才连接。<br>⑤libtool库文件(.a)<br>在连接库文件时，这些文件会被用到，比如它们列出了当前库文件所依赖的其他库文件。程序运行时无需这些文件。<br>⑥gconv目录<br>里面是有头字符集的动态库，比如ISO8859-l.o、GB18030.so等。<br>⑦ldscripts目录<br>里面是各种连接脚本，在编译应用程序时，它们被用于指定程序的运行地址、各段的位置等。<br>⑧其他目录及文件</p>
<h2 id="安装glibc-库"><a href="#安装glibc-库" class="headerlink" title="安装glibc 库"></a>安装glibc 库</h2><p>在开发板上只需要加载器和动态库，假设要构建的根文件系统目录为&#x2F;work&#x2F;nfs_root&#x2F;fs_mini，操作如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /work/nfs_root/fs_mini/lib</span><br><span class="line">cd /work/tools/gcc-3.4.5-glibc-2.3.6/arm-linux/lib</span><br><span class="line">cp *.so* /work/nfs_root/fs_mini/lib -d</span><br></pre></td></tr></table></figure>
<p>上面复制的库文件不是每个都会用到，可以根据应用程序对库的依赖关系保留需要用到的。通过ldd命令查看一个程序会用到哪些库，主机自带的ldd命令不能查看交叉编译出来的文件。有以下两种替代方法。<br>①如果有uClibc-0.9.28的代码，可以进入utils子目录生成ldd.host工具。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd uClibc-0.9.28/utils</span><br><span class="line">make ldd.host</span><br></pre></td></tr></table></figure>
<p>然后将生成的ldd.host放到主机&#x2F;usr&#x2F;local&#x2F;bin目录下即可使用。<br>比如对于动态连接的Busybox，它的库的依赖关系如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldd.host busybox</span><br><span class="line">    libcrypto.so.1  =&gt;  /lib/libcrypto.so.1 (0x00000000)</span><br><span class="line">    libm.so.6   =&gt;  /lib/libm.so.6  (0x00000000)</span><br><span class="line">    libc.so.6   =&gt;  /lib/libc.so.6  (0x00000000)</span><br><span class="line">    /lib/ld-linux.so.2  =&gt;  /lib/ld-linux.so.2  (0x00000000)</span><br></pre></td></tr></table></figure>
<p>这表示Busybox要使用的要使用的库文件有libcrypto.so.1、libm.so.6、libc.so.6，加载器为&#x2F;lib&#x2F;ld-linux.so.2。上面的“not found”表示主机上没有这个条件，这么关系，开发板的根文件系统上有就行。<br>②可以使用以下命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-readelf -a &quot;your binary&quot; | grep &quot;Shared&quot;</span><br></pre></td></tr></table></figure>
<p>比如对于动态连接的Busybox，它的库依赖如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-readelf -a ./busybox | grep &quot;Shared&quot;</span><br><span class="line">0x00000001 (NEEDED)                 Shared library:[libcrypto.so.1]</span><br><span class="line">0x00000001 (NEEDED)                 Shared library:[libm.so.6]</span><br><span class="line">0x00000001 (NEEDED)                 Shared library:[libc.so.6]</span><br></pre></td></tr></table></figure>

<h1 id="构建根文件系统"><a href="#构建根文件系统" class="headerlink" title="构建根文件系统"></a>构建根文件系统</h1><p>前面在介绍了如何安装Busybox、C库，建立了bin&#x2F;、sbin&#x2F;、usr&#x2F;bin、usr&#x2F;sbin、lib&#x2F;等目录，最小根文件系统的大部分目录、文件已经建立好。</p>
<h2 id="构建etc目录"><a href="#构建etc目录" class="headerlink" title="构建etc目录"></a>构建etc目录</h2><p>init进程根据&#x2F;etc&#x2F;inittab来创建其他子进程，比如调用脚本配置文件配置IP地址、挂接其他文件分系统，最后启动shell等。<br>etc目录下的内容取决于要运行的程序，本节只需要3个文件：etc&#x2F;inittab、etc&#x2F;init.d&#x2F;rcS、etc&#x2F;fstab。</p>
<h3 id="创建etc-x2F-inittab文件"><a href="#创建etc-x2F-inittab文件" class="headerlink" title="创建etc&#x2F;inittab文件"></a>创建etc&#x2F;inittab文件</h3><p>仿照Busybox的examples&#x2F;inittab文件，在&#x2F;work&#x2F;nfs_root&#x2F;fs_mini&#x2F;etc目录下创建一个inittab文件，内容如下。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># /etc/inittab</span><br><span class="line">::sysinit:/etc/init.d/rcS</span><br><span class="line">ttySAC0::askfirst:-/bin/sh</span><br><span class="line">::ctrlaltdel:/sbin/reboot</span><br><span class="line">::shutdown:/bin/unmount -a -r</span><br></pre></td></tr></table></figure>

<h3 id="创建etc-x2F-init-d-x2F-rcS文件"><a href="#创建etc-x2F-init-d-x2F-rcS文件" class="headerlink" title="创建etc&#x2F;init.d&#x2F;rcS文件"></a>创建etc&#x2F;init.d&#x2F;rcS文件</h3><p>这是一个脚本文件，可以在里面添加想自动执行的命令。以下命令配置IP地址、挂接&#x2F;etc&#x2F;fstab指定的文件系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line">ifconfig eth0 192.168.1.17</span><br><span class="line">mount -a</span><br></pre></td></tr></table></figure>
<p>第一行表示这是一个脚本文件，运行时使用&#x2F;bin&#x2F;sh解析。<br>第一行用来配置IP地址。<br>第三行挂接&#x2F;etc&#x2F;fstab文件指定的所有文件系统。<br>最后还要改变它的属性，使它能够执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">chmod +x etc/init.d/rcS</span><br></pre></td></tr></table></figure>

<h3 id="创建etc-x2F-fstab文件"><a href="#创建etc-x2F-fstab文件" class="headerlink" title="创建etc&#x2F;fstab文件"></a>创建etc&#x2F;fstab文件</h3><p>内容如下，表示执行“mount -a”命令后将挂接proc、tmpfs文件系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># device        mount-point        type        options      dump        fsck        order</span><br><span class="line">  proc          /proc               proc        defaults    0           0</span><br><span class="line">  tmpfs         /tmp                tmpfs       defaults    0           0</span><br></pre></td></tr></table></figure>
<p>&#x2F;etc&#x2F;fstab文件被用来定义文件系统的“静态信息”，这些信息被用来控制mount命令的行为。文件中各字段的意义如下。<br>①device：要挂接的设备<br>比如&#x2F;dev&#x2F;hda2、&#x2F;dev&#x2F;mtdblock1等设备文件；也可以是其他格式，比如对于proc文件系统这个字段没有意义，可以是任意值；对于NFS文件系统，这个字段为<code>&lt;host&gt;:&lt;dir&gt;</code>。<br>②mount-point：挂接点<br>③type：文件系统类型<br>比如proc、jffs2、yaffs、ext2、nfs等；也可以是auto，表示自动检测文件系统类型。<br>④options：挂接参数，以逗号隔开。<br>&#x2F;etc&#x2F;fstab的作用不仅仅是用来控制“mount -a”的行为，即使是一般的mount命令也受它控制，这可以从下表的参数看出。除与文件系统类型相关的参数外，常用的有以下几种取值。</p>
<table>
<thead>
<tr>
<th>参数名</th>
<th>说明</th>
<th>默认值</th>
</tr>
</thead>
<tbody><tr>
<td>auto<br>noauto</td>
<td>决定执行“mount -a”时是否自动挂接 <br> auto：挂接 noauto：不挂接</td>
<td>auto</td>
</tr>
<tr>
<td>user<br>nouser</td>
<td>user：运行普通用户挂接设备<br>nouser：只允许root用户挂接设备</td>
<td>nouser</td>
</tr>
<tr>
<td>exec<br>noexec</td>
<td>exec：允许所挂接设备上的文件<br>noexec：不允许允许所挂接设备上的程序</td>
<td>exec</td>
</tr>
<tr>
<td>Ro</td>
<td>以只读方式挂接文件系统</td>
<td>-</td>
</tr>
<tr>
<td>Rw</td>
<td>以读写方式挂接文件系统</td>
<td>-</td>
</tr>
<tr>
<td>sync<br>async</td>
<td>sync：修改文件时，它会同步写入设备中<br>async：不会同步写入</td>
<td>sync</td>
</tr>
<tr>
<td>default</td>
<td>rw、suid、dev、exec、auto、nouser、async等的组合</td>
<td>-</td>
</tr>
</tbody></table>
<p>⑤dump和fsck order：用来决定控制dump、fsck程序的行为。<br>dump是一个用来备份文件的程序，fsck是一个用来检查磁盘的程序。<br>dump程序程序根据dump字段的值来决定这个文件系统是否需要备份，如果没有这个字段，或者其值为0，则dump忽略这个文件系统。<br>fsck程序根据fsck order字段来决定磁盘的检查顺序，一般来说对于根据根文件系统这个字段设为1，其他文件系统设为2。如果设为0，则fsck忽略这个文件系统。</p>
<h2 id="构建dev目录"><a href="#构建dev目录" class="headerlink" title="构建dev目录"></a>构建dev目录</h2><p>使用两种方式创建dev目录。</p>
<h3 id="静态创建设备文件"><a href="#静态创建设备文件" class="headerlink" title="静态创建设备文件"></a>静态创建设备文件</h3><p>为简单起见，本书先使用最原始的方法处理设备：在&#x2F;dev目录下静态创建各种节点。<br>从系统启动过程可知，涉及的设备有：&#x2F;dev&#x2F;mtdblock<em>、&#x2F;dev&#x2F;ttySAC</em>、&#x2F;dev&#x2F;console、dev&#x2F;null，只要建立以下设备就可以启动系统。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /work/nfs_root/fs_mini/dev</span><br><span class="line">cd /work/nfs_root/fs_mini/dev</span><br><span class="line">sudo mknod console c 5 1</span><br><span class="line">sudo mknod null c 1 3</span><br><span class="line">sudo mknod ttySAC0 c 204 64</span><br><span class="line">sudo mknod mtdblock0 b 31 0</span><br><span class="line">sudo mknod mtdblock1 b 31 1</span><br><span class="line">sudo mknod mtdblock2 b 31 2</span><br></pre></td></tr></table></figure>
<p>其他设备文件可以当系统启动后，使用“cat &#x2F;proc&#x2F;devices”命令查看内核中注册了哪些设备，然后一一创建相应的设备文件。</p>
<h3 id="使用mdev创建设备文件"><a href="#使用mdev创建设备文件" class="headerlink" title="使用mdev创建设备文件"></a>使用mdev创建设备文件</h3><p>mdev是udev的简化版本，也是通过读取内核信息来创建设备文件。<br>mdev的用途主要有两个：初始化&#x2F;dev目录、动态更新。动态更新不仅是更新&#x2F;dev目录，还支持热插拔。<br>要使用mdev，需要内核支持sysfs文件系统，为了减少对Flash的读写，还要支持tmpfs文件系统。先确保内核已经设置了CONFIG_SYSFS、CONFIG_TMPFS配置项。<br>使用mdev的命令如下，请参考它们的注释以了解其作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -t tmpfs mdev /dev                    //使用内存文件系统，减少对Flash的读写</span><br><span class="line">mkdir /dev/pts                              //devpts用来支持外部网络连接的虚拟终端</span><br><span class="line">mount -t devpts devpts /dev/pts     </span><br><span class="line">mount -t sysfs sysfs /sys                   //mdev通过sysfs文件系统获得设备信息</span><br><span class="line">echo /bin/mdev&gt;/proc/sys/kernel/hotplug     //设置内核，当有设备拔插时调用/bin/mdev程序</span><br><span class="line">mdev -s                                     //在/dev目录下生成内核支持的所有设备节点</span><br></pre></td></tr></table></figure>
<p>要在内核启动时，自动运行mdev。这要修改&#x2F;work&#x2F;nfs_root&#x2F;fs_mini中的两个文件：修改etc&#x2F;fstab来自动挂载文件系统、修改etc&#x2F;init.d&#x2F;rcS加入要自动运行的命令。修改后如下所示：<br>①etc&#x2F;fstab</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># device        mount-point        type        options      dump        fsck        order</span><br><span class="line">  proc          /proc               proc        defaults    0           0</span><br><span class="line">  tmpfs         /tmp                tmpfs       defaults    0           0</span><br><span class="line">  sysfs         /sys                sysfs       defaults    0           0</span><br><span class="line">  tmpfs         /dev                tmpfs       defaults    0           0</span><br></pre></td></tr></table></figure>
<p>②etc&#x2F;init.d&#x2F;rcS：加入下面几行</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -a</span><br><span class="line">mkdir /dev/pts</span><br><span class="line">mount -t devpts devpts /dev/pts</span><br><span class="line">echo /sbin/mdev &gt; /proc/sys/kernel/hotplug</span><br><span class="line">mdev -s</span><br></pre></td></tr></table></figure>
<p>需要注意的是，开发板上通过mdev生成的&#x2F;dev目录中，S3C2410、S3C2440的串口名是s3c2410_serial0、s3c2410_serial1、s3c2410_serial2，不是ttySAC0、ttySAC1、ttySAC2。需要修改etc&#x2F;inittab文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line">ttySAC0: askfirst:-/bin/sh</span><br><span class="line">修改后：</span><br><span class="line">s3c2410_serial0::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure>
<p>另外，mdev是通过init进程来启动的，在使用mdev构造&#x2F;dev目录之前，init进程至少要用到设备文件&#x2F;dev&#x2F;console、&#x2F;dev&#x2F;nul，所以要建立这两个设备文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mkdir -p /work/nfs_root/fs_mini/dev</span><br><span class="line">cd /work/nfd_root/fs_mini/dev</span><br><span class="line">sudo mknod console c 5 1 </span><br><span class="line">sudo mknod null c 1 3 </span><br></pre></td></tr></table></figure>

<h2 id="构建其他目录"><a href="#构建其他目录" class="headerlink" title="构建其他目录"></a>构建其他目录</h2><p>其他目录可以是空目录，比如proc、mnt、tmp、sys、root等。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/nfs_root/fs_mini</span><br><span class="line">mkdir proc mnt tmp sys root</span><br></pre></td></tr></table></figure>
<p>现在，&#x2F;work&#x2F;nfs_root&#x2F;fs_mini目录下就是一个非常小的文件系统。开发板可以将它作为网络根文件系统直接启动。如果要烧入开发板，还要将它制作为一个文件，称为映像文件。</p>
<h3 id="制作-x2F-使用yaffs文件系统映像文件"><a href="#制作-x2F-使用yaffs文件系统映像文件" class="headerlink" title="制作&#x2F;使用yaffs文件系统映像文件"></a>制作&#x2F;使用yaffs文件系统映像文件</h3><p>按照前面的方法，在&#x2F;work&#x2F;nfs_root目录下构造了两个根文件系统：fs_mini、fs_mini_mdev。前者使用&#x2F;dev目录中事先建立好的设备文件，后者使用mdev机制来生成dev目录，它们的差别只在于3点：etc&#x2F;inittab文件、etc&#x2F;init.d&#x2F;rcS文件、dev&#x2F;目录。下面以&#x2F;work&#x2F;nfs_root&#x2F;fs_mini为例制作根文件系统映像。<br>所谓制作文件系统映像，就是将一个目录下的所有内容按照一定的格式存放到一个文件中，这个文件可以直接烧写到存储设备中去。当系统启动后挂接这个设备，就可以看到与原来目录一样的内容。<br>制作不同类型的文件系统映像需要使用不同的工具。</p>
<h4 id="修改制作yaffs映像文件的工具"><a href="#修改制作yaffs映像文件的工具" class="headerlink" title="修改制作yaffs映像文件的工具"></a>修改制作yaffs映像文件的工具</h4><p>在yaffs源码包有一个utils目录，里面是工具mkyaffsimage和mkyaffs2image的源代码。前者用来制作yaffs1映像文件，后者用来制作yaffs2映像文件。<br>目前mkyaffsimage工具只能生成老格式的yaffs1映像文件，需要修改才能支持新格式。<br>yaffs1新、老格式的不同在于oob区的使用发生了变化：一是ECC检验码的位置发生了变化，二是可用空间即标记（tag）的数据结构定义发生了变化。<br>另外，由于配置内核时没有设置CONFIG_YAFFS_DOES_ECC，yaffs文件系统将使用MTD设备层的ECC校验方法，制作映像文件时也使用与MTD设备层相同的函数计算ECC码。<br>①oob区中校验码的位置变化：<br>oob区中使用6个字节来存放ECC校验码，前3个字节对应上半页，后3个字节对应下半页。<br>由nand_oob_16结构可知，以前的校验码在oob区中存放的位置为8、9、10、13、14和15，现在改为0、1、2、3、6、7。<br>②oob区中可用空间的数据结构定义变化。<br>oob区中可用的空间有8个字节，它用来存放文件系统的数据，代码中这些数据被称为标记（tag）。<br>老格式的yaffs1中，这8个字节的数据结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//老格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> chunkId:<span class="number">20</span>;</span><br><span class="line">    <span class="type">unsigned</span> serialNumber:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> byteCount:<span class="number">10</span>;</span><br><span class="line">    <span class="type">unsigned</span> objectId:<span class="number">18</span>;</span><br><span class="line">    <span class="type">unsigned</span> ecc:<span class="number">12</span>;</span><br><span class="line">    <span class="type">unsigned</span> unusedStuff:<span class="number">2</span>;</span><br><span class="line">&#125;yaffs_Tags;</span><br><span class="line"></span><br><span class="line"><span class="comment">//新格式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> chunkId:<span class="number">20</span>;</span><br><span class="line">    <span class="type">unsigned</span> serialNumber:<span class="number">2</span>;</span><br><span class="line">    <span class="type">unsigned</span> byteCount:<span class="number">10</span>;</span><br><span class="line">    <span class="type">unsigned</span> objectId:<span class="number">18</span>;</span><br><span class="line">    <span class="type">unsigned</span> ecc:<span class="number">12</span>;</span><br><span class="line">    <span class="type">unsigned</span> deleted:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> unusedStuff:<span class="number">1</span>;</span><br><span class="line">    <span class="type">unsigned</span> shouldBeff;</span><br><span class="line">&#125;yaffs_PackedTags1;</span><br></pre></td></tr></table></figure>
<p>新、老结构有细微差别：老结构中有两位没有使用（unusedStaff）；新结构中只有一位没有使用，另一位（deleted）被用来表示当前页是否已经删除。<br>③oob区中ECC码的计算<br>如果配置内核时设置了CONFIG_YAFFS_DOES_ECC，则yaffs文件系统将使用yaffs2&#x2F;yaffs_ecc.c文件中的yaffs_ECCCalculate函数来计算ECC码；否则使用drivers&#x2F;mtd&#x2F;nand&#x2F;nand_ecc.c文件中的nand_calculate_ecc函数。<br>mkyaffsimage工具原来的代码中使用yaffs_ECCCalculate函数。由于上面配置内核时，没有选择CONFIG_YAFFS_DOES_ECC，为了使映像文件与内核保持一致，要修改mkyaffsimage源码，使用nand_calculate_ecc函数。<br>对mkyaffsiamge的修改如下所示。<br>①增加头文件<br>修改文件mkyaffsimage.c，加上下面这行，里面定义了yaffs_PackedTags1结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#include &quot;yaffs_packedtags1.h&quot;</span><br></pre></td></tr></table></figure>
<p>②修改mkyaffsimages.c文件的write_chunk函数<br>代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">write_chunk</span><span class="params">(__u8 *data,__u32 chunkId,__u32 nBytes)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_YAFFS_9BYTE_TAGS <span class="comment">//如果要生成老格式的yaffs1映像文件，定义这个宏</span></span></span><br><span class="line"><span class="comment">/*原来的代码*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line">    yaffs_PachedTags pt1;</span><br><span class="line">    yaffs_ExtendedTags  etags;</span><br><span class="line">    __u8  ecc_code[<span class="number">6</span>];</span><br><span class="line">    __u8  oobbuf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写页数据，512个字节</span></span><br><span class="line">    error = write(outFile,data,<span class="number">512</span>);</span><br><span class="line">    <span class="keyword">if</span>(error &lt; <span class="number">0</span>) <span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//构造tag</span></span><br><span class="line">    etags.chunkId = chunkId;</span><br><span class="line">    etags.serialNumber = <span class="number">0</span>;</span><br><span class="line">    etags.byteCount = nBytes;</span><br><span class="line">    etags.objectId = objId;</span><br><span class="line">    etags.chunkDeleted = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//重定位oob区中的可用数据（称为tag）</span></span><br><span class="line">    yaffs_PackTags1(&amp;pt1,&amp;etags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//计算tag本身的ECC码</span></span><br><span class="line">    yaffs_CalcTagsECC((yaffs_Tags *)&amp;pt1);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(oobbuf,<span class="number">0xff</span>,<span class="number">16</span>);</span><br><span class="line">    <span class="built_in">memcpy</span>(oobbuf+<span class="number">8</span>,&amp;pt1,<span class="number">8</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//使用与内核MTD层相同的计算方法一页数据（5124字节）的ECC码，并把它们填入oob</span></span><br><span class="line">    nand_calculate_ecc(data,&amp;ecc_code[<span class="number">0</span>]);</span><br><span class="line">    nand_calculate_ecc(data+<span class="number">256</span>,&amp;ecc_code[<span class="number">3</span>]);</span><br><span class="line"></span><br><span class="line">    oobbuf[<span class="number">0</span>] = ecc_code[<span class="number">0</span>];</span><br><span class="line">    oobbuf[<span class="number">1</span>] = ecc_code[<span class="number">1</span>];</span><br><span class="line">    oobbuf[<span class="number">2</span>] = ecc_code[<span class="number">2</span>];</span><br><span class="line">    oobbuf[<span class="number">3</span>] = ecc_code[<span class="number">3</span>];</span><br><span class="line">    oobbuf[<span class="number">4</span>] = ecc_code[<span class="number">4</span>];</span><br><span class="line">    oobbuf[<span class="number">6</span>] = ecc_code[<span class="number">6</span>];</span><br><span class="line">    oobbuf[<span class="number">7</span>] = ecc_code[<span class="number">7</span>];</span><br><span class="line"></span><br><span class="line">    nPages++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//写oob数据，169字节</span></span><br><span class="line">    <span class="keyword">return</span> write(outFile,oobbuf,<span class="number">16</span>);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>值得注意的是，第20行设置新tag结构中增加的chunkDeleted成员；第32-41行将计算出来的ECC码填入新的ECC位置，它正是nand_oob_16结构的eccpos数组定义的位置。<br>其中第32、33行的nand_calculate_ecc函数是从内核源文件drivers&#x2F;mtd&#x2F;nand&#x2F;nand_ecc.c修改而来；在&#x2F;work&#x2F;system&#x2F;Development&#x2F;yaffs2&#x2F;utils目录下新建一个同名文件nand_ecc.c，把内核文件nand_ecc.c的nand_calculate_ecc函数、函数中用到的nand_ecc_precalc_table数组摘出来；并去除函数中的第一个形参“struct mtd_info *mtd”。<br>③添加文件，修改Makefile<br>第23行的yaffs_PackTags1函数在上一层目录yaffs_packedtags1.c中定义，先将这个文件复制到当前目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cp ../yaffs_packedtags1.c ./</span><br></pre></td></tr></table></figure>
<p>另外，nand_calculate_ecc函数是在新加的nand_ecc.c中定义的，所以要修改Makefile，把yaffs_packedtags1.c和nand_ecc.c也编译进mkyaffsimage工具中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">修改前：</span><br><span class="line">MKYAFFSSOURCES = mkyaffsimage.c</span><br><span class="line">修改后：</span><br><span class="line">MKYAFFSSOURCES = mkyaffsimage.c yaffs_packedtags1.c nand_ecc.c</span><br></pre></td></tr></table></figure>
<p>现在，在&#x2F;work&#x2F;system&#x2F;Development&#x2F;yaffs2&#x2F;utils目录下执行“make”命令生成mkyaffsimage工具，将它复制到&#x2F;usr&#x2F;local&#x2F;bin目录。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo cp mkyaffsimage /usr/local/bin</span><br><span class="line">sudo chmod +x /usr/local/bin/mkyaffsimage</span><br></pre></td></tr></table></figure>

<h4 id="制作-x2F-烧写yaffs映像文件"><a href="#制作-x2F-烧写yaffs映像文件" class="headerlink" title="制作&#x2F;烧写yaffs映像文件"></a>制作&#x2F;烧写yaffs映像文件</h4><p>使用如下命令将&#x2F;work&#x2F;nfs_root&#x2F;fs_mini目录制作为fs_mini.yaffs文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/nfs_root</span><br><span class="line">mkyaffsimage fs_mini fs_mini.yaffs</span><br></pre></td></tr></table></figure>
<p>将fs_mini.yaffs放入tftp目录或nfs目录后，在U-Boot界面就可以下载、烧入NAND Flash中，操作命令如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tftp 0x30000000 fs_mini.yaffs 或 nfs 0x30000000 192.168.1.57:/work/nfs_root/fs_mini.yaffs</span><br><span class="line">nand erase 0xA00000 0x3600000</span><br><span class="line">nand write.yaffs 0x30000000 0xA00000 $(filesize)</span><br></pre></td></tr></table></figure>
<p>现在可以修改命令行参数以MTD2分区作为根文件系统，比如在U-Boot控制界面如下设置：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set bootargs noinitrd console=ttySAC0 root=/dev/mtdblock2 rootfstype=yaffs</span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第3篇第17章 构建Linux根文件系统</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>根文件系统</tag>
        <tag>Rootfs移植</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux异常处理体系结构</title>
    <url>/2022/09/24/Linux%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux设备驱动开发之Linux异常处理体系结构</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第20章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解Linux异常处理体系结构</li>
<li>掌握Linux中断处理体系结构，了解几种重要的数据结构</li>
<li>学习中断处理函数的注册、处理、卸载流程</li>
<li>掌握在驱动程序中使用中断的方法</li>
</ol>
<h1 id="Linux异常处理体系结构概述"><a href="#Linux异常处理体系结构概述" class="headerlink" title="Linux异常处理体系结构概述"></a>Linux异常处理体系结构概述</h1><h2 id="Linux异常处理的层次结构"><a href="#Linux异常处理的层次结构" class="headerlink" title="Linux异常处理的层次结构"></a>Linux异常处理的层次结构</h2><p>内核的中断处理结构有很好的扩充性，并适当屏蔽了一些实现细节。但是开发人员一个深入“黑盒子”了解其中的实现原理。</p>
<h3 id="异常的作用"><a href="#异常的作用" class="headerlink" title="异常的作用"></a>异常的作用</h3><p>异常，就是可以打断CPU正常运行流程的一些事情，比如外部中断、未定义的指令、视图修改只读的数据、执行swi（软中断）指令等。当这些事情发生时，CPU暂停当前的程序，先处理异常事件，然后再继续执行被中断地程序。操作系统中经常通过异常来完成一些特定地功能。</p>
<ol>
<li>当CPU执行未定义的机器指令将触发“未定义指令异常”，操作系统可以利用这个特点使用一些自定义的机器指令，它们在异常处理函数中实现。</li>
<li>可以将一块数据设为只读的，然后提供给多个进程使用，这样可以节省内存。当某个进程视图修改其中的数据时，将触发“数据访问中止异常”，在异常处理函数中将这块数据复制出一份可写的副本，提供给这个进程使用。</li>
<li>当用户程序试图读写的数据或执行的指令不在内存中，也会触发一个“数据访问中止异常”或“指令预取中止异常”，在异常处理函数中将这些数据或指令读入内存（内存不足时还可以将不使用的数据、指令换出内存），然后重新执行被中断的程序。这样可以节省内存，还使得操作系统可以运行这类程序：它们使用的内存远大于实际的物理内存。</li>
<li>当程序使用不对齐的地址访问内存时，也会触发“数据访问中止异常”，在异常处理程序中先使用多个对齐的地址读出数据；对于读操作，从中选取数据组合好后返回给被中断的程序；对于写操作，修改其中的部分数据后再写入内存。这使得程序（特别是应用程序）不用考虑地址对齐的问题。</li>
<li>应用程序可以通过“swi”指令触发“swi异常”，操作系统在swi异常处理函数中实现各种系统调用。</li>
</ol>
<h3 id="Linux内核对异常的设置"><a href="#Linux内核对异常的设置" class="headerlink" title="Linux内核对异常的设置"></a>Linux内核对异常的设置</h3><p>内核在<code>start_kernel</code>函数中调用<code>trap_init</code>、<code>init_IRQ</code>两个函数来设置异常的处理函数。</p>
<h4 id="trap-init函数分析"><a href="#trap-init函数分析" class="headerlink" title="trap_init函数分析"></a>trap_init函数分析</h4><p><code>trap_init</code>函数（<code>arch/arm/kernel/trap.c</code>）被用来设置各种异常的处理向量，包括中断向量。所谓向量，就是一些被安放在固定位置的代码，当发生异常时，CPU会自动执行这些固定位置上的指令。ARM架构的CPU的异常向量基址可以是0x00000000，也可以是0xffff0000，Linux内核使用后者。<code>trap_init</code>函数将异常向量复制到0xffff0000处，部分代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">trap_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *)vectors,__vectors_start,__vectors_end - __vectors-start);</span><br><span class="line">    <span class="built_in">memcpy</span>((<span class="type">void</span> *)vectors + <span class="number">0x200</span>,__stubs_start,__stubs_end - __stubs_start);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第4行中，vectors等于0xffff0000。地址__vectors_start-_vectors_end之间的代码就是异常向量，在<code>arch/arm/kernel/entry-armv.S</code>中定义，它们被复制到地址0xffff0000处。<br>异常向量的代码很简单，它们只是一些跳转指令。发生异常时，CPU自动执行这些指令，跳转去执行更复杂的代码，比如保存被中断程序的执行环境，调用异常处理函数，恢复被中断程序的执行环境并重新运行。这些“更复杂的代码”在地址__stubs_start-__stubs_end之间，它们在<code>arch/arm/kernel/entry-armv.S</code>中定义。第5行将它们复制到地址0xffff0000+0x200处。<br>异常向量跳去执行的代码都是使用汇编写的，为给读者一个形象概念，下面讲解部分代码，他们在<code>arch/zarm/kernel/entry-armv.S</code>中。<br>异常向量的代码如下，其中的“stubs_offset”用来重新定位跳转的位置（向量被复制到地址0xffff0000处，跳转的目的代码被复制到地址0xffff0000+0x200处）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.equ	stubs_offset, __vectors_start + 0x200 - __stubs_start</span><br><span class="line"></span><br><span class="line">	.globl	__vectors_start</span><br><span class="line">__vectors_start:</span><br><span class="line">	swi	SYS_ERROR0                              //复位时，CPU将执行这条指令</span><br><span class="line">	b	vector_und + stubs_offset               //未定义异常时，CPU将执行这条指令</span><br><span class="line">	ldr	pc, .LCvswi + stubs_offset              //swi异常</span><br><span class="line">	b	vector_pabt + stubs_offset              //指令预取中止</span><br><span class="line">	b	vector_dabt + stubs_offset              //数据访问中止</span><br><span class="line">	b	vector_addrexcptn + stubs_offset        //没有用到</span><br><span class="line">	b	vector_irq + stubs_offset               //irq异常</span><br><span class="line">	b	vector_fiq + stubs_offset               //fiq异常</span><br><span class="line"></span><br><span class="line">	.globl	__vectors_end</span><br><span class="line">__vectors_end:</span><br></pre></td></tr></table></figure>
<p>其中的vector_und、vector_pabt等表示要跳转去执行的代码。以vector_und为例，它仍在<code>arch/arm/kernel/entry-armv.S</code>中，通过vector_stub宏来定义，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">vector_stub	und, UND_MODE</span><br><span class="line"></span><br><span class="line">.long	__und_usr			    @  0 (USR_26 / USR_32) 在用户模式执行了未定义的指令</span><br><span class="line">.long	__und_invalid			@  1 (FIQ_26 / FIQ_32) 在FIQ模式执行了未定义的指令</span><br><span class="line">.long	__und_invalid			@  2 (IRQ_26 / IRQ_32) 在IRQ模式执行了未定义的指令</span><br><span class="line">.long	__und_svc			    @  3 (SVC_26 / SVC_32) 在管理模式执行了未定义的指令</span><br><span class="line">.long	__und_invalid			@  4</span><br><span class="line">.long	__und_invalid			@  5</span><br><span class="line">.long	__und_invalid			@  6</span><br><span class="line">.long	__und_invalid			@  7</span><br><span class="line">.long	__und_invalid			@  8</span><br><span class="line">.long	__und_invalid			@  9</span><br><span class="line">.long	__und_invalid			@  a</span><br><span class="line">.long	__und_invalid			@  b</span><br><span class="line">.long	__und_invalid			@  c</span><br><span class="line">.long	__und_invalid			@  d</span><br><span class="line">.long	__und_invalid			@  e</span><br><span class="line">.long	__und_invalid			@  f</span><br></pre></td></tr></table></figure>
<p>第1行的vector_stub是一个宏，它根据后面的参数“und,UND_MODE”定义了以“vector_und”为标号的一段代码。vector_stub宏的功能为：计算处理完异常后的返回地址、保存一些寄存器（比如r0、lr、spsr），然后进入管理模式，最后根据被中断的工作模式调用第3-18行中的某个跳转分支。当发生异常时，CPU会根据异常的类型进入某个工作模式，但是很快vector_stub宏又会强制CPU进入管理模式，在管理模式下进行后续处理，这种方法简化了程序设计，使得异常发生前的工作模式要么是用户模式，要么是管理模式。<br>第3-18行中的代码表示在各个工作模式中执行未定义指令时，发生的异常的处理分支。比如第3行的<code>__und_usr</code>表示在用户模式下执行未定义指令时，所发生的未定义异常将由它来处理；第6行的<code>__und_svc</code>表示在管理模式下执行未定义指令，所发生的异常将由它来处理。在其他工作模式下不可能发生未定义指令异常，否则使用<code>__und_invalid</code>来处理错误。ARM架构CPU中使用4位数据表示工作模式（目前只有7种工作模式），所有共有16个跳转分支。<br>不同的跳转分支（比如<code>__und_usr</code>、<code>__und_svc</code>）只是在它们的入口处（比如保存被中断程序的寄存器）稍有差别，后续的处理大体相同，都是调用相应的C函数。比如未定义指令异常发生时，最终会调用C函数<code>do_undefinstr</code>函数进行处理。各种的异常C处理函数可以分为5类，它们分布在不同的文件种。</p>
<ol>
<li>在<code>arch/arm/kernel/traps.c</code>中<br>未定义指令异常的C处理函数在这个文件中定义，总入口函数为<code>do_undefinstr</code>。</li>
<li>在<code>arch/arm/mm/fault.c</code>中<br>与内存访问相关的异常的C处理函数在这个文件中定义，比如数据访问中止异常、指令预取中止异常。总入口函数为<code>do_DataAbort</code>、<code>do_PrefetchAbort</code>。</li>
<li>在<code>arch/arm/mm/irq.c</code>中<br>中断处理函数的这个文件中定义，总入口函数为<code>asm_do_IRQ</code>，它调用其他文件注册的中断处理函数。</li>
<li>在<code>arch/arm/kernel/calls.S</code>中<br>在这个文件中，swi异常的处理函数被组织成一个表格；swi指令机器码的位[23:0]被用来作为索引。这样，通过不同的“swi index”指令就可以调用不同的swi异常处理函数，它们被称为系统调用，比如<code>sys_open、sys_read、sys_write</code>。</li>
<li>没有使用的异常<br>在Linux 2.6.22.6中没有使用FIQ异常。<br><code>trap_init</code>函数搭建了各类异常的处理框架。当发生异常时，各种C处理函数会被调用。这些C函数还要进一步细分异常发生的情况，分别调用更具体的处理函数。比如未定义指令异常的C处理函数总入口为<code>do_undefinstr</code>，这个函数里还要根据具体的未定义指令调用它的模拟函数。<br>除了中断外，内核已经为各类异常准备了细致而完备的处理函数，比如swi异常处理函数为每一种系统调用都准备了一个<code>sys_</code>开头函数，数据访问中止异常的处理函数为对齐错误、页权限错误、段翻译错误等具体异常都准备了相应的处理函数。这些异常的处理函数与开发板的配置无关，基本不用修改。</li>
</ol>
<h4 id="init-IRQ-函数分析"><a href="#init-IRQ-函数分析" class="headerlink" title="init_IRQ 函数分析"></a>init_IRQ 函数分析</h4><p>中断也是一种异常，之所以把它单独提出来，是因为中断的处理与具体开发板密切相关，除一些必须、共用的中断（系统时钟中断、片内外设UART中断）外，必须由驱动开发者提供处理函数。内核提炼出中断处理的共性，搭建了一个非常容易扩充的中断处理体系。<br>init_IRQ函数（代码在<code>arch/arm/kernel/irq.c</code>中）被用来初始化中断的处理框架，设置各种中断的默认处理函数。当发生中断时，中断总入口函数<code>asm_do_IRQ</code>就可以调用这些函数作进一步处理。<br>下图为异常处理体结构：<br><img src="/2022/09/24/Linux%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/1.jpeg" alt="img not found"></p>
<h2 id="常见的异常"><a href="#常见的异常" class="headerlink" title="常见的异常"></a>常见的异常</h2><p>ARM架构Linux内核中，只用到了5种异常，在它们的处理函数中进一步细分发生这些异常的原因。</p>
<table>
<thead>
<tr>
<th>异常总类</th>
<th>异常细分</th>
</tr>
</thead>
<tbody><tr>
<td>未定义指令异常</td>
<td>ARM 指令break <br> Thumb 指令break<br>ARM 指令mrc</td>
</tr>
<tr>
<td>指令预取中止异常</td>
<td>取值时地址翻译错误（translation fault），系统中还没有为这个指令建立映射关系</td>
</tr>
<tr>
<td>数据访问中止异常</td>
<td>访问数据时段地址翻译错误（section translation fault）<br>访问数据时页地址翻译错误（page translation fault）<br>地址对齐错误<br>段权限错误（section permission fault）<br>页权限错误（page permission fault）<br>…</td>
</tr>
<tr>
<td>中断异常</td>
<td>GPIO中断、WDT中断、定时器中断、USB中断、UART中断等</td>
</tr>
<tr>
<td>swi异常</td>
<td>各类下图调用 <code>sys_open、sys_read、sys_write</code>等</td>
</tr>
</tbody></table>
<h1 id="Linux-中断处理体系结构"><a href="#Linux-中断处理体系结构" class="headerlink" title="Linux 中断处理体系结构"></a>Linux 中断处理体系结构</h1><h2 id="中断处理体系结构的初始化"><a href="#中断处理体系结构的初始化" class="headerlink" title="中断处理体系结构的初始化"></a>中断处理体系结构的初始化</h2><h3 id="中断处理体系结构"><a href="#中断处理体系结构" class="headerlink" title="中断处理体系结构"></a>中断处理体系结构</h3><p>Linux内核将所有的中断统一编号，使用一个irq_desc结构数组来描述这些中断：每个数组项对应一个中断（也有可能是一组中断，它们共用相同的中断号），里面记录了中断的名称、中断状态、中断标记（比如中断类型、是否共享中断等），并提供了中断的底层硬件访问函数（清除、屏蔽、使能中断），提供了这个中断的处理函数入口，通过它可以调用用户注册的中断处理函数。<br>通过irq_desc结构数组就可以了解中断处理体系结构，irq_desc结构的数组类型在<code>include/linux/irq.h</code>中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> &#123;</span></span><br><span class="line">	<span class="type">irq_flow_handler_t</span>	handle_irq; <span class="comment">//当前中断的处理函数入口</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span>		*<span class="title">chip</span>;</span>      <span class="comment">//底层的硬件访问</span></span><br><span class="line">...</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span>	*<span class="title">action</span>;</span>	<span class="comment">/* 用户提供的中断处理函数链表 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span>		status;		<span class="comment">/* IRQ状态 */</span></span><br><span class="line">...</span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>		*name;          <span class="comment">//中断名称</span></span><br><span class="line">&#125; ____cacheline_internodealigned_in_smp;</span><br></pre></td></tr></table></figure>
<p>第2行的<code>handle_irq</code>是这个或这组中断的处理函数入口。发生中断时，总入口函数<code>asm_do_IRQ</code>将根据中断号调用相应<code>irq_desc</code>数组项中的<code>handle_irq</code>。<code>handle_irq</code>使用chip结构中的函数来清除、屏蔽或者重新使能中断，还一一调用用户在actions链表中注册的中断处理函数。<br>第3行的irq_chip结构类型也是在<code>include/linux/irq.h</code>中定义，其中的成员大多用于操作底层硬件，比如设置寄存器以屏蔽中断、使能中断、清除中断等。这个结构的部分成员如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irq_chip</span> &#123;</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span>	*name;</span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">int</span>	<span class="params">(*startup)</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;           <span class="comment">//启动中断，如果不设置，缺省为“enable”</span></span><br><span class="line">	<span class="type">void</span>		(*shutdown)(<span class="type">unsigned</span> <span class="type">int</span> irq);              <span class="comment">//关闭中断，如果不设置，缺省为“disable”</span></span><br><span class="line">	<span class="type">void</span>		(*enable)(<span class="type">unsigned</span> <span class="type">int</span> irq);                <span class="comment">//使能中断，如果不设置，缺省为“unmask”</span></span><br><span class="line">	<span class="type">void</span>		(*disable)(<span class="type">unsigned</span> <span class="type">int</span> irq);               <span class="comment">//禁止中断，如果不设置，缺省为“mask”</span></span><br><span class="line"></span><br><span class="line">	<span class="type">void</span>		(*ack)(<span class="type">unsigned</span> <span class="type">int</span> irq);                   <span class="comment">//响应中断，通常是清除当前中断使得可以接收下一个中断</span></span><br><span class="line">	<span class="type">void</span>		(*mask)(<span class="type">unsigned</span> <span class="type">int</span> irq);                  <span class="comment">//屏蔽中断源</span></span><br><span class="line">	<span class="type">void</span>		(*mask_ack)(<span class="type">unsigned</span> <span class="type">int</span> irq);              <span class="comment">//屏蔽和响应中断</span></span><br><span class="line">	<span class="type">void</span>		(*unmask)(<span class="type">unsigned</span> <span class="type">int</span> irq);                <span class="comment">//开启中断源</span></span><br><span class="line">...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>irq_desc结构中第5行的irqaction结构类型在<code>include/linux/interrupt.h</code>中定义。用户注册的每个中断处理函数用一个irqaction结构来表示，一个中断（比如共享中断）可以有多个处理函数，它们的irqaction结构链接成一个链表，以action为表头。irq_desc结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> &#123;</span></span><br><span class="line">	<span class="type">irq_handler_t</span> handler;              <span class="comment">//用户注册的中断处理函数</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;                <span class="comment">//中断标志，比如是否共享中断、电平触发还是边沿触发</span></span><br><span class="line">	<span class="type">cpumask_t</span> mask;                     <span class="comment">//用于SMP（对称多处理系统）</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;                   <span class="comment">//用户注册的中断名字，“cat /proc/interrupts”时可以看到</span></span><br><span class="line">	<span class="type">void</span> *dev_id;                       <span class="comment">//用户传给上面的handler的参数，还可以用来区分共享中断</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irqaction</span> *<span class="title">next</span>;</span>             </span><br><span class="line">	<span class="type">int</span> irq;                            <span class="comment">//中断号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">proc_dir_entry</span> *<span class="title">dir</span>;</span>         </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>irq_desc结构数组、它的成员<code>struct irq_chip  *chip</code>、<code>struct irqaction   *action</code>，这3种数据结构成了中断处理体系的框架。这3者的关系如图所示：<br><img src="/2022/09/24/Linux%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/2.jpeg" alt="img not found"><br>中断的处理流程如下：</p>
<ol>
<li>发生中断时，CPU执行异常向量vector_irq的代码</li>
<li>在vector_irq里面，最终会调用中断处理的总入口函数的代码</li>
<li><code>asm_do_IRQ</code>根据中断号调用irq_desc数组项中的<code>handle_irq</code></li>
<li><code>handle_irq</code>会使用chip成员中的函数来设置硬件，比如清除中断、禁止中断、重新使能中断。</li>
<li><code>handle_irq</code>逐个调用用户在action链表中注册的处理函数<br>可见，中断体系结构的初始化就是构造这些数据结构，比如irq_desc数组项中的<code>handle_irq</code>、chip等成员；用户注册中断时就是构造action链表；用户卸载中断时就是从action链表中去除不需要的项。</li>
</ol>
<h3 id="中断处理体系结构的初始化-1"><a href="#中断处理体系结构的初始化-1" class="headerlink" title="中断处理体系结构的初始化"></a>中断处理体系结构的初始化</h3><p><code>init_IRQ</code>函数被用来初始化中断处理体系结构，代码在<code>arch/arm/kernel/irq.c</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">init_IRQ</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> irq;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (irq = <span class="number">0</span>; irq &lt; NR_IRQS; irq++)</span><br><span class="line">		irq_desc[irq].status |= IRQ_NOREQUEST | IRQ_NOPROBE;</span><br><span class="line">...</span><br><span class="line">	init_arch_irq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第5-6行初始化irq_desc结构数组中每一项的中断状态。<br>第8行调用架构相关的中断初始化函数。对于S3C2410、S3C2440开发板，这个函数就是s3c24xx_init_irq，移植Linux内核时讲述的machine_desc结构中的init_irq成员就是指向这个函数。<br>s3c24xx_init_irq函数在<code>arch/arm/plat-s3c24xx/irq.c</code>中定义，它为所有的中断设置了芯片相关的数据结构（<code>irq_desc[irq].chip</code>），设置了处理函数入口（<code>irq_desc[irq].handle_irq</code>）。以外部中断EINT4-EINT23为例，用来设置它们的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(irqno = IRQ_EINT4; irqno &lt;= IRQ_EINT23; irqno++) &#123;</span><br><span class="line">    irqdbf(<span class="string">&quot;registering irq %d (extended s3c irq)\n&quot;</span>,irqno);</span><br><span class="line">    set_irq_chip(irqno, &amp;s3c_irqext_chip);</span><br><span class="line">    set_irq_handler(irqno, handle_edge_irq);</span><br><span class="line">    set_irq_flags(irqno, IRQF_VALID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>set_irq_chip</code>的作用就是<code>irq_desc[irqno].chip = &amp;s3c_irqext_chip</code>。以后就可以通过<code>irq_desc[irqno].chip</code>结构中的函数指针设置这些外部中断的触发方式（电平触发、边沿触发等）、使能中断、禁止中断等。<br>第4行设置这些中断的处理函数入口为<code>handle_edge_irq</code>，即<code>irq_desc[irqno].handle_irq = handle_edge_irq</code>。发生中断时，<code>handle_edge_irq</code>函数会调用用户注册的具体处理函数。<br>第5行设置中断标志为“IRQF_VALID”，表示可以使用它们。</p>
<h2 id="用户注册中断处理函数的过程"><a href="#用户注册中断处理函数的过程" class="headerlink" title="用户注册中断处理函数的过程"></a>用户注册中断处理函数的过程</h2><p>用户（即驱动程序）通过<code>request_irq</code>函数向内核注册中断处理函数，<code>request_irq</code>函数根据中断号找到irq_desc数组项，然后在它的action链表中添加一个表项。<br><code>request_irq</code>函数在<code>kernel/irq/manage.c</code>中定义，函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">irq_handle_t</span> handler, <span class="type">unsigned</span> <span class="type">long</span> irqflags, <span class="type">const</span> <span class="type">char</span> *devname, <span class="type">void</span> *dev_id)</span></span><br></pre></td></tr></table></figure>
<p><code>request_irq</code>函数首先使用这4个参数构造一个irqaction结构，然后调用<code>setup_irq</code>函数将它链入链表中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">	action = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> irqaction), GFP_ATOMIC);</span><br><span class="line">...</span><br><span class="line">	action-&gt;handler = handler;</span><br><span class="line">	action-&gt;flags = irqflags;</span><br><span class="line">	cpus_clear(action-&gt;mask);</span><br><span class="line">	action-&gt;name = devname;</span><br><span class="line">	action-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	action-&gt;dev_id = dev_id;</span><br><span class="line">...</span><br><span class="line">	retval = setup_irq(irq, action);</span><br></pre></td></tr></table></figure>
<p><code>setup_irq</code>函数也是在<code>kernel/irq/manage.c</code>中定义，它完成如下3个功能</p>
<ol>
<li>将新建的irqaction结构链入irq_desc[irq]结构的action链表中，有两种可能。<br> ①如果action链表为空，则直接链入。<br> ②否则先判断新建的irqaction结构和链表中的irqaction结构所表示的中断类型是否一致，即是否都声明为“可共享的”（IRQF_SHARED）、是否都使用相同的触发方式（电平、边沿、极性），如果一致，则将新建的irqaction结构链入。</li>
<li>设置irq_desc[irq]结构中chip成员的还没设置的指针，让它们指向一些默认函数<br>这通过<code>irq_chip_set_defaults</code>函数来完成，它在<code>kernel/irq/chip.c</code>中定义。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">irq_chip_set_defaults</span><span class="params">(<span class="keyword">struct</span> irq_chip *chip)</span></span><br><span class="line"> &#123;</span><br><span class="line">     <span class="keyword">if</span> (!chip-&gt;enable)</span><br><span class="line">         chip-&gt;enable = default_enable;          <span class="comment">//它调用chip-&gt;unmask</span></span><br><span class="line">     <span class="keyword">if</span> (!chip-&gt;disable)</span><br><span class="line">         chip-&gt;disable = default_disable;        <span class="comment">//此函数为空</span></span><br><span class="line">     <span class="keyword">if</span> (!chip-&gt;startup)</span><br><span class="line">         chip-&gt;startup = default_startup;        <span class="comment">//它调用chip-&gt;enable</span></span><br><span class="line">     <span class="keyword">if</span> (!chip-&gt;shutdown)</span><br><span class="line">         chip-&gt;shutdown = chip-&gt;disable;</span><br><span class="line">     <span class="keyword">if</span> (!chip-&gt;name)</span><br><span class="line">         chip-&gt;name = chip-&gt;typename;</span><br><span class="line">     <span class="keyword">if</span> (!chip-&gt;end)</span><br><span class="line">         chip-&gt;end = dummy_irq_chip.end;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li>
<li>设置中断的触发方式<br>如果<code>request_irq</code>函数中传入的irqflags参数表示中断的触发方式为高电平触发、低电平触发、上升沿触发或下降沿触发，则调用irq_desc[irq]结构中的chip-&gt;set_type成员函数来进行设置：设置引脚功能为外部中断，设置中断触发方式。</li>
<li>启动中断<br>如果irq_desc[irq]结构中status成员没有指明为IRQ_NOAUTOEN（表示注册中断时不要使能中断），还要调用chip-&gt;startup或chip-&gt;enable来启动中断。所谓启动中断通常就是使能中断。</li>
</ol>
<p>一般来说，只有那些“可以自动使能的”中断对应irq_desc[irq].status才会被指明为IRQ_NOAUTOEN。所以，无论哪种情况，执行request_irq注册中断之后，这个中断就已经被使能了，在编写驱动程序时要注意这点。<br>总结一下使用<code>request_irq</code>函数注册中断后的“成果”。<br>①irq_desc[irq]结构中的action链表中已经链入了用户注册的中断处理函数<br>②中断的触发方式已经被设置好<br>③中断已经被使能<br>总之，执行<code>irq_request</code>函数之后，中断就可以发生并能够被处理了。</p>
<h2 id="中断的处理过程"><a href="#中断的处理过程" class="headerlink" title="中断的处理过程"></a>中断的处理过程</h2><p><code>asm_do_IRQ</code>是中断的C语言总入口函数，它在<code>arch/arm/kernel/irq.c</code>中定义，部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">void</span> __exception <span class="title function_">asm_do_IRQ</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> pt_regs *regs)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pt_regs</span> *<span class="title">old_regs</span> =</span> set_irq_regs(regs);</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">irq_desc</span> *<span class="title">desc</span> =</span> irq_desc + irq;</span><br><span class="line">...</span><br><span class="line">	desc_handle_irq(irq, desc);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第6行的<code>desc_handle_irq</code>函数直接调用desc结构中的handle_irq成员函数，它就是irq_desc[irq].handle_irq。<br>需要说明的是，asm_do_IRQ函数中参数irq的取值范围为IRQ_EINT0-(IRQ_EINT0 + 31)，只有32个取值。它可能是一个实际中断的中断号，也可能是一组中断的中断号。这是由S3C2410、S3C2440的芯片特性决定的：发生中断时INTPND寄存器的某一位被置1，INTOFFSET寄存器中记录了是哪一位（0-31），中断向量调用<code>asm_do_IRQ</code>之前根据INTOFFSET寄存器的值确定irq参数。每一个实际的中断在irq_desc数组中都有一项与它对应，它们的数目不止32。当<code>asm_do_IRQ</code>函数中参数irq表示的是一组中断时，irq_desc[irqno].handle_irq来进一步处理。<br>以外部中断EINT8-EINT32为例，它们通常是边沿触发。</p>
<ol>
<li>它们被触发时，INTOFFSET寄存器中的值都是5，<code>asm_do_IRQ</code>函数中参数irq的值为<code>IRQ_EINT0 + 5</code>，即<code>IRQ_EINT8t23</code>。上面代码中第6行将调用<code>irq_desc[IRQ_EINT8t23].handle_irq</code>来进行处理。</li>
<li><code>irq_desc[IRQ_EINT8t23].handle_irq</code>在前面<code>init_IRQ</code>函数初始化中断体系结构的时候被设为<code>s3c_irq_demux_extint8</code>。</li>
<li><code>s3c_irq_demux_extint8</code>函数的代码在<code>arch/arm/plat-s3c24xx/irq.c</code>中，它首先读取EINTPND、EINTMASK寄存器，确定发生了哪些中断，重新计算它们的中断号，然后调用irq_desc数组项中的handle_irq成员函数。<br> 代码如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">s3c_irq_demux_extint8</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">            <span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eintpnd = __raw_readl(S3C24XX_EINTPEND);      <span class="comment">//EINT8-EINT23发生时，相应位被置1</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> eintmsk = __raw_readl(S3C24XX_EINTMASK);      <span class="comment">//屏蔽寄存器</span></span><br><span class="line"></span><br><span class="line">    eintpnd &amp;= ~eintmsk;                                        <span class="comment">//清除被屏蔽的位</span></span><br><span class="line">    eintpnd &amp;= ~<span class="number">0xff</span>;	                                        <span class="comment">//清除低8位（EINT8对应位8,...）</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 循环处理所有的子中断 */</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (eintpnd) &#123;</span><br><span class="line">        irq = __ffs(eintpnd);                                   <span class="comment">//确定eintpnd中为1的最高位</span></span><br><span class="line">        eintpnd &amp;= ~(<span class="number">1</span>&lt;&lt;irq);                                   <span class="comment">//将此位清0</span></span><br><span class="line"></span><br><span class="line">        irq += (IRQ_EINT4 - <span class="number">4</span>);                                 <span class="comment">//重新计算中断号，前面计算出irq等于8时，中断号为IRQ_EINT8</span></span><br><span class="line">        desc_handle_irq(irq, irq_desc + irq);                   <span class="comment">//调用这个中断的真正的处理函数入口</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>IRQ_EINT8-IRQ_EINT23这几个中断的处理函数入口，在<code>init_IRQ</code>函数初始化中断体系结构的时候已经被设置为<code>handle_edge_irq</code>函数。上面第185行的代码就是调用这个函数，它在<code>kernel/irq/chip.c</code>中定义。从它的名字可以知道，它用来处理边沿触发的中断（处理电平触发的中断为<code>handle_level_irq</code>）。以下的讲解中，只关心一般的的情形，忽略有关中断嵌套的代码，部分代码如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> fastcall</span><br><span class="line"><span class="title function_">handle_edge_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    kstat_cpu(cpu).irqs[irq]++;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* Start handling the irq*/</span></span><br><span class="line">    desc-&gt;chip-&gt;ack(irq);</span><br><span class="line">    ...</span><br><span class="line">    action_ret = handle_IRQ_event(irq, event);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 第5行用来统计中断发生的次数。<br> 第8行响应中断，通常是清除当前中断使得可以接收下一个中断。对于IRQ_EINT8-IRQ_EINT23这几个中断，desc-&gt;chip在前面<code>init_IRQ</code>函数初始化中断体系结构的时候被设为s3c_irqext_chip。desc-&gt;chip-&gt;ack就是<code>s3c_extirq_ack</code>函数，它用来清除中断。<br> 第10行通过<code>handle_IRQ_event</code>函数来逐个执行action链表中用户注册的中断处理函数，它在<code>kernel/irq/handle.c</code>中定义，关键代码如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    ret = action-&gt;handler(irq, action-&gt;dev_id); <span class="comment">//执行用户注册的中断处理函数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ret == IRQ_HANDLED)</span><br><span class="line">        statue |= action-&gt;flags;</span><br><span class="line">    retval |= ret;</span><br><span class="line">    action = action-&gt;next;                      <span class="comment">//下一个</span></span><br><span class="line">&#125;<span class="keyword">while</span>(action);</span><br></pre></td></tr></table></figure>
 从第2行可以知道，用户注册的中断处理函数的参数为中断号irq、action-&gt;dev_id。后一个参数是通过request_irq函数注册中断时传入的dev_id参数。它由用户自己指定、自己使用，可以为空，当这个中断是“共享中断”除外。<br> 对于电平触发的中断，它们的irq_desc[irq].handle_irq通常是<code>handle_level_irq</code>函数。它也是在<code>kernel/irq/chip.c</code>中定义，其功能与上述<code>handle_edge_irq</code>函数相似，关键代码如下： <figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> fastcall</span><br><span class="line"><span class="title function_">handle_level_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="keyword">struct</span> irq_desc *desc)</span></span><br><span class="line">&#123;</span><br><span class="line">    ...</span><br><span class="line">    mask_ack_irq(desc, irq);</span><br><span class="line">    ...</span><br><span class="line">    kstat_cpu(cpu).irqs[irq]++;</span><br><span class="line">    ...</span><br><span class="line">    action_ret = handle_IRQ_event(irq, action);</span><br><span class="line">    ...</span><br><span class="line">    desc-&gt;chip-&gt;unmask(irq);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
 第5行用来屏蔽和响应中断，响应中断通常就是清除中断，使得可以接收下一个中断。<br> 第7行用来统计中断发生的次数。<br> 第9行通过<code>handle_IRQ_event</code>函数来逐个执action链表中用户注册的中断处理函数。<br> 第11行开启中断，与第5行对应。<br> 在<code>handle_edge_irq</code>、<code>handle_level_irq</code>函数的开头都清除了中断。所以一般来说，在用户注册的中断函数中就不用再次清除中断了。但是对于电平触发的中断也有例外：虽然<code>handle_level_irq</code>函数已经清除了中断，但是它只限于清除SoC内部的信号；如果外设输入到SoC的中断信号仍然有效，这就会导致当前中断处理完毕后，会误认为再次发生了中断。对于这种情况，需要在用户注册的最大处理函数中清除中断：先清除外设的中断，然后再清除SoC内部的中断信号。<br> 忽略上述的中断号重新计算过程，中断的处理流程可以总结如下：<br> ①中断向量调用总入口函数<code>asm_do_IRQ</code>，传入中断号irq。<br> ②<code>asm_do_IRQ</code>函数根据中断号irq调用irq_desc[irq].handle_irq，它是这个中断的处理函数入口。对于电平触发的中断，这个入口通常为<code>handle_level_irq</code>;对于边沿触发的中断，这个入口通常为<code>handle_edge_irq</code>。<br> ③入口函数首先清除中断，入口函数是<code>handle_level_irq</code>时还要屏蔽中断。<br> ④逐个调用用户在irq_desc[irq].action链表中注册的中断处理函数。<br> ⑤入口函数是<code>handle_level_irq</code>时还要重新开启中断。</li>
</ol>
<h2 id="卸载中断处理函数"><a href="#卸载中断处理函数" class="headerlink" title="卸载中断处理函数"></a>卸载中断处理函数</h2><p>中断是一种很稀缺的资源，当不再使用一个设备时，应该释放它占据的中断。这通过<code>free_irq</code>函数来实现，它与<code>request_irq</code>一样，也是在<code>kernel/irq/manage.c</code>中定义。它的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span>;</span><br></pre></td></tr></table></figure>
<p>它需要用到两个参数：irq和dev_id，它们与通过<code>request_irq</code>注册中断函数时使用的参数一样。使用中断号irq定位actions链表，再使用dev_id在action链表中找到要卸载的表项。所以，同一个中断的不同中断处理函数必须使用不同的dev_id来区分，这就要求在注册共享中断时参数dev_id必须唯一。<br><code>free_irq</code>函数的处理过程与<code>request_irq</code>函数相反。</p>
<ol>
<li>根据中断号irq、dev_id从action链表中找到表项，将它移除。</li>
<li>如果它是唯一的表项，还要调用irq_desc[irqno].chip-&gt;shutdown或irq_desc[irq].chip-&gt;disable来关闭中断。</li>
</ol>
<h1 id="使用中断的驱动程序示例"><a href="#使用中断的驱动程序示例" class="headerlink" title="使用中断的驱动程序示例"></a>使用中断的驱动程序示例</h1><h2 id="按键驱动程序源码分析"><a href="#按键驱动程序源码分析" class="headerlink" title="按键驱动程序源码分析"></a>按键驱动程序源码分析</h2><p>开发板上有4个按键，它们的连线如图所示：<br><img src="/2022/09/24/Linux%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/3.jpeg" alt="img not found"></p>
<h3 id="模块的初始化函数和卸载函数"><a href="#模块的初始化函数和卸载函数" class="headerlink" title="模块的初始化函数和卸载函数"></a>模块的初始化函数和卸载函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行 insmod s3c24xx_buttons.ko 命令时就会调用这个函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3c24xx_buttons_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        注册字符设备驱动程序</span></span><br><span class="line"><span class="comment">        参数为主设备号、设备名字、file_operations结构；</span></span><br><span class="line"><span class="comment">        这样，主设备号就和具体的file_operations结构联系起来了，</span></span><br><span class="line"><span class="comment">        操作主设备为BUTTON_MAJOR的设备文件时，就会调用s3c24xx_buttons_fops中的相关成员函数</span></span><br><span class="line"><span class="comment">        BUTTON_MAJOR可以设为0，表示由内核自动分配主设备号</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    ret = register_chrdev(BUTTON_MAJOR, DEVICE_NAME, &amp;s3c24xx_buttons_fops);</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        printk(DEVICE_NAME<span class="string">&quot;can&#x27;t register major number\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    printk(DEVICE_NAME<span class="string">&quot;initialized\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    执行 rmmod s3c24xx_buttons.ko 命令时就会调用这个函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">s3c24xx_buttons_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*卸载驱动程序*/</span></span><br><span class="line">    unregister_chrdev(BUTTON_MAJOR, DEVICE_NAME);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*这两行指定驱动程序的初始化函数和卸载函数*/</span></span><br><span class="line">module_init(s3c24xx_buttons_init);</span><br><span class="line">module_exit(s3c24xx_buttons_exit);</span><br></pre></td></tr></table></figure>
<p>与LED驱动相似，执行“insmod s3c24xx_buttons.ko”命令加载驱动时就会调用这个驱动初始化函数<code>s3c24xx_buttons_init</code>；执行“rmmod s3c24xx_buttons.ko”命令卸载驱动时就会调用卸载函数<code>s3c24xx_buttons_exit</code>。前者调用<code>register_chrdev</code>函数向内核注册驱动程序，后者调用<code>unregister_chrdev</code>卸载这个驱动程序。<br>驱动程序的核心是s3c24xx_buttons_fops结构，定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">s3c24xx_buttons_fops</span> =</span> &#123;</span><br><span class="line">    .owner = THIS_MODULE,               <span class="comment">//这是一个宏，指向编译模块时自动创建的__this_module变量</span></span><br><span class="line">    .open = s3c24xx_buttons_open,</span><br><span class="line">    .release = s3c24xx_button_close,</span><br><span class="line">    .read = s3c24xx_button_read,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="s3c24xx-buttons-open-函数"><a href="#s3c24xx-buttons-open-函数" class="headerlink" title="s3c24xx_buttons_open 函数"></a>s3c24xx_buttons_open 函数</h3><p>在应用程序执行<code>open(&quot;/dev/buttons&quot;,...)</code>系统调用时，<code>s3c24xx_buttons_open</code>函数将被调用。它用来注册4个按键的中断处理程序，代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    应用程序执行`open(&quot;/dev/buttons&quot;,...)`系统调用时,</span></span><br><span class="line"><span class="comment">    `s3c24xx_buttons_open`函数将被调用</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_buttons_open</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(bittons_irqs)/<span class="keyword">sizeof</span>(buttons_irqs[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="comment">//注册中断处理函数</span></span><br><span class="line">        err = request_irq(buttons_irq[i].irq, buttons_interrupt, button_irqs[i].flags, button_irqs[i].name, (<span class="type">void</span> *)&amp;press_cnt[i]);</span><br><span class="line">        <span class="keyword">if</span>(err)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(err) &#123;</span><br><span class="line">        <span class="comment">//如果出错，释放已经注册的中断</span></span><br><span class="line">        i--;</span><br><span class="line">        <span class="keyword">for</span>(; i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">            free_irq(button_irqs[i].irq, (<span class="type">void</span> *)&amp;press_cnt[i]);</span><br><span class="line">        <span class="keyword">return</span> -EBUSY;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>request_irq</code>函数的作用前面已经讲解过。注册成功后，这4个按键所用GPIO引脚的功能被设为外部中断，触发方式为下降沿触发，中断处理函数为<code>buttons_interrupt</code>。最后一个参数<code>(void *)&amp;press_cnt[i]</code>将在<code>buttons_interrupt</code>函数中用到，它用来存储按键按下的次数。<br><code>free_irq</code>用来卸载已经注册的中断。<br>参数<code>button_irqs</code>定义如下，表示了4个按键的中断号、中断触发方式、中断名称（名称供执行“cat &#x2F;proc&#x2F;interrupts”时显示用）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">button_irq_desc</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> irq;                <span class="comment">//中断号</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> flags     <span class="comment">//中断标志，用来定义中断的触发方式</span></span><br><span class="line">    <span class="type">char</span> *name;             <span class="comment">//中断名称</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">/*用来指定按键所用的外部中断引脚及中断触发方式、名字*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">button_irq_desc</span> <span class="title">button_irqs</span>[] =</span> &#123;</span><br><span class="line">    &#123;IRQ_EINT19, IRQF_TRIGGER_FALLING, <span class="string">&quot;KEY1&quot;</span>&#125;,     <span class="comment">/*K1*/</span></span><br><span class="line">    &#123;IRQ_EINT11, IRQF_TRIGGER_FALLING, <span class="string">&quot;KEY2&quot;</span>&#125;,     <span class="comment">/*K2*/</span></span><br><span class="line">    &#123;IRQ_EINT2, IRQF_TRIGGER_FALLING, <span class="string">&quot;KEY3&quot;</span>&#125;,      <span class="comment">/*K3*/</span></span><br><span class="line">    &#123;IRQ_EINT0, IRQF_TRIGGER_FALLING, <span class="string">&quot;KEY4&quot;</span>&#125;,      <span class="comment">/*K4*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="s3c24xx-buttons-close-函数"><a href="#s3c24xx-buttons-close-函数" class="headerlink" title="s3c24xx_buttons_close 函数"></a>s3c24xx_buttons_close 函数</h3><p><code>s3c24xx_buttons_close</code>函数的作用与<code>s3c24xx_buttons_open</code>函数相反，它用来卸载4个按键的中断处理函数，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    应用程序对设备文件/dev/buttons执行close(fd)时，</span></span><br><span class="line"><span class="comment">    就会调用s3c24xx_buttons_close函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c34xx_buttons_close</span><span class="params">(<span class="keyword">struct</span> inode *inode, <span class="keyword">struct</span> file *file)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(button_irqs)/<span class="keyword">sizeof</span>(button_irqs[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="comment">//释放已经注册的中断</span></span><br><span class="line">        free_irq(button_irqs[i].irq, (<span class="type">void</span> *)&amp;press_cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="s3c24xx-buttons-read-函数"><a href="#s3c24xx-buttons-read-函数" class="headerlink" title="s3c24xx_buttons_read 函数"></a>s3c24xx_buttons_read 函数</h3><p>中断处理函数会在press_cnt数组中记录按键按下的次数。<code>s3c24xx_buttons_read</code>函数首先判断是否有按键按下，如果没有则休眠等待；否则读取press_cnt数组的数据，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    等待队列：</span></span><br><span class="line"><span class="comment">    当没有按键按下时，如果有进程调用s3c24xx_buttons_read函数</span></span><br><span class="line"><span class="comment">    它将休眠</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_WAIT_QUEUE_HEAD</span><span class="params">(button_waitq)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*中断事件标志，中断服务程序将它置1，s3c24xx_buttons_read将它清0*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">volatile</span> <span class="type">int</span> ev_press = <span class="number">0</span>;</span><br><span class="line">...</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    应用程序对设备文件/dev/buttons执行read(...)时，</span></span><br><span class="line"><span class="comment">    就会调用s3c24xx_buttons_read函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_buttons_read</span><span class="params">(<span class="keyword">struct</span> file *flip,<span class="type">char</span> __user *buff, <span class="type">size_t</span> count, <span class="type">loff_t</span> *offp)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果ev_press等于0，休眠</span></span><br><span class="line">    wait_event_interruptible(button_waitq, ev_press);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//执行到这里时，ev_press肯定等于1，将它清0</span></span><br><span class="line">    ev_press = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将按键状态复制给用户，并清0</span></span><br><span class="line">    err = copy_to_user(buff, (<span class="type">const</span> <span class="type">void</span> *)press_cnt, min(<span class="keyword">sizeof</span>(press_cnt), count));</span><br><span class="line">    <span class="built_in">memset</span>((<span class="type">void</span> *)press_cnt, <span class="number">0</span>, <span class="keyword">sizeof</span>(press_cnt));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> err ? -EFAULT : <span class="number">0</span> ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第20行的<code>wait_event_interruptible</code>首先会判断ev_press是否为0，如果为0才会令当前进程进入休眠；否则向下继续执行。它的第一个参数button_waitq是一个等待队列，在前面第6行中定义；第二个参数ev_press用来表示中断是否已经发生，中断服务程序将它置1，<code>s3c24xx_buttons_read</code>将它清0。如果ev_press为0，则当前进程会进入休眠，中断发生时，中断处理函数<code>buttons_interrupts</code>会把它唤醒。<br>第23行将ev_press清0。<br>第26行将press_cnt数组的内容复制到用户空间。buff参数表示的缓冲区位于用户空间，使用<code>copy_to_user</code>向它赋值。<br>第27行将press_cnt数组清0。</p>
<h3 id="中断处理函数-buttons-interrupt"><a href="#中断处理函数-buttons-interrupt" class="headerlink" title="中断处理函数 buttons_interrupt"></a>中断处理函数 buttons_interrupt</h3><p>这4个按键的中断处理函数都是buttons_interrupt，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">buttons_interrupt</span><span class="params">(<span class="type">int</span> irq, <span class="type">void</span> *dev_id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> *press_cnt = (<span class="keyword">volatile</span> <span class="type">int</span> *)dev_id;</span><br><span class="line"></span><br><span class="line">    *press_cnt = *press_cnt + <span class="number">1</span>;            <span class="comment">//按键计数加1</span></span><br><span class="line">    ev_press = <span class="number">1</span>;                           <span class="comment">//表示中断发生了</span></span><br><span class="line">    wake_up_interruptible(&amp;button_waitq);   <span class="comment">//唤醒休眠的进程</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_RETVAL(IRQ_HANDLED);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><code>buttons_interrupt</code>函数第一个参数irq表示发生的中断号，第二个参数dev_id就是<code>request_irq</code>注册中断时传入的“&amp;press_cnt[i]”。<br>第5行将按键计数加1。<br>第6-7行将ev_press设为1，唤醒休眠的进程。<br>将s3c24xx_buttons.c放到内核源码目录<code>drivers/char</code>下，在<code>drivers/char/Makefile</code>中增加如下一行：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-m += s3c24xx_buttons.o</span><br></pre></td></tr></table></figure>
<p>在内核根目录下执行“make modules”命令即可在<code>drivers/char</code>目录下生成可加载模块s3c24xx_buttons.ko，把它放到开发板根文件系统的<code>/lib/modules/2.6.22.6/</code>目录下，就可以使用“insmod s3c24xx_buttons.ko”、“rmmod s3c24xx_buttons.ko”命令进行加载、卸载了。</p>
<h2 id="测试程序情景分析"><a href="#测试程序情景分析" class="headerlink" title="测试程序情景分析"></a>测试程序情景分析</h2><h3 id="加载模块"><a href="#加载模块" class="headerlink" title="加载模块"></a>加载模块</h3><p>执行“insmod s3c24xx_buttons.ko”即可加载模块，这时在控制台执行“cat &#x2F;proc&#x2F;devices”命令可以看到内核中已经有了buttons设备，可以看到如下字样：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Character devices</span><br><span class="line">...</span><br><span class="line">232 buttons</span><br></pre></td></tr></table></figure>
<p>这表明按键设备属于字符设备，主设备号为232。</p>
<h3 id="测试程序打开设备"><a href="#测试程序打开设备" class="headerlink" title="测试程序打开设备"></a>测试程序打开设备</h3><p>运行测试程序button_test后，<code>/dev/buttons</code>设备就被打开了，可以使用“cat &#x2F;proc&#x2F;interrupts”命令看到注册了4个中断。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># cat /proc/interrupts</span><br><span class="line">16:     1   s3c-ext0    KEY4</span><br><span class="line">18:     0   s3c-ext0    KEY3</span><br><span class="line">55:     0   s3c-ext0    KEY2</span><br><span class="line">63:     22   s3c-ext0    KEY1</span><br></pre></td></tr></table></figure>
<p>测试程序button_test中打开设备的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ioctl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> **argv)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    <span class="type">int</span> fd;</span><br><span class="line">    <span class="type">int</span> press_cnt[<span class="number">4</span>];</span><br><span class="line"></span><br><span class="line">    fd = open(<span class="string">&quot;/dev/buttons&quot;</span>,<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span>(fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;can&#x27;t open /dev/buttons\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<h3 id="测试程序读取数据"><a href="#测试程序读取数据" class="headerlink" title="测试程序读取数据"></a>测试程序读取数据</h3><p>读取数据的代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//这是一个无限循环，进程有可能在read函数中休眠，当有按键被按下时，它才返回</span></span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">    <span class="comment">//读出按键被按下的次数</span></span><br><span class="line">    ret = read(fd, press_cnt, <span class="keyword">sizeof</span>(press_cnt));</span><br><span class="line">    <span class="keyword">if</span>(ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;read err!\b&quot;</span>);</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="keyword">sizeof</span>(press_cnt)/<span class="keyword">sizeof</span>(press_cnt[<span class="number">0</span>]); i++) &#123;</span><br><span class="line">        <span class="comment">//如果被按下的次数不为0，打印出来</span></span><br><span class="line">        <span class="keyword">if</span>(press_cnt[i])</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;K%d has been pressed %d times \n&quot;</span>,i + <span class="number">1</span>,press_cnt[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第4篇第20章 Linux异常处理体系结构</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>IDE接口和SD卡驱动程序移植</title>
    <url>/2022/10/14/IDE%E6%8E%A5%E5%8F%A3%E5%92%8CSD%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux设备驱动开发之IDE接口和SD卡驱动程序移植</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第23章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解IDE接口驱动程序的框架，掌握移植方法</li>
<li>了解硬盘、光盘等块设备的使用方法</li>
<li>了解MMC&#x2F;SD卡驱动程序的框架</li>
<li>掌握通过补丁文件移植驱动程序的方法</li>
</ol>
<h1 id="IDE接口驱动程序移植"><a href="#IDE接口驱动程序移植" class="headerlink" title="IDE接口驱动程序移植"></a>IDE接口驱动程序移植</h1><h2 id="IDE接口相关概念介绍"><a href="#IDE接口相关概念介绍" class="headerlink" title="IDE接口相关概念介绍"></a>IDE接口相关概念介绍</h2><p>IDE的英文全称为“Integrated Driver Electronics”，即“电子集成驱动器”，它的本意是指把“硬盘控制器”与“盘体（存储部件）”集成在一起的硬盘驱动器。IDE代表着硬盘的一种类型，但是实际的应用中，人们也习惯用IDE来称呼最早出现IDE类型的硬盘ATA-1，这种类型的接口随着技术的发展已经被淘汰了，而其后发展的ATA-2、ATA-3等更高版本的接口规范。<br>IDE硬盘又称为并口硬盘（与下面介绍的SATA接口硬盘相对），它的已经接口有两种：台式机中使用的40脚IDE接口、笔记本中使用的44脚接口（其中的40个引脚是一样的）。从外形看，台式机中的硬盘比较大，为3.5英寸，40个引脚的旁边还有4个很大的引脚，它们用来接12V、5V电源；笔记本中的硬盘比较小，为2.5英寸，电源等就在多出来的4个引脚中。<br>ATA：ATA（AT Attachment）是一个20世纪80年代由一些软硬件厂家制定的IDE驱动器接口规范，AT是指IBM PC&#x2F;AT个人电脑及其总线结构。通常人们也把ATA接口称为IDE接口，但是实际上两者有着细微的区别，ATA主要指硬盘驱动器与计算机的连接规范，而IDE则主要是指硬盘驱动器本身的技术规范。经过多年发展，ATA规范逐渐升级，访问硬盘的速度逐渐提高。它们的特点简要介绍如下：</p>
<ol>
<li>ATA-1: 这是最初的IDE标准，ATA-1主板上只有一个插口，支持1个主设备和1个从设备，每个设备的最大容量为504MB。ATA-1支持PIO-0、PIO-1和PIO-2共3种PIO模式，传输速率只有3.3MB&#x2F;s；另外还支持4种DMA模式。这种标准的硬盘在市场上基本已经看不到了。</li>
<li>ATA-2：它是ATA-1的扩展，也称为EIDE（Enhanced IDE）或Fast ATA。它在ATA的基础上增加了两种PIO模式和两种DMA模式，最高传输速率达到16.7MB&#x2F;s。同时引进了LBA（Logical Block Address）地址转换方式，原来的地址转换方式为CHS（Cylinder Head Sector）。主板上有两个插口，每个插口可以连接1个主设备和1个从设备，共可以支持4个设备。</li>
<li>ATA-3：它没有引进更高的传输模式，在传输速度上没有任何提升。最重要的是引入了一个划时代的技术–SMART技术（Self-Monitoring Analysis and Reporting Technology），自检测、分析和报告技术。</li>
<li>ATA-4：也称Ultra DMA 33或ATA33，从它开始正式支持Ultra DMA数据传输模式，增加了PIO-4传输模式，传输速率达到33MB&#x2F;s。它首次采用了Double Data Rate技术，让接口在一个时钟周期内传输数据达到两次（上升沿和下降沿各一次），这样数据传输率从16.7MB&#x2F;s提升到33MB&#x2F;s。</li>
<li>ATA-5：也称Ultra DMA 66或ATA66，传输速率达到66.6MB&#x2F;s。从ATA-5开始，为防止电磁干扰，硬盘的连线开始使用40针脚80芯的电缆，就是说其中的信号线仍是40根，这与以前的接口兼容，新增的40根都是地线。打开机箱，40针脚80芯的电缆与原来的电缆相比，显得更细更密，数一下排线的数目，会发现是80根。</li>
<li>ATA-6：也称ATA100，它也是使用40针脚80芯的电缆，传输速率达到100MB&#x2F;s。这是目前市场上主流的IDE接口硬盘。</li>
<li>ATA-7：也称ATA133，它是ATA接口的最后一个版本，传输速率达到133MB&#x2F;s。只有迈拓公司推出了ATA133标准的硬盘，其他厂商则停止了对IDE接口的开发，转而生产Serial ATA接口标准的硬盘。</li>
</ol>
<p>ATAPI：AT Attachment Packet Interface，AT附加分组接口。ATA可以使用户在PC机器上连接硬盘，但是有时这样还不够。有些用户需要通过同样方便的手段连接CDROM、磁带机、MO驱动器等设备。ATAPI标准就是为了解决在IDE&#x2F;EIDE接口上连接多种设备而制定的。支持ATAPI的IDE&#x2F;EIDE接口可以像连接硬盘一样连接ATAPI设备。目前几乎所有的IDE&#x2F;EIDE接口都支持ATAPI。ATAPI是一个软件接口，它将SCSI&#x2F;ASPI命令调整到ATA接口上，这使得光驱制造商能比较容易的将其高端的CD&#x2F;DVD驱动器产品调整到ATA接口上。以光驱为例，它可以像硬盘一样接在任何一个IDE接口上，但是它的驱动程序与IDE硬盘不同。<br>SATA和PATA：两个都是ATA规范，PATA的全称是ParallelATA，就是并行ATA硬盘接口规范，即ATA-1、ATA-2等。PATA硬盘接口规模已经具有相当的辉煌历史了，而且从ATA33&#x2F;66一直发展到ATA100&#x2F;133。而SATA硬盘全称则是SerialATA，即串行ATA硬盘接口规范。当硬盘的访问速度进一步提高时，并行接口的电缆属性、连接器和信号协议都表现出了很大的技术瓶颈，在技术上突破这些瓶颈存在相当大的难度。SATA的出现就是为了取代PATA。第一代的SATA硬盘的写入速度为150MB&#x2F;s，第二代的SATA硬盘的写入速度则高达300MB&#x2F;s，比第一代的速度提高了1倍。SATA除了速度更快之外，另一个进步在于它的数据连线，它的体积更小，散热也更好，与硬盘的连接相当方便。与PATA相比，SATA的功耗更低，这对于笔记本而言是一个好消息，同时独有的CRC技术让数据传输也更为安全。</p>
<h2 id="IDE接口驱动移植"><a href="#IDE接口驱动移植" class="headerlink" title="IDE接口驱动移植"></a>IDE接口驱动移植</h2><h3 id="IDE接口驱动程序框架及源码分析"><a href="#IDE接口驱动程序框架及源码分析" class="headerlink" title="IDE接口驱动程序框架及源码分析"></a>IDE接口驱动程序框架及源码分析</h3><h4 id="IDE接口驱动程序框架"><a href="#IDE接口驱动程序框架" class="headerlink" title="IDE接口驱动程序框架"></a>IDE接口驱动程序框架</h4><p>PC机上最多可以有主、次两个IDE接口，每个IDE接口又可以支持主、从共两个IDE硬盘，所以最多可以有4个IDE硬盘。<br>内核有个数组ide_hwifs[]，数组的每个元素都是一个ide_hwif_t数组结构，代表着系统中的一个可能的IDE接口。系统初始化时如果检测到一个IDE接口，就把相应表项中的noprobe字段设置成0，表示后面要通过这个接口来检测上面是否连接了硬盘，这称为IDE枚举。<br>同时，ide_hwif_t数据结构中又有个ide_drive_t结构数组drivers[]。IDE枚举时如果检测到某个接口上有磁盘相连，就将相应ide_driver_t结构中的present字段也设成1，并根据检测到或从系统的CMOS芯片中读到的各项参数设置这个数据结构。也就是说，ide_hwif_t数据结构是对IDE接口的描述，而ide_driver_t数据结构是对连接在具体IDE接口上的“IDE设备”的描述。<br>例如，如果在系统的主（primary）IDE接口上检测到有主&#x2F;从两个磁盘相连，就把这两个磁盘的参数分别填入ide_hwifs[0]中的drivers[0]和drivers[1]，并把它们的present字段设置成1。再例如，如果在次（secondary）IDE接口上连接着一个Mitsumi CDROM，那就把它的参数填入ide_hwifs[1]里面的drives[0]，并且把ide_hwifs[1]中的字段major设置成MITSUMI_CDROM_MAJOR。<br>在ide_drive_t结构中有个void指针driver_data，可以指向不同的ide_driver_t数据结构（ide_drive_t和ide_driver_t是两种不同的数据结构）。这个指针在系统初始化过程中根据枚举到的IDE设备的类型而设置成不同的数据结构。对于IDE硬盘，它指向一个ide_driver_t数据结构idedisk_driver。同类的数据结构还有idetape_driver、ide_cdrom_driver以及ide_floppy_driver，分别代表着连接到IDE接口上的不同类型的设备，如果ide_drive_t结构drivers[]非空，但是它的driver指针确是NULL，就说明初始化时虽然检测到了硬盘的存在，但是却因某种原因未能完成对设备以及数据结构的初始化。<br>上面涉及到了3种数据结构：ide_hwif_t、ide_drive_t和ide_driver_t，它们刚好表示了IDE驱动程序的3个层次。代码中，这3种变量的名称常写为hwif、drive、driver，前面两个表示“硬件”，IDE接口、硬盘；后面一个表示“软件”，表示这个磁盘的具体驱动程序，有idedisk_driver、detape_driver等。<br>为了形象，从软件人员的角度说明：<br><img src="/2022/10/14/IDE%E6%8E%A5%E5%8F%A3%E5%92%8CSD%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/1.jpeg" alt="img not found"><br>从图中可以看出驱动初始化的顺序：初始化IDE接口（hwif）、IDE枚举（识别挂接的磁盘）、挂接具体的驱动程序。</p>
<ol>
<li>初始化IDE接口<br>简单来说，每个IDE接口（驱动中用hwif表示）就是9个地址和它们的读写函数（及中断号），对磁盘的一切访问都通过这些地址：选择磁盘（一个IDE接口上可以接两个磁盘，这两个磁盘共用这9个地址，访问它们之前需要发出选择命令）、发出命令、查询状态、读写数据。对hwif的初始化主要包括一下两点。<br>①<strong>确定这9个地址和中断号，即ide_hwifs[].io_ports[]。</strong><br>②<strong>确定这9个地址的读&#x2F;写函数：ide_hwifs[].OUTB&#x2F;INB&#x2F;OUTW&#x2F;INW等</strong><br>就软件而言，就是设置相应的ide_hwifs[]项。</li>
<li>IDE枚举<br>确定了IDE接口的地址、读写函数和中断号后，IDE驱动即会利用它们自动设别所挂接的磁盘，包括一下3点。<br>①<strong>检查是否有挂接了磁盘</strong><br>②<strong>识别是磁盘、光盘还是软盘</strong><br>③<strong>注册中断处理函数</strong><br>一个IDE接口上最多可以挂接两个磁盘，可以是硬盘、光盘或软盘等，这可以通过不同的命令序列识别出来。命令序列分两类：ATA、ATAPI。前者对应硬盘，后者对应光盘&#x2F;软盘等。<br>把磁盘当作一个巨大的可读写的数组的话，可以想象得到，磁盘上必然有一些只读的数据来标识它：生产厂商、容量、柱面数、磁头数、扇区数、是否支持多扇区读写等，称这些信息为“磁盘ID”，大小为512字节，这些信息读出后会保存起来。<br>就软件而言，就是设置数据结构ide_hwifs[].drivers[0]，对应主磁盘；设置数据结构ide_hwifs[].drivers[1]，它对应从磁盘。<br>如果检测到有磁盘相连，则将ide_hwifs[].drives[].present置1，然后使用ATA&#x2F;ATAPI命令序列查询所接磁盘类型（硬盘、软盘、光盘），读取“磁盘ID”，保存在ide_hwifs[].drives[].id中；并设置ide_hwifs[].drives[].media，取值有ide_disk、ide_cdrom、ide_floppy等。<br>注册中断：同一个IDE接口（hwif）下的主、从两个磁盘，它们共用一根中断线。识别出了一个IDE接口下所有磁盘后，发现有磁盘时才注册中断。</li>
<li>挂接具体驱动程序<br>步骤2已经获取了磁盘的参数，并在ide_hwifs[].drives[].media中标明了磁盘类型，不同的类型对应不同的驱动程序：硬盘驱动、光盘驱动、软盘驱动等。加载这些驱动时，它们会遍历每个磁盘，即每个ide_hwifs[].drives[]。比对ide_hwifs[].dirves[].media项，匹配的话就将ide_hwifs[].drives[].driver_data指向相应的结构。比如：对于IDE硬盘，它指向一个ide_driver_t数据结构idedisk_driver。同类的数据结构还有idetape_driver、ide_cdrom_driver以及ide_floopy_driver。以硬盘为例，以后就会利用idedisk_driver结构中提供的函数进行读写硬盘了。<br>然后，识别磁盘分区。磁盘分区表的表示方法并不属于IDE驱动的范畴，但是了解它有助于调试驱动。<br>综上所述，可以认为IDE驱动分为3层：IDE接口层（hwif）、磁盘驱动器层（hwif.drives[]）、具体驱动程序（hwif.drives[].driver）。实际上，在S3C2410&#x2F;S3C2440系统中移植IDE接口驱动层程序，主要的工作也就是让操作系统能识别板上的IDE接口。</li>
</ol>
<h4 id="IDE接口驱动程序源码分析"><a href="#IDE接口驱动程序源码分析" class="headerlink" title="IDE接口驱动程序源码分析"></a>IDE接口驱动程序源码分析</h4><p>下面按照上述3个步骤分析驱动程序，代码在<code>dirvers/ide</code>目录下，分别是ide.c、ide-generic.c、ide-disk.c（硬盘）&#x2F;ide-cd.c（CDROM）&#x2F;ide-floppy.c（软盘）。</p>
<ol>
<li>初始化IDE接口<br>入口在<code>drivers/ide/ide.c</code>的<code>ide_init</code>函数中，它的初始化默认的IDE接口，或者调用体系结构相关的函数初始化IDE接口，即确定IDE接口的9个地址和它们的读写函数。主要的函数调用关系如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ide_init -&gt;</span><br><span class="line"> init_ide_data -&gt;</span><br><span class="line">     init_hwif_data -&gt;</span><br><span class="line">         default_hwif_iops <span class="comment">//确定IDE接口的默认读写函数，OUTB/INB/OUTW/INW等</span></span><br><span class="line">         default_hwif_transport <span class="comment">//一些默认的读写函数，会调用上面确定的函数</span></span><br><span class="line">     init_hwif_default -&gt;<span class="comment">//确认默认的IDE接口地址，对于X86架构外的CPU，通常无用</span></span><br><span class="line">     ide_arm_init -&gt;<span class="comment">//确认ARM架构相关的IDE接口地址</span></span><br><span class="line"> probe_for_hwifs -&gt;<span class="comment">//确定各种“已知的”IDE接口，它们通常是架构相关的</span></span><br></pre></td></tr></table></figure></li>
<li>IDE枚举（识别挂接的磁盘）<br>入口在<code>drivers/ide/ide-generic.c</code>的<code>ide_generic_init</code>函数中，主要的函数调用关系如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ide_generic_init -&gt;</span><br><span class="line"> ideprobe_inti -&gt;</span><br><span class="line">     probe_hwif -&gt;</span><br><span class="line">         probe_for_drive -&gt;  <span class="comment">//枚举磁盘</span></span><br><span class="line">             do_probe</span><br><span class="line">     hwif_init               <span class="comment">//将枚举到的磁盘作为块设备注册到内核中，并注册中断处理函数等</span></span><br></pre></td></tr></table></figure>
函数do_probe在<code>dirvers/ide/ide-probe.c</code>中定义，它利用前面确定的IDE接口的地址发出各类命令序列检测磁盘。摘取此函数里面用到的一个函数，可以看到是它如何使用前面确定的IDE接口的：SELECT_DRIVE（hwif,drive）被用来发出选择命令，选择主从磁盘，它在<code>drivers/ide/ide-iops.c</code>中的定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SELECT_DRIVE</span> <span class="params">(<span class="type">ide_drive_t</span> *drive)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (HWIF(drive)-&gt;selectproc)</span><br><span class="line">        HWIF(drive)-&gt;selectproc(drive);</span><br><span class="line">    HWIF(drive)-&gt;OUTB(drive-&gt;select.all, IDE_SELECT_REG);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<code>IDE_SELECT_REG</code>就是hwif-&gt;io_ports[IDE_SELECT_OFFSET]。这行使用OUTB向寄存器IDE_SELECT_REG输出一个字节，而OUTB通常就是前面的default_hwif_iops函数设置的ide_outb，即outb。<br>前面说过的每个磁盘都有一些只读信息来标识自己—“磁盘ID”，读取“磁盘ID”的函数调用顺序如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ide_generic_init -&gt;</span><br><span class="line"> ideprobe_init -&gt;</span><br><span class="line">     probe_hwif -&gt;</span><br><span class="line">         probe_for_driver -&gt;</span><br><span class="line">             do_probe -&gt;</span><br><span class="line">                 try_to_identify -&gt;</span><br><span class="line">                     actual_try_to_identify -&gt;</span><br><span class="line">                         do_identify -&gt;</span><br><span class="line">                             hwif-&gt;ata_input_data -&gt;</span><br><span class="line">                                 INSW -&gt;</span><br><span class="line">                                     INW</span><br></pre></td></tr></table></figure>
它们最终还是通过前面确定的OUTB&#x2F;INB&#x2F;OUTW&#x2F;INW等函数来完成，只要读出了“磁盘ID”，磁盘的枚举基本就成功了。</li>
<li>挂接具体驱动程序<br>以硬盘驱动程序为例，代码在<code>drivers/ide/ide-disk.c</code>中，入口函数为<code>idedisk_init</code>，代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">idedisk_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> driver_register(&amp;idedisk_driver.gen_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
向内核注册驱动之后，最终会调用<code>drivers/ide/ide-disk.c</code>中的<code>ide_disk_probe</code>函数来识别每个磁盘。<br>对于所有磁盘，如果是硬盘（ide_hwifs[].drives[].driver_req为“ide-disk”、ide_hwifs[].drives[].media等于ide_disk），则挂接硬盘驱动程序：ide_hwifs[].drives[].driver &#x3D; &amp;idedisk_driver。<br>为硬盘挂接具体驱动程序的主要函数调用关系如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">idedisk_init -&gt;</span><br><span class="line"> ide_disk_probe -&gt;</span><br><span class="line">     idkp-&gt;driver = &amp;idedisk_driver;<span class="comment">//挂接硬盘驱动程序</span></span><br><span class="line">     idedisk_setup<span class="comment">//根据磁盘ID做一些设置，比如获取磁盘容量、确定能否多扇区操作、确定读写能否以32位进行等</span></span><br><span class="line">     set_capacity<span class="comment">//设置容量</span></span><br><span class="line">     g-&gt;fops = &amp;idedisk_ops;<span class="comment">//确定文件处理函数（用户调用open/read/write等时对应的函数）</span></span><br><span class="line">     add_disk(g);<span class="comment">//识别分区</span></span><br></pre></td></tr></table></figure>
假设一切正常，那么系统启动后就可以访问磁盘了。</li>
</ol>
<h3 id="S3C2410-x2F-S3C2440开发板上的IDE接口驱动程序移植"><a href="#S3C2410-x2F-S3C2440开发板上的IDE接口驱动程序移植" class="headerlink" title="S3C2410&#x2F;S3C2440开发板上的IDE接口驱动程序移植"></a>S3C2410&#x2F;S3C2440开发板上的IDE接口驱动程序移植</h3><p>从前面的分析可以知道，IDE接口驱动程序的移植只有一点：确定IDE的接口（地址、中断号、读写函数）。<br>开发板上的IDE接口硬件连线如下图所示：<br><img src="/2022/10/14/IDE%E6%8E%A5%E5%8F%A3%E5%92%8CSD%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/2.jpeg" alt="img not found"></p>
<p>在修改代码之前，先介绍一下IDE设备的寄存器。对硬盘、光盘、软盘等IDE设备的所有操作，都是通过读写它们的寄存器来完成的。这些寄存器分为两种：命令块寄存器、控制块寄存器。前者被用来给设备发送命令或是查询状态；后者被用来控制设备，它也可以用来查询状态。这两类寄存器通过CS1、CS0、DA2-DA0来分辨，它们的功能和地址信号如下图所示：<br><img src="/2022/10/14/IDE%E6%8E%A5%E5%8F%A3%E5%92%8CSD%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/3.jpeg" alt="img not found"></p>
<p>这些寄存器都是8位的，当设置好相关寄存器之后，就可以通过“数据端口”发送或读取数据了。“数据端口”的地址与数据寄存器一样，只不过传输的是16位的。<br>从上面的图可知，命令块寄存器的基地址是BANK1的基地址，即0x08000000，这些寄存器的地址分别为：0x0800000、0x0800002、0x0800004、…、0x080000E；控制块寄存器的基地址为BANK2的基地址，<br>即0x1000000，只用到一个地址：0x1000000C。硬件连线图中，ADD3-ADD1连接到DA2-DA0，没有使用ADDR0，确定地址时需要注意到这点。另外，这些地址是物理地址，在内核中使用时需要映射为虚拟地址。<br>中断引脚为EINT6，上升沿有效；使用nWAIT信号；数据位宽为16。<br>如前所述，只要告诉内核这些地址、中断号就可以了（还要进行相关设置使它们可用）。这些地址的读写函数使用前面设置的默认函数。<br>只需要修改两个文件：<code>drivers/ide/arm/ide_arm.c</code>、<code>drivers/ide/Kconfig</code>。<br>在<code>drivers/ide/arm/ide_arm.c</code>文件中增加ide_s3c24xx_init函数，修改后的文件如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">elif</span> defined (CONFIG_ARCH_S3C2410)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/irq.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch-s3c2410/regs-mem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch-s3c2410/regs-gpio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_ARM_IOs &#123;0x80000000,0x10000000&#125; <span class="comment">//IDE接口CS0、CS1的物理基址</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> IDE_ARM_IRQPIN  S3C2410_GPF6    <span class="comment">//中断引脚</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_S3C2410</span></span><br><span class="line"><span class="comment">/*set hwif for S3C2410/S3C2440*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">ide_s3c24xx_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> oldval_bwscon;<span class="comment">//用来保存BWSCON寄存器的值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mapaddr0;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> mapaddr1;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> baseaddr[] = IDE_ARM_IOs;</span><br><span class="line">    <span class="type">hw_regs_t</span> hw;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置BANK1/2：总线宽度为16</span></span><br><span class="line">    oldval_bwscon = readl(S3C2410_BWSCON);</span><br><span class="line">    writel(oldval_bwscon &amp; ~(( <span class="number">3</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">3</span> &lt;&lt; <span class="number">8</span>))) \</span><br><span class="line">        | S3C2410_BWSCON_DW1_16 | S3C2410_BWSCON_WS1 \</span><br><span class="line">        | S3C2410_BWSCON_DW2_16 | S3C2410_BWSCON_WS2, S3C2410_BWSCON);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//设置BANK1/BANK2的时间参数</span></span><br><span class="line">    writel((S3C2410_BANKCON_Tacs4 | S3C2410_BANKCON_Tcos4 | S3C2410_BANKCON_Taccl4 \</span><br><span class="line">            S3C2410_BANKCON_Tcoh4 | S3C2410_BANKCON_Tcah4 | S3C2410_BANKCON_Tacp6   \</span><br><span class="line">            S3C2410_BANKCON_PMCnorm),S3C2410_BANKCON1);</span><br><span class="line">    writel((S3C2410_BANKCON_Tacs4 | S3C2410_BANKCON_Tcos4 | S3C2410_BANKCON_Taccl4 \</span><br><span class="line">            S3C2410_BANKCON_Tcoh4 | S3C2410_BANKCON_Tcah4 | S3C2410_BANKCON_Tacp6   \</span><br><span class="line">            S3C2410_BANKCON_PMCnorm),S3C2410_BANKCON2);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        设置IDE接口的地址，ADDR3~ADDR1接到的A02~A00</span></span><br><span class="line"><span class="comment">        注意：没有使用ADDR0，所以下面确定地址时，都左移1位</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    mapaddr0 = (<span class="type">unsigned</span> <span class="type">long</span>)ioremap(baseaddr[<span class="number">0</span>],<span class="number">16</span>);</span><br><span class="line">    mapaddr1 = (<span class="type">unsigned</span> <span class="type">long</span>)ioremap(baseaddr[<span class="number">1</span>],<span class="number">16</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">memset</span>(&amp;hw, <span class="number">0</span>, <span class="keyword">sizeof</span>(hw));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = IDE_DATA_OFFSET; i &lt;= IDE_STATUS_OFFSET; i++)</span><br><span class="line">        hw.io_ports[i] = mapaddr0 + (i &lt;&lt; <span class="number">1</span>);   <span class="comment">//命令块寄存器</span></span><br><span class="line">    </span><br><span class="line">    hw.io_ports[IDE_CONTROL_OFFSET] = mapaddr1 + (<span class="number">6</span> &lt;&lt; <span class="number">1</span>); <span class="comment">//控制块寄存器</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 设置中断引脚 */</span></span><br><span class="line">    hw.irq = s3c2410_gpio_getirq(IDE_ARM_IRQPIN);</span><br><span class="line">    s3c2410_gpio_cfgpin(IDE_ARM_IRQPIN, S3C2410_GPIO_IRQ);</span><br><span class="line">    set_irq_type(hw.irq, IRQF_TRIGGER_RISING);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 注册IDE接口 */</span></span><br><span class="line">    ide_regitser_hw(&amp;hw, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="type">void</span> __init <span class="title function_">ide_arm_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_ARCH_S3C2410</span></span><br><span class="line">    <span class="keyword">if</span>(IDE_ARM_HOST) &#123;</span><br><span class="line">        ide_s3c24xx_init();</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line">    <span class="keyword">if</span>(IDE_ARM_HOST) &#123;</span><br><span class="line">        <span class="type">hw_reg_t</span> hw;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">memset</span>(&amp;hw, <span class="number">0</span>, <span class="keyword">sizeof</span>(hw));</span><br><span class="line">        ide_std_init_ports(&amp;hw, IDE_ARM_IO, IDE_ARM_IO + <span class="number">0x206</span>);</span><br><span class="line">        hw.irq = IDE_ARM_IRQ;</span><br><span class="line">        ide_register_hw(&amp;hw, <span class="number">1</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第[6]、[7]行定义了IDE接口CS0、CS1的物理基址和中断引脚，它们在下面会用到。<br>第[22]-[25]行用来设置存储控制器，IDE接口使用BANK1、BANK2，数据总线位宽为16；还使用到了nWAIT信号。<br>第[28]-[33]行设置BANK1、BANK2的时序参数，现在设为比较宽松的值，基本都取最大值，读者可以根据硬盘特性进行调整。<br>第[39]-[47]行设置IDE接口的9个地址，第[39]、[40]两行首先将物理地址映射为虚拟地址，后面就是直接赋值了。需要注意的是：由于S3C2410&#x2F;S3C2440的ADDR3-ADDR1接到IDE接口的DA02-DA00，没有使用ADDR0，所以是[45]、[47]行中地址的偏移都左移了1位。<br>第[50]-[52]行设置中断引脚，第[50]行的<code>s3c2410_gpio_getirq</code>函数的返回值就是中断号IRQ_EINT6；第[51]行用来选择引脚功能为外部中断，第[52]行用来设置中断的触发方式为上升沿触发。第[50]-[52]行的功能完全可以在调用<code>requset_irq</code>函数注册中断时，通过指定参数irqflags为IRQF_TRIGGER_RISING来完成，在这里之所以不使用这种方法是为了减少修改其他文件（在<code>dribers/ide/ide-probe.c</code>中注册中断处理函数）。<br>第[55]行调用<code>ide_register_hw</code>注册IDE接口，其实就是在将上面确定的地址、中断号填入某个不用的ide_hwifs[]表项中。<br>后面第[58]行开始的<code>ide_arm_init</code>函数直接调用<code>ide_s3c24xx_init</code>函数。<br><code>ide_arm_init</code>函数在<code>drivers/ide/ide.c</code>文件中的<code>init_ide_data</code>函数中被调用，需要设置配置项CONFIG_IDE_ARM。<code>ide_arm_init</code>函数被调用时的代码如下:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">init_ide_data</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_IDE_ARM</span></span><br><span class="line">    ide_arm_init();</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>配置项COFIG_IDE_ARM在<code>drivers/ide/Kconfig</code>中定义，代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config IDE_ARM</span><br><span class="line">    def_bool ARM &amp;&amp; (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK)</span><br></pre></td></tr></table></figure>
<p>在配置菜单中看不到它，它取默认值。增加一个依赖条件ARCH_S3C2410，新代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config IDE_ARM</span><br><span class="line">    def_bool ARM &amp;&amp; (ARCH_A5K || ARCH_CLPS7500 || ARCH_RPC || ARCH_SHARK || ARCH_S3C2410)</span><br></pre></td></tr></table></figure>

<h2 id="IDE接口驱动程序测试"><a href="#IDE接口驱动程序测试" class="headerlink" title="IDE接口驱动程序测试"></a>IDE接口驱动程序测试</h2><p>首先配置内核，需要增加不少配置项；还要移植一些分区、格式化的工具。</p>
<h3 id="配置、编译内核"><a href="#配置、编译内核" class="headerlink" title="配置、编译内核"></a>配置、编译内核</h3><p>为了支持硬盘、CDROM等设备，需要在设备驱动、文件系统等方面设置相应的配置项。在内核根目录下执行“make menuconfig”后，按照下面的指示进行配置即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">    &lt;*&gt; ATA/ATAPI/MFM/RLL support ---&gt;</span><br><span class="line">        &lt;*&gt; Enhanced IDE/MFM/RLL disk/cdrom/tape/floppy support</span><br><span class="line">        &lt;*&gt; Include IDE/ATA<span class="number">-2</span> DISK support</span><br><span class="line">        &lt;*&gt; Include IDE/ATAPI CDROM support</span><br><span class="line">        [*] legacy /proc/ide/ supprot</span><br><span class="line">        &lt;*&gt; generic/<span class="keyword">default</span> IDE chipset support</span><br><span class="line">File systems ---&gt;</span><br><span class="line">    CD-ROM/DVD Filesystems ---&gt;</span><br><span class="line">        &lt;*&gt; ISO <span class="number">9660</span> CDROM file system support </span><br><span class="line">        [*] Microsoft Joliet system supprt</span><br><span class="line">        [*] Transport decompression extension</span><br><span class="line">        &lt;*&gt; UDF file system support</span><br><span class="line">    DOS/FAT/NT Filesystems ---&gt;</span><br><span class="line">        &lt;*&gt; VFAT (Windows<span class="number">-95</span>) fs <span class="title function_">support</span></span><br><span class="line">        <span class="params">(<span class="number">936</span>)</span> Default codepage <span class="keyword">for</span> <span class="title function_">FAT</span></span><br><span class="line">        <span class="params">(cp936)</span> Default iocharset <span class="keyword">for</span> FAT</span><br><span class="line">    Native Language support ---&gt;</span><br><span class="line">        &lt;*&gt; Simplified Chinese <span class="title function_">charset</span> <span class="params">(CP936,GB2312)</span>    </span><br></pre></td></tr></table></figure>
<p>值得一提的是上面的“(936)Default codepage for FAT”和“(cp936) Default iocharset for FAT”。<br>首先介绍一下字符集的概念：计算机中使用数值来表示字符，比如使用0x41来表示字符“A”。同一个数值在不同的字符集中可能表示不同的字符，比如数值0xABB6在gb2312字符集中式“东”，在big5字符集中却是“奎”，在UNICODE字符集中没有对应的字符。<br>在FAT文件系统中存储一个短文件名时使用本地的字符集进行存储，这个字符集被称为“codepage”；存储长文件名时，使用UNICODE字符集。在Linux中，查看FAT文件系统的文件时，比如使用“ls”命令时，这些以“codepage”或UNICODE字符集保存的数值，还要转换为另一个字符集的数值，才发送到控制台上去显示。这个“显示用”的字符集就是“iocharset”。<br>在Linux下挂接FAT文件系统时，经常碰到汉字的目录名、文件名显示“？”，就是因为在挂接文件系统时，没有正确设置“codepage”或“iocharset”所致。“codepage”和“iocharset”可以相同，也可以不同，比如我们可以这样挂接硬盘：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o codepage=950,iocharset=cp936 /dev/hda2 /mnt</span><br></pre></td></tr></table></figure>
<p>cp950表示字符集BIG5，cp936表示字符集GB2312，这个命令使得FAT文件系统使用BIG5字符集保存的繁体文件名，可以通过GB2312正确显示为简体字。<br>最后一项配置“Native Language Support”表示“本地语言支持”，就是将各种字符集编译进内核，或编译为模块。</p>
<h3 id="移植工具"><a href="#移植工具" class="headerlink" title="移植工具"></a>移植工具</h3><p>在Busybox中已经有分区工具fdisk，还需要移植EXT2文件系统格式化工具mke2fs、FAT文件系统格式化工具mkdosfs。</p>
<ol>
<li>移植EXT2文件系统格式化工具mke2fs</li>
<li>FAT文件系统格式化工具mkdosfs</li>
</ol>
<p>分区、格式化、使用IDE接口设备<br>开发板上只有一个IDE接口，所以最多可以接两个设备：要么是主设备（hda）、要么是从设备（hdb），可以通过设置它们的跳线来确定谁是主设备、谁是从设备。<br>设备文件&#x2F;dev&#x2F;hda、&#x2F;dev&#x2F;hdb表示整个磁盘，设备文件&#x2F;dev&#x2F;hda1、&#x2F;dev&#x2F;hda2、&#x2F;dev&#x2F;hdb1、&#x2F;dev&#x2F;hdb2等表示磁盘的分区。初始化硬盘时，驱动程序会自动识别它的分区。</p>
<ol>
<li>创建设备文件<br>进行下一步操作之前，先在开发板根文件系统中创建几个设备文件，以下命令在开发板上执行。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mknod /dev/hda b <span class="number">3</span> <span class="number">0</span></span><br><span class="line">mknod /dev/hda1 b <span class="number">3</span> <span class="number">1</span></span><br><span class="line">mknod /dev/hda2 b <span class="number">3</span> <span class="number">2</span></span><br><span class="line">mknod /dev/hda3 b <span class="number">3</span> <span class="number">3</span></span><br><span class="line">mknod /dev/hda4 b <span class="number">3</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">mknod /dev/hdb b <span class="number">3</span> <span class="number">64</span></span><br><span class="line">mknod /dev/hdb1 b <span class="number">3</span> <span class="number">65</span></span><br><span class="line">mknod /dev/hdb2 b <span class="number">3</span> <span class="number">66</span></span><br><span class="line">mknod /dev/hdb3 b <span class="number">3</span> <span class="number">67</span></span><br><span class="line">mknod /dev/hdb4 b <span class="number">3</span> <span class="number">68</span></span><br></pre></td></tr></table></figure></li>
<li>分区<br>分区工具fdisk操作的是整个设备，比如“fdisk &#x2F;dev&#x2F;hda”。fdisk提供字符界面的菜单供用户进行各种操作：查看、增加、删除分区，查看主扇区的数据。需要注意的是：增加、删除分区等操作只是在内存中完成，还没有写入磁盘，这需要在主菜单中选择“w”才会将变化的数据写入磁盘。</li>
<li>格式化<br>分区之后就是格式化了，可以使用mke2fs工具将某个分区格式化为EXT2文件系统，或是使用mkdosfs工具格式化为FAT文件系统。mkdosfs工具的默认格式为FAT16，要格式化为FAT32需要增加参数“-F 32”。使用的命令示范如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mke2fs /dev/hda1</span><br><span class="line">mkdosfs -F 32 /dev/hda2</span><br></pre></td></tr></table></figure></li>
<li>挂接磁盘<br>对于已经格式化好的磁盘，直接使用mount命令即可挂接，之后就可以使用了。挂接命令如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对于EXT2文件系统，不需要指定字符集</span></span><br><span class="line">mount /dev/hda1 /mnt</span><br><span class="line"><span class="comment">//对于FAT文件系统，指定codepage和iocharset；可省略，因为内核已设置默认字符集为cp936</span></span><br><span class="line">mount -o codepage=<span class="number">936</span>,iocharset=cp936 /dev/hda2 /mnt</span><br></pre></td></tr></table></figure>
如果IDE接口接上了光驱，在启动内核时会看到类似以下的信息：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Uniform Multi-Platform E-IDE driver Revision: 7.00alpha2</span><br><span class="line">ide: Assuming 50MHz system bus speed for PIO modes; override with idebus=xx</span><br><span class="line">hdb: BENQ DVD DD DW1650, ATAPI CD/DVD-ROM drive</span><br><span class="line">ide0 at 0xc4872000-0xc4872007,0xc487400c on irq 50</span><br><span class="line">hdb: ATAPI 48X DVD-ROM DVD-R CD-R/RW drive, 2048KB Cache</span><br><span class="line">Uniform CD-ROM driver Revison: 3.20</span><br></pre></td></tr></table></figure>
表示识别到了一个光驱，它是从设备（hdb）。光盘没有分区，直接使用“整个设备”，即&#x2F;dev&#x2F;hdb。在光驱中装入光盘后，挂接命令如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mount -o iocharset=gb2312 /dev/hdb /mnt #要显示简体汉字，指定字符集gb2312</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="SD卡驱动程序移植"><a href="#SD卡驱动程序移植" class="headerlink" title="SD卡驱动程序移植"></a>SD卡驱动程序移植</h1><h2 id="SD卡相关概念介绍"><a href="#SD卡相关概念介绍" class="headerlink" title="SD卡相关概念介绍"></a>SD卡相关概念介绍</h2><p>MMC：MMC就是MultiMediaCard的缩写，即多媒体卡。它是一种非易失性存储器件，体积小巧，类似一张邮票大小，容量大，耗电量低，传输速度快，广泛用于电子玩具、PDA、数码相机、手机、MP3等设备中。以前的MMC规范的数据传输宽度只有1位，最新的4.0版本的MMC规范拓宽了4位、8位带宽，时钟频率达到52MHz频率，从而支持50MB&#x2F;s的传输速率。对于SD卡的“数据保全”特性，MMC协会接纳了具有竞争性的安全卡标准—Secure MMC 1.1版规范。<br>SD：SD卡的英文名为Secure Digital Memory Card，即安全数码卡。它在MMC的基础上发展而来，增加了两个主要特色：SD卡强调数据的保全，可以设定所存储数据的使用权限，防止他人复制；另一个特色就是传输速度比2.11版的MMC快了4倍。在数据传输和物理规范上，SD卡向前兼容MMC卡；外观上，SD卡尺寸为24mmX32mmX2.1mm，是比MMC卡更厚一些；这两个特点使得支持SD卡的设备也支持MMC卡。SD卡和2.11版的MMC卡完全兼容。<br>SDIO：SDIO是在SD标准上定义了一种外设接口，它和SD卡规范间的一个重要区别是增加了低速标准。SDIO卡只需要SPI和1位SD传输模式。低速卡的目标应用是以最小的硬件开支支持低速I&#x2F;O能力。低速卡支持剋四调制解调器、条码扫描仪和GPS接收器等应用。对“组合卡”（存储器+SDIO）而言，全速和4位操作对卡内存储器和SDIO部分都是强制要求的。<br>MMC&#x2F;SD&#x2F;SDIO这3种存储卡都支持这两种接口：对于MMC卡，称为MMC接口和SPI接口；对于SD卡，SDIO卡，称为SD接口和SPI接口。SD接口有1位和4位之分，上电时默认使用1位模式，设置SD主机后可以使用4位模式。<br>MCI：MCI是Multimedia Card Interface的简称，即多媒体卡接口。上述的MMC、SD、SDIO卡定义的接口都属于MCI接口。MCI这个术语在驱动程序种经常使用，很多文件、函数名字都包含“mci”。</p>
<h2 id="SD卡驱动程序移植-1"><a href="#SD卡驱动程序移植-1" class="headerlink" title="SD卡驱动程序移植"></a>SD卡驱动程序移植</h2><p>S3C2410&#x2F;S3C2440中集成了一个MMC&#x2F;SD&#x2F;SDIO主机控制器，用于访问外接的MMC卡、SD卡或SDIO卡，它有如下特性：</p>
<ol>
<li>支持SD存储卡规范1.0、MMC卡规范2.11</li>
<li>支持SDIO规范1.0</li>
<li>内部有16个字（64字节）的FIFO，用于发送、接收数据</li>
<li>40位的命令寄存器（SDICARG[31:0]+SDICCON[7:0]）</li>
<li>136位的回应寄存器（SDIRSPn[127:0]+SDICSTA[7:0]）</li>
<li>8位的预分频逻辑电路<br>对于S3C2410，Freq&#x3D;System Clock&#x2F;(2(P+1))<br>对于S3C2440，Freq&#x3D;System Clock&#x2F;(P+1)</li>
<li>CRC7和CRC16校验码产生器</li>
<li>支持查询、中断或者DMA传输模式</li>
<li>数据总线的宽度可以是1位或者4位，支持串流或区块传输模式</li>
<li>对于SD卡、SDIO卡，传输数据时最高时钟频率为25MHz</li>
<li>对于MMC卡，传输数据时最高时钟频率为20MHz</li>
</ol>
<p>Linux2.6.22.6尚未支持S3C2410&#x2F;S3C2440的MMC&#x2F;SD&#x2F;SDIO控制器，需要移植驱动程序。在这之前，先介绍一下MMC&#x2F;SD驱动的框架。这些驱动程序在内核<code>drivers/mmc</code>目录下。</p>
<h3 id="内核MMC-x2F-SD驱动程序框架"><a href="#内核MMC-x2F-SD驱动程序框架" class="headerlink" title="内核MMC&#x2F;SD驱动程序框架"></a>内核MMC&#x2F;SD驱动程序框架</h3><p>内核<code>drivers/mmc</code>目录下有3个子目录：card&#x2F;、core&#x2F;和host&#x2F;，这刚好表示了MMC&#x2F;SD驱动程序的3个层次，层次结构如下图所示：<br><img src="/2022/10/14/IDE%E6%8E%A5%E5%8F%A3%E5%92%8CSD%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/4.jpeg" alt="img not found"></p>
<ol>
<li>区块层<br>向文件系统层、用户空间提供文件操作的接口，主要文件是card&#x2F;目录下的block.c，queue.c向它提供了几个函数来操作队列。<br>区块层调用core&#x2F;目录下的core.c、sysfs.c提供的接口来识别存储卡的分区、读写存储卡等功能。</li>
<li>核心层<br>核心层代码在core&#x2F;目录下，它封装了MMC&#x2F;SD命令，实现MMC&#x2F;SD协议，它调用主机控制器层的接口完成存储卡的识别、设置、读写等。<br>如上图所示，core.c文件由sd.c、mmc.c两个文件支撑，core.c把MMC卡、SD卡的共性抽象出来，它们的差别由sd.c和sd_ops.c、mmc.c和mmc_ops.c来完成。<br>sysfs.c是MMC&#x2F;SD驱动程序的sysfs文件系统的实现，它提供一些内核体系相关的函数来实现注册、调用驱动程序；在用户空间挂接sysfs文件系统后，可以从中看到MMC&#x2F;SD的一些信息。</li>
<li>主机控制器层<br>核心层根据需要构造各种MMC&#x2F;SD命令，这些命令是怎么发送给MMC&#x2F;SD卡的？这通过主机控制器来实现。这层是架构相关的，里面针对各款CPU提供了一个文件，目前支持的CPU还很少。<br>以即将移植的s3cmci.c为例，它首先进行一些底层设置，比如设置MMC&#x2F;SD&#x2F;SDIO控制器使用到的GPIO引脚、使能控制器、注册中断处理函数等，然后向上面的核心层增加一个主机（Host），这样核心层就可以调用s3cmci.c提供的函数来识别、使用具体存储卡了。<br>在向核心层增加主机之前，s3cmci.c设置了一个mmc_host_ops结构，它实现了两个函数：发起访问请求的request函数，进行一些属性设置（时钟频率、数据线位宽）的set_ios函数。以后上层对存储卡的操作都是通过这两个函数来完成。</li>
</ol>
<p>下面列出识别存储卡、区块层发起操作请求这两种情况下函数的主要调用关系，读者根据函数名称及所在文件，就可以了解到上面讲述的层次结构。<br>仍以即将移植的s3cmci.c为例：</p>
<ol>
<li>识别存储卡<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3c2410sdi_probe(host/s3c2410mci.c)</span><br><span class="line">     mmc_alloc_host(core/core.c)</span><br><span class="line">         mmc_rescan(core/core.c)</span><br><span class="line">             mmc_attach_sd(core/sd.c)(SD卡的入口点)<span class="comment">//尝试识别SD卡</span></span><br><span class="line">                 mmc_sd_init_card(core/sd.c)</span><br><span class="line">                     mmc_all_send_cid(core/sd_ops.c)<span class="comment">//读取存储卡的CID</span></span><br><span class="line">                         mmc_wait_for_cmd(core/core.c)<span class="comment">//发起并等待请求完成</span></span><br><span class="line">                             mmc_start_request(core/core.c)</span><br><span class="line">                                 host-&gt;ops-&gt;request(host, mrq);<span class="comment">//host/s3cmci.c的s3cmci_requset</span></span><br><span class="line">                     ...</span><br><span class="line">                     mmc_switch_hs(sd.c)<span class="comment">//设置为高速模式</span></span><br><span class="line">                         mmc_set_timing(core.c)<span class="comment">//设置时钟</span></span><br><span class="line">                             mmc_set_ios(core.c)</span><br><span class="line">                                 host-&gt;ops-&gt;set_ops(host,ios);<span class="comment">//host/s3cmci.c的s3cmci_set_ios</span></span><br><span class="line">                     ...</span><br><span class="line">             mmc_attach_mmc(core/mmc.c)(MMC卡的入口点)<span class="comment">//尝试识别MMC卡</span></span><br><span class="line">             ...</span><br></pre></td></tr></table></figure></li>
<li>区块层发起操作请求<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mmc_blk_issue_req(block/block.c)</span><br><span class="line">     mmc_wait_for_req(core/core.c)<span class="comment">//发起并等待请求完成</span></span><br><span class="line">         mmc_start_requst(core/core.c)</span><br><span class="line">             host-&gt;ops-&gt;request(host,mrq);<span class="comment">//host/s3cmci.c中的s3cmci_request</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="S3C2410-x2F-S3C2440的MMC-x2F-SD-x2F-SDIO控制器驱动程序移植"><a href="#S3C2410-x2F-S3C2440的MMC-x2F-SD-x2F-SDIO控制器驱动程序移植" class="headerlink" title="S3C2410&#x2F;S3C2440的MMC&#x2F;SD&#x2F;SDIO控制器驱动程序移植"></a>S3C2410&#x2F;S3C2440的MMC&#x2F;SD&#x2F;SDIO控制器驱动程序移植</h3><p>开发板上MMC&#x2F;SD接口的连线如下图所示，nCD接到外部中断引脚EINT16，接上或拔下存储卡时会触发中断。<br><img src="/2022/10/14/IDE%E6%8E%A5%E5%8F%A3%E5%92%8CSD%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/5.jpeg" alt="img not found"><br>移植MMC&#x2F;SD&#x2F;SDIO控制器驱动程序分为3个步骤：打补丁、增加MMC&#x2F;SD平台设备、修改主机控制器驱动程序以指定上图中的nCD中断。</p>
<ol>
<li>给内核打补丁<br>内核中要增加对S3C2410&#x2F;S3C2440的MMC&#x2F;SD&#x2F;SDIO控制器的支持，需要打补丁。以下6个patch：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">s3c_mci.patch</span><br><span class="line">s3c_mci_platform.patch</span><br><span class="line">s3cmci-dma-free.patch</span><br><span class="line">s3cmci-stop-fix.patch</span><br><span class="line">s3cmci-unfinished-write-fix.patch</span><br><span class="line">s3cmci_dbg.patch</span><br></pre></td></tr></table></figure>
按照上述文件的次序，执行以下命令打上补丁。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd linux-2.6.22.6</span><br><span class="line">patch -p1 &lt; s3c_mci.patch</span><br><span class="line">patch -p1 &lt; s3c_mci_platform.patch</span><br><span class="line">patch -p1 &lt; s3cmci-dma-free.patch</span><br><span class="line">patch -p1 &lt; s3cmci-stop-fix.patch</span><br><span class="line">patch -p1 &lt; s3cmci-unfinished-write-fix.patch</span><br><span class="line">patch -p1 &lt; s3cmci_dbg.patch</span><br></pre></td></tr></table></figure>
这些补丁修改或添加的文件有：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">drivers/mmc/host/Kconfig     <span class="comment">//修改</span></span><br><span class="line">drivers/mmc/host/Makefile    <span class="comment">//修改</span></span><br><span class="line">include/<span class="keyword">asm</span>-arm/arch-s3c2410/regs-sdi.h  <span class="comment">//修改</span></span><br><span class="line">include/<span class="keyword">asm</span>-arm/arch-s3c2410/mci.h       <span class="comment">//新增</span></span><br><span class="line">drivers/mmc/host/mmc_debug.c             <span class="comment">//新增</span></span><br><span class="line">drivers/mmc/host/mmc_debug.h             <span class="comment">//新增</span></span><br><span class="line">drivers/mmc/host/s3cmci.c                <span class="comment">//新增</span></span><br><span class="line">drivers/mmc/host/s3cmci.h                <span class="comment">//新增</span></span><br></pre></td></tr></table></figure>
然后配置内核，增加MMC块设备驱动、s3c24xx的MMC&#x2F;SD卡驱动，配置如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">     &lt;*&gt; MMC/SD card support ---&gt;</span><br><span class="line">         [*] MMC debugging</span><br><span class="line">         &lt;*&gt; MMC block device driver</span><br><span class="line">         &lt;*&gt; Samsung S3C SD/MMC Card Interface support</span><br></pre></td></tr></table></figure>
配置后编译内核时，会发现MMC_ERR_DMA、MMC_ERR_BUSY、MMC_ERR_CANCLED这3个宏没有定义，在<code>include/linux/mmc/core.c</code>中增加以下3行：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_ERR_DMA 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_ERR_BUSY 7</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MMC_ERR_CANCLED 8</span></span><br></pre></td></tr></table></figure></li>
<li>增加MMC&#x2F;SDI平台设备<br><code>drivers/mmc/s3cmci.c</code>文件的入口函数为s3cmci_init，代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3cmci_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">     platform_driver_register(&amp;s3cmci_driver_2410);</span><br><span class="line">     platform_driver_register(&amp;s3cmci_driver_2412);</span><br><span class="line">     platform_driver_register(&amp;s3cmci_driver_2440);</span><br><span class="line">     <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
上述向内核注册3个平台驱动，本书关注的两个驱动如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">s3cmci_driver_2410</span> =</span> &#123;</span><br><span class="line">     .driver.name = <span class="string">&quot;s3c2410-sdi&quot;</span>,</span><br><span class="line">     .probe = s3cmci_probe_2410,</span><br><span class="line">     .remove = s3cmci_remove,</span><br><span class="line">     .suspend = s3cmci_suspend,</span><br><span class="line">     .resume = s3cmci_resume,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">s3cmci_driver_2440</span> =</span> &#123;</span><br><span class="line">     .driver.name = <span class="string">&quot;s3c2440-sdi&quot;</span>,</span><br><span class="line">     .probe = s3cmci_probe_2440,</span><br><span class="line">     .remove = s3cmci_remove,</span><br><span class="line">     .suspend = s3cmci_suspend,</span><br><span class="line">     .resume = s3cmci_resume,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
当发现名称为“s3c2410-sdi”或“s3c2440-sdi”的平台设备时，会调用其中的s3cmci_probe_2410或s3cmci_probe_2440函数来枚举MMC&#x2F;SD设备。<br>如上所述，要为MMC&#x2F;SD驱动定义平台设备。在内核文件<code>arch/arm/plat-s3c24xx/devs.c</code>中，已经有一个平台设备的数据结构s3c_device_sdi（名称为“s3c2410-sdi”），只不过还没有使用它。<br>现在仿照它在以下两个文件中分别增加s3c2410_device_sdi，s3c2440_device_sdi结构，并把它们加入到设备列表中（就是smdk2410_devices[]、smdk2440_devices[]数组）。<br>①修改<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code><br>以下是修改的代码<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*SDI*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">s3c2410_sdi_resource</span>[] =</span> &#123;</span><br><span class="line">     [<span class="number">0</span>] = &#123;</span><br><span class="line">         .start = S3C2410_PA_SDI,</span><br><span class="line">         .end = S3C2410_PA_SDI + S3C24XX_SZ_SDI - <span class="number">1</span>,</span><br><span class="line">         .flag = IORESOURCE_MEM,</span><br><span class="line">     &#125;,</span><br><span class="line">     [<span class="number">1</span>] = &#123;</span><br><span class="line">         .start = IRQ_SDI,</span><br><span class="line">         .end = IRQ_SDI,</span><br><span class="line">         .flag = IORESOURCE_IRQ,</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">s3c2410_device_sdi</span> =</span> &#123;</span><br><span class="line">     .nane = <span class="string">&quot;s3c2410-sdi&quot;</span>,</span><br><span class="line">     .id = <span class="number">-1</span>,</span><br><span class="line">     .num_resources = ARRAY_SIZE(s3c2410_sdi_resource),</span><br><span class="line">     .resource = s3c2410_sdi_resource,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">smdk2410_devices</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     &amp;s3c2410_device_sdi,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
②修改<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*SDI*/</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">resource</span> <span class="title">s3c2440_sdi_resource</span>[] =</span> &#123;</span><br><span class="line">     [<span class="number">0</span>] = &#123;</span><br><span class="line">         .start = S3C2410_PA_SDI,</span><br><span class="line">         .end = S3C2410_PA_SDI + S3C24XX_SZ_SDI - <span class="number">1</span>,</span><br><span class="line">         .flag = IORESOURCE_MEM,</span><br><span class="line">     &#125;,</span><br><span class="line">     [<span class="number">1</span>] = &#123;</span><br><span class="line">         .start = IRQ_SDI,</span><br><span class="line">         .end = IRQ_SDI,</span><br><span class="line">         .flag = IORESOURCE_IRQ,</span><br><span class="line">     &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">s3c2440_device_sdi</span> =</span> &#123;</span><br><span class="line">     .nane = <span class="string">&quot;s3c2440-sdi&quot;</span>,</span><br><span class="line">     .id = <span class="number">-1</span>,</span><br><span class="line">     .num_resources = ARRAY_SIZE(s3c2440_sdi_resource),</span><br><span class="line">     .resource = s3c2440_sdi_resource,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">smdk2410_devices</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">     ...</span><br><span class="line">     &amp;s3c2440_device_sdi,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
③修改<code>drivers/mmc/host/s3cmci.c</code>，指定nCD中断。<br>只要在s3cmci_def_pdata结构中修改gpio_detect成员即可，将它从0改为S3C2410_GPG8。修改后的代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">s3c24xx_mci_pdata</span> <span class="title">s3cmci_def_pdata</span> =</span> &#123;</span><br><span class="line">     .gpio_detect = S3C2410_GPG8,</span><br><span class="line">     .set_power = <span class="literal">NULL</span>,</span><br><span class="line">     .ocr_avail = MMC_VDD_32_33,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
s3cmci.c中的函数会将GPG8引脚设置为外部中断EINT16，设置双边沿触发。现在可以编译内核了。</li>
</ol>
<h2 id="SD卡驱动程序测试"><a href="#SD卡驱动程序测试" class="headerlink" title="SD卡驱动程序测试"></a>SD卡驱动程序测试</h2><p>使用新编译的内核启动系统，可以看到如下信息：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3c2440-sdi s3c2440-sdi: powered down</span><br><span class="line">s3c2440-sdi s3c2440-sdi: initialisation done</span><br></pre></td></tr></table></figure>
<p>如果接上SD卡，还可以看到类似下面的信息：<br><img src="/2022/10/14/IDE%E6%8E%A5%E5%8F%A3%E5%92%8CSD%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/6.jpeg" alt="img not found"><br>这表明已经识别出了SD卡，然后就可以使用fdisk工具来分区，使用mke2fs或mkdosfs来格式化设备了。<br>如果根文件系统中没有使用mdev机制，在使用之前要先创建设备节点（主设备号可以通过“cat &#x2F;proc&#x2F;devices”命令确定），mmcblk0表示整个SD卡，mmcblk0p1等表示上面的分区。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">mknod /dev/mmcblk0 b 179 0</span><br><span class="line">mknod /dev/mmcblk0p1 b 179 1</span><br><span class="line">mknod /dev/mmcblk0p2 b 179 2</span><br><span class="line">mknod /dev/mmcblk0p3 b 179 3</span><br><span class="line">mknod /dev/mmcblk0p4 b 179 4</span><br></pre></td></tr></table></figure>

<h2 id="磁盘分区表"><a href="#磁盘分区表" class="headerlink" title="磁盘分区表"></a>磁盘分区表</h2><p>磁盘的分区形式表示形式有多种风格：BSD&#x2F;SUN、IRIX&#x2F;SGI、DOS。在DOS风格的分区表中，分区开始地址和大小是以两种不同的形式来存放的：以扇区数的绝对值来描述（占32位）和以柱面、磁头、扇区三个一组的形式（占10+8+6个位）来描述。前者编号从0开始；后者被称为C&#x2F;H&#x2F;S方式。<br>磁盘一个扇区大小为512字节，第一个扇区被称为主引导记录（MBR，Mater Boot Record）。MBR中偏移地址446-509处存放了分区表，每个表项为16字节，可以存放4个表项。MBR偏移地址中510、511处的数据为0x55、0xAA。<br>分布表项的数据结构如下（在<code>include/linux/genhd.h</code>中定义）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">partition</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> boot_ind;		<span class="comment">/*引导标志。4个分区中同时只能有一个分区是可引导的</span></span><br><span class="line"><span class="comment">                                    0x00：不从该分区引导操作系统</span></span><br><span class="line"><span class="comment">                                    0x08：从该分区引导操作系统</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> head;		    <span class="comment">/*起始磁头*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sector;		<span class="comment">/* 起始扇区 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> cyl;		    <span class="comment">/* 起始柱面 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> sys_ind;		<span class="comment">/* 分区类型</span></span><br><span class="line"><span class="comment">                                    0x05：扩展分区</span></span><br><span class="line"><span class="comment">                                    0x06：FAT16</span></span><br><span class="line"><span class="comment">                                    0x83：Linux</span></span><br><span class="line"><span class="comment">                                */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> end_head;		<span class="comment">/* 结束磁头 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> end_sector;	<span class="comment">/* 结束扇区 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">char</span> end_cyl;		<span class="comment">/* 结束柱面 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> start_sect;	<span class="comment">/* 分区起始物理扇区号（从0计数） */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> nr_sects;		<span class="comment">/* 分区占用的扇区数 */</span></span><br><span class="line">&#125; __attribute__((packed));</span><br></pre></td></tr></table></figure>
<p>其中的head、sector、cyl、end_head、end_sector、end_cyl在Linux中不再使用，而是使用start_sect、nr_sects来定义一个分区的开始扇区和大小。<br>由于MBR中只有4个分区表项，所以一个磁盘最多可以有4个主分区。如果要划分更多的分区，那么这4个分区只可以用1个来作为扩展分区（表项中sys_ind等于0x05）。当创建一个扩展分区时，扩展分区表也被创建。扩展分区就像一个独立的磁盘驱动器，它有自己的分区表，在他里面又可以进一步划分最多4个分区，也可以划分一个扩展分区。扩展分区里面进一步划分出来的分区被称为逻辑分区，与主分区相对，扩展分区的分区表完全包含在扩展分区之内。<br><img src="/2022/10/14/IDE%E6%8E%A5%E5%8F%A3%E5%92%8CSD%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/7.jpeg" alt="img not found"></p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第4篇第23章 IDE接口和SD卡驱动程序移植</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux Driver</tag>
      </tags>
  </entry>
  <entry>
    <title>进程管理</title>
    <url>/2022/10/26/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本章引入进程的概念，进程是Unix操作系统抽象概念中最基本的一种。其中涉及进程的定义以及相关的概念，比如线程；然后讨论Linux内核如何管理每个进程：它们在内核中如何被列举，如何创建，最终又如何消亡。我们拥有操作系统就是为了运行用户程序，因此，进程管理就是所有操作系统的心脏所在，Linux也不例外。</p>
<span id="more"></span>

<h1 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h1><p>进程就是处于执行期的程序（目标码存放在某种存储介质上）。但进程并不仅仅局限于一段可执行程序代码（Unix称其为代码段，text section）。通常进程还要包含其他资源，像打开的文件，挂起的信号，内核内部数据，处理器状态，一个或多个具有内存映射的内存地址空间及一个或多个执行线程（thread of execution），当然还包括用来存放全局变量的数据段等。实际上，进程就是正在执行的程序代码的实时结果。内核需要有效而又透明地管理所有细节。<br>执行线程，简称线程（thread），是在进程中活动的对象。每个线程都拥有一个独立的程序技术器、进程栈和一组进程寄存器。内核调度的对象是线程，而不是进程。在传统的Unix系统中，一个进程只包含一个线程，但现在的系统中，包含多个线程的多线程程序司空见惯。稍后你就会看到，Linux系统的线程实现非常特别：它对线程和进程并无特别区分。对Linux而言，线程不过是一种特殊的进程罢了。<br>在现代操作系统中，进程提供两种虚拟机制：虚拟处理器和虚拟内存。虽然实际上可能是许多进程正在分享一个处理器，但是虚拟处理器会给进程一种假象，让这些进程觉得自己在独享处理器。而虚拟内存让进程在分配和管理内存时觉得自己拥有整个系统的所有内存资源。有趣的是，注意在线程之间可以共享虚拟内存，但每个都拥有各自的虚拟处理器。<br>程序本身并不是进程，进程是处于执行期的程序以及相关的资源的总称。实际上，完全可能存在两个或多个不同的进程执行的是同一个程序。并且两个或两个以上并存的进程还可以共享许多诸如打开的文件、地址空间之类的资源。<br>无疑，进程在创建它的时刻开始存活。在Linux系统中，这通常是调用fork()系统的结果，该系统调用通过复制一个现有进程来创建一个全新的进程。调用fork()的进程称为父进程，新产生的进程称为子进程。在该调用结束时，在返回点这个相同位置上，父进程恢复执行，子进程开始执行。fork()系统调用从内核返回两次：一次回到父进程，另一次回到新产生的子进程。<br>通常，创建新的进程都是为了立即执行新的、不同的程序，而接着调用exec()这组函数就可以创建新的地址空间，并把新的程序载入其中。在现代Linux内核中，fork()实际上是由clone()系统调用实现的。<br>最终，程序通过exit()系统调用调用并退出执行。这个函数会终结进程并将其占用的资源释放掉。父进程可以通过wait4()系统调用查询子进程是否终结，这其实使得进程拥有了等待特定进程执行完毕的能力。进程退出执行之后被设置为僵死状态，直到它的父进程调用wait()或waitpid()为止。<br><strong>注意</strong><br>    进程的另一个名字是任务（task），Linux通常把进程也叫做任务。</p>
<h1 id="进程描述符及任务结构"><a href="#进程描述符及任务结构" class="headerlink" title="进程描述符及任务结构"></a>进程描述符及任务结构</h1><p>内核把进程的列表存放在叫做任务队列（task list）的双向循环链表中。链表中中的每一项都是类型为task_struct、称为进程描述符（process descriptor）的结构，该结构定义在&lt;linux&#x2F;sched.h&gt;文件中。进程描述符中包含一个具体进程的所有信息。<br>task_struct相对较大，在32位机器上，它大约有1.7KB。但如果考虑到该结构内包含了内核管理一个进程所需的所有信息，那么它的大小也算相当小的了。进程描述符中包含的数据能完整的描述一个正在执行的程序：它打开的文件，进程的地址空间，挂起的信号，进程的状态，还有其他更多信息。<br><img src="/2022/10/26/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/1.jpeg" alt="img not found"></p>
<h2 id="分配进程描述符"><a href="#分配进程描述符" class="headerlink" title="分配进程描述符"></a>分配进程描述符</h2><p>Linux通过slab分配器分配task_struct结构，这样能达到对象复用和缓存着色（cache coloring）的目的。在2.6以前的内核中，各个进程的task_struct存放在它们内核栈的尾端。这样做是为了让那些像x86那样寄存器较少的硬件体系结构只要通过栈指针就能计算出它的位置，而避免使用额外的寄存器专门记录。由于现在使用的slab分配器动态生成task_struct，所以只需要在栈底或栈顶创建一个新的结构struct thread_info。<br>在x86上，struct thread_info在文件&lt;asm&#x2F;thread_info.h&gt;中定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	        *<span class="title">task</span>;</span>		<span class="comment">/* main task structure */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">exec_domain</span>	        *<span class="title">exec_domain</span>;</span>	<span class="comment">/* execution domain */</span></span><br><span class="line">	__u32			            flags;		<span class="comment">/* low level flags */</span></span><br><span class="line">	__u32			            status;		<span class="comment">/* thread synchronous flags */</span></span><br><span class="line">	__u32			            cpu;		<span class="comment">/* current CPU */</span></span><br><span class="line">	<span class="type">int</span> 			            preempt_count;	<span class="comment">/* 0 =&gt; preemptable, &lt;0 =&gt; BUG */</span></span><br><span class="line"></span><br><span class="line">	<span class="type">mm_segment_t</span>		        addr_limit;	</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">restart_block</span>        <span class="title">restart_block</span>;</span></span><br><span class="line">    <span class="type">void</span>                        *sysenter_return;</span><br><span class="line">    <span class="type">int</span>                         uaccess_err;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><img src="/2022/10/26/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/2.jpeg" alt="img not found"><br>每个任务的thread_info结构在它的内核栈的尾端分配。结构中task域中存放的是指向该任务实际task_struct的指针。</p>
<h2 id="进程描述符的存放"><a href="#进程描述符的存放" class="headerlink" title="进程描述符的存放"></a>进程描述符的存放</h2><p>内核通过一个唯一的进程标识值（PID）来标识每个进程。PID是一个数，表示为pid_t隐含类型，实际上就是一个int类型。为了与老版本的Unix和Linux兼容，PID的最大值默认设置为32768（short int 短整型的最大值），尽管这个值也可以增加到高达400万（这受&lt;linux&#x2F;threads.h&gt;中所定义PID最大值的限制）。内核把每个进程的PID存放在它们各自的进程描述符中。<br>这个最大值很重要，因为它实际上就是系统中允许同时存在的进程的最大数目。尽管32768对于一般的桌面系统足够用了，但是大型服务器可能需要更多进程。这和值越小，转一圈就越快，本来数值大的进程比数值小的进程迟允许，但这样一来就破坏了这一原则。如果确实需要的话，可以不考虑与老式系统的兼容，由系统管理员通过修改<code>/proc/sys/kernel/pid_max</code>来提高上限。<br>在内核中，访问任务通常需要获得指向其task_struct的指针。实际上，内核中大部分处理进程的代码都是直接通过task_struct进行的。因此，通过current宏查找当前正在运行进程的进程描述符的速度就显得尤为重要。硬件体系结构不同，该宏的实现也不同，它必须针对专门的硬件体系结构做处理。有的硬件体系结构可以拿出一个专门寄存器来存放指向当前进程task_struct的指针，用于加快访问速度。而有些像x86这样的体系结构（其寄存器并不富余），就只能在内核栈的尾端创建thread_info结构，通过计算间接偏移查找task_struct结构。<br>在x86系统上，current把栈指针的后13个有效位屏蔽掉，用来计算出thread_info的偏移。该操作是通过current_thread_info()函数来完成的。汇编代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">movl $-8192, %eax</span><br><span class="line">andl %esp, %eax</span><br></pre></td></tr></table></figure>
<p>这里假定栈的大小位8KB。当4KB的栈启用时，就要用4096，而不是8192。<br>最后，current再从thread_info的task域中提取并返回task_struct的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">current_thread_info()-&gt;task;</span><br></pre></td></tr></table></figure>
<p>对比一下这部分在PowerPC上的实现（IBM基于RISC的现代微处理器），我们可以发现PPC当前的task_struct是保存在一个寄存器中的。也就是说，在PPC上，current宏只需把r2寄存器中值返回就行了。与x86不一样，PPC有足够多的寄存器，所以它的实现有这样选择的余地。而访问进程描述符是一个重要的频繁操作，所以PPC的内核开发者觉得完全有必要为此使用一个专用的寄存器。</p>
<h3 id="进程状态"><a href="#进程状态" class="headerlink" title="进程状态"></a>进程状态</h3><p>进程描述符中的state描述了进程的当前状态。系统中的每个进程都必然处于五种进程状态中的一种。该域的值也必为下列五种状态之一：</p>
<ol>
<li>TASK_RUNNING（运行）–进程是可执行的；它或者正在执行，或者在运行队列中等待执行。这是进程在用户空间中执行的唯一可能的状态；这种状态也可以应用到内核空间中正在执行的进程。</li>
<li>TASK_INTERRUPTIBLE（可中断）–进程正在睡眠（也就是说它被阻塞），等待某些条件的达成。一旦条件达成，内核就会把进程状态设置成运行。处于此状态的进程也会因为接收到信号而被提前唤醒并随时准备投入运行。</li>
<li>TASK_UNINTERRUPTIBLE（不可中断）–除了就算是接收到信号也不会被唤醒或准备投入运行外，这个状态域可打断状态相同。由于处于此状态的任务对信号不做响应，所以较之可中断状态，使用的较少。</li>
<li>__TASK_TRACES–被其他进程跟踪的进程，例如通过ptrace对调试程序进行跟踪。</li>
<li>__TASK_STOPPED（停止）–进程停止执行；进程没有投入运行也不能投入运行。通常这种状态发生在接收到SIGSTOP、SIGTSTP、SIGTTIN、SIGTTOU等信号的时候。此外，在调试期间接收到任何信号，都会使进程进入这种状态。<br><img src="/2022/10/26/%E8%BF%9B%E7%A8%8B%E7%AE%A1%E7%90%86/3.jpeg" alt="img not found"></li>
</ol>
<h3 id="设置当前进程状态"><a href="#设置当前进程状态" class="headerlink" title="设置当前进程状态"></a>设置当前进程状态</h3><p>内核需要经常调整某个进程的状态。这时最好使用set_task_state(task,state)函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">set_task_state(task,state); <span class="comment">//将任务task的状态设置为state</span></span><br></pre></td></tr></table></figure>
<p>该函数将指定的进程设置为指定的状态。必要的时候，它会设置内存屏障来强制其他处理器作重新排序。（一般只有在SMP系统中有此必要）否则，它等价于：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">task-&gt;state = state;</span><br></pre></td></tr></table></figure>
<p>set_current_state(state)和set_task_state(current,state)含义是等同的。参看&lt;linux&#x2F;sched.h&gt;中对相关函数实现的说明。</p>
<h3 id="进程上下文"><a href="#进程上下文" class="headerlink" title="进程上下文"></a>进程上下文</h3><p>可执行程序代码是进程的重要组成部分。这些代码从一个可执行文件载入到进程的地址空间执行。一般程序在用户空间执行。当一个程序调用执行了系统调用或者出发了某个异常，它就陷入内核空间。此时，我们称内核“代表进程执行”并处于进程上下文中。由此上下文中current宏是有效的。除非在此间隙有更高优先级的进程需要执行并由调度器做出相应调整，否则在内核退出的时候，程序恢复在用户空间继续执行。<br>系统调用和异常处理程序是对内核明确定义的接口。进程只有通过这些接口才能陷入内核执行–对内核的所有访问都必须通过这些接口。</p>
<h3 id="进程家族树"><a href="#进程家族树" class="headerlink" title="进程家族树"></a>进程家族树</h3><p>Unix系统的进程之间存在一个明显的继承关系，在Linux系统中也是如此。所有进程都是PID为1的init进程的后代。内核在系统启动的最后阶段启动init进程。该进程读取系统的初始化脚本（initscript）并执行其他的相关程序，最终完成系统启动的整个过程。<br>系统中的每个进程必有一个父进程，相应的，每个进程也可以拥有零个或多个子进程。拥有同一个父进程的所有进程被称为兄弟。进程间的关系存放在进程描述符中。每个task_struct都包含一个指向其父进程task_struct、叫做parent的指针，还包含一个称为children的子进程链表。所以，对于当前进程，可以通过下面的代码获得其父进程的进程描述符：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">my_parent</span> =</span> current-&gt;parent;</span><br></pre></td></tr></table></figure>
<p>同样，也可以按以下方式依次访问子进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(<span class="built_in">list</span>,&amp;current-&gt;children) &#123;</span><br><span class="line">    task = list_entry(<span class="built_in">list</span>,<span class="keyword">struct</span> task_struct,sibling);</span><br><span class="line">    <span class="comment">/* task现在指向当前的某个子进程 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>init进程的进程描述符是作为init_task静态分配的。下面的代码可以很好地演示所有进程之间的关系：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"><span class="keyword">for</span>(task = current;task != &amp;init_task;task = task-&gt;parent)</span><br><span class="line"><span class="comment">/* task现在指向init */</span></span><br></pre></td></tr></table></figure>
<p>实际上，你可以通过这种继承体系从系统的任何一个进程出发查找到任意指定的其他进程。但大多数时候，只需要通过简单的重复方式就可以遍历系统中的所有进程。这非常容易做到，因为任务队列就是一个双向循环链表。对于给定的进程，获取链表的下一个进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.next,<span class="keyword">struct</span> task_struct,tasks)</span><br></pre></td></tr></table></figure>
<p>获取前一个进程的方法与之相同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_entry(task-&gt;tasks.prev,<span class="keyword">struct</span> task_struct,tasks)</span><br></pre></td></tr></table></figure>
<p>这两个例程分别通过next_task(task)宏和prev_task(task)宏实现。而实际上，for_each_process(task)宏提供了一次访问整个任务队列的能力。每次访问，任务指针都指向链表中的下一个元素：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span>;</span></span><br><span class="line"></span><br><span class="line">for_each_process(task) &#123;</span><br><span class="line">    <span class="comment">/* 它打印出的每一个任务的名称和PID */</span></span><br><span class="line">    printk(<span class="string">&quot;%s[%d]\n&quot;</span>,task-&gt;comm,task-&gt;pid);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>特别提醒</strong><br>    <em>在一个拥有大量进程的系统中通过重复来遍历所有的进程代价是很大的，因此，如果没有充足的理由，别这样做</em></p>
<h1 id="进程创建"><a href="#进程创建" class="headerlink" title="进程创建"></a>进程创建</h1><p>Unix的进程创建很特别。许多其他的操作相同都提供了产生（spawn）进程的机制，首先在新的地址空间里创建进程，读入可执行程序，最后开始执行。Unix采用了与众不同的实现方式，它把上述步骤分解到两个单独的函数中去执行：fork()和exec()。首先，fork()通过拷贝当前进程创建一个子进程。父进程与子进程的区别仅仅在于PID（每个进程唯一）、PPID（父进程的进程号，子进程将其设置为被拷贝进程的PID）和某些资源和统计量（例如，挂起的信号，它没有必要被继承）。exec()函数负责读取可执行文件并将其载入地址空间开始运行。把这两个函数组合起来使用的效果跟其他系统使用的单一函数的效果相似。</p>
<h2 id="写时拷贝"><a href="#写时拷贝" class="headerlink" title="写时拷贝"></a>写时拷贝</h2><p>传统的fork()系统调用直接把所有的资源复制给新创建的进程。这种实现过于简单并且效率低下，因为它拷贝的数据也许并不共享，更糟的情况是，如果新进程打算立即执行一个新的映像，那么所有的拷贝都将前功尽弃。Linux的fork()使用写时拷贝（copy-on-write）页实现。写时拷贝是一种可以推迟甚至是免除拷贝数据的技术。内核此时并不复制整个地址空间，而是让父进程和子进程共享同一个拷贝。<br>只有在需要写入的时候，数据才会被复制，从而使各个进程拥有各自的拷贝。也就是说，资源的复制只有在需要写入的时候才进行，在此之前，只是以只读方式共享。这种技术使地址空间上的页的拷贝被推迟到实际发生写入的时候才进行。在页根本不会被写入的情况下（fork()后立即调用exec()）它们就无须复制了。<br>fork()的实际开销就是复制父进程的页表以及给子进程创建唯一的进程描述符。在一般情况下，进程创建后都会马上运行一个可执行的文件，这种优化可以避免拷贝大量根本不会使用的数据（地址空间中常常包含数十兆的数据）。由于Unix强调进程快速执行的能力，所以这个优化是很重要的。</p>
<h2 id="fork"><a href="#fork" class="headerlink" title="fork()"></a>fork()</h2><p>Linux通过clone()系统调用实现fork()。这个调用通过一系列的参数标志来指明父、子进程需要共享的资源。fork()、vfork()和__clone()库函数都根据各自需要的参数标志去调用clone()，然后由clone()去调用do_fork()。<br>do_fork()完成了创建中的大部分工作，它的定义在<code>kernel/fork.c</code>文件中。该函数调用copy_process()函数，然后让进程开始运行。copy_process()函数完成的工作很有意思：</p>
<ol>
<li>调用dup_task_struct()为新进程创建一个内核栈，thread_info结构和task_struct，这些值与当前进程的值相同。此时，子进程和父进程的描述符是完全相同的。</li>
<li>检查并确保新创建这个子进程后，当前用户所拥有的进程数目没有超出给它分配的资源的限制。</li>
<li>子进程着手使自己与父进程区别开来。进程描述符内的许多成员都要被清0或设为初始值。那些不是继承而来的进程描述符成员，主要是统计信息。task_struct中的大多数数据都依然未被修改。</li>
<li>子进程的状态被设置为TASK_UNINTERRUPTBLE，以保证它不会投入运行。</li>
<li>copy_process()调用copy_flag()以更新task_struct的flags成员。表明进程是否拥有超级用户权限的PF_SUPERPRIV标志被清0。表明进程还没有调用exec()函数的PF_FORKNOEXEC标志被设置。</li>
<li>调用alloc_pid()为新进程分配一个有效的PID。</li>
<li>根据传递给clone()的参数标志，copy_process()拷贝或共享打开的文件、文件系统信息、信号处理函数、进程地址空间和命名空间等。在一般情况下，这些资源会被给定进程的所有线程共享；否则，这些资源对每个进程是不同的，因此被拷贝到这里。</li>
<li>最后，copy_process()做扫尾工作并返回一个指向子进程的指针。</li>
</ol>
<p>再回到do_fork()函数，如果copy_process()函数成功返回，新创建的子进程被唤醒并让其投入运行。内核有意选择子进程首先执行。因为一般子进程都会马上调用exec()函数，这样可以避免写时拷贝的额外开销，如果父进程首先执行的话，有可能会开始向地址空间写入。</p>
<h2 id="vfork"><a href="#vfork" class="headerlink" title="vfork()"></a>vfork()</h2><p>除了不拷贝父进程的页表项外，vfork()系统调用和fork()的功能相同。子进程作为父进程的一个单独的线程在它的地址空间里运行，父进程被阻塞，直到子进程退出或执行exec()。子进程不能向地址空间写入。在过去的3BSD时期，这个优化是很有意义的，那时并未使用写时拷贝页来实现fork()。现在由于在执行fork()时引入了写时拷贝页并且明确了子进程先执行，vfork()的好处就只仅限于不拷贝父进程的页表项了。如果Linux将来fork()有了写时拷贝页表项，那么vfork()就彻底没用了。另外由于vfork()语意非常微妙（试想，如果exec()调用失败会发生什么），所以理想情况下，系统最好不要调用vfork()，内核也不用实现它。完全可以把vfork()实现成一个普普通通的fork()–实际上，Linux2.2以前都是这么做的。<br>vfork()系统调用的实现是通过向clone()系统调用传递一个特殊标志来进行的。</p>
<ol>
<li>在调用copy_process()时，task_struct的成员vfork_done被设置为NULL。</li>
<li>在执行do_fork()时，如果给定特别标志，则vfork_done会指向一个特定地址。</li>
<li>子进程先开始执行后，父进程不是马上执行，而是一直等待，直到子进程通过vfork_done指针向它发送信号。</li>
<li>在调用mm_release()时，该函数用于进程退出内存地址空间，并且检查vfork_done是否为空，如果不为空，则会向父进程发送信号。</li>
<li>回到do_fork()，父进程醒来并返回。</li>
</ol>
<p>如果一切执行顺利，子进程在新的地址空间里运行而父进程也恢复了在原地址空间的运行。这样，开销确实低了，不过它的实现并不是优良的。</p>
<h1 id="线程在Linux中的实现"><a href="#线程在Linux中的实现" class="headerlink" title="线程在Linux中的实现"></a>线程在Linux中的实现</h1><p>线程机制是现代编程技术中常用的一种抽象概念。该机制提供了在同一程序内共享内存地址空间运行的一组线程。这些线程还可以共享打开的文件和其他资源。线程机制支持并发程序设计技术（concurrent programing），在多处理系统上，它也能保证真正的并行处理（parallelism）。<br>Linux实现线程的机制非常独特。从内核的角度来说，它并没有线程这个概念。Linux把所有的线程都当作进程来实现。内核并没有准备特别的调度算法或是定义特别的数据结构来表征线程。相反，线程仅仅被视为一个与其他进程共享资源的进程。每个线程都有唯一隶属于自己的task_struct，所以在内核中，它看起来就像一个普通的进程（只是线程和其他的一些进程共享某些资源，如地址空间）。<br>上述线程机制的实现与Mircosoft Windows或是Sun Solaris等操作系统的实现差异非常大。这些系统都在内核中提供了专门支持线程的机制（这些系统常常把线程称为轻量级进程（lightweight processes））。“轻量级进程”这种叫法本身就概括了Linux在此处与其他系统的差异。在其他的系统中，相较于重量级的进程，线程被抽象成一种耗费较小资源，运行迅速的执行单元。而对于Linux来说，它只是一种进程间共享资源的手段（Linux中的进程本身就是轻量级了）。举个例子来说，假如我们有一个包含四个线程的进程，在专门提供线程支持的系统中，通常会有一个包含指向四个不同线程的指针的进程描述符。该描述符负责描述像地址空间、打开的文件等这样的共享资源。线程本身再去描述它独占的资源。相反，Linux仅仅创建四个进程并分配四个普通的task_struct结构。建立这四个进程时指定它们共享某些资源，这是相当高雅的做法。</p>
<h2 id="创建线程"><a href="#创建线程" class="headerlink" title="创建线程"></a>创建线程</h2><p>线程的创建和普通进程的创建类似，只不过在调用clone()的时候需要传递一些参数标志来指明需要共享的资源：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(CLONE_VM | CLONE_FS | CLONE_FILES | CLONE_SIGHAND,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>上面的代码产生的结果和调用fork()差不多，只是父子俩共享地址空间、文件系统资源、文件描述符和信号处理程序。换个说法就是，新建的进程和它的父进程就是流行的所谓线程。<br>对比一下，一个普通的fork()的实现就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(SIGCHLD,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>而vfork()的实现是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clone(CLONE_VFORK | CLONE_VM | SIGCHLD,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>传递给clone()的参数标志决定了新创建进程的行为方式和父子进程之间共享的资源种类。下表列举了这些clone()用到的参数以及它们的作用，这些都是在&lt;linux&#x2F;sched.h&gt;中定义的。</p>
<table>
<thead>
<tr>
<th>参数标志</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>CLONE_FILES</td>
<td>父子进程共享打开的文件</td>
</tr>
<tr>
<td>CLONE_FS</td>
<td>父子进程共享文件系统信息</td>
</tr>
<tr>
<td>CLONE_IDLETASK</td>
<td>将PID设置为0（只供idle进程使用）</td>
</tr>
<tr>
<td>CLONE_NEWNS</td>
<td>为子进程创建新的命名空间</td>
</tr>
<tr>
<td>CLONE_PARENT</td>
<td>指定子进程与父进程拥有同一个进程</td>
</tr>
<tr>
<td>CLONE_PTRACE</td>
<td>继续调试子进程</td>
</tr>
<tr>
<td>CLONE_SETTID</td>
<td>将TID回写至用户空间</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>为子进程创建新的TLS</td>
</tr>
<tr>
<td>CLONE_SIGHAND</td>
<td>父子进程共享信号处理函数及被阻断的信号</td>
</tr>
<tr>
<td>CLONE_SYSVSEM</td>
<td>父子进程共享System V SEM_UNDO语义</td>
</tr>
<tr>
<td>CLONE_THREAD</td>
<td>父子进程放入相同的线程组</td>
</tr>
<tr>
<td>CLONE_VFORK</td>
<td>调用vfork()，所以父进程准备睡眠等待子进程将其唤醒</td>
</tr>
<tr>
<td>CLONE_UNTRACED</td>
<td>防止跟踪进程在子进程上强制执行CLONE_PTRACE</td>
</tr>
<tr>
<td>CLONE_STOP</td>
<td>以TASK_STOPPED状态开始进程</td>
</tr>
<tr>
<td>CLONE_SETTLS</td>
<td>为子进程创建新的TLS（thread-local storage）</td>
</tr>
<tr>
<td>CLONE_CHILD_CLEARTID</td>
<td>清除子进程的TID</td>
</tr>
<tr>
<td>CLONE_CHILD_SETTID</td>
<td>设置子进程的TID</td>
</tr>
<tr>
<td>CLONE_PARENT_SETTID</td>
<td>设置父进程的TID</td>
</tr>
<tr>
<td>CLONE_VM</td>
<td>父子进程共享地址空间</td>
</tr>
</tbody></table>
<h2 id="内核线程"><a href="#内核线程" class="headerlink" title="内核线程"></a>内核线程</h2><p>内核经常需要在后台执行一些操作。这种任务可以通过内核线程（kernel thread）完成–独立运行在内核空间的标准进程。<code>内核线程和普通的进程间的区别在于内核线程没有独立的地址空间（实际上指向地址空间的mm指针被设置为NULL）。</code>它们只在内核空间运行，从来不切换到用户空间去。内核进程和普通进程一样，可以被调度，也可以被抢占。<br>Linux确实会把一些任务交给内核线程去做，像flush和ksofirqd这些任务就是明显的例子。在装有Linux系统的机子上运行<code>ps -ef</code>命令，你可以看到内核线程，有很多！这些线程在系统启动时由另外一些内核线程创建。实际上，内核线程也只能由其他内核线程创建。内核是通过从kthread内核进程中衍生出所有新的内核线程来自动处理这一点。在&lt;linux&#x2F;kthread.h&gt;中申明有接口，于是，从现有内核线程中创建一个新的内核线程的方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_create</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                                   <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                                   <span class="type">const</span> <span class="type">char</span> namefmt[],</span></span><br><span class="line"><span class="params">                                   ...)</span></span><br></pre></td></tr></table></figure>
<p>新的任务是由kthread内核进程通过clone()系统调用而创建的。新的进程将运行threadfn函数，给其传递的参数为data。进程会被命名为namefmt，namefmt接受可变参数列表类似于printf()的格式化参数。新创建的进程处于不可运行状态，如果不通过调用wake_up_process()明确唤醒它，它不会主动运行。创建一个进程并让它运行起来，可以通过调用kthread_run()来达到：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> task_struct *<span class="title function_">kthread_run</span><span class="params">(<span class="type">int</span> (*threadfn)(<span class="type">void</span> *data),</span></span><br><span class="line"><span class="params">                                <span class="type">void</span> *data,</span></span><br><span class="line"><span class="params">                                <span class="type">const</span> <span class="type">char</span> namefmt[],</span></span><br><span class="line"><span class="params">                                ...)</span></span><br></pre></td></tr></table></figure>
<p>这个例程是以宏实现的，只是简单的调用了看thread_create()和wake_up_process()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> kthread_run(threadfn,data,namefmt,...)                  \</span></span><br><span class="line"><span class="meta">(&#123;                                                              \</span></span><br><span class="line"><span class="meta">    struct task_struct *k;                                      \</span></span><br><span class="line"><span class="meta">                                                                \</span></span><br><span class="line"><span class="meta">    k = kthread_create(threadfn,data,namefmt,##__VA_ARGS__);    \</span></span><br><span class="line"><span class="meta">    <span class="keyword">if</span>(!IS_ERR(k))                                              \</span></span><br><span class="line"><span class="meta">        wake_up_process(k);                                     \</span></span><br><span class="line"><span class="meta">    k;                                                          \</span></span><br><span class="line"><span class="meta">&#125;)</span></span><br></pre></td></tr></table></figure>
<p>内核线程启动后就一直运行直到调用do_exit()退出，或者内核的其他部分调用kthread_stop()退出，传递给kthread_stop()的参数为kthread_create()函数返回的task_struct结构的地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kthread_stop</span><span class="params">(<span class="keyword">struct</span> task_struct *k)</span></span><br></pre></td></tr></table></figure>

<h1 id="进程终结"><a href="#进程终结" class="headerlink" title="进程终结"></a>进程终结</h1><p>虽然让人伤感，但进程终归是要终结的。当一个进程终结时，内核必须释放它所占有的资源，并把这一不幸告知其父进程。<br>一般来说，进程的析构是自身引起的。它发生在进程调用exit()系统调用时，既可能显式地调用这个系统调用，也可能隐式地从某个程序的主函数返回（其实C语言编译器会在main()函数的返回点后面放置调用exit()的代码）。当进程接收到它既不能处理也不能忽略的信号或者异常时，它还可能被动的终结。不管进程是怎么终结的，该任务大部分都要靠do_exit()（定义于kernel&#x2F;exit.c）来完成，它要做下面这些繁琐的工作：</p>
<ol>
<li>将task_struct中的标志成员设置为PF_EXITING。</li>
<li>调用del_timer_sync()删除任一内核定时器。根据返回的结果，它确保没有定时器在排队，也没有定时器处理程序在运行。</li>
<li>如果BSD的进程记账功能是开启的，do_exit()调用acct_update_integrals()来输出记账信息。</li>
<li>然后调用exit_mm()函数释放进程占用的mm_struct，如果没有别的进程使用它们（也就是说，这个地址空间没有被共享），就彻底释放它们。</li>
<li>接下来调用sem_exit()函数。如果进程排队等候IPC信号，它则离开队列。</li>
<li>调用exit_files()和exit_fs()，以分别递减文件描述符、文件系统数据的引用计数。如果其中某个引用计数的数值降为零，那么就代表没有进程在使用相应的资源，此时可以释放。</li>
<li>接着把存放在task_struct的exit_code成员中的任务退出代码置为由exit()提供的退出代码，或者去完成任何其他由内核机制规定的退出动作。退出代码存放在这里供父进程随时检索。</li>
<li>调用exit_notify()向父进程发送信号，给子进程重新找养父，养父为线程组中的其他线程或者init进程，并把进程状态（存放在task_struct结构中的exit_state中）设成EXIT_ZOMBIE。</li>
<li>do_exit()调用schedule()切换到新的进程。因为处于EXIT_ZOMBIE状态的进程不会再被调度，所以这是进程执行的最后一段代码。do_exit()永不返回。</li>
</ol>
<p>至此，与进程相关联的所有资源都被释放掉了（假设该进程是这些资源的唯一使用者）。进程不可运行（实际上也没有地址空间让它运行）并处于EXIT_ZOMBIE退出状态。它占用的所有内存就是内核栈、thread_info结构和task_struct结构。此时进程存在的唯一目的就是向它的父进程提供信息。父进程检索到信息后，或者通知内核那是无关的信息后，由进程所持有的剩余内存被释放，归还系统使用。</p>
<h2 id="删除进程描述符"><a href="#删除进程描述符" class="headerlink" title="删除进程描述符"></a>删除进程描述符</h2><p>在调用了do_exit()之后，尽管线程已经僵死不能再运行了，但是系统还保留了它的进程描述符。前面说过，这样做可以让系统有办法在子进程终结后仍能获得它的信息。因此，进程终结时所需的清理工作和进程描述符的删除被分开执行。在父进程获得已终结的子进程的信息后，或者通知内核它并不关注那些信息后，子进程的task_struct结构才被释放。<br>wait()这一族函数都是通过唯一（但是很复杂）的一个系统调用wait()来实现的。它的标准动作是挂起调用它的进程，直到其中的一个子进程退出，此时函数会返回孩子进程的PID。此外，调用该函数时提供的指针会包含子函数退出时的退出代码。<br>当最终需要释放进程描述符时，release_task()会被调用，用以完成以下工作：</p>
<ol>
<li>它调用__exit_signal()，该函数调用_unhash_process()，后者又调用detach_pid()从pidhash上删除该进程，同时也从任务列表中删除该进程。</li>
<li>_exit_signal()释放目前僵死进程所使用的所有剩余资源，并进行最终统计和记录。</li>
<li>如果这个进程是线程组最后一个进程，并且领头进程已经死掉，那么release_task()就要通知僵死的领头进程的父进程。</li>
<li>release_task()调用put_task_struct()释放进程内核栈和thread_info结构所占的页，并释放task_struct所占的slab高速缓存。</li>
</ol>
<p>至此，进程描述符和所有进程独享的资源就全部被释放掉了。</p>
<h2 id="孤儿进程造成的进退维谷"><a href="#孤儿进程造成的进退维谷" class="headerlink" title="孤儿进程造成的进退维谷"></a>孤儿进程造成的进退维谷</h2><p>如果父进程在子进程之前退出，必须有机制来保证子进程能找到一个新的父亲，否则这些成为孤儿的进程就会在退出时永远处于僵死状态，白白的耗费内存。前面的部分已经有所暗示，对于这个问题，解决方法是给子进程在当前线程组内找一个线程作为父亲，如果不行，就让init做它们的父进程。在do_exit()中会调用exit_notify()，该函数会调用forget_original_parent()，而后者会调用find_new_reaper()来执行寻父过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> task_struct *<span class="title function_">find_new_reaper</span><span class="params">(<span class="keyword">struct</span> task_struct *father)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pid_namespace</span> *<span class="title">pid_ns</span> =</span> task_active_pid_ns(father);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">thread</span>;</span></span><br><span class="line"></span><br><span class="line">    thread = father;</span><br><span class="line">    while_each_thread(father,thread) &#123;</span><br><span class="line">        <span class="keyword">if</span>(thread-&gt;flags &amp; PF_EXITING)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(unlikely(pid_ns-&gt;child_reaper == father))</span><br><span class="line">            pid_ns-&gt;child_reaper = thread;</span><br><span class="line">        <span class="keyword">return</span> thread;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(unlikely(pid_ns-&gt;child_reaper == father)) &#123;</span><br><span class="line">        write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line">        <span class="keyword">if</span>(unlikely(pid_ns == &amp;init_pid_ns))</span><br><span class="line">            panic(<span class="string">&quot;Attempted to kill init!&quot;</span>);</span><br><span class="line">        </span><br><span class="line">        zap_pid_ns_processes(pid_ns);</span><br><span class="line">        write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">            We can not clear -&gt;child_reaper or leave it alone.</span></span><br><span class="line"><span class="comment">            There may by stealth EXIT_DEAD tasks on -&gt;children,</span></span><br><span class="line"><span class="comment">            forget_original_parent() must move them somewhere.</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">       pid_ns-&gt;child_reaper = init_pid_ns.child_reaper;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pid_ns-&gt;child_reaper;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码试图找到进程所在的线程组内的其他进程。如果线程组内没有其他的进程，它就找到并返回的是init进程。现在，给子进程找到合适的养父进程了，只需要遍历所有子进程并为它们设置新的父进程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">reaper = find_new_reaper(father);</span><br><span class="line">list_for_each_entry_safe(p,n,&amp;father-&gt;children,sibling) &#123;</span><br><span class="line">    p-&gt;real_parent = reaper;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;parent == father) &#123;</span><br><span class="line">        BUG_ON(p-&gt;ptrace);</span><br><span class="line">        p-&gt;parent = p-&gt;real_parent;</span><br><span class="line">    &#125;</span><br><span class="line">    reparent_thread(p,father);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后调用ptrace_exit_finish()同样进行新的寻父过程，不过这次是给ptraced的子进程寻找父亲。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">exit_ptrace</span><span class="params">(<span class="keyword">struct</span> task_struct *tracer)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_strcut</span> *<span class="title">p</span>,*<span class="title">n</span>;</span></span><br><span class="line">    LIST_HEAD(ptrace_dead);</span><br><span class="line"></span><br><span class="line">    write_lock_irq(&amp;tasklist_lock);</span><br><span class="line">    list_for_each_entry_safe(p,n,&amp;tracer-&gt;ptraced,ptrace_entry) &#123;</span><br><span class="line">        <span class="keyword">if</span>(__ptrace_detach(tracer,p))</span><br><span class="line">            list_add(&amp;p-&gt;ptrace_entry,&amp;ptrace_dead);</span><br><span class="line">    &#125;</span><br><span class="line">    write_unlock_irq(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">    BUG_ON(!list_empty(&amp;tracer-&gt;ptraced));</span><br><span class="line"></span><br><span class="line">    list_for_each_entry_safe(p,n,&amp;ptrace_dead,ptrace_entry) &#123;</span><br><span class="line">        list_del_init(&amp;p-&gt;ptrace_entry);</span><br><span class="line">        release_task(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码遍历了两个链表：子进程链表和ptrace子进程链表，给每个子进程设置新的父进程。这两个链表同时存在的原因很有意思，它也是2.6内核的一个新特性。当一个进程被跟踪时，它的临时父亲设定为调试进程，。此时如果它的父进程退出了，系统会为它和它的所有兄弟重新找一个父进程。在以前的内核中，这就需要遍历系统所有的进程来找这些子进程。现在的解决方法是在一个单独被ptrace跟踪的子进程链表中搜索相关的兄弟进程–用两个相对较小的链表减轻了遍历带来的消耗。<br>一旦系统为进程成功地找到和设置了新的父进程，就不会再有出现驻留僵死进程的危险了。init进程会例行调用wait()来检查其子进程，清除所有与其相关的僵死进程。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在本章中，我们考察了操作系统中的核心概念–进程。我们也讨论了进程的一般特性，它为何如此重要，以及进程和线程之间的关系。然后，谈论了Linux如何存放和表示进程（用task_struct和thread_info），如何创建进程（通过fork()，实际上最终是clone()），如何把新的执行映像装入到地址空间（通过exec()系统调用族），如何让表示进程的层次关系，父进程又是如何收集其后代的信息（通过wait()系统调用族），以及进程最终如何消亡（强制或者自愿的调用exit()）。进程是一个非常基础的、非常关键的抽象概念，位于每一种现代操作系统的核心位置，也是我们拥有操作系统（用来运行程序）的最终原因。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第3章 进程管理</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内核数据结构</title>
    <url>/2022/11/04/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>本章将介绍几种Linux内核常用的内建数据结构。和其他很多大型项目一样，Linux内核实现了这些通用数据结构，而且提倡大家在开发时重用。内核开发者应该尽可能地使用这些数据结构，而不要搞自作主张地山寨方法。在下面的内容中，我们讲述这些通用数据结构中最有用的几个。</p>
<ol>
<li>链表</li>
<li>队列</li>
<li>映射</li>
<li>二叉树</li>
</ol>
<p>最后还要讨论算法复杂度，以及何种规模的算法或者数据结构可以相对容易的支持更大的输入集合。</p>
<span id="more"></span>

<h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>链表是Linux内核中最简单、最普通的数据结构。链表是一种存放和操作可变数量元素（常称为节点）的数据结构。链表和静态数组的不同在于，它所包含的元素都是动态创建并插入链表的，在编译时不必知道具体需要创建多少个元素。另外也因为链表中每个元素的创建时间各不相同，所以它们在内存中无需占用连续内存区。正是因为元素不连续的存放，所以各元素需要通过某种方式被连接在一起。于是每个元素都包含一个指向下一个元素的指针，当有元素加入链表或从链表删除元素时，简单调整指向下一个节点的指针就可以了。</p>
<h2 id="单向链表和双向链表"><a href="#单向链表和双向链表" class="headerlink" title="单向链表和双向链表"></a>单向链表和双向链表</h2><p>可以用一种简单的数据结构来表示这样一个链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个链表中的一个元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *data;                 <span class="comment">//有效数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elemet</span> *<span class="title">next</span>;</span>   <span class="comment">//指向下一个元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下图描述一个链表结构体。<br><img src="/2022/11/04/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/1.jpeg" alt="img not found"><br>在有些链表中，每个元素还包含一个指向前一个元素的指针，因为它们可以同时向前和向后相互连接，所以这些链表被称作双向链表。而上图那种只能向后连接的链表被称作单向链表。<br>表示双向链表的一种数据结构如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//一个链表中的一个元素</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_element</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> *data;                 <span class="comment">//有效数据</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elemet</span> *<span class="title">next</span>;</span>   <span class="comment">//指向下一个元素的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_elemet</span> *<span class="title">prev</span>;</span>   <span class="comment">//指向上一个元素的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下图描述了一个双向链表<br><img src="/2022/11/04/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/2.jpeg" alt="img not found"></p>
<h2 id="环形链表"><a href="#环形链表" class="headerlink" title="环形链表"></a>环形链表</h2><p>通常情况下，因为链表中的最后一个元素不再有下一个元素，所以将链表尾元素中的向后指针设置为NULL，以此表明它是链表中的最后一个元素。但在有些链表中，末尾元素并不指向特殊值，相反，它指回链表的首元素。这种链表因为首尾相连，所以被称为是环形链表。环形链表也存在双向链表和单向链表两种形式。在环形双向链表中，首节点的向前指针指向尾节点。下图分别表示单向和环形双向链表：<br><img src="/2022/11/04/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/3.jpeg" alt="img not found"><br>因为环形双向链表提供了最大的灵活性，所以Linux内核的标准链表就是采用环形双向链表形式实现的。</p>
<h2 id="沿链表移动"><a href="#沿链表移动" class="headerlink" title="沿链表移动"></a>沿链表移动</h2><p>沿链表移动只能是线性移动。先访问某个元素，然后沿该元素的向后指针访问下一个元素，不断重复这个过程，就可以沿链表向后移动了。这是一种最简单的沿链表移动方法，也是最适合访问链表的方法。如果需要随机访问数据，一般不使用链表。使用链表存放数据的理想情况是，需要遍历所有数据或需要动态加入和删除数据时。<br>有时，首元素会用一个特殊指针表示–该指针称为头指针，利用头指针可方便、快速地找到链表地“起始端”。在非环形链表里，向后指针指向NULL的元素是尾元素，而在环形链表里向后指针指向头元素的元素是尾元素。遍历一个链表需要线性地访问从第一个元素到最后一个元素之间的所有元素。对于双向链表来说，也可以反向遍历链表，可以从最后一个元素线性访问到第一个元素。当然还可以从链表中的指定元素开始向前和向后访问数个元素，并不一定要访问整个链表。</p>
<h2 id="Linux内核中的实现"><a href="#Linux内核中的实现" class="headerlink" title="Linux内核中的实现"></a>Linux内核中的实现</h2><p>相比普遍的链表实现方式（包括前面章节描述的通用方法），Linux内核的实现可以说是独树一帜。回忆早先提到的数据（或者一组数据，比如一个struct）通过在内部添加一个指向数据的next节点指针，才能串联在链表中。比如，假定我们有一个fox数据结构来描述犬科动物中的一员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   tail_length;    <span class="comment">//尾巴长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   weight;         <span class="comment">//重量</span></span><br><span class="line">    <span class="type">bool</span>            is_fantastic;   <span class="comment">//这只狐狸奇妙吗？</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>存储这个结构到链表里的通常方法是在数据结构中嵌入一个链表指针，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   tail_length;    <span class="comment">//尾巴长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   weight;         <span class="comment">//重量</span></span><br><span class="line">    <span class="type">bool</span>            is_fantastic;   <span class="comment">//这只狐狸奇妙吗？</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fox</span>      *<span class="title">next</span>;</span>          <span class="comment">//指向下一只狐狸</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fox</span>      *<span class="title">prev</span>;</span>          <span class="comment">//指向上一只狐狸</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Linux内核方式与众不同，它不是将数据结构塞入链表，而是将链表节点塞入数据结构。</p>
<h3 id="链表数据结构"><a href="#链表数据结构" class="headerlink" title="链表数据结构"></a>链表数据结构</h3><p>在过去，内核中有许多链表的实现，该选一个即简单、又高效的链表来统一它们了。在2.1内核开发系列中，首次引入了官方内核链表实现。从此内核中的所有链表现在都使用官方的链表实现了，千万不要自己造轮子拉！<br>链表代码在头文件&lt;linux&#x2F;list.h&gt;中声明，其数据结构很简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>next指针指向了下一个链表节点，prev指针指向前一个。然而，似乎这里还看不出它们有多大的作用。到底什么才是链表存储的具体内容呢？其实关键在于理解list_head结构是如何使用的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       tail_length;    <span class="comment">//尾巴长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       weight;         <span class="comment">//重量</span></span><br><span class="line">    <span class="type">bool</span>                is_fantastic;   <span class="comment">//这只狐狸奇妙吗？</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span>           <span class="comment">//所有fox结构体形成链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上述结构中，fox中的list.next指向下一个元素，list.prev指向前一个元素。现在链表已经能用了，但是显然还不够方便。因此内核又提供了一组链表操作例程。比如<code>list_add()</code>方法加入一个新节点到链表中。但是，这些方法都有一个统一的特点：它们只接受list_head结构作为参数。使用宏<code>container_of()</code>我们可以很方便的从链表指针找到父结构中包含的任何变量。这是因为在C语言中，一个给定结构中的变量偏移在编译时地址就被ABI固定下来了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> container_of(ptr, type, member) (&#123;                  \</span></span><br><span class="line"><span class="meta">	const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr);    \</span></span><br><span class="line"><span class="meta">	(type *)( (char *)__mptr - offsetof(type,member) );&#125;)</span></span><br></pre></td></tr></table></figure>
<p>使用<code>container_of()</code>宏，我们定义了一个简单的函数便可以返回包含list_head的父类型结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> list_entry(ptr,type,member) \</span></span><br><span class="line"><span class="meta">    container_of(ptr,type,member)</span></span><br></pre></td></tr></table></figure>
<p>依靠list_entry()方法，内核提供了创建、操作以及其他链表管理的各种例程–所有这些方法都不需要知道list_head所嵌入对象的数据结构。</p>
<h3 id="定义一个链表"><a href="#定义一个链表" class="headerlink" title="定义一个链表"></a>定义一个链表</h3><p>正如看到的：list_head本身其实并没有意义–它需要被嵌入到你自己的数据结构中才能生效：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       tail_length;    <span class="comment">//尾巴长度</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       weight;         <span class="comment">//重量</span></span><br><span class="line">    <span class="type">bool</span>                is_fantastic;   <span class="comment">//这只狐狸奇妙吗？</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span>           <span class="comment">//所有fox结构体形成链表</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>链表需要在使用前初始化。因为多数元素都是动态创建的（也许这就是需要链表的原因），因此最常见的方式是在运行时初始化链表。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> *<span class="title">red_fox</span>;</span></span><br><span class="line">red_fox = kmalloc(<span class="keyword">sizeof</span>(*red_fox),GFP_KERNEL);</span><br><span class="line">red_fox-&gt;tail_length = <span class="number">40</span>;</span><br><span class="line">red_fox-&gt;weight = <span class="number">6</span>;</span><br><span class="line">red_fox-&gt;is_fantastic = <span class="literal">false</span>;</span><br><span class="line">INIT_LIST_HEAD(&amp;red_fox-&gt;<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure>
<p>如果一个结构在编译期静态创建，而你需要在其中给出一个链表的直接引用，下面是最简方式：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> <span class="title">red_fox</span> =</span> &#123;</span><br><span class="line">    .tail_length = <span class="number">40</span>,</span><br><span class="line">    .weight = <span class="number">6</span>,</span><br><span class="line">    .<span class="built_in">list</span> = LIST_HEAD_INIT(red_fox.<span class="built_in">list</span>),</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="链表头"><a href="#链表头" class="headerlink" title="链表头"></a>链表头</h3><p>前面我们展示了如何把一个现有的数据结构（这里是我们的fox结构体）改造成链表。<br>简单修改上述代码，我们的结构便可以被内核链表例程管理。但是在可以使用这些例程前，需要一个标准的索引指针指向整个链表，即链表的头指针。<br>内核链表实现中最杰出的特性就是：我们的fox节点都是无差别的–每一个都包含一个list_head指针，于是我们可以从任何一个节点起遍历链表，直到我们看到所有节点。这种方式确实很优美，不过有时确实也需要一个特殊指针索引到整个链表，而不是从一个链表节点触发。有趣的是，这个特殊的索引节点事实上也就是一个常规的list_head：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">LIST_HEAD</span><span class="params">(fox_list)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数定义并初始化了一个名为fox_list的链表例程，这些例程中的大多数都只接受一个或者两个参数：头节点或者头节点加上一个特殊链表节点。下面我们就看看这些操作例程。</p>
<h2 id="操作链表"><a href="#操作链表" class="headerlink" title="操作链表"></a>操作链表</h2><p>内核提供了一组函数来操作链表，这些函数都要使用一个或多个list_head结构体指针作参数。因为函数都是C语言以内联函数形式实现的，所以它们的原型在文件&lt;linux&#x2F;list.h&gt;中。<br>有趣的是，所有这些函数的复杂度都为O（1）。这意味着，无论这些函数操作的链表大小如何，无论它们得到的参数如何，它们都在恒定的时间内完成。比如，不管是对于包含3个元素的链表还是对于包含3000个元素的链表，从链表中删除一项或者加入一项花费的时间都是相同的。这点可能没有什么让人惊奇的，但你最好还是搞清楚其中的原因。</p>
<h3 id="向链表中增加一个节点"><a href="#向链表中增加一个节点" class="headerlink" title="向链表中增加一个节点"></a>向链表中增加一个节点</h3><p>给链表增加一个节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_add(<span class="keyword">struct</span> list_head *new,<span class="keyword">struct</span> list_head *head)</span><br></pre></td></tr></table></figure>
<p>该函数向指定链表的head节点后插入new节点。因为链表是循环的，而且通常没有首位节点的概念。所以你可以把任何一个节点当成head。如果把“最后”一个节点当成head的话，那么该函数可以用来实现一个栈。<br>回到我们的例子，假定我们创建一个新的struct fox，并把它加入到fox_lixt，那么我们这样做：<br>把节点增加到链表尾：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_add_tail(<span class="keyword">struct</span> list_head *new,<span class="keyword">struct</span> list_head *head)</span><br></pre></td></tr></table></figure>
<p>该函数向指定链表的head节点前插入new节点。和list_add()函数类似，因为链表是环形的，所以可以把任何一个节点当作head。如果把第一个元素当作head的话，那么该函数可以用来实现一个队列。</p>
<h3 id="从链表中删除一个节点"><a href="#从链表中删除一个节点" class="headerlink" title="从链表中删除一个节点"></a>从链表中删除一个节点</h3><p>从链表中增加一个节点之后，从中删除一个节点是另外一个重要的操作。从链表中删除一个节点，调用list_del()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_del(<span class="keyword">struct</span> list_head *entry)</span><br></pre></td></tr></table></figure>
<p>该函数从链表中删除entry元素。注意，该操作并不会释放entry或释放包含entry的数据结构体所占用的内存；该函数仅仅是将entry元素从链表中移走，所以该函数被调用之后，通常还需要再撤销包含entry的数据结构体和其中的entry项。<br>例如，为了删除for节点，我们回到前面增加节点的fox_list：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_del(&amp;f-&gt;<span class="built_in">list</span>)</span><br></pre></td></tr></table></figure>
<p>注意该函数并没有接受fox_list作为输入参数。它只是接受一个特定的节点，并修改其前后节点的指针，这样给定的节点就从链表中删除。代码的实现颇具启发性：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> __list_del(<span class="keyword">struct</span> list_head *prev,<span class="keyword">struct</span> list_head *next)</span><br><span class="line">&#123;</span><br><span class="line">    next-&gt;prev = prev;</span><br><span class="line">    prev-&gt;next = next;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">list_del</span><span class="params">(<span class="keyword">struct</span> list_head *entry)</span></span><br><span class="line">&#123;</span><br><span class="line">    __list_del(entry-&gt;prev,entry-&gt;next);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从链表中删除一个节点并对其重新初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_del_init();</span><br><span class="line">list_del_init(<span class="keyword">struct</span> list_head *entry);</span><br></pre></td></tr></table></figure>
<p>该函数除了还需要再次初始化entry外，其他和list_del()函数类似。这样做是因为：虽然链表不再需要entry项，但是还是可以再次使用包含entry的数据结构体。</p>
<h3 id="移动和合并链表节点"><a href="#移动和合并链表节点" class="headerlink" title="移动和合并链表节点"></a>移动和合并链表节点</h3><p>把节点从一个链表移到另一个链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_move(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,<span class="keyword">struct</span> list_head *head)</span><br></pre></td></tr></table></figure>
<p>该函数从一个链表移除list项，然后将其加入到另一链表的head节点后面。<br>把节点从一个链表移到另一个链表的末尾：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_move_tail(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,<span class="keyword">struct</span> list_head *head)</span><br></pre></td></tr></table></figure>
<p>该函数和list_move()函数一样，唯一的不同就是将list项插入到head项前。<br>检查链表是否为空：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_empty(<span class="keyword">struct</span> list_head *head)</span><br></pre></td></tr></table></figure>
<p>如果指定的链表为空，该函数返回非0值；否则返回0.<br>把两个未连接的链表合并在一起：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_splice(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,<span class="keyword">struct</span> list_head *head)</span><br></pre></td></tr></table></figure>
<p>该函数合并两个链表，它将list指向的链表插入到指定链表的head元素后面。<br>把两个未连接的链表合并在一起，并重新初始化原来的链表：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_splice_init(<span class="keyword">struct</span> list_head *<span class="built_in">list</span>,<span class="keyword">struct</span> list_head *head)</span><br></pre></td></tr></table></figure>
<p>该函数和list_splice()函数一样，唯一的不同就是由list指向的链表要被重新初始化。</p>
<p><strong>节约两次提领（dereference）</strong><br>如果你碰巧已经得到next和prev指针，你可以直接调用内部链表函数，从而省下一点时间（其实就是提领指针的时间）。前面讨论的所有函数其实没有做什么其他特别的操作，它仅仅是找到next和prev指针，再去调用内部函数而已。内部函数和它们的外部包装函数同名，仅仅在前面加了两条下划线。比如，可以调用__list_del(prev,next)函数代替调用list_del(list)函数。但这只有在向前向后指针确实已经被提领的情况下才有意义。否则，你只是在画蛇添足。</p>
<h2 id="遍历链表"><a href="#遍历链表" class="headerlink" title="遍历链表"></a>遍历链表</h2><p>现在你已经知道了如何在内核中声明、初始化和操作一个链表。这很了不起，但如果无法访问自己的数据，这些没有任何意义。链表仅仅是个能够包含重要数据的容器；我们必须利用链表移动并访问包含我们数据的结构体。幸好，内核为我们提供了一组非常棒的接口，可以用来遍历链表和引用链表中的数据结构体。<br><strong>注意</strong><br>和链表操作函数不同，遍历链表的复杂度为O(n)，n是链表所包含的元素数目。</p>
<h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>遍历链表最简单的方法是使用list_for_each()宏，该宏使用两个list_add()类型的参数，第一个参数用来指向当前项，这是一个你必须要提供的临时变量，第二个参数是需要遍历的链表的以头节点形式存在的list_head。每次遍历中，第一个参数在链表中不断移动指向下一个元素，直到链表中的所有元素都被访问为止。方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line">list_for_each(p,<span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="comment">//p指向链表中的元素</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>好了实话实说，其实一个指向链表结构的指针通常是无用的；我们所需要的是一个指向包含list_head的结构体的指针。比如前面的fox结构体的例子，我们需要的是指向每个fox的指针，而不需要指向结构体list成员的指针。我们可以使用前面讨论的list_entry()宏，来获得包含给定list_head()的数据结构。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">p</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each(p,&amp;fox_list) &#123;</span><br><span class="line">    <span class="comment">//f points to the structure in which the list is embedded</span></span><br><span class="line">    f = list_entry(p,<span class="keyword">struct</span> fox,<span class="built_in">list</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="可用的方法"><a href="#可用的方法" class="headerlink" title="可用的方法"></a>可用的方法</h3><p>前面的方法虽然确实展示了list_head节点的功效，但并不优美，而且也不够灵活。所以多数内核代码采用list_for_each_entry()宏遍历链表。该宏内部也使用list_entry()宏，但简化了遍历过程：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_for_each_entry(pos,head,member)</span><br></pre></td></tr></table></figure>
<p>这里pos是一个指向包含list_head节点对象的指针，可将它看作是list_entry()宏的返回值。head是一个指向头节点的指针，即遍历开始位置–在我们前面的例子中，fox_list.member送是pos中list_head结构的变量名。这听起来令人迷惑，但是简单实用。下面的代码片段展示了如何重写前面的list_for_each()，来遍历所有fox节点：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">fox</span> *<span class="title">f</span>;</span></span><br><span class="line"></span><br><span class="line">list_for_each_entry(f,&amp;fox_list,<span class="built_in">list</span>) &#123;</span><br><span class="line">    <span class="comment">//on each iteration,&#x27;f&#x27; points to the next for structure</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在看看实际例子吧。它来自inotify–内核文件系统的更新通知机制：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">struct</span> inotify_watch *<span class="title function_">inode_find_handle</span><span class="params">(<span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">                                               <span class="keyword">struct</span> inotify_handle *ih)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_watch</span> *<span class="title">watch</span>;</span></span><br><span class="line"></span><br><span class="line">    list_for_each_entry(watch,&amp;inode-&gt;inotify_watches,i_list) &#123;</span><br><span class="line">        <span class="keyword">if</span>(watch-&gt;ih == ih)</span><br><span class="line">            <span class="keyword">return</span> watch;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数遍历了inode-&gt;inotify_watches链表中的所有项，每个项的类型都是struct inotify_watch，list_head在结构中被命名为i_list。循环中的每一个遍历，watch都指向链表的新节点。该函数的目的在于：在inode结构串联起来的inotify_wwatches链表中，搜寻其inotify_handle与所提供的句柄相匹配的inotify_watch项。</p>
<h3 id="反向遍历链表"><a href="#反向遍历链表" class="headerlink" title="反向遍历链表"></a>反向遍历链表</h3><p>宏list_for_each_entry_reverse()的工作和list_for_each_entry()类似，不同点在于它是反向遍历链表的。也就是说，不再是沿着next指针向前遍历，而是沿着prev指针向后遍历。其用法和list_for_each_entry()相同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_for_each_entry_reverse(pos,head,member)</span><br></pre></td></tr></table></figure>
<p>很多原因会需要反向遍历链表，其中一个是性能原因–如果你要寻找的节点最可能在你搜索的起始点的前面，那么反向搜索岂不是更快。第二个原因是如果顺序很重要，比如，如果你使用链表实现堆栈，那么你需要从尾部向前遍历才能达到先进先出原则（LIFO）。如果你没有确切的反向遍历的原因，就老实点，用list_for_each_entry()宏吧。</p>
<h3 id="遍历的同时删除"><a href="#遍历的同时删除" class="headerlink" title="遍历的同时删除"></a>遍历的同时删除</h3><p>标准的遍历方法在你遍历链表的同时想要删除节点是不行的。因为标准的链表方法建立在你的操作不会改变链表项这一假设上面，所以如果当前项在遍历循环中被删除，那么接下来的遍历就无法获得next（或prev）指针了。这其实是循环处理中的一个常见范式，开发人员通过在潜在的删除操作之前存储next（或prev）指针到一个临时变量中，以便能执行删除操作。好在Linux内核提供了例程处理这种情况：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_for_each_entry_safe(pos,next,head,member)</span><br></pre></td></tr></table></figure>
<p>你可以按照list_for_each_entry()宏的方式使用上述例程，只是需要通过next指针，next指针和pos是同样的类型。list_for_each_entry_safe()启用next指针来将下一项存进表中，以使得能安全删除当前项。我们再次看看inotify的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">inotify_node_is_dead</span><span class="params">(<span class="keyword">struct</span> inode *inode)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">inotify_watch</span> *<span class="title">watch</span>,*<span class="title">next</span>;</span></span><br><span class="line"></span><br><span class="line">    mutex_lock(&amp;inode-&gt;inotify_mutex);</span><br><span class="line">    list_for_each_entry_safe(watch,next,&amp;inode-&gt;inotify_watches,i_list) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">inotify_handle</span> *<span class="title">ih</span> =</span> watch-&gt;ih;</span><br><span class="line">        mutex_lock(&amp;ih-&gt;mutex);</span><br><span class="line">        inotify_remove_watch_locked(ih,watch);</span><br><span class="line">        mutex_unlock(&amp;ih-&gt;mutex);</span><br><span class="line">    &#125;</span><br><span class="line">    mutex_unlock(&amp;inode-&gt;inotify_mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数遍历并删除inotify_watches链表中的所有项。如果使用了标准的list_for_each_entry()，那么上述代码会造成“使用–在–释放后”的错误，因为在移向链表中下一项时，需要访问watch，但这时它已经被撤销。<br>如果你需要在反向遍历链表的同时删除它，那么内核提供了list_for_each_safe_reverse()宏帮你完成此任务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">list_for_each_entry_safe_reverse(pos,n,head,member)</span><br></pre></td></tr></table></figure>
<p>上述函数的用法同list_for_each_entry_safe()。</p>
<p><strong>你仍然需要锁定！</strong><br>list_for_each_entry()的安全版本只能保护你在循环体中从链表中删除数据。如果这时有可能从其他地方并发进行删除，或者有其他任何并发的链表操作，你就需要锁定链表。</p>
<h3 id="其他链表方法"><a href="#其他链表方法" class="headerlink" title="其他链表方法"></a>其他链表方法</h3><p>Linux提供了很多链表操作方法–几乎就是你所能想到的所有访问和操作链表方法，所有这些方法都可在头文件&lt;Linux&#x2F;list.h&gt;中找到。</p>
<h1 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h1><p>任何操作系统内核都少不了一种编程模型：生产者和消费者。在该模式中，生产者创造数据（比如说需要读取的错误信息或者需要处理的网络包），而消费者则反过来，读取消息和处理包，或者以其他方式消费这些数据。实现该模型的最简单的方式无非是使用队列。生产者将数据推进队列，然后消费者从队列中摘取数据。消费者获取数据的顺序和推入队列的顺序一致。也就是说，第一个进入队列的数据一定是第一个离开队列的。也正是这个原因，队列也称为FIFO。顾名思义，FIFO就是先进先出的缩写。下图是一个标准队列的例子。<br><img src="/2022/11/04/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/4.jpeg" alt="img not found"><br>Linux内核通用队列实现称为kfifo。它实现在文件<code>kernel/kfifo.c</code>中，声明在文件&lt;linux&#x2F;kfifo.h&gt;中。本节讨论的是自2.66.33以后更新的API，使用方法和2.6.33前的内核稍有不同，所以在使用前请仔细检查文件&lt;linux&#x2F;kfifo.h&gt;。</p>
<h2 id="kfifo"><a href="#kfifo" class="headerlink" title="kfifo"></a>kfifo</h2><p>Linux的kfifo和多数其他队列实现类似，提供了两个主要操作：enqueue（入队列）和dequeue（出队列）。kfifo对象维护了两个偏移量：入口偏移和出口偏移。入口偏移是指下一次入队时的位置，出口偏移是指下一次出队列时的位置。出口偏移总是小于等于入口偏移，否则无意义，因为那样说明要出队列的元素根本还没有入队列。<br>enqueue操作拷贝数据到队列中的入口偏移位置。当上述动作完成后，入口偏移随之加上推入的元素数目。dequeue操作从队列中出口偏移处拷贝数据，当上述动作完成之后，出口偏移随之减去摘取的元素数目。当出口偏移等于入口偏移时，说明队列空了：在新数据被推入之前，不可再摘取任何数据了。当入口偏移等于队列长度时，说明在队列空置之前，不可再有新数据推入队列。</p>
<h2 id="创建队列"><a href="#创建队列" class="headerlink" title="创建队列"></a>创建队列</h2><p>使用kfifo前，首先必须对它进行定义和初始化。和多数内核对象一样，有动态或静态方法供你选择。动态方法更为普遍：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kfifo_alloc</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,<span class="type">unsigned</span> <span class="type">int</span> size,<span class="type">gfp_t</span> gfp_mask)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数创建并初始化一个大小为size的kfifo。内核使用gfp_mask标识分配队列。如果成功，kfifo_alloc返回0；错误则返回一个负数错误码。下面便是一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kfifo</span> <span class="title">fifo</span>;</span></span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = kfifo_alloc(&amp;kfifo,PAGE_SIZE,GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(ret)</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"><span class="comment">//fifo现在代表一个大小为PAGE_SIZE的队列</span></span><br></pre></td></tr></table></figure>
<p>你要想自己分配缓冲，可以调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfifo_init</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,<span class="type">void</span> *buffer,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数创建并初始化一个kfifo对象，它将使用由buffer指向的size字节大小的内存。对于kfifo_alloc()和kfifo_init()，size必须是2的幂。<br>静态声明kfifo更简单，但不大常用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_KFIFO(name,size);</span><br><span class="line">INTI_KFIFO(name);</span><br></pre></td></tr></table></figure>
<p>上述方法会创建一个名称为name、大小为size的kfifo对象。和前面一样，size必须是2的幂。</p>
<h2 id="推入队列数据"><a href="#推入队列数据" class="headerlink" title="推入队列数据"></a>推入队列数据</h2><p>当你的kfifo对象创建和初始化之后，推入数据到队列需要通过kfifo_in()方法完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_in</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,<span class="type">const</span> <span class="type">void</span> *from,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数把from指针所指的字节数据拷贝到fifo所指的队列中，如果成功，则返回推入数据的字节大小。如果队列中的空闲字节小于len，则该函数值最多可拷贝队列可用空间那么多的数据，这样的话，返回值可能小于len，甚至返回0，这时意味着没有任何数据被推入。</p>
<h2 id="摘取队列数据"><a href="#摘取队列数据" class="headerlink" title="摘取队列数据"></a>摘取队列数据</h2><p>推入数据使用函数kfifo_in()，摘取数据则需要通过函数kfifo_out完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_out</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,<span class="type">void</span> **to,<span class="type">unsigned</span> <span class="type">int</span> len)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数从fifo指向的队列中拷贝出长度为len字节的数据到to所指向的缓存中。如果成功，该函数则返回拷贝的数据长度。如果队列中数据大小小于len，则该函数拷贝出的数据必然小于需要的数据大小。<br>当数据被摘取之后，数据就不再存在于队列之中。这是队列操作的常用方式。不过如果仅仅想“偷窥”队列中的数据，而不像真的删除它，你可以使用kfifo_out_peek()方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_out_peek</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo,<span class="type">void</span> *to,<span class="type">unsigned</span> <span class="type">int</span> len,<span class="type">unsigned</span> offset)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数与kfifo_out类似，但出口偏移不增加，而且摘取的数据仍然可被下次kfifo_out获得。参数offset指向队列中的索引位置，如果该参数为0，则读队列头，这和kfifo_out()无异。</p>
<h2 id="获取队列长度"><a href="#获取队列长度" class="headerlink" title="获取队列长度"></a>获取队列长度</h2><p>若想获得用于存储kfifo队列的空间的总体大小（以字节为单位），可调用方法kfifo_size()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_size</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure>
<p>另一个内核命名不佳的例子来了–kfifo_len()方法返回kfifo队列中已推入的数据大小：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_len</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure>
<p>如果想要得到kfifo队列中还有多少可用空间，则要调用方法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">kfifo_avail</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure>
<p>最后两个方法是kfifo_is_empty()和kfifo_is_full()。如果给定的kfifo分别是空或者满，它们返回非0值。如果返回0，则相反。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">kfifo_is_empty</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">kfifo_is_full</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="重置和撤销队列"><a href="#重置和撤销队列" class="headerlink" title="重置和撤销队列"></a>重置和撤销队列</h2><p>如果重置kfifo，意味着抛弃所有队列中的内容，调用kfifo_reset()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">kfifo_reset</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure>
<p>撤销一个使用kfifo_alloc分配的队列，调用kfifo_free()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfifo_free</span><span class="params">(<span class="keyword">struct</span> kfifo *fifo)</span>;</span><br></pre></td></tr></table></figure>
<p>如果你是使用kfifo_init()方法创建的队列，那么你需要负责释放相关的缓冲。具体方法取决于你是如何创建它的。</p>
<h2 id="队列使用举例"><a href="#队列使用举例" class="headerlink" title="队列使用举例"></a>队列使用举例</h2><p>使用上述接口，我们去看一个kfifo的具体用例。假定我们创建了一个有fifo指向的8KB大小的kfifo。我们就可以推入数据到队列中。这个例子中，我们推入简单的整形数。在你自己的代码中，可以推入更复杂的任务相关数据。这里使用整数，我们看看kfifo如何工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line"><span class="comment">//将[0,32]压入到名为“fifo”的kfifo中</span></span><br><span class="line"><span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; <span class="number">32</span>;i++)</span><br><span class="line">    kfifo_in(fifo,&amp;i,<span class="keyword">sizeof</span>(i));</span><br></pre></td></tr></table></figure>
<p>名为fifo的kfifo现在包含了0到31的整数，我们查看一下队列的第一个元素是不是0：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line"><span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">ret = kfifo_out_peek(fifo,&amp;val,<span class="keyword">sizeof</span>(val),<span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span>(ret != <span class="keyword">sizeof</span>(val))</span><br><span class="line">    <span class="keyword">return</span>  -EINVAL;</span><br><span class="line">printk(KERN_INFO<span class="string">&quot;%u\n&quot;</span>,val);<span class="comment">//应该输出0</span></span><br></pre></td></tr></table></figure>
<p>摘取并打印kfifo中的所有元素，我们可以调用kfifo_out()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//当队列中还有数据时</span></span><br><span class="line"><span class="keyword">while</span>(kfifo_avail(fifo)) &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> val;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//read it,one intager at a time</span></span><br><span class="line">    ret = kfifo_out(fifo,&amp;val,<span class="keyword">sizeof</span>(val));</span><br><span class="line">    <span class="keyword">if</span>(ret != <span class="keyword">sizeof</span>(val))</span><br><span class="line">        <span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;%u\n&quot;</span>,val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>0到31的整数将一一按序打印出来。</p>
<h1 id="映射"><a href="#映射" class="headerlink" title="映射"></a>映射</h1><p>一个映射，也常称为关联数组，其实是一个由唯一键组成的集合，而每个键必然关联一个特定的值。这种键到值的关联关系称为映射。映射要至少支持三个操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Add(key,value)</span><br><span class="line">Remove(key)</span><br><span class="line">value = Lookup(key)</span><br></pre></td></tr></table></figure>
<p>虽然散列表是一种映射，但并非所有的映射都需要通过散列表实现。除了使用散列表之外，映射也可以通过自平衡二叉搜索树存储数据。虽然散列表能提供更好的平均的渐近复杂度，但是二叉搜索树在最坏情况下能有更好的表现。二叉搜索树同时满足顺序保证，这将给用户的按序遍历带来很好的性能。二叉搜索树的最后一个优势是它不需要散列函数，需要的键类型只要可以定义&lt;&#x3D;操作算子便可以。<br>虽然键到值的映射属于一个通用说法，但是更多时候特指使用二叉树而非散列表实现的关联数组。比如，C++的STL容器std::map便是采用自平衡二叉搜索树实现的，它能提供按序遍历的功能。<br>Linux内核提供了简单的、有效的映射数据结构。但是它不是一个通用的映射结构。因为它的目标是：映射一个唯一的标识数（UID）到一个指针。除了提供三个标准的映射操作之外，Linux还在add操作基础上实现了allocate操作。这个allocate操作不但向map中加入了键值对，而且还可以产生UID。<br>idr数据结构用于映射用户空间的UID，比如将inotify watch的描述符或者POSIX的定时器ID映射到内核中相关联的数据结构上，如inotify_watch或k_itimer结构体。其命名依然沿袭了内核中有些含混不清的命名体系，这个映射被命名为idr。</p>
<h2 id="初始化一个idr"><a href="#初始化一个idr" class="headerlink" title="初始化一个idr"></a>初始化一个idr</h2><p>建立一个idr很简单，首先你需要静态定义或者动态分配一个idr数据结构。然后调用idr_init()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idr_init</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;</span><br></pre></td></tr></table></figure>
<p>比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">idr</span> <span class="title">id_huh</span>;</span><span class="comment">//静态定义idr结构</span></span><br><span class="line">idr_init(&amp;idr_huh);<span class="comment">//初始化idr结构</span></span><br></pre></td></tr></table></figure>

<h2 id="分配一个新的UID"><a href="#分配一个新的UID" class="headerlink" title="分配一个新的UID"></a>分配一个新的UID</h2><p>一旦建立了idr，就可以分配新的UID了，这个过程分两步完成。第一步，告诉idr你需要分配新的UID，允许其在必要时调整后备树的大小。然后，第二步才是真正请求新的UID。之所以需要这两个组合动作是因为要允许调整初始大小–这中间涉及在无锁情况下分配内存的场景。<br>第一个调整后备树大小的方法是idr_pre_get()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_pre_get</span><span class="params">(<span class="keyword">struct</span> idr *idp,<span class="type">gfp_t</span> gtp_mask)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数将在需要时进行UID的分配工作：调整由idp指向的idr的大小。如果真的需要调整大小，则内存分配例程使用gfp标识：gfp_mask，你不需要对并发访问该方法进行同步保护。和内核中其他函数的做法相反，idr_pre_get()成功时返回1，失败时返回0–这点一定要注意。<br>第二个函数，实际执行获取新的UID，并且将其加到idr的方法是idr_get_new()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_get_new</span><span class="params">(<span class="keyword">struct</span> idr *idp,<span class="type">void</span> *ptr,<span class="type">int</span> *id)</span>;</span><br></pre></td></tr></table></figure>
<p>该方法使用idp所指向的idr去分配一个新的UID，并且将其关联到指针ptr上。成功时，该方法返回0，并且将新的UID存于id。错误时，返回非0的错误码，错误码是-EAGAIN，说明你需要再次调用idr_get_new()；如果idr已满，错误码是-ENOSPC。下面看一个完整的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!idr_ptr_get(&amp;idr_huh,GFP_KERNRL))</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    ret = idr_get_new(&amp;idr_huh,ptr,&amp;id);</span><br><span class="line">&#125;<span class="keyword">while</span>(ret == -EAGAIN);</span><br></pre></td></tr></table></figure>
<p>如果成功，上述代码片段将获得一个新的UID，它被存储在整型变量id中，而且将UID映射到ptr。<br>函数idr_get_new_above()使得调用者可以指定一个最小的UID返回值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">idr_get_new_above</span><span class="params">(<span class="keyword">struct</span> idr *idp,<span class="type">void</span> *ptr,<span class="type">int</span> starting_id,<span class="type">int</span> *id)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数的作用和idr_get_new()相同，除了它确保新的UID大于或等于starting_id外。使用这个变种方法允许idr的使用者确保UID不会被重用，允许其值不但在当前分配的ID中唯一，而且还保证在系统的整个运行期间唯一，下面的代码片段和前例中类似，不过我们明确要求增加UID的值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> id;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(!idr_pre_get(&amp;idr_huh,GFP_KERNRL))</span><br><span class="line">        <span class="keyword">return</span> -ENOSPC;</span><br><span class="line">    ret = idr_get_new_above(&amp;idr_huh,ptr,next_id,&amp;id); </span><br><span class="line">&#125;<span class="keyword">while</span>(ret == -EAGAIN);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(!ret)</span><br><span class="line">    next_id = id + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h2 id="查找UID"><a href="#查找UID" class="headerlink" title="查找UID"></a>查找UID</h2><p>当我们在一个idr中已经分配了一些UID时，我们自然就需要查找它们：调用者要给出UID，idr将返回对应的指针。查找步骤显然要比分配一个新的UID要来的简单，仅需要使用idr_find()方法即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">idr_find</span><span class="params">(<span class="keyword">struct</span> idr *idp,<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数如果调用成功，则返回id关联的指针；如果错误，则返回空指针。注意，如果你使用idr_get_new()或者idr_get_new_above()将空指针映射给UID，那么该函数在成功时也返回NULL。这样你就无法区分时成功还是失败，所以，最好不要将UID映射到空指针上。<br>这个函数的使用比较简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ma_struct</span> *<span class="title">ptr</span> =</span> idr_find(&amp;idr_huh,id);</span><br><span class="line"><span class="keyword">if</span>(!ptr)</span><br><span class="line">    <span class="keyword">return</span> -EINVAL;<span class="comment">//错误</span></span><br></pre></td></tr></table></figure>

<h2 id="删除UID"><a href="#删除UID" class="headerlink" title="删除UID"></a>删除UID</h2><p>从idr中删除UID使用方法idr_remove()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idr_remove</span><span class="params">(<span class="keyword">struct</span> idr *idp,<span class="type">int</span> id)</span>;</span><br></pre></td></tr></table></figure>
<p>如果idr_remove()成功，则将id关联的指针一起从映射中删除。遗憾的是，idr_remove()并没有办法提示任何错误。</p>
<h2 id="撤销idr"><a href="#撤销idr" class="headerlink" title="撤销idr"></a>撤销idr</h2><p>撤销一个idr的操作很简单，调用idr_destroy()函数即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idr_destroy</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;</span><br></pre></td></tr></table></figure>
<p>如果该方法成功，则只释放idr中未使用的内存。它并不释放当前分配给UID使用的任何内存。通常，内核代码不会撤销idr，除非关闭或者卸载，而且只有在没有其他用户是才能删除，但是你可以调用idr_remove_all()方法强制删除所有的UID：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">idr_remove_all</span><span class="params">(<span class="keyword">struct</span> idr *idp)</span>;</span><br></pre></td></tr></table></figure>
<p>你应该首先对idp指向的idr调用idr_remove_all()，然后再调用idr_destroy()，这样就能使idr占用的内存都被释放。</p>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><p>树结构是一个能提供分层的树形数据结构的特定数据结构。在数学意义上，树是一个无环的、连接的有向图，其中任何一个顶点具有0个或者多个出边以及0个或者1个入边。一个二叉树是每个节点最多具有2个出边的树–也就是，一个树，其节点具有0个、1个或者2个子节点。</p>
<h2 id="二叉搜索树"><a href="#二叉搜索树" class="headerlink" title="二叉搜索树"></a>二叉搜索树</h2><p>一个二叉搜索树（BST）是一个节点有序的二叉树，其顺序通常遵循下列法则：</p>
<ol>
<li>根的左分支节点值都小于根节点值。</li>
<li>右分支节点值都大于根节点值。</li>
<li>所有的子树也都是二叉搜索树。</li>
</ol>
<p>因此，一个二叉搜索树所有节点都必然有序，且左子节点小于其父节点值，而右子节点大于其父节点值的二叉树。所以，在树中搜索一个给定值或者按序遍历树都相当快捷。<br><img src="/2022/11/04/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/5.jpeg" alt="img not found"></p>
<h2 id="自平衡二叉搜索树"><a href="#自平衡二叉搜索树" class="headerlink" title="自平衡二叉搜索树"></a>自平衡二叉搜索树</h2><p>一个节点的深度是指从其根节点起，到达它一共需要经过的父节点数目。处于树底层的节点称为叶子节点。一个树的高度是指树中的处于最底层的节点的深度。一个平衡二叉搜索树是一个所有叶子节点深度差不超过1的二叉搜索树。一个自平衡二叉搜索树是指其操作都试图维持平衡的二叉搜索树。<br><img src="/2022/11/04/%E5%86%85%E6%A0%B8%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/6.jpeg" alt="img not found"></p>
<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p>红黑树是一种自平衡二叉搜索树。Linux主要的平衡二叉树数据结构就是红黑树。红黑树具有特殊的着色属性，或红色或黑色。红黑树因遵循下面6个属性，所以能维持半平衡结构：</p>
<ol>
<li>所有的节点要么是着红色，要么是着黑色。</li>
<li>叶子节点都是黑色。</li>
<li>叶子节点不包含数据。</li>
<li>所有非叶子节点都有两个子节点。</li>
<li>如果一个节点是红色，则它的子节点都是黑色。</li>
<li>在一个节点到其叶子节点的路径中，如果总是包含相同数目的黑色节点，则该路径相比其他路径是最短的。</li>
</ol>
<p>上述条件，保证了最深的叶子节点的深度不会大于两倍的最浅叶子节点的深度。所以，红黑树总是半平衡的。为什么它具有如此神奇的特点？首先，第五个属性，一个红色节点不能是其他红色节点的子节点或者父节点。而第六个属性保证了从树的任何节点到其叶子节点的路径都具有相同数目的黑色节点，树里的最长路径则是红黑交替节点路径，所以最短路径必然是具有相同数量黑色节点的–只包含黑色节点的路径。于是从根节点到叶子节点的最长路径不会超过最短路劲的两倍。<br>如果插入和删除操作可以遵循上述六个要求，那这个树会始终保持是一个半平衡树。看起来也许有些奇怪，为什么插入和删除动作都需要服从这些特别的约束，为什么不能用一些简单的规则去维持平衡树呢？其实，实践证明这些规则遵循起来还是相对简单的（实现复杂），而且在保证半平衡树的前提下，这些插入和删除动作并不会增加额外负担。<br>至于如何让插入和删除动作都能遵循这些规则，请参考相关的数据结构书籍。</p>
<h3 id="rbtree"><a href="#rbtree" class="headerlink" title="rbtree"></a>rbtree</h3><p>Linux实现的红黑树称为rbtree。其定义在文件<code>lib/rbtree.c</code>中，声明在文件<code>&lt;linux/rbtree.h&gt;</code>中。除了一定的优化外，Linux的rbtree类似于前面所描述的经典红黑树，即保持了平衡性，所以插入效率和树中节点数目呈对数关系。<br>rbtree的根节点由数据结构rb_root描述。创建一个红黑树，我们要分配一个新的rb_root结构，并且需要初始化为特殊值RB_ROOT：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">root</span> =</span> RB_ROOT;</span><br></pre></td></tr></table></figure>
<p>树里的其他节点由rb_node描述。给定一个rb_node，我们可以通过跟踪同名节点指针来找到它的左右子节点。<br>rbtree的实现并没有提供插入和搜索例程，这些例程希望由rbtree的用户自己定义。这是因为C语言不大容易进行泛型编程，同时Linux内核开发者们相信最有效的搜索和插入方法需要每个用户自己去实现。你可以使用rbtree提供的辅助函数，但你自己要实现比较操作算子。<br>搜索操作和插入操作最好的范例就是展示一个实际场景：我们先来看搜索，下面的函数实现了在页高速缓存中搜索一个文件区（由一个i节点和一个偏移量共同描述）。每个i节点都有自己的rbtree，以关联在文件中的页偏移。该函数将搜索给定<br>i节点的rbtree，以寻找匹配的偏移值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rb_search_page_cache</span><span class="params">(<span class="keyword">struct</span> inode *inode</span></span><br><span class="line"><span class="params">                                  <span class="type">unsigned</span> <span class="type">long</span> offset)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">n</span> =</span> inode-&gt;i_rb_page_cache.rb_node;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(n) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> =</span> rb_entry(n,<span class="keyword">struct</span> page,rb_page_cache);</span><br><span class="line">        <span class="keyword">if</span>(offset &lt; page-&gt;offset)</span><br><span class="line">            n = n-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(offset &gt; page-&gt;offset)</span><br><span class="line">            n = n-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个例子中，在while循环中遍历了整个rbtree。offset将决定是向左或者向右遍历。if和else条件实际上实现了rbtree的比较方法，从而确保了树的有序性。如果循环中找到了一个匹配offset的节点，则搜索完成，并返回对应的page结构。如果循环查找了全树也没有找到一个匹配项，说明树中不存在匹配项，则函数返回NULL。<br>插入操作要相对复杂一点，因为必须实现搜索和插入逻辑。下面并非一个了不起的函数，但是可以作为你实现自己的插入操作的一个指导：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rb_insert_page_cache</span><span class="params">(<span class="keyword">struct</span> inode *inode,</span></span><br><span class="line"><span class="params">                                  <span class="type">unsigned</span> <span class="type">long</span> offset,</span></span><br><span class="line"><span class="params">                                  <span class="keyword">struct</span> rb_node *node)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">p</span> =</span> &amp;inode-&gt;i_rb_page_cache.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(*p) &#123;</span><br><span class="line">        parent = *p;</span><br><span class="line">        page = rb_entry(parent,<span class="keyword">struct</span> page,rb_page_cache);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(offset &lt; page-&gt;offset)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(offset &gt; page-&gt;offset)</span><br><span class="line">            p = &amp;(*p)-&gt;rb_right;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> page;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    rb_link_node(node,parent,p);</span><br><span class="line">    rb_insert_color(node,&amp;inode-&gt;i_rb_page_cache);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和搜索操作一样，while循环需要遍历整个树，也是根据offset选择遍历方向。但是和搜索不同的是，该函数希望找不到匹配的offset，因为它想要找的是新offset要插入的叶子节点。当插入点找到之后，调用rb_link_node()在给定位置插入新节点。接着调用rb_insert_color()方法执行复杂的再平衡动作。如果页被加入到页高速缓存中，则返回NULL。如果页已经再高速缓存了，则返回这个已存在的页结构地址。</p>
<h1 id="数据结构以及选择"><a href="#数据结构以及选择" class="headerlink" title="数据结构以及选择"></a>数据结构以及选择</h1><p>我们已经详细讨论了Linux中最重要的四种数据结构：链表、队列、映射和红黑树。在本节中，我们将教你如何在代码中具体选择使用哪种数据结构。<br>如果你对数据集合的主要操作是遍历数据，就使用链表。事实上没有数据结构可以提供比线性算法复杂度更好的算法遍历元素，所以你应该用最简单的数据结构完成简单工作。另外，当性能并非首要考虑因素时，或者当你需要存储相对较少的数据项时，或者当你需要和内核中其他使用链表的代码交互时，也该优先选择链表。<br>如果你的代码符合生产者&#x2F;消费者模式，则使用队列，特别是你想（或者可以）要一个定长缓冲。队列会使得添加和删除项的工作简单有效。同时队列也提供了先入先出（FIFO）语义，而这也正是生产者&#x2F;消费者用例的普遍需求。另一方面，如果你需要存储一个大小不明的数据集合，那么链表可能更合适，因为你可以动态添加任何数量的数据项。<br>如果你需要映射一个UID到一个对象，就使用映射。映射结构使得映射工作简单有效，而且映射可以帮你维护和分配UID。Linux的映射接口是针对UID到指针的映射，它并不适合其他场景。但是如果你在处理发给用户空间的描述符，就考虑一下映射吧。<br>如果你需要存储大量数据，并且检索迅速，那么红黑树最好。红黑树可确保搜索时间复杂度是对数关系，同时也能保证按序遍历时间复杂度是线性关系。虽然它比其他数据结构复杂一点，但其对内存开销情况并不是太糟。但是如果你没有执行太多次时间紧迫的查找操作，则红黑树可能不是最好选择。这种情况最好使用链表。<br>要是上述数据结构都不能满足你的需要，内核还实现了一些较少使用的数据结构，也许它们能帮助你。比如基树（trie）和位图。只有当寻遍所有内核提供的数据结构都不能满足时，你才需要自己设计数据结构。经常在独立的源文件中实现的一种常见的数据结构是散列表。因为散列表无非是一些“桶”和一个散列函数，而且这个散列函数是针对每个用例的，因此用非泛型编程语言（C语言）实现内核范围内的统一散列表，其实这并没有什么价值。</p>
<h1 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h1><p>在计算机和相关的学科中，很有必要将算法的复杂度（或伸缩度）量化的表示出来。虽然存在各种各样表示伸缩度的方法，但最常用的技术还是研究算法的渐近行为。渐近行为是指当算法的输入变得非常大或接近于无限大时算法的行为。渐近行为充分显式了当一个算法的输入逐渐变大时，该算法的伸缩度如何。研究算法的伸缩度（当输入增大时算法执行的变化）可以帮助我们以特定基准抽象出算法模型，从而更好地理解算法的行为。</p>
<h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法就是一系列的指令，它可能有一个或多个输入，最后产生一个结果或输出。比如计算一个房间中人数的步骤就是一个算法，它的输入是人，计算结果是输出。在Linux内核中，页换出和进程调度都是算法的例子。从数学角度讲，一个算法好比一个函数（或至少我们可将它抽象为一个函数）。比如，我们称人数统计算法为f，要统计的人数为x，可以写成下面形式：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">y = f(x)  人数统计的函数</span><br></pre></td></tr></table></figure>
<p>这里y是统计x个人所需的时间。</p>
<h2 id="大o符号"><a href="#大o符号" class="headerlink" title="大o符号"></a>大o符号</h2><p>一种很有用的渐近表示法就是上限–它是一个函数，其值从一个起始点之后总是超过我们所研究的函数的值，也就是说上限增长等于或者快于我们研究的函数。一个特殊符号，大o符号用来描述这种增长率。函数f(x)可写作O(g(x))，读为“f是g的大o”。数学定义形式为：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果f(x)是O(g(x))，那么</span><br><span class="line">存在c，x’满足f(x)&lt;=c*g(x)，任意x&gt;x&#x27;</span><br></pre></td></tr></table></figure>
<p>换成自然语言就是，完成f(x)的时间总是短于或等于完成g(x)的时间和任意常量（至少，只要输入的x值大于某个初始值x’）的乘积。<br>从根本上讲，我们需要寻找一个函数，它的行为和我们的算法一样差或更差。这样一来我们就可以通过给该函数送入非常大的输入，然后观察该函数的结果，从而了解我们算法的执行上限。</p>
<h2 id="大θ符号"><a href="#大θ符号" class="headerlink" title="大θ符号"></a>大θ符号</h2><p>当大多数人谈论大o符号时，更准确地讲他们谈论的更接近Donald Knuth所描述的大θ符号。从技术角度讲，大o符号适合描述上限，比如7是6的上限，同样道理，9、12、65也都是6的上限。但在后来大多数人谈论函数增长率时，更多说的时最小上限，或抽象出具有上限和下限的函数。算法分析领域之父，Knuth教授，将其描述为大θ符号，并给出了下面的定义：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">如果f(x)是g(x)的大θ，那么g(x)既是f(x)的上限也是f(x)的下限。</span><br></pre></td></tr></table></figure>
<p>那么，我们也可以说f(x)是g(x)级（order）。级或大θ是理解内核中算法的最重要的数学工具之一。<br>所以当人们谈论大o符号时，他们往往是谈论大θ。</p>
<h2 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h2><p>比如，再次考虑计算房间里的人数，假设你一秒钟数一个人，那么如果有7个人在房间里，你需要花7秒钟数他们。显然如果有n个人，需要花n秒钟数他们。我们称该算法的复杂度为O(n)。如果任务是在房间里的所有人面前跳舞呢，因为不管你是5个人还是5000个人，跳舞花费的时间都是相同的，所以该任务的复杂度为O(1)。下表给出了常见的复杂度。</p>
<table>
<thead>
<tr>
<th>O(g(x))</th>
<th>名称</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>恒量</td>
</tr>
<tr>
<td>log n</td>
<td>对数的</td>
</tr>
<tr>
<td>n</td>
<td>线性的</td>
</tr>
<tr>
<td>n²</td>
<td>平方的</td>
</tr>
<tr>
<td>n³</td>
<td>立方的</td>
</tr>
<tr>
<td>2ⁿ</td>
<td>指数的</td>
</tr>
<tr>
<td>n!</td>
<td>阶乘</td>
</tr>
</tbody></table>
<p>让房间里的所有人相互介绍的复杂度是多少呢？有什么函数抽象这种算法呢？如果介绍一个人需要花费30秒，那么互相介绍10个人花多久呢？介绍100个人又需要花多久呢？理解一个算法在提高工作负载时的表现，是为给定工作选择最好算法的关键。<br>显然，应避免使用复杂度为O(n!)或O(2ⁿ)的算法，另外，用复杂度为O(1)的函数代替复杂度为O(n)的函数通常都会提高执行性能。但是情况并非总是如此，不能仅仅依靠算法复杂度来判断哪种算法在实际使用中性能最高。回忆一下，指定的O(g(x))，有一个恒量c和g(x)相乘，所以有可能算法复杂度为O(1)的算法需要花费3个小时才能完成任务，而且无论输入多大，总是要花3个小时。这样的话很可能要比复杂度O(n)、但输入很少的算法费时还长。因此我们在比较算法性能时，还需要考虑输入规模。<br>我们不赞成使用复杂的算法，但是时刻要注意算法的负载和典型输入集合大小的关系。不要为了你根本不需要支持的伸缩度的要求，盲目的去优化算法。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章我们讨论了许多Linux内核开发者们用于实现从进程调度到设备驱动等内核代码的通用数据结构。你会随着学习的深入，慢慢发现这些数据结构的妙用。你写你自己的内核代码时，记住总是应该重用已经存在的内核基础设施，别去重复早轮子。<br>我们也介绍了算法复杂度以及测量和标识算法复杂度的工具，其中最值得注意的是大o。贯穿本书，以及Linux内核，大o都是我们评价算法和内核组件在多用户、处理器、进程、网络连接，以及其他环境下伸缩度的重要指标。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第6章 内核数据结构</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>中断和中断处理</title>
    <url>/2022/11/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>任何操作系统内核的核心任务，都包含对连接到计算机上的硬件设备进行有效管理，如硬盘、蓝光碟机、键盘、鼠标、3D处理器，以及无线电等。而想要管理这些设备，首先要能和它们互通音信才行。众所周知，处理器的速度跟外围硬件设备的速度往往不在一个数量级上，因此，如果内核采取让处理器向硬件发出一个请求，然后专门等待回应的办法，显然差强人意。既然的硬件响应这么慢，那么内核就应该在此期间处理其他事务，等待硬件真正完成了请求的操作之后，再回过头来对它进行处理。<br>那么到底如何让处理器和这些外部设备能协同工作，且不会降低机器的整体性能呢？轮询（polling）可能会是一种解决办法。它可以让内核定期对设备的状态进行查询，然后做出相应的处理。不过这种方法很可能会让内核做不少无用功，因为无论硬件设备是正在忙碌着完成任务还是已经大功告成，轮询总会周期性地重复执行。更好的办法是由我们来提供一种机制，让硬件在需要的时候再向内核发出信号。这就是中断机制。在本章中，我们将先讨论中断，进而讨论内核如何使用所谓的中断处理函数处理对应的中断。</p>
<span id="more"></span>

<h1 id="中断"><a href="#中断" class="headerlink" title="中断"></a>中断</h1><p>中断使得硬件得以发出通知给处理器。例如，在你敲击键盘的时候，键盘控制器会发送一个中断，通知操作系统有按键按下。中断本质上是一种特殊的电信号，由硬件设备发向处理器。处理器接收到中断后，会马上向操作系统反映此信号的到来，然后就由操作系统负责处理这些新到来的数据。硬件设备生成中断的时候并不考虑与处理器的时钟同步–换句话说就是中断随时可以产生。因此，内核随时可能因为新到来的中断而被打断。<br>从物理学的角度来看，中断是一种电信号，由硬件设备生成，直接送入中断控制器的输入引脚当中–中断控制器是个简单的电子芯片，其作用是将多路中断管线，采用复用技术只通过一个和处理器相连接的管线与处理器通信。当接收到一个中断后，中断控制器会向处理器发送一个电信号。处理器一经检测到此信号，便中断自己当前的工作转而处理中断。此后，处理器会通知操作系统系统已经产生中断，这样，操作系统就可以对这个中断进行适当的处理了。<br>不同的设备对应不同的中断，而每个中断都通过一个唯一的数字标志。因此，来自键盘的中断就区别于来自硬盘的中断，从而使得操作系统能够对中断进行区分，并知道哪个硬件设备产生了哪个中断。这样，操作系统才能给不同的中断提供对应的中断处理程序。<br>这些中断通常被称为中断请求（IRQ）线。每个IRQ线都会被关联一个数值量–例如，在经典的PC机上，IRQ0是时钟中断，而IRQ1是键盘中断。但并非所有的中断号都是这样严格定义的。例如，对于连接在PCI总线上的设备而言，中断是动态分配的。而且其他非PC体系结构也具有动态分配可用中断的特性。重点在于特定的重点总是与特定的设备相关联，并且内核要知道这些信息。实际上，硬件发出中断是为了引起内核的关注。</p>
<p><strong>异常</strong><br>在操作系统中，讨论中断就不能不提及异常。<code>异常与中断不同，它在产生时必须考虑与处理器时钟同步</code>。实际上，异常也常常被称为同步中断。在处理器执行到由于编程失误而导致的错误指令的时候，或者是在执行期间出现特殊情况（缺页），必须依靠内核来处理的时候，处理器就会产生一个异常。因为许多处理器体系结构处理异常与处理中断的方式类似，因此，内核对它们的处理也很类似。本章对中断（硬件产生的异步中断）的讨论，大部分也适用于异常（由处理器本身产生的同步中断）。<br>在x86体系结构上如何通过软中断实现系统调用，那就是陷入内核，然后引起一种特殊的异常–系统调用处理程序异常。你会看到，中断的工作方式与之类似，其差异只在于中断是由硬件而不是软件引起的。</p>
<h1 id="中断处理程序"><a href="#中断处理程序" class="headerlink" title="中断处理程序"></a>中断处理程序</h1><p>在响应一个特定中断的时候，内核会执行一个函数，该函数叫做中断处理程序（interrupt handle）或中断服务例程（ISR）。产生中断的每个设备都有一个相应的中断处理程序。例如，由一个函数专门处理来自系统时钟的中断，而另外一个函数专门处理由键盘产生的中断。<code>一个设备的中断处理程序是它设备驱动程序的一部分--设备驱动程序是用于对设备进行管理的内核代码</code>。<br>在Linux中，中断处理程序就是普普通通的C函数。只不过这些函数必须按照特定的类型声明，以便内核能够以标准的方式传递处理程序的信息，在其他方面，它们与一般的函数别无二致。中断处理程序与其他内核函数的真正区别在于，中断处理程序是被内核调用来响应中断的，而它们运行于我们称之为中断上下文的特殊上下文中。需要指出的是，中断上下文偶尔也称为原子上下文，因为正如我们看到的，该上下文中的执行代码不可阻塞。<br>中断随时可能发生，因此中断处理程序也就随时可能执行。所以必须保证中断处理程序能够快速执行，这样才能保证尽可能快地恢复中断代码的执行。因此，尽管对硬件而言，操作系统能迅速对其中断进行服务非常重要；当然对系统的其他部分而言，让中断处理程序在尽可能短的时间内完成运行也同样重要。<br>最起码的，中断处理程序要负责通知硬件设备中断已被接收：嗨，硬件，我听到你了，现在回去工作吧！但是中断处理器程序往往还要完成大量其他的工作。例如，我们可以考虑一下网络设备的中断处理程序面临的挑战。该处理程序除了要对硬件应答，还要把来自硬件的网络数据包拷贝到内存，对其进行处理后再交给合适的协议栈或应用程序。显而易见，这种工作量不会太小，尤其对于如今的千兆比特和万兆比特以太网卡而言。</p>
<h1 id="上半部和下半部的对比"><a href="#上半部和下半部的对比" class="headerlink" title="上半部和下半部的对比"></a>上半部和下半部的对比</h1><p>又想中断处理程序运行得快，又想中断处理程序完成的工作量多，这两个目的显然有所抵触。鉴于两个目的之间存在此消彼长的矛盾关系，所以我们一般把中断处理切为两个部分或两半。中断处理程序是上半部–接收到一个中断，它就立即开始执行，但只做由严格时限的工作，例如对接收的中断进行应答或者复位硬件，这些工作都是在所有中断被禁止的情况下完成的。能够被允许稍后完成的工作会推迟到下半部去。此后，在合适的时机，下半部会被开中断执行。Linux提供了实现下半部的各种机制。<br>让我们考察一下上半部和下半部分割的例子，还是以我们的老朋友–网卡为例。当网卡接收来自网络的数据包时，需要通知内核数据包到了。网卡需要立即完成这件事，从而优化网络的吞吐量和传输周期，以避免超时。因此，网卡立即发出中断：嗨，内核，我这里有最新数据包了。内核通过执行网卡已注册的中断处理程序来做出应答。<br>中断开始执行，通知硬件，拷贝最新的网络数据包到内存，然后读取网卡更多的数据包。这都是重要、紧迫而又与硬件相关的工作。内核通常需要快速的拷贝网络数据包到系统内存，因为网卡上接收网络数据包的缓存大小固定，而且相比系统内存也要小得多。所以上述拷贝动作一旦被延迟，必然造成缓存溢出–进入的网络包占满了网卡的缓存，后续的入包只能丢弃。当网络数据包被拷贝到系统内存后，中断的任务算是完成了，这时它将控制器交还给系统被中断前运行的程序。处理和操作数据包的其他工作在随后的下半部中进行。</p>
<h1 id="注册中断处理程序"><a href="#注册中断处理程序" class="headerlink" title="注册中断处理程序"></a>注册中断处理程序</h1><p>中断处理程序是管理硬件的驱动程序的组成部分。每一设备都有相关的驱动程序，如果设备使用中断（大部分设备如此），那么相应的驱动程序就注册一个中断处理程序。<br>驱动程序可以通过<code>request_irq()</code>函数注册一个中断处理程序（它被声明在文件<code>&lt;linux/interrupt.h&gt;</code>中），并且激活给定的中断线，以处理中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//request_irq: 分配一条给定的中断线</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">request_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,</span></span><br><span class="line"><span class="params">                <span class="type">irq_handler_t</span> handler,</span></span><br><span class="line"><span class="params">                <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                <span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                <span class="type">void</span> *dev)</span></span><br></pre></td></tr></table></figure>
<p>第一个参数irq表示要分配的中断号。对某些设备，如传统PC设备上的系统时钟或键盘，这个值通常是预先确定的。而对于大多数其他设备来说，这个值要么是可以通过探测获取，要么可以通过编程动态确定。<br>第二个参数handler是一个指针，指向处理这个中断的实际中断处理函数。只要操作系统一接收到中断，该函数就被调用。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="title function_">irqreturn_t</span> <span class="params">(*<span class="type">irq_handler_t</span>)</span><span class="params">(<span class="type">int</span>,<span class="type">void</span> *)</span>;</span><br></pre></td></tr></table></figure>
<p>注意handler函数的原型，它接受两个参数，并有一个类型为irqreturn_t的返回值。</p>
<h2 id="中断处理程序标志"><a href="#中断处理程序标志" class="headerlink" title="中断处理程序标志"></a>中断处理程序标志</h2><p>第三个参数flags可以为0，也可能是下列一个或多个标志的位掩码。其定义在文件&lt;linux&#x2F;interrupt.h&gt;。在这些标志中最重要的是：<br>IRQF_DISABLED–该标志被设置后，意味着内核在处理中断处理程序本身期间，要禁止所有的其他中断。如果不设置，中断处理程序可以与除本身外的其他任何中断同时运行。多数中断处理程序是不会去设置该位的，因为禁止所有中断是一种野蛮行为。这种用法留给希望快速执行的轻量级中断。这一标志是SA_INTERRUPT标志的当前表现形式，在过去的中断中用以区分“快速”和“慢速”中断。<br>IRQF_SAMPLE_RANDOM–此标志表明这个设备产生的中断对内核熵池（entropy pool）有贡献。内核熵池负责提供从各种随机事件导出真正的随机数。如果指定了该标志，那么来自该设备的中断时间间隔就会作为熵填充到熵池。如果你的设备以预知的速率产生中断（如系统定时器），或者可能受到外部攻击者（如联网设备）的影响，那么就不要设置这个标志。相反，有其他很多硬件产生中断的速率是不可预知的，所以都能成为一种很好的熵源。<br>IRQF_TIMER–该标志是特别为系统定时器的中断处理而准备的。<br>IRQF_SHARED–此标志表明可以在多个中断处理程序之间共享中断线。在同一个给定线上注册的每一个处理程序必须指定这个标志；否则，在每条线上只能有一个处理程序。<br>第四个参数name是与中断相关的设备的ASCII文本表示。例如，PC机上键盘中断对应的这个值为“keyboard”。这些名字会被<code>/proc/irq</code>和<code>/proc/interrupts</code>文件使用，以便与用户通信。<br>第五个参数dev用于共享中断线。当一个中断处理程序需要释放时，dev将提供唯一的标志信息（cookie），以便从共享中断线的诸多中断处理程序中删除指定的那一个。如果没有这个参数，那么内核不可能知道在给定的中断线上到底要删除哪一个处理程序，如果无须共享中断线，那么将该参数赋为空值（NULL）就可以了，但是，如果中断线是被共享的，那么就必须传递唯一的信息（除非设备又旧又破且位于ISA总线上，那么就必须支持共享中断）。另外，内核每次调用中断处理程序时，就会把这个指针传递给它。实践中往往会通过它传递驱动程序的设备结构：这个指针是唯一的，而且有可能在中断处理程序内被用到。<br>request_irq()成功执行会返回0。如果返回非0值，就表示有错误发生，在这种情况下，指定的中断处理程序不会被注册。最常见的错误是-EBUSY，它表示给定的中断线已经在使用（或者当前用户或者你没有指定IRQF_SHARED）。<br>注意，request_irq()函数可能会睡眠，因此，不能在中断上下文或其他不允许阻塞的代码中调用该函数。天真地在睡眠不安全的上下文中调用request_irq()函数，是一种常见错误。造成这种错误的部分原因是为什么request_irq()会引起堵塞–这确实让人费解。在注册的过程中，内核需要在<code>/proc/irq</code>文件中创建一个与中断对应的项。函数proc_mkdir()就是用来创建这个新的procfs项的。proc_mkdir()通过调用函数proc_create()对这个新的porcfs项进行设置，而proc_create()会调用函数kmalloc()来请求分配内存。函数kmalloc()是可以睡眠的。</p>
<h2 id="一个中断例子"><a href="#一个中断例子" class="headerlink" title="一个中断例子"></a>一个中断例子</h2><p>在一个驱动程序中请求一个中断线，并在通过request_irq()安装中断处理程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">request_irq():</span><br><span class="line"><span class="keyword">if</span>(request_irq(irqn,my_interrupt,IRQF_SHARED,<span class="string">&quot;my_device&quot;</span>,my_dev)) &#123;</span><br><span class="line">    printk(KERN_ERR<span class="string">&quot;my_device:cannot register IRQ %d\n&quot;</span>,irqn);</span><br><span class="line">    <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这个例子中，irqn是请求的中断线；my_interrupt是中断处理程序；我们通过标志设置中断线可以共享；设备命名为“my_device”；最后是传递my_dev变量给dev形参。如果请求失败，那么这段代码将打印出一个错误并返回。如果调用返回0，则说明处理程序已经成功安装。此后，处理程序就会在响应该中断时被调用。有一点很重要，初始化硬件和注册中断处理程序的顺序必须正确，以防止中断处理程序在设备初始化完成之前就开始执行。</p>
<h2 id="释放中断处理程序"><a href="#释放中断处理程序" class="headerlink" title="释放中断处理程序"></a>释放中断处理程序</h2><p>卸载驱动程序时，需要注销相应的中断处理程序，并释放中断线。上述动作需要调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">free_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,<span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure>
<p>如果指定的中断线不是共享的，那么，该函数删除处理程序的同时将禁用这条中断线。如果中断线是共享的，则仅删除dev对应的处理程序，而这条中断线本身只有在删除了最后一个处理程序时才会被禁用。由此可以看出为什么唯一的dev如此重要。对于共享的中断线，需要一个唯一的信息来区分上面的多个处理程序，并让free_irq()仅仅删除指定的处理程序。不管在哪种情况下（共享或不共享），如果dev非空，它都必须与需要删除的处理程序相匹配。必须从进程上下文中调用free_irq()。<br>下表给出中断处理函数的注册和注销函数。<br><strong>中断注册方法表</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>request_irq()</td>
<td>在给定的中断线上注册一给定的中断处理程序</td>
</tr>
<tr>
<td>free_irq()</td>
<td>如果在给定的中断线上没有中断处理程序，则注销响应的处理程序，并禁用其中断线</td>
</tr>
</tbody></table>
<h1 id="编写中断处理程序"><a href="#编写中断处理程序" class="headerlink" title="编写中断处理程序"></a>编写中断处理程序</h1><p>以下是一个中断处理函数声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">intr_handler</span><span class="params">(<span class="type">int</span> irq,<span class="type">void</span> *dev)</span>;</span><br></pre></td></tr></table></figure>
<p>注意，它的类型与request_irq()参数中的handler所要求的参数类型相匹配。第一个参数irq就是这个处理程序要响应的中断的中断号。如今，这个参数已经没有太大用处了，可能只是在打印日志信息时会用到。而在2.0版本以前的Linux内核中，由于没有dev这个参数，必须通过irq才能区分使用相同驱动程序。因而也使用相同的中断处理程序的多个设备。例如，具有多个相同类型的硬盘驱动控制器的计算机。<br>第二个参数dev是一个通用指针，它与在中断处理程序注册时传递给request_irq()的参数dev必须一致。如果该值有唯一确定性（这样做是为了能支持共享），那么它就相当于一个cookie，可以用来区分共享同一中断处理程序的多个设备。另外dev也可能指向中断处理程序使用的一个数据结构。因为对每个设备而言，设备结构都是唯一的，而且可能在中断处理程序中也用得到，因此，它也通常被看做dev。<br>中断处理程序的返回值是一个特殊类型：irqreturn_t。中断处理程序可能返回两个特殊的值：IRQ_NONE和IRQ_HANDLED。当中断处理程序检测到一个中断，但该中断对应的设备并不是在注册处理函数期间指定的产生源时，返回IRQ_NONE；当中断处理程序被正确调用，且确实是它所对应的设备产生了中断时，返回IRQ_HANDLED。另外，也可以使用宏IRQ_RETVAL(val)。如果val为非0值，那么该宏返回IRQ_HANDLED；否则，返回IRQ_NONE。利用这些特殊的值，内核可以知道设备发出的是否是一种虚假的中断。如果给定中断线上所有中断处理程序返回的都是IRQ_NONE，那么，内核就可以检测出了问题。注意，irqreturn_t这个返回值类型实际上是一个int型数据。之所以使用这个特殊值是为了与早期的内核保持兼容–2.6版本之前的内核并不支持这种特性，中断处理程序只需返回void就行了。如果要在2.4或者更早的内核上使用这样的驱动程序，只需简单地将typedef irqreturn_t 改为void，屏蔽掉此特性，并给no-ops定义不同的返回值，其他用不着做什么大的修改。中断处理函数通常会标记为static，因为它从来不会被别的文件中的代码直接调用。<br>中断处理程序扮演什么样的角色要取决于产生中断的设备和该设备为什么要发送中断。即使其他什么工作也不做，绝大部分的中断处理程序至少需要知道产生中断的设备，告诉它已经收到中断了。对于复杂一点的设备，可能还需要在中断处理程序中发送和接受数据，以及执行一些扩充的工作。如前所述，应尽可能将扩充的工作推给下半部处理程序。</p>
<p><strong>重入和中断处理程序</strong><br><code>Linux中的中断处理程序是无须重入的</code>。当一个给定的中断处理程序正在执行时，相应的中断线在所有的处理器上都会被屏蔽掉，以防止在同一中断线上接收另一个新的中断。通常情况下，所有其他的中断都是打开的，所有这些不同中断线上的其他中断都能被处理，但当前中断线总是被禁止的。由此可以看出，<code>同一个中断处理程序绝对不会被同时调用以处理嵌套的中断</code>。这极大地简化了中断处理程序的编写。</p>
<h2 id="共享的中断处理程序"><a href="#共享的中断处理程序" class="headerlink" title="共享的中断处理程序"></a>共享的中断处理程序</h2><p>共享的处理程序与非共享的处理程序在注册和运行方式上比较相似，但差异主要有以下三处：</p>
<ol>
<li>request_irq()的参数flags必须设置IRQF_SHARED标志。</li>
<li>对于每个注册的中断处理程序来说，dev参数必须唯一。指向任意设备结构的指针就可以满足这一要求；通常会选择设备结构，因为它是唯一的，而且中断处理程序可能会用到它。不能给共享的处理程序传递NULL值。</li>
<li>中断处理程序必须能够区分它的设备是否真的产生了中断。这既需要硬件的支持，也需要处理出程序中有相关的处理逻辑。如果硬件不支持这一功能，那中断处理程序肯定会束手无策，它根本没法知道到底是与它对应的设备发出了这个中断，还是共享这条中断线的其他设备发出了这个中断。</li>
</ol>
<p>所有共享中断线的驱动程序都必须满足以上要求。只要有任何一个设备没有按规则进行共享，那么中断线就无法共享。指定IRQF_SHARED标志以调用request_irq()时，只有在以下两种情况下才可能成功：中断线当前未被注册，或者在该线上的所有已注册处理程序都指定了IRQF_SHARED。注意，在这一点上2.6版与以前的内核是不同的，共享的处理程序可以混用IRQF_DISABLED。<br><code>内核接收一个中断之后，它将依次调用该中断线上注册的每一个处理程序</code>。因此，一个处理程序必须知道它是否应该为这个中断负责。如果与它相关的设备并没有产生中断，那么处理程序应该立即退出。这需要硬件设备提供状态寄存器（或类似机制），以便中断处理程序进行检查。毫无疑问，大多数硬件都提供这种功能。</p>
<h2 id="中断处理程序实例"><a href="#中断处理程序实例" class="headerlink" title="中断处理程序实例"></a>中断处理程序实例</h2><p>让我们考察一个实际的中断处理程序，它来自real-time clock（RTC）驱动程序，可以在<code>drivers/char/rtc.c</code>中找到。很多机器（包括PC）都可以找到RTC。它是从一个系统定时器中独立出来的设备，用于设置系统时钟，提供报警器（alarm）或周期性的定时器。对大多数体系结构而言，系统时钟的设置，通常只需要向某个特定的寄存器或I&#x2F;O地址写入想要的时间就可以了。然而报警器或周期性定时器通常就得靠中断来实现。这种中断与生活中的闹铃差不多：中断发出时，报警器或定时器就会启动。<br>RTC驱动程序装载时，rtc_init()函数会被调用，对这个驱动程序进行初始化。它的职责之一就是注册中断处理程序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//对rtc_irq注册rtc_interrupt</span></span><br><span class="line"><span class="keyword">if</span>(request_irq(rtc_irq,rtc_interrupt,IRQF_SHARED,<span class="string">&quot;rtc&quot;</span>,(<span class="type">void</span> *)&amp;rtc_port)) &#123;</span><br><span class="line">    printk(KERN_ERR<span class="string">&quot;rtc: cannot register IRQ %d\n&quot;</span>,rtc_irq);</span><br><span class="line">    <span class="keyword">return</span> -EIO;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从中我们看出，中断号由rtc_irq指定。这个变量用于为给定体系结构指定RTC中断。例如，在PC上，RTC位于IRQ 8。第二个参数是我们的中断处理程序rtc_interrupt–它将与其他中断处理程序共享中断线，因为它设置了IRQF_SHARED标志。由第四个参数我们看出，驱动程序名称为“rtc”。因为这个设备允许共享中断线，所以它给dev形参传递了一个面向每个设备的实参值。<br>最后要展示的是处理程序本身：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">irqreturn_t</span> <span class="title function_">rtc_interrupt</span><span class="params">(<span class="type">int</span> irq,<span class="type">void</span> *dev)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        可以是报警器中断、更新完成的中断或周期性中断</span></span><br><span class="line"><span class="comment">        我们把状态保存在rtc_irq_data的低字节中，</span></span><br><span class="line"><span class="comment">        而把从最后一次读取之后所接收的中断号保存在其余字节中</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    spin_lock(&amp;rtc_lock);</span><br><span class="line"></span><br><span class="line">    rtc_irq_data += <span class="number">0x100</span>;</span><br><span class="line">    rtc_irq_data &amp;= ~<span class="number">0xff</span>;</span><br><span class="line">    rtc_irq_data |= (CMOS_READ(RTC_INTR_FLAGS) &amp; <span class="number">0xF0</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(rtc_status &amp; RTC_TIMER_ON)</span><br><span class="line">        mod_timer(&amp;rtc_irq_timer,jiffies + HZ/rtc_freq + <span class="number">2</span>*HZ/<span class="number">100</span>);</span><br><span class="line">    </span><br><span class="line">    spin_unlock(&amp;rtc_lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//现在执行其余的操作</span></span><br><span class="line">    spin_lock(&amp;rtc_task_lock);</span><br><span class="line">    <span class="keyword">if</span>(rtc_callback)</span><br><span class="line">        rtc_callback-&gt;func(rtc_callback-&gt;private_data);</span><br><span class="line">    spin_unlock(&amp;rtc_task_lock);</span><br><span class="line">    wake_up_interruptible(&amp;rtc_wait);</span><br><span class="line"></span><br><span class="line">    kill_fasync(&amp;rtc_async_queue,SIGIO,POLL_IN);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> IRQ_HANDLED;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要计算机一接收到RTC中断，就会调用这个函数。首先要注意的是使用了自旋锁–第一次调用是为了保证rtc_irq_data不被SMP机器上的其他处理器同时访问，第二次调用避免rtc_callback出现相同的情况。<br>rtc_irq_data变量是无符号长整数，存放有关RTC的信息，每次中断时都会更新以反映中断的状态。<br>接下来，如果设置了RTC周期性定时器，就要通过函数mod_timer()对其更新。<br>代码的最后一部分–处于注释“现在执行其余的操作”下，会执行一个可能被预先设置好的回调函数。RTC驱动程序允许注册一个回调函数，并在每个RTC中断到来时执行。<br>最后，这个函数会返回IRQ_HANDLED，表明已经正确的完成了对此设备的操作。因为这个中断处理程序不支持共享，而且RTC也没有什么用来测试虚假中断的机制，所以该处理程序总是返回IRQ_HANDLED。</p>
<h1 id="中断上下文"><a href="#中断上下文" class="headerlink" title="中断上下文"></a>中断上下文</h1><p>当执行一个中断处理程序时，内核处于中断上下文（interrupt context）中。让我们先回忆一下进程上下文。进程上下文是一种内核所处的操作模式，此时内核代表进程执行–例如，执行系统调用或允许内核线程。在进程上下文中，可以通过current宏关联当前进程。此外，因为进程是以进程上下文的形式连接到内核中的，<code>因此，进程上下文可以睡眠，也可以调用调度程序</code>。<br>与之相反，中断上下文和进程并没有什么瓜葛。与current宏也是不相干的（尽管它会指向被中断的进程）。因为没有后备进程，所以中断上下文不可以睡眠，否则又怎能再对它重新调度呢？<code>因此，不能从中断上下文中调用某些函数。如果一个函数睡眠，就不能在你的中断处理程序中使用它</code>–这是对什么样的函数可以在中断处理函数中使用的限制。<br>中断上下文具有较为严格的时间限制，因为它打断了其他代码。<code>中断上下文的代码应当迅速、简洁，尽量不要使用循环去处理繁重的工作</code>。有一点非常重要，请永远牢记：中断处理程序打断了其他代码（甚至可能是打断了在其他中断线上的另一中断处理程序）。正是因为这种异步执行地特性，<code>所以所有的中断处理程序必须尽可能的迅速、简洁</code>。尽量把工作从中断处理程序中分离出来，放在下半部执行，因为下半部可以在更合适的时间运行。<br>中断处理程序栈的设置是一个配置选项。曾经，中断处理程序并不具有自己的栈。相反，它们共享所中断进程的内核栈。内核栈的大小是两页，具体来说，在32位体系结构上是8KB，在64位体系结构上是16KB。因为在这种设置中，中断处理程序共享别人的堆栈，所以它们在栈中获取空间时必须非常节约。当然，内核栈本来就很有限，因此，所有的内核代码都应该谨慎利用它。<br>在2.6版早期的内核中，增加了一个选项，把栈的大小从两页减到一页，也就是在32位的系统上只提供4KB的栈。这就减轻了内存的压力，因为系统中每个进程原先都需要两页连接，且不可换出的内核内存。为了应对栈大小的减少，中断处理程序拥有了自己的栈，每个处理器一个，大小为一页。这个栈就称为中断栈，尽管中断栈的大小是原先共享栈的一半，但平均可用栈空间大得多，因为中断处理程序把这一整页占为己有。<br>你的中断处理程序不必关心栈如何设置，或者内核栈的大小是多少。总而言之，尽量节约内核栈空间。</p>
<h1 id="中断处理机制的实现"><a href="#中断处理机制的实现" class="headerlink" title="中断处理机制的实现"></a>中断处理机制的实现</h1><p>中断处理系统在Linux中的实现是非常依赖于体系结构的，想必你对此不会感到特别惊讶。实现依赖于处理器、所使用的中断控制器的类型、体系结构的设计及机器本身。<br>下图是中断从硬件到内核的路由。<br><img src="/2022/11/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/1.jpeg" alt="img not found"><br>设备产生中断，通过总线把电信号发送给中断控制器。如果中断线是激活的（它们是允许被屏蔽的），那么中断控制器就会把中断发往处理器。在大多数体系结构中，这个工作就是通过电信号给处理器的特定管脚发送一个信号。除非在处理器上禁止该中断，否则，处理器会立即停止它正在做的事，关闭中断系统，然后跳到内存中预定义的位置开始执行那里的代码。这个预定义的位置是由内核设置的，是中断处理程序的入口点。<br>在内核中，中断的旅程开始于预定义入口点，这类似于系统调用通过预定义的异常句柄进入内核。对于每条中断线，处理器都会跳到对应的一个唯一的位置。这样，内核就可以知道所接收中断的IRQ号了。初始入口点只是在栈中保存这个号，并存放当前寄存器的值（这些值属于被中断的任务）；然后，内核调用函数do_IRQ()。从这里开始，大多数中断处理代码是用C编写的–但它们依然于体系结构相关。<br>do_IRQ()的声明如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">int</span> <span class="title function_">do_IRQ</span><span class="params">(<span class="keyword">struct</span> pt_regs regs)</span></span><br></pre></td></tr></table></figure>
<p>因为C的调用惯例是要把函数参数放在栈的顶部，因此pt_regs结构包含原始寄存器的值，这些值是以前在汇编入口例程中保存在栈中的。中断的值也会得以保存，所以，do_IRQ()可以将它提取出来。<br>计算出中断号之后，do_IRQ()对所接收的中断进行应答，禁止这条线上的中断传递。在普通的PC机上，这些操作都是由mask_and_ack_8259A()来完成的。<br>接下来，do_IRQ()需要确保在这条中断线上有一个有效的处理程序，而且这个程序已经启动，但是当前并没有执行。如果是这样的话，<code>do_IRQ()就调用handle_IRQ_event()来运行为这条中断线所安装的中断处理程序</code>。handle_IRQ_event()方法被定义在文件<code>kernel/irq/handler.c</code>中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * handle_IRQ_event - irq action chain handler</span></span><br><span class="line"><span class="comment"> * @irq:	the interrupt number</span></span><br><span class="line"><span class="comment"> * @action:	the interrupt action chain for this irq</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Handles the action chain of an irq event</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="type">irqreturn_t</span> <span class="title function_">handle_IRQ_event</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq,<span class="keyword">struct</span> irqaction *action)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">irqreturn_t</span> ret,retval = IRQ_NONE;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!(action-&gt;flags &amp; IRQF_DISABLED))</span><br><span class="line">        local_irq_enable_in_hardirq();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        trace_irq_handler_entry(irq,action);</span><br><span class="line">        ret = action-&gt;handler(irq,action-&gt;dev_id);</span><br><span class="line">        trace_irq_handler_exit(irq,action,ret);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">switch</span>(ret) &#123;</span><br><span class="line">            <span class="keyword">case</span> IRQ_WAKE_THREAD:</span><br><span class="line">                <span class="comment">//把返回值设置为已处理，以便可疑的检查不再触发</span></span><br><span class="line">                ret = IRQ_HANDLED;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//捕获返回值为WAKE_THREAD的驱动程序，但是并不创建一个线程函数</span></span><br><span class="line">                <span class="keyword">if</span>(unlikely(!action-&gt;thread_fn)) &#123;</span><br><span class="line">                    warn_no_thread(irq,action);</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="comment">//为这次中断唤醒处理线程。万一线程崩溃且被杀死，我们仅仅假装已经处理了该中断。上述的硬件中断</span></span><br><span class="line">                <span class="comment">//（hardirq）处理程序已经禁止设备中断，因此杜绝irq产生。</span></span><br><span class="line">                <span class="keyword">if</span>(likely(!test_bit(IRQTF_DIED,</span><br><span class="line">                                    &amp;action-&gt;thread_flags))) &#123;</span><br><span class="line">                    set_bit(IRQTF_RUNTHREAD,&amp;action-&gt;thread_flags);</span><br><span class="line">                    wake_up_process(action-&gt;thread);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//Fall through to add to randomness</span></span><br><span class="line">            <span class="keyword">case</span> IRQ_HANDLED:</span><br><span class="line">                status |= action-&gt;flags;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            retval |= ret;</span><br><span class="line">            action = action-&gt;next;</span><br><span class="line">    &#125;<span class="keyword">while</span>(action);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(status &amp; IRQF_SAMPLE_RANDOM)</span><br><span class="line">        add_interrupt_randomness(irq);</span><br><span class="line">    local_irq_disable();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，因为处理器禁止中断，这里要把它们打开，就必须在处理程序注册期间指定IRQF_DISABLED标志。回想一下，IRQF_DISABLED表示处理程序必须在中断禁止的情况下运行。接下来，每个潜在的处理程序在循环中依次执行。如果这条线不是共享的，第一次执行后就退出循环。否则，所有的处理程序都要被执行。之后，如果在注册期间指定了IRQF_SAMPLE_RANDOM标志，则还要调用函数add_interrupt_randomness()。这个函数使用中断间隔时间为随机数产生器产生熵。最后，再将中断禁止（do_IRQ()期望中断一直是禁止的），函数返回。回到do_IRQ()，该函数做清理工作并返回到初始入口点，然后再从这个入口点跳到函数ret_from_intr()。<br>ret_from_intr()例程类似于初始入口代码，以汇编语言编写。这个例程检查重新调度是否正在挂起，这意味着设置了need_resched。如果重新调度正在挂起，而且内核正在返回用户空间，也就是说，中断了用户进程。那么，schedule()被调用。如果内核正在返回内核空间，也就是说，中断了内核本身，只有在preempt_count为0时，schedule()才会被调用，否则，抢占内核便是不安全的。在schedule()返回之后，或者如果没有挂起的工作，那么，原来的寄存器被恢复，内核恢复到曾经中断的点。<br>在x86上，初始的汇编例程位于<code>arch/x86/kernel/entry_64.S</code>（文件entry_32.S对应32位的x86体系架构），C方法位于<code>arch/x86/kernel/irq.c</code>。其他所支持的结构与此类似。</p>
<h1 id="x2F-proc-x2F-interrupt"><a href="#x2F-proc-x2F-interrupt" class="headerlink" title="&#x2F;proc&#x2F;interrupt"></a>&#x2F;proc&#x2F;interrupt</h1><p>procfs是一个虚拟文件系统，它只存在于内核内存，一般安装于&#x2F;proc目录。在procfs中读写文件都要调用内核函数，这些函数模拟从真实文件中读或写。与此相关的例子是<code>/proc/interrupts</code>文件，该文件存放的是系统中与中断相关的统计信息。下面是从单处理器PC上输出的信息：<br><img src="/2022/11/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/2.jpeg" alt="img not found"><br>第1列是中断线。在这个系统中，现有的中断号为0-2、4、5、12以及15。这里没有显示没有安装处理程序的中断线。第2列是一个接收中断数目的计数器。事实上，系统中的每个处理器都存在这样的列，但是，这个机器只是一个处理器。我们看到，时钟中断已接收3602371次中断，这里，声卡（EMU10K1）没有接收一次中断（这表示机器启动以来还没有使用它）。第3列是处理这个中断的中断控制器。XT-PIC对应于标准的PC可编程中断控制器。在具有I&#x2F;O APIC的系统上，大多数中断会列出IO-APIC-level或IO-APIC-edge，作为自己的中断控制器。最后一列是与这个中断相关的设备名字。这个名字是通过参数devname提供给函数request_irq()的，前面已经讨论过了。如果中断是共享的，则这条中断线上注册的所有设备都会列出来。<br>对于想深入探究procfs内部的人来说，procfs的代码位于<code>fs/proc</code>中。不必惊讶，提供&#x2F;proc&#x2F;interrupts的函数是与体系结构相关的，叫做show_interrupts()。</p>
<h1 id="中断控制"><a href="#中断控制" class="headerlink" title="中断控制"></a>中断控制</h1><p>Linux内核提供了一组接口用于操作机器上的中断状态。这些接口为我们提供了能够禁止当前处理器的中断系统，或屏蔽掉整个机器的一条中断线的能力，这些例程都是与体系结构相关的，可以在&lt;asm&#x2F;system.h&gt;和&lt;asm&#x2F;irq.h&gt;中找到。<br>一般来说，控制中断系统的原因归根结底是需要提供同步。通过禁止中断，可以确保其中某个自动处理程序不会抢占当前的代码。此外，禁止中断还可以禁止内核抢占，然而，不管是禁止中断还是禁止内核抢占，都没有提供任何保护机制来防止其他处理器的并发访问。Linux支持多处理器，因此，内核代码一般都需要获取某种锁，防止来自其他处理器对共享数据的并发访问。获取这些锁的同时也伴随着禁止本地中断。锁提供保护机制，防止来自其他处理器的并发访问，而禁止中断提供保护机制，则是防止来自其他中断处理程序的并发访问。因此，必须理解内核中的控制接口。</p>
<h2 id="禁止和激活中断"><a href="#禁止和激活中断" class="headerlink" title="禁止和激活中断"></a>禁止和激活中断</h2><p>用于禁止当前处理器（仅仅是当前处理器）上的本地中断，随后又激活它们的语句为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">local_irq_disable();</span><br><span class="line"><span class="comment">//禁止中断</span></span><br><span class="line">local_irq_enable();</span><br></pre></td></tr></table></figure>
<p>这两个函数通常以单个汇编指令来实现（当然，这依赖于体系结构）。实际上，在x86中，local_irq_disable()仅仅是cli指令，而local_irq_enable()只不过是sti指令。cli和sti分别是对clear和set允许中断（allow interrupt）标志的汇编调用。换句话说，在发出中断的处理器上，它们将禁止和激活中断的传递。<br>如果在调用local_irq_discable()例程之前已经禁止了中断，那么该例程往往会带来潜在的危险；同样相应的local_irq_enable()例程也存在潜在危险，因为它将无条件的激活中断，尽管这些中断可能在开始时就是关闭的。所以我们需要一种机制把中断恢复到以前的状态而不是简单的禁止或激活。内核普遍关心这点是因为，内核中一个给定的代码路径既可以在中断激活的情况下达到，也可以在中断禁止的情况下达到，这取决于具体的调用链。例如，想象一下前面的代码片段是一个大函数的组成部分。这个函数被另外两个函数调用：其中一个函数禁止中断，而另一个函数不禁止中断。因为随着内核的不断增长，要想知道到达这个函数的所有代码路径将变得越来越困难，因此，在禁止中断之前保存中断系统的状态会更加安全一些。相反，在准备激活中断时，只需把中断恢复到它们原来的状态。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line">local_irq_save(flags);<span class="comment">//禁止中断</span></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line">local_irq_restore(flags);<span class="comment">//中断被恢复到它们原来的状态</span></span><br></pre></td></tr></table></figure>
<p>这些方法至少部分要以宏的形式实现，因此表面上flags参数（这些参数必须定义为unsigned long类型）是以值传递的。该参数包含具体体系结构的数据，也就是包含中断系统的状态。至少有一种体系结构把栈信息与值相结合（SPARC），因此flags不能传递给另一个函数（特别是它必须驻留在同一栈帧中）。基于这个原因，对local_irq_save()和对local_irq_restore()的调用必须在同一个函数中进行。<br>前面的所有函数既可以在中断中调用，也可以在进程上下文中调用。</p>
<p><strong>不再使用全局的cli()</strong><br>以前的内核中提供了一种“能够禁止系统中所有处理器上的中断”方法。而且，如果另一个处理器调用这个方法，那么它就不得不等待，直到中断重新被激活才能继续执行。这个函数就是cli()，相应的激活中断函数为sti()–虽然适用于所有体系结构，但完全以x86为中心。这些接口在2.5版本开发期间取消了，相应地，所有的中断同步现在必须结合使用本地中断控制和自旋锁。这就意味着，为了确保对共享数据地互斥访问，以前代码仅仅需要通过全局禁止中断达到互斥，而现在则需要多做些工作了。<br>以前，驱动程序编写者可能假定在他们地中断处理程序中，任何访问共享数据地方都可以使用cli()提供互斥访问。cli()调用将确保没有其他的中断处理程序（因而只有它们特定的处理程序）会运行。此外，如果另一个处理器进入了cli保护区，那么它不可能继续运行，直到原来的处理器退出它们的cli()保护区，并调用了sti()后才能继续运行。</p>
<p>取消全局cli()有不少优点。首先，强制驱动程序编写者实现真正的加锁。要知道具有特定目的细粒度锁比全局锁要快许多，而且也完全吻合cli()的使用初衷。其次，这也使得很多代码更具流线型，避免了代码的成簇布局。所以由此得到的中断系统更简单也更易于理解。</p>
<h2 id="禁止指定中断线"><a href="#禁止指定中断线" class="headerlink" title="禁止指定中断线"></a>禁止指定中断线</h2><p>在前面的内容中，我们看到了禁止整个处理器上所有中断的函数。在某些情况下，只禁止整个系统中一条特定的中断线就足够了。这就是所谓的屏蔽掉一条中断线。作为例子，你可能想在对中断的状态操作之前禁止设备中断的传递。为此，Linux提供了四个接口。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">disable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">disable_irq_nosync</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">enable_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">synchronize_irq</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> irq)</span>;</span><br></pre></td></tr></table></figure>
<p>前两个函数禁止中断控制器上指定的中断线，即禁止给定中断向系统中所有处理器的传递。另外，函数只有在当前正在执行的所有处理程序完成后，diasble_irq()才能返回。因此，调用者不仅要确保不在指定线上传递新的中断，同时还要确保所有已经开始执行的处理程序已全部退出。函数disable_irq_nosync()不会等待当前中断处理程序执行完毕。<br>函数synchronize_irq()等待一个特定的中断处理程序的退出。如果该程序正在执行，那么该函数必须在退出后才能返回。<br>对这些函数的调用可以嵌套。但要记住在一条指定的中断线上，对diasble_irq()或disable_irq_nosync()的每次调用，都需要相应的调用一次enable_irq()。只有在对enable_irq()完成最后一次调用之后，才真正激活了中断线。例如，如果disable_irq()被调用了两次，那么直到第二次调用enable_irq()后，才能真正地激活中断线。<br>所有这三个函数可以从中断或者进程上下文中调用，而且不会睡眠。但如果从中断上下文中调用，就要特别小心！例如，当你正在处理一条中断线时，并不想激活它（回想当某个处理程序的中断线正在被处理时，它被屏蔽掉）。<br>禁止多个中断处理程序共享的中断线是不合适的，禁止中断线也就禁止了这条线上所有设备的中断传递。因此，用于新设备的驱动程序应该倾向于不使用这一些接口。根据规范，PCI设备必须支持中断线共享，因此，它们根本不应该使用这些接口。所以，diable_irq()及其相关函数在老式传统设备（如PC并口）的驱动程序中更容易被找到。</p>
<h2 id="中断系统的状态"><a href="#中断系统的状态" class="headerlink" title="中断系统的状态"></a>中断系统的状态</h2><p>通常有必要了解中断系统的状态（如中断是禁止的还是激活的），或者你当前是否正处于中断上下文的执行状态中。<br>宏irqs_disable()定义在&lt;asm&#x2F;system.h&gt;中。如果本地处理器上的中断系统被禁止，则它返回非0；否则返回0。<br>在&lt;linux&#x2F;hardirq.h&gt;中定义的两个宏提供一个用来检查内核的当前上下文的接口，它们是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">in_interrupt()</span><br><span class="line">in_irq()</span><br></pre></td></tr></table></figure>
<p>第一个宏最有用：如果内核处于任何类型的中断处理中，它返回非0，说明内核此刻正在执行中断处理程序，或者正在执行下半部处理程序。宏in_irq()只有在内核确实正在执行中断处理程序时才返回非0。<br>通常情况下，你要检查自己是否处于进程上下文中。也就是说，你希望确保自己不在中断上下文中。这种情况很常见，因为代码要做一些像睡眠这样只能从进程上下文中做的事。如果in_interrupt()返回0，则此刻内核处于进程上下文中。<br>是的，名字有些混淆，但可以对它们的含义稍加区别。下表是中断控制方法和其描述的摘要。<br><strong>中断控制方法的列表</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>local_irq_disable()</td>
<td>禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_enable()</td>
<td>激活本地中断传递</td>
</tr>
<tr>
<td>local_irq_save()</td>
<td>保存本地中断传递的当前状态，然后禁止本地中断传递</td>
</tr>
<tr>
<td>local_irq_restore</td>
<td>恢复本地中断传递到给定的状态</td>
</tr>
<tr>
<td>disable_irq()</td>
<td>禁止给定中断线，并确保该函数返回之前在该中断线上没有处理程序在运行</td>
</tr>
<tr>
<td>disable_irq_nosync()</td>
<td>禁止给定中断线</td>
</tr>
<tr>
<td>enable_irq()</td>
<td>激活给定中断线</td>
</tr>
<tr>
<td>irqs_disable()</td>
<td>如果本地中断传递被禁止，则返回非0；否则返回0</td>
</tr>
<tr>
<td>in_interrupt()</td>
<td>如果在中断上下文中，则返回非0；如果在进程上下文中，则返回0</td>
</tr>
<tr>
<td>in_irq()</td>
<td>如果当前正在执行中断处理程序，则返回非0；否则返回0</td>
</tr>
</tbody></table>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章介绍了中断，它是一种由设备使用的硬件资源异步向处理器发信号。实际上，中断就是由硬件来打断操作系统。<br>大多数现代硬件都通过中断与操作系统通信。对给定硬件进行管理的驱动程序注册中断中断处理程序，是为了响应并处理来自相关硬件的中断。中断过程所做的工作包括应答并重新设置硬件，从设备拷贝数据到内存以及反之，处理硬件请求，并发送新的硬件请求。<br>内核提供的接口包括注册和注销中断处理程序、禁止中断、屏蔽中断线以及检查中断系统的状态。<br>因为中断打断了其他代码的执行（进程，内核本身，甚至其他中断处理程序），它们必须赶快执行完。但通常还有很多工作要做。为了在大量的工作与必须快速执行之间求得一种平衡，内核把处理中断的工作分为两半。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第7章 中断和中断处理</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>定时器和时间管理</title>
    <url>/2022/11/23/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>时间管理在内核中占有非常重要的地位。相对于事件驱动而言，内核中有大量的函数都是基于时间驱动的。其中有些函数是周期执行的，像对调度程序中的运行队列进行平衡调整或对屏幕进行刷新这样的函数，都需要定期执行，比如说，每秒执行100次；而另外一些函数，比如需要推后执行的磁盘I&#x2F;O操作等，则需要等待一个相对时间后才运行—-比如说，内核会在500ms后再执行某个任务。除了上述两种函数需要内核提供时间外，内核还必须管理系统的运行时间以及当前日期和时间。<br>请注意相对时间和绝对时间之间的差别。如果某个事件在5s后被调度执行，那么系统所需要的不是绝对时间，而是相对时间；相反，如果要求管理当前日期和当前时间，则内核不但要计算流逝的时间而且还要计算绝对时间。所以这两种时间概念对内核时间管理来说都至关重要。<br>另外，还请注意周期性产生的事件与内核调度程序推迟到某个确定点执行的事件之间的差别。周期性产生的事件—-比如每10ms一次—-都是由系统定时器决定的。系统定时器是一种可编程硬件芯片，它能以固定频率产生中断。该中断就是所谓的定时器中断，它所对应中断处理程序负责更新系统时间，也负责执行需要周期性运行的任务。系统定时器和时钟中断处理程序是Linux系统内核管理机制中的中枢，本章将着重讨论它们。<br>本章关注的另外一个焦点是动态定时器—-一种用来推迟执行程序的工具。比如说，如果软驱马达在一定时间内都未活动，那么软盘驱动程序会使用动态定时器关闭软驱马达。内核可以动态创建或撤销动态定时器。本章将介绍动态定时器在内核中的实现，同时给出在内核代码中可供使用的定时器接口。</p>
<span id="more"></span>

<h1 id="内核中的时间概念"><a href="#内核中的时间概念" class="headerlink" title="内核中的时间概念"></a>内核中的时间概念</h1><p>时间概念对计算机来说有点模糊，事实上内核必须在硬件的帮助下才能计算和管理时间。硬件为内核提供了一个系统定时器用以计算流逝的时间，该时钟在内核中可看成一个电子时间资源，比如数字时钟或处理器频率等。系统定时器以某种频率自行触发时钟中断，该频率可以通过编程预定，称作节拍率。当时钟中断发生时，内核就通过一种特殊的中断处理程序对其进行处理。<br>因为预编的节拍率对内核来说是可知的，所以内核知道连续两次时钟中断的时间间隔。这个间隔时间就称为节拍，它等于节拍率分之一秒。正如你所看到的，内核就是靠这种已知的时钟中断间隔来计算墙上时间和系统运行时间的。墙上时间对用户空间的应用程序来说是最重要的。内核通过控制时钟中断维护实际时间，另外内核也为用户空间提供了一组系统调用以获取实际日期和实际时间。系统运行时间（自系统运行开始所经过的时间）对用户空间和内核都很有用，因为许多程序必须清楚流逝的时间。通过两次（现在和以后）读取运行时间再计算它们的差，就可以得到相对的流逝的时间了。</p>
<ol>
<li>时钟中断对于管理操作系统尤为重要，大量内核函数的生命周期都离不开流逝的时间的控制。下面给出一些利用时间中断周期执行的工作。</li>
<li>更新系统运行时间。</li>
<li>更新实际时间。</li>
<li>在smp系统上，均衡调度程序中各处理器上的运行队列。如果运行队列负载不均衡的话，尽量使它们均衡。</li>
<li>检查当前进程是否用尽了自己的时间片。如果用尽，就重新进行调度。</li>
<li>运行超时的动态定时器。</li>
<li>更新资源消耗和处理器时间的统计值。</li>
</ol>
<p>这其中有些工作在每次的时钟中断处理程序中都要被处理—-也就是说，这些工作随时钟的频率反复运行。另一些也是周期性地执行，但只需要每n次时钟中断运行一次，也就是说，这些函数在累计一定数量的时钟节拍数才能被执行。在“定时器中断处理程序”这一小节中，我们将详细讨论时钟中断处理程序。</p>
<h1 id="节拍率：HZ"><a href="#节拍率：HZ" class="headerlink" title="节拍率：HZ"></a>节拍率：HZ</h1><p>系统定时器频率（节拍率）是通过静态预处理定义的，也就是HZ（赫兹），在系统启动时按照HZ值对也就进行设置。体系结构不同，HZ的值也不同，实际上，对于某些体系结构来说，甚至是机器的不同，它的值也会不一样。<br>内核在&lt;asm&#x2F;param.h&gt;文件中定义了这个值。节拍率有一个HZ频率，一个周期为1&#x2F;HZ秒。例如，在x86体系结构中，系统定时器频率默认100。因此，x86时钟中断的频率就为100HZ，也就是说在i386处理器上的每秒钟时钟中断100次（百分之一秒，即10ms产生一次）。但其他体系结构的节拍率为250和1000，分别对应4ms和1ms。下表给出了各种体系结构与各自对应节拍率的完整列表。<br><img src="/2022/11/23/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/1.jpeg" alt="img not found"><br>编写内核代码时，不要认为HZ值是一个固定不变的值。这不是一个常见的错误，因为大多数体系结构的节拍率都是可调的。但是在过去，只有Alpha一种机型的节拍率不等于100，所以，很多本该使用HZ的地方，都错误地在代码中直接硬编码（hard-code）成100这个值。稍后，我们会给出内核代码中使用HZ的例子。<br>正如我们所看到的，时钟中断能处理许多内核事务，所以它对内核来说极为重要。事实上，内核中的全部时间概念都来源于周期运行的系统时钟。所以选择一个合适的频率，就如同在人际交往中建立和谐关系一样，必须取得各方面的折中。</p>
<h2 id="理想的HZ值"><a href="#理想的HZ值" class="headerlink" title="理想的HZ值"></a>理想的HZ值</h2><p>自Linux问世以来，i386体系结构中时钟中断频率就设定为100HZ，但是在2.5开发版内核中，中断频率被提高到1000HZ。当然，是否应该提高频率是饱受争议的。由于内核中众多子系统都必须依赖于时钟中断工作，所以改变中断频率必然会对这个系统造成很大的冲击。但是，任何事情总是有两面性的，我们接下来就来分析系统定时器使用高频率与使用低频率各有哪些优劣。<br>提高节拍率意味着时钟中断产生得更加频繁，所以中断处理程序也会更频繁地执行。如此一来会给整个系统带来如下好处：</p>
<ol>
<li>更高的时钟中断解析度可提高时间驱动事件的解析度。</li>
<li>提高了时间驱动事件的准确度。</li>
</ol>
<p>提高节拍率等同于提高中断解析度。比如HZ&#x3D;100的时钟的执行粒度为10ms，即系统中的周期事件最快为每10ms运行一次，而不可能由更高的精度，但是当HZ&#x3D;100时，解析度就为1ms—-精细了10倍。虽然内核可以提高额度为1ms的时钟，但是并没有证据显示对系统中所有程序而言，频率为1000Hz的时钟频率相比频率为100Hz的时钟都更合适。<br>另外，提高解析度的同时也提高了准确度。假定内核在某个随机时刻触发定时器，而它可能在任何时间超时，但由于只有在时钟中断到来时才可能执行它，所以平均误差大约为半个时钟中断周期。比如说，如果时钟周期为HZ&#x3D;100，那么事件平均在设定时刻的+&#x2F;-5ms内发生，所以误差为5ms。如果HZ&#x3D;1000，那么平均误差可降低到0.5ms—-准确度提高了10倍。</p>
<h2 id="高HZ的优势"><a href="#高HZ的优势" class="headerlink" title="高HZ的优势"></a>高HZ的优势</h2><p>更高的时钟中断频度和更高的准确度又会带来如下优点：</p>
<ol>
<li>内核定时器能够以更高的频度和更高的准确度运行。</li>
<li>依赖定时值执行的系统调用，比如poll()和select()，能够以更高的精度运行。</li>
<li>对诸如资源消耗和系统运行时间等的测量会有更精细的解析度。</li>
<li>提高进程抢占的准确度。</li>
</ol>
<p>对poll()和select()超时精度的提高会给系统性能带来极大的好处。提高精度可以大幅度提高系统性能。频繁使用上述两种系统调用的应用程序，往往在等待时钟中断上浪费大量的时间，而事实上，定时值可能早就超时了。回忆一下，平均误差可是时钟周期的一半。<br>更高的准确率也使进程抢占更准确，同时还会加快调度响应时间。时钟中断处理程序负责减少当前进程的时间片计数。当时间片计数跌到0时，而又设置了need_resched标志的话，内核便立刻重新运行调度程序。假定有一个正在运行的进程，它的时间片只剩下2ms了，此时调度程序又要求抢占该进程，然后去运行另一个新进程；然而，该抢占行为不会在下一个时钟中断到来前发生，也就是说，在这2ms内不可能进行抢占。实际上，对于频率为100HZ的时钟来说，最坏要在10ms后，当下一个时钟中断到来时才能进行抢占，所以新进程也就可能要求的晚10ms才能执行。当然，进程之间也是平等的，因为所有的进程都是一视同仁的待遇，调度起来都不是很明确—-但关键不在于此。问题在于由于耽误了抢占，所以对于类似于填充音频缓冲区这样有严格时间要求的任务来说，结果是无法接受的。如果将节拍率提高到1000HZ，在最坏情况下，也能将调度延误时间降低到1ms，而在平均情况下，只能降低到0.5ms左右。</p>
<h2 id="高HZ的劣势"><a href="#高HZ的劣势" class="headerlink" title="高HZ的劣势"></a>高HZ的劣势</h2><p>提高节拍率会产生副作用。事实上，把节拍率提高到1000HZ，甚至更高，会带来一个大问题：节拍率越高，意味着时钟中断频率越高，也就意味着系统负担越重。 因为处理器必须花时间来执行时钟中断处理程序，所以节拍率越高，中断处理程序占用的处理器的时间越多。这样不但减少了处理器处理其他工作的时间，而且还会更频繁地打乱处理器高速缓存并增加耗电。负载造成的影响值得进一步探讨。将时钟频率从100HZ提高到1000HZ必然会是时钟中断的负载增加10倍。可是增加前的系统负载又是多少呢？最后的结论是：至少在现代计算机系统上，时钟频率为1000HZ不会导致难以接受的负担，并且不会对系统性能造成较大的影响。尽管如此，在2.6版本内核中还是运行在编译内核时选定不同的HZ值。</p>
<p><strong>无节拍的OS？</strong><br>也许你疑惑操作系统是否一定要有固定时钟。尽管40年来，几乎所有的通用操作系统都使用与本章所描述的系统类似的时钟中断，但Linux内核支持“无节拍操作”这样的选项。当编译内核时设置了CONFIG_HZ配置选项，系统就根据这个选项动态调度时钟中断。并不是每隔固定的时间间隔触发时钟中断，而是按需动态调度和重新设置。如果下一个时钟频率设置为3ms，就每3ms触发一次时钟中断。之后，如果50ms内都无事可做，内核以50ms重新调度时钟中断。<br>减少开销总是受欢迎的，但是实质性收益还是省电，特别是在系统空闲时。在基于节拍的标准系统中，即使在系统空闲期间，内核也需要为时钟中断提供服务。对于无节拍的系统而言，空闲档期不会被不必要的时钟中断所打断，于是减少了系统的能耗。且不论空闲期是200ms还是200s，随着时间的推移，所省的电是实实在在的。</p>
<h1 id="jiffies"><a href="#jiffies" class="headerlink" title="jiffies"></a>jiffies</h1><p>全局变量jiffies用来记录自系统启动以来产生的节拍的总数。启动时，内核将该变量初始化为0，此后，每次时钟中断处理程序就会增加该变量的值。因为一秒内时钟中断的次数等于HZ，所以jiffies一秒内增加的值也就为HZ。系统运行时间以秒为单位计算，就等于jiffies&#x2F;HZ。实际出现的情况可能稍微复杂些：内核给jiffies赋一个特殊的初值，引起这个变量不断地溢出，由此捕捉bug。当找到实际的jiffies值后，就首先把这个“偏差”减去。</p>
<p><strong>Jiffy的语源</strong><br>术语jiffy起源是未知的。据说这个短语起源于18世纪的英国。最初，jiffy所指含义不明确，但简单地表示时间周期。<br>在科学应用中，jiffy表示各种时间间隔，通常指10ms。在物理中，jiffy有时表示光传播某一特定距离所花的时间。<br>在计算机工程中，jiffy常常是两次连续的时钟周期之间的时间。在电机工程中，jiffy是完成一次AC（交流电）周期的时间。<br>在操作系统中，尤其是Unix中，jiffy是两次连续的时钟节拍之间的时间。历史上，这是10ms。但是，我们在本章中已经看到，jiffy在Linux中已经有所变化。<br>jiffies定义于文件&lt;linux&#x2F;jiffies.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> jiffies;</span><br></pre></td></tr></table></figure>
<p>现在我们先来看一些用到jiffies的内核代码。下面表达式将以秒为单位的时间转化为jiffies：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(seconds * HZ)</span><br></pre></td></tr></table></figure>
<p>相反，下面表达式将jiffies转换为以秒为单位的时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">(jiffies/HZ)</span><br></pre></td></tr></table></figure>
<p>比较而言，内核中将秒转换为jiffies用得多一些，比如代码经常需要设置一些将来的时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> time_stamp = jiffies;         <span class="comment">//现在</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> next_tick = jiffies + <span class="number">1</span>;      <span class="comment">//从现在开始1个节拍</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> later = jiffies + <span class="number">5</span>*HZ;       <span class="comment">//从现在开始5秒</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> fraction = jiffies + HZ/<span class="number">10</span>;   <span class="comment">//从现在开始1/10秒</span></span><br></pre></td></tr></table></figure>
<p>把时钟转化为秒经常会用在内核和用户空间进行交互的时候，而内核本身很少用到绝对时间。<br>注意，jiffies类型为无符号长整型，用其他任何类型存放它都不正确。</p>
<h2 id="jiffies的内部表示"><a href="#jiffies的内部表示" class="headerlink" title="jiffies的内部表示"></a>jiffies的内部表示</h2><p>jiffies变量总是无符号长整数，因此，在32位体系结构上是32位，在64位体系结构上是64位。32位的jiffies变量，在时钟频率为100HZ情况下，497天后回溢出。如果频率为100HZ，49.7天后回溢出。而如果使用64位的jiffies变量，任何人都别指望会看到它溢出。<br>由于性能和历史的原因，主要还考虑到与现有内核代码的兼容性，内核开发者希望jiffies依然为unsigned long。有一些巧妙的思想和少数神奇的链接程序扭转了这一局面。<br>前面已经看到，jiffies定义为 unsigned long：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="type">unsigned</span> <span class="type">long</span> <span class="keyword">volatile</span> jiffies;</span><br></pre></td></tr></table></figure>
<p>第二个变量也定义在&lt;linux&#x2F;jiffies.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">extern</span> u64 jiffies_64;</span><br></pre></td></tr></table></figure>
<p>ld脚本用于连接主内核映像（在x86位于arch&#x2F;x86&#x2F;kernel&#x2F;vmlinux.lds.S），然后用jiffies_64变量的初值覆盖jiffies变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">jiffies = jiffies_64;</span><br></pre></td></tr></table></figure>
<p>因此，jiffies取整个64位jiffies_64变量的低32位。代码可以完全像以前一样继续访问jiffies。因为大多数代码只不过是使用jiffies存放流失的事件，因此，也就只关心低32位。不过，时间管理代码使用整个64位，以此来避免整个64位的溢出。下图呈现了jiffies和jiffies_64的划分。<br><img src="/2022/11/23/%E5%AE%9A%E6%97%B6%E5%99%A8%E5%92%8C%E6%97%B6%E9%97%B4%E7%AE%A1%E7%90%86/2.jpeg" alt="img not found"><br>访问jiffies的代码仅会读取jiffies_64的低32位。通过get_jiffies_64()函数，就可以读取整个64位数值。但是这种需求很少，多数代码仍然只要能通过jiffies变量读取低32位就够了。<br>在这64位体系结构上，jiffies_64和jiffies指的是同一个变量，代码既可以直接读取jiffies也可以调用get_jiffies_64()函数，它们的作用相同。</p>
<h2 id="jiffies的回绕"><a href="#jiffies的回绕" class="headerlink" title="jiffies的回绕"></a>jiffies的回绕</h2><p>和任何C整形一样，当jiffies变量的值超过它的最大存放范围后就会发生溢出。对于32位无符号长整形，最大取值为2³²-1。所以在溢出前，定时器节拍数最大为4294967295.如果节拍计数达到了最大值后还要继续增加的话，它的值会回绕到0。<br>请看下面一个回绕的例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> timeout = jiffies + HZ/<span class="number">2</span>;     <span class="comment">//0.5s后超时</span></span><br><span class="line"><span class="comment">/*执行一些任务*/</span></span><br><span class="line"><span class="comment">/*然后查看是否花的时间过长*/</span></span><br><span class="line"><span class="keyword">if</span>(timeout &gt; jiffies) &#123;</span><br><span class="line">    <span class="comment">//没有超时</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//超时了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面这一小段代码是希望设置一个准确的超时时间—-本例中从现在开始计时，时间为半秒。然后再去处理一些工作，比如探测硬件然后等待它的响应。如果处理这些工作的时间超过了设定的超时时间，代码就要做出相应的出错处理。<br>这里有很多种发生溢出的可能，我们之分析其中之一：考虑如果在设置完timeout变量后，jiffies重新回绕为0将会发生什么？此时，第一个判断将返回假，因为尽管实际上用去的时间可能比timeout值要大，但是由于溢出后回绕为0，所以jiffies这时肯定会小于timeout的值。jiffies本该是个非常大的数值—-大于timeout，但是因为超过了它的最大值，所以反而变成了一个很小的值—-也许仅仅只有几个节拍计数。由于发生了回绕，所以if判断语句的结果刚好相反。<br>幸好，内核提供了四个宏来帮助比较节拍计数，它们能正确地处理节拍计数回绕情况。这些宏定义在文件&lt;linux&#x2F;jiffies.h&gt;中，这里列出的宏是简化版：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> time_after(unknown,known)   ((long)(known) - (long)(unknown)&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_before(unknown,known)   ((long)(unknown) - (long)(known)&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_after_eq(unknown,known)   ((long)(unknown) - (long)(known)&gt;=0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> time_before_eq(unknown,known)   ((long)(known) - (long)(unknown)&gt;=0)</span></span><br></pre></td></tr></table></figure>
<p>其中unknown参数通常是jiffies，known参数是需要比对的值。<br>宏time_after(unknown,known)，当时间unknown超过指定的known时，返回真，否则返回假；宏time_before(unknown,known)，当时间unknown没超过指定的know时，返回真，否则返回假。后面两个宏作用和前面两个宏一样，只有当两个参数相等时，它们才返回真。<br>所以前面的例子可以改造成时钟–回绕–安全的版本，形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> timeout = jiffies + HZ/<span class="number">2</span>;     <span class="comment">//0.5秒后超时</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*...*/</span></span><br><span class="line"><span class="keyword">if</span>(time_after(jiffies,timeout)) &#123;</span><br><span class="line">    <span class="comment">//没有超时</span></span><br><span class="line">&#125;<span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">//超时了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果你对这些宏能避免因为回绕产生的错误感到好奇的话，你可以试试对这两个参数取不同的值。然后设定一个参数回绕到0值，看看会发生什么。</p>
<h2 id="用户空间和HZ"><a href="#用户空间和HZ" class="headerlink" title="用户空间和HZ"></a>用户空间和HZ</h2><p>在2.6版以前的内核中，如果改变内核中HZ的值，会给用户空间中某些程序造成异常结果。这是因为内核是以节拍数&#x2F;秒的形式给用户空间导出这个值的，在这个接口稳定了很长一段时间之后，应用程序便逐渐依赖于这个特定的HZ值了。所以如果在内核中更改了HZ的定义值，就打破了用户空间的常量关系—-用户空间并不知道新的HZ值。所以用户空间可能认为系统运行时间已经是打破20小时了，但实际上系统仅仅是启动了两个小时。<br>要想避免上面的错误，内核必须更改所有导出的jiffies值。因而内核定义了USER_HZ来代表用户空间看到的HZ值。在x86体系结构上，由于HZ值原来一直是100，所以USER_HZ值就定义为100。内核可以使用函数<code>jiffies_to_clock_t()</code>将一个由HZ表示的节拍计数转换为一个由USER_HZ表示的节拍计数。所采用的表达式取决于USER_HZ和HZ是否互为整数倍，而且USER_HZ是否小于等于HZ。如果这两个条件都满足，对大多数系统来说通常也能够满足，则表达式相当简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">return</span> x/(HZ/USER_HZ);</span><br></pre></td></tr></table></figure>
<p>如果不是整数倍关系，那么该宏就得用到更为复杂的算法了。<br>最后还要说明，内核使用函数jiffies_64_to_clock_t()将64位的jiffies值的单位从HZ转换为USER_HZ。<br>在需要把节拍数&#x2F;秒为单位的值导出到用户空间时，需要使用上面这几个函数。比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> start;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> total_time;</span><br><span class="line"></span><br><span class="line">start = jiffies;</span><br><span class="line"><span class="comment">/*执行一些任务*/</span></span><br><span class="line">total_time = jiffies - start;</span><br><span class="line">printk(<span class="string">&quot;That you %lu ticks\n&quot;</span>,<span class="type">jiffies_to_clock_t</span>(total_time));</span><br></pre></td></tr></table></figure>
<p>用户空间期望HZ&#x3D;USER_HZ，但是如果它们不相等，则由宏完成转换，这样的结果自然是皆大欢喜。</p>
<h1 id="硬时钟和定时器"><a href="#硬时钟和定时器" class="headerlink" title="硬时钟和定时器"></a>硬时钟和定时器</h1><p>体系结构提供了两种设备进行计时—-一种是我们前面讨论过的系统定时器；另一种是实时时钟。虽然在不同机器上这两种时钟的实现并不相同，但是它们有着相同的作用和设计思路。</p>
<h2 id="实时时钟"><a href="#实时时钟" class="headerlink" title="实时时钟"></a>实时时钟</h2><p>实时时钟（RTC）是用来持久存放系统时间的设备，即便系统关闭之后，它也可以靠主板上的微型电池提供的电力保持系统的计时。在PC体系结构中，RTC和CMOS集成在一起，而且RTC的运行和BIOS的保存设置都是通过同一个电池供电的。<br>当系统启动时，内核通过读取RTC来初始化墙上时间，该时间存放在xtime变量中。虽然内核通常不会在系统启动后在读取xtime变量，但是有些体系结构会周期性地将时间值存回RTC中。尽管如此，实时时钟最主要的功能仍是在启动时初始化xtime变量。</p>
<h2 id="系统定时器"><a href="#系统定时器" class="headerlink" title="系统定时器"></a>系统定时器</h2><p>系统定时器是内核定时机制中最为重要的角色。尽管不同体系结构中的定时器实现不尽相同，但是系统定时器的根本思想并没有区别—-提供一种周期性触发中断机制。有些体系结构是通过对电子晶振进行分频来实现系统定时器，还有些体系结构则提供了一个衰减测量器—-衰减测量器设置一个初始值，该值以固定频率递减，当减到零时，触发一个中断。无论哪种情况，其效果都一样。<br>在x86体系结构中，主要采用可编程中断时钟（PIT）。PIT在PC机器中普遍存在，而且从DOS时代，就开始以它作为时钟中断源了。内核在启动时对PIT进行编程初始化，使其能够以HZ&#x2F;秒的频率产生时钟中断。虽然PIT设备很简单，但功能也有限，但它足以满足我们的需要。x86体系结构中的其他的时钟资源还包括本地APIC时钟和时间戳计数（TSC）等。</p>
<h1 id="时钟中断处理程序"><a href="#时钟中断处理程序" class="headerlink" title="时钟中断处理程序"></a>时钟中断处理程序</h1><p>现在我们已经理解了HZ、jiffies等概念以及系统定时器的功能。下面将分析时钟中断处理程序是如何实现的。时钟中断处理程序可以划分为两个部分：体系结构相关部分和体系结构无关部分。<br>与体系结构相关的例程作为系统定时器的中断处理程序而注册到内核中，以便在产生时钟中断时，它能够相应地运行。虽然处理程序的具体工作依赖于特定的体系结构，但绝大多数处理程序最低限度也都要执行如下工作：</p>
<ol>
<li>获得xtime_lock锁，以便对访问jiffies_64和墙上时间xtime进行保护。</li>
<li>需要时应答或重新设置系统时钟。</li>
<li>周期地使用墙上时钟更新实时时钟。</li>
<li>调用体系结构无关的时钟例程：tick_periodic()。</li>
</ol>
<p>中断服务程序主要通过调用与体系结构无关的例程，tick_periodic()执行下面更多的工作：</p>
<ol>
<li>给jiffies_64变量增加1（这个操作即使是在32位体系结构上也是安全的，因为前面已经获得了xtime_lock锁）。</li>
<li>更新资源消耗的统计值，比如当前进程所消耗的系统时间和用户时间。</li>
<li>执行已经到期的动态定时器动态定时器。</li>
<li>执行scheduler_tick()函数。</li>
<li>更新墙上时间，该时间存放在xtime变量中。</li>
<li>计算平均负载值。</li>
</ol>
<p>因为上述工作分别都由单独的函数负责完成，所以tick_periodic()例程的代码看起来非常简单。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">tick_periodic</span><span class="params">(<span class="type">int</span> cpu)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(tick_do_timer_cpu == cpu) &#123;</span><br><span class="line">        write_seqlock(&amp;xtime_lock);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//记录下一个节拍事件</span></span><br><span class="line">        tick_next_period = ktime_add(tick_next_period,tick_period);</span><br><span class="line"></span><br><span class="line">        do_timer(<span class="number">1</span>);</span><br><span class="line">        write_sequnlock(&amp;xtime_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update_process_times(user_mode(get_irq_regs()));</span><br><span class="line">    profile_tick(CPU_PROFILING);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>很多重要的操作都在do_timer()和update_process_times()函数中进行。前者承担着对jiffies_64的实际增加操作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">do_timer</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> ticks)</span></span><br><span class="line">&#123;</span><br><span class="line">    jiffies_64 += ticks;</span><br><span class="line">    update_wall_time();</span><br><span class="line">    calc_global_load();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数update_wall_time()，顾名思义，根据所流逝的时间更新墙上的时钟，而calc_global_load()更新系统的平均负载统计值。当do_timer()最终返回时，调用update_process_times()更新所耗费的各种节拍数。注意，通过user_tick区别是花费在用户空间还是内核空间。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">update_process_times</span><span class="params">(<span class="type">int</span> user_tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span> =</span> current;</span><br><span class="line">    <span class="type">int</span> cpu = smp_processor_id();</span><br><span class="line">    <span class="comment">//注意：也必须对这个时钟irq的上下文说明一下原因</span></span><br><span class="line">    account_process_tick(p,user_tick);</span><br><span class="line">    run_local_timers();</span><br><span class="line">    rcu_check_callbacks(cpu,user_tick);</span><br><span class="line">    printk_tick();</span><br><span class="line">    scheduler_tick();</span><br><span class="line">    run_posix_cpu_timers(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>回想一下tick_periodic()，user_tick的值是通过查看系统寄存器来设置的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">update_process_times(user_mode(get_irq_regs()));</span><br></pre></td></tr></table></figure>
<p>account_process_tick()函数对进程的时间进行实质性更新：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">account_process_tick</span><span class="params">(<span class="keyword">struct</span> task_struct *p,<span class="type">int</span> user_tick)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">cputime_t</span> one_jiffy_scaled = cputime_to_scaled(cputime_one_jiffy);</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rq</span> *<span class="title">rq</span> =</span> this_rq();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(user_tick)</span><br><span class="line">        account_user_time(p,cputime_one_jiffy,one_jiffy_scaled);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((p != rq-&gt;idle) || (irq_count() != HARDIRQ_OFFSET))</span><br><span class="line">        account_system_time(p,HARDIRQ_OFFSET,cputime_one_jiffy,one_jiffy_scaled);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        account_idle_time(cputime_one_jiffy);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>也许你已经发现了，这样做意味着内核对进程进行时间计数时，是根据中断发生时处理器所处的模式进行分类统计的，它把上一个节拍全部算给了进程。但是事实上进程在上一个节拍期间可能多次进入和退出内核模式，而且在上一个节拍期间，该进程也不一定是唯一一个运行进程。很不幸，这种粒度的进程统计方式是传统的Unix所具有的，现在还没有更加精密的统计算法的支持，内核现在只能做到这个程度。这也是内核应该采用更高频率的另一个原因。<br>接下来的run_local_timers()函数标记了一个软中断去处理所有到期的定时器。<br>最后，scheduler_tick()函数负责减少当前运行进程的时间片计数值并且在需要时设置need_resched标志。在SMP机器中，该函数还要负责平衡每个处理器上的运行队列。<br>tick_periodic()函数执行完毕后返回与体系结构相关的中断处理程序，继续执行后面的工作，释放xtime_lock锁，然后退出。<br>以上全部工作每1&#x2F;HZ秒都要发生一次，也就是说在x86机器上时钟中断处理程序每秒执行100次或1000次。</p>
<h1 id="实际时间"><a href="#实际时间" class="headerlink" title="实际时间"></a>实际时间</h1><p>当前实际时间定义在文件<code>kernel/time/timekeeping.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">xtime</span>;</span></span><br></pre></td></tr></table></figure>
<p>timespec数据结构定义在文件&lt;linux&#x2F;time.h&gt;中，形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> &#123;</span></span><br><span class="line">    <span class="type">_kernel_time_t</span> tv_sec;  <span class="comment">//秒</span></span><br><span class="line">    <span class="type">long</span> tv_nsec;           <span class="comment">//纳秒</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>xtime.tv_sec以秒为单位，存放着自1970年1月1日（UTC）以来经过的时间，1970年1月1日被称为纪元，多数Unix系统的墙上时间都是基于该纪元而言的。xtime.tv_nsec记录自上一秒开始经过的ns数。<br>读写xtime变量需要使用xtime_lock锁，该锁不是普通自旋锁而是一个seqlock锁。<br>更新xtime首先要申请一个seqlock锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write_seqlock(&amp;xtime_lock);</span><br><span class="line"><span class="comment">/*更新xtime*/</span></span><br><span class="line">write_sequnlock(&amp;xtime_lock);</span><br></pre></td></tr></table></figure>
<p>读取xtime时也要使用read_seqbegin()和read_seqretry()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> seq;</span><br><span class="line"></span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> lost;</span><br><span class="line">    seq = read_seqbegin(&amp;xtime_lock);</span><br><span class="line"></span><br><span class="line">    usec = timer-&gt;get_offset();</span><br><span class="line">    lost = jiffies - wall_jiffies;</span><br><span class="line">    <span class="keyword">if</span>(lost)</span><br><span class="line">        usec += lost * (<span class="number">1000000</span> / HZ);</span><br><span class="line">    sec = xtime.tv_sec;</span><br><span class="line">    usec += (xtime.tv_usec / <span class="number">1000</span>);</span><br><span class="line">&#125;<span class="keyword">while</span>(read_seqretry(&amp;xtime_lock,seq));</span><br></pre></td></tr></table></figure>
<p>该循环不断重复，直到读者确认读取数据时没有写操作介入。如果发现循环期间有时钟中断处理程序更新xtime，那么read_seqretry()就返回无效序列号，继续循环等待。<br>从用户空间取得墙上时间的主要接口是gettimeofday()，在内核中对应系统调用为sys_gettimeofday()，定义于<code>kernel/time.c</code>：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">asmlinkage <span class="type">long</span> <span class="title function_">sys_gettimeofday</span><span class="params">(<span class="keyword">struct</span> timeval *tv,<span class="keyword">struct</span> timezone *tz)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(likely(tv)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ktv</span>;</span></span><br><span class="line">        do_gettimeofday(&amp;ktv);</span><br><span class="line">        <span class="keyword">if</span>(copy_to_user(tv,&amp;ktv,<span class="keyword">sizeof</span>(ktv)))</span><br><span class="line">            <span class="keyword">return</span> -FAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(unlikely(tz)) &#123;</span><br><span class="line">        <span class="keyword">if</span>(copy_to_user(tz,&amp;sys_tz,<span class="keyword">sizeof</span>(sys_tz)))</span><br><span class="line">            <span class="keyword">return</span> -EFAULT;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果用户提供的tv参数非空，那么与体系结构相关的do_gettimeofday()函数将被调用。该函数执行的就是上面提到的循环读取xtime的操作。如果tz参数为空，该函数将把系统时区（存放在sys_tz中）返回用户。如果在给用户空间拷贝墙上时间或时区时发生错误，该函数返回-EFAULT；如果成功，则返回0。<br>虽然内核也实现了time()系统调用，但是gettimeofday()几乎完全取代了它。另外C库函数也提供了一些墙上时间的相关的库调用，比如ftime()和ctime()。<br>另外，系统调用settimeofday()来设置当前时间，它需要具有CAP_SYS_TIME权能。<br>除了更新xtime时间之外，内核不会像用户空间程序那样频繁使用xtime。但也有需要注意的情况，那就是在文件系统的实现代码中存放访问时间戳时需要使用xtime。</p>
<h1 id="定时器"><a href="#定时器" class="headerlink" title="定时器"></a>定时器</h1><p>定时器是管理内核时间流逝的基础。内核经常需要推后执行某些代码，比如以前章节提到的下半部机制就是为了将工作放到以后执行，但不幸的是，之后这个概念很模糊，下半部的本意并非是放到以后的某个时间去执行任务，而仅仅是不在当前时间执行就可以了。我们所需要的是一种工具，能够使工作在指定时间点上执行—-不长不短。正好在希望的时间点上。内核定时器正是解决这个问题的理想工具。<br>定时器的使用很简单。你只需要执行一些初始化工作，设置一个超时时间，指定超时发生后执行的函数，然后激活定时器就可以了。指定的函数将在定时器到期时自动执行。注意定时器并不周期执行，它在超时之后就会自行撤销，这也正是这种定时器被称为动态定时器的一个原因；动态定时器不断地创建和撤销，而且它的运行次数也不受限制。定时器在内核中应用得非常普遍。</p>
<h2 id="使用定时器"><a href="#使用定时器" class="headerlink" title="使用定时器"></a>使用定时器</h2><p>定时器由结构timer_list表示，定义在文件&lt;linux&#x2F;timer.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span>             <span class="comment">//定时器链表的入口</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expires;              <span class="comment">//以jiffies为单位的定时值</span></span><br><span class="line">    <span class="type">void</span> (*function)(<span class="type">unsigned</span> <span class="type">long</span>);    <span class="comment">//定时器处理函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;                 <span class="comment">//传给处理函数的长整型参数</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tvec_t_base_s</span> *<span class="title">base</span>;</span>         <span class="comment">//定时器内部值，用户不要使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>幸运的是，使用定时器并不需要深入了解该数据结构。事实上，过深地陷入该结构，反而会使你的代码不能保证对可能发生的变化提供支持。内核提供了一组与定时器相关的接口用来简化管理定时器的操作。所有这些接口都声明在文件&lt;linux&#x2F;timer.h&gt;中，大多数接口在文件<code>kernel/timer.c</code>中实现。<br>创建定时器时需要先定义它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">my_timer</span>;</span></span><br></pre></td></tr></table></figure>
<p>接着需要通过一个辅助函数来初始化定时器数据结构的内部值，初始化必须在使用其他定时器管理函数对定时器进行操作前完成。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init_timer(&amp;my_timer);</span><br></pre></td></tr></table></figure>
<p>现在你可以填充结构中需要的值了：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_timer.expires = jiffies + delay; <span class="comment">//定时器超时时的节拍数</span></span><br><span class="line">my_timer.data = <span class="number">0</span>;                  <span class="comment">//给定时器处理函数传入0值</span></span><br><span class="line">my_timer.function = my_function;    <span class="comment">//定时器超时时调用的函数</span></span><br></pre></td></tr></table></figure>
<p>my_timer.expires表示超时时间，它是以节拍为单位的绝对计数值，如果当前jiffies计数等于或大于my_timer.expires，那么my_timer.function指向的处理函数就会开始执行，另外该函数还要使用长整型参数my_timer.data。所以正如我们从time_list结构看到的形式，处理函数必须符合下面的函数原型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_timer_function</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span>;</span><br></pre></td></tr></table></figure>
<p>data参数使你可以利用同一个处理函数注册多个定时器，只需通过该参数就能区别对待它们。如果你不需要这个参数，就可以简单地传递0给处理函数。<br>最后，你必须激活定时器：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">add_timer(&amp;my_timer);</span><br></pre></td></tr></table></figure>
<p>大功告成，定时器可以工作了！但请注意定时值的重要性。当前节拍计数等于或大于指定的超时时，内核就开始执行定时器处理函数。虽然内核可以保证不会在超时时间到期前运行定时器处理函数，但是有可能延误定时器的执行。<code>一般来说，定时器都在超时后马上执行，但是也有可能推迟到下一次时钟节拍才能运行，所以不能用定时器来实现任何硬实时任务</code>。<br>有时可能需要更改已经激活的定时器超时时间，所以内核通过函数mod_timer()来实现该功能，该函数可以改变指定的定时器超时时间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mod_timer(&amp;my_tiemr,jiffies+new_delay); <span class="comment">//新的定时值</span></span><br></pre></td></tr></table></figure>
<p>mod_timer()函数也可操作那些已经初始化，但还没被激活的定时器，如果定时器未被激活，mod_timer()会激活它。如果调用时定时器未被激活，该函数返回0；否则返回1。但不论哪种情况，一旦从mod_timer()函数返回，定时器都将被激活而且设置了新的定时值。<br>如果需要在定时器超时前停止定时器，可以使用del_timer()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">del_timer(&amp;my_timer);</span><br></pre></td></tr></table></figure>
<p>被激活或未被激活的定时器都可以使用该函数，如果定时器还未被激活，该函数返回0；否则返回1。注意，不需要为已经超时的定时器调用该函数，因为它们会自动删除。<br>当删除定时器时，必须注意一个潜在的竞争条件。当del_timer()返回后，可以保证的只是：定时器不会再被激活，但是在多处理器机器上定时器中断可能已经在其他处理器上运行了，所以删除定时器时需要等待可能在其他处理器上运行的定时器处理程序都退出，这是就要使用del_timer_sync()函数执行删除工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">del_timer_sync(&amp;my_timer);</span><br></pre></td></tr></table></figure>
<p>和del_timer()函数不同，del_timer_sync()函数不能在中断上下文中使用。</p>
<h2 id="定时器竞争条件"><a href="#定时器竞争条件" class="headerlink" title="定时器竞争条件"></a>定时器竞争条件</h2><p>因为定时器与当前执行代码是异步的，因此就有可能存在潜在的竞争条件。所以，首先，绝不能用如下所示的代码替代mod_timer()函数，来改变定时器的超时时间。这样的代码在多处理器机器上是不安全的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">del_timer(my_timer);</span><br><span class="line">my_timer-&gt;expires = jiffies + new_delay;</span><br><span class="line">add_timer(my_timer);</span><br></pre></td></tr></table></figure>
<p>其次，一般情况下应该使用del_tiemr_sync()函数取代dele_timer()函数，因为无法确定在删除定时器时，它是否正在其他处理器上运行。为了防止这种情况的发生，应该调用del_timer_sync()函数，而不是del_timer()函数。否则，对定时器执行删除操作之后，代码会继续执行，但它有可能会去操作在其他处理器上运行的定时器正在使用的资源，因而造成并发访问，所以请优先使用删除定时器的同步方法。<br>最后，因为内核异步执行中断处理程序，所以应该重点保护定时器中断处理程序中的共享数据。</p>
<h2 id="实现定时器"><a href="#实现定时器" class="headerlink" title="实现定时器"></a>实现定时器</h2><p>内核在时钟中断发生后执行定时器，定时器作为软中断在下半部上下文中执行。具体来说，时钟中断处理程序会执行updaye_process_times()函数，该函数随机调用run_local_timers()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">run_local_timers</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    hrtiemr_run_queues();</span><br><span class="line">    raise_softirq(TIMER_SOFTIRQ);   <span class="comment">//执行定时器软中断</span></span><br><span class="line">    softlockup_tick();    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>run_timer_softirq()函数处理软中断TIMER_SOFTIRQ，从而在当前处理器上运行所有的超时定时器。<br>虽然所有定时器都以链表形式存放在一起，但是让内核经常为了寻找超时定时器而遍历整个链表是不明智的。同样，将链表以超时时间进行排序也是很不明智的做法，因为这样一来在链表中插入和删除定时器都会很费时。为了提高搜索效率，内核将定时器按它们的超时时间划分为五组。当定时器超时时间接近时，定时器将随组一起下移。采用分组定时器的方法可以在执行软中断的多数情况下，确保内核尽可能减少搜索超时定时器所带来的负担。因此定时器管理代码是非常高效的。</p>
<h1 id="延迟执行"><a href="#延迟执行" class="headerlink" title="延迟执行"></a>延迟执行</h1><p>内核代码（尤其是驱动程序）除了使用定时器或下半部机制以外，还需要其他方法来推迟执行任务。这种推迟通常发生在等待硬件完成某些工作时，而且等待的时间往往非常短，比如，重新设置网卡的以太模式需要花费2ms，所以在设定网卡速度后，驱动程序必须等待至少2ms才能继续运行。<br>内核提供了许多延迟方法处理各种延迟请求。不同的方法有不同的处理特点，有些是在延迟任务时挂起处理器，防止处理器执行任何实际工作；另一些不会挂起处理器，所以也不能确保被延迟的代码能够在指定的延迟时间运行。</p>
<h2 id="忙等待"><a href="#忙等待" class="headerlink" title="忙等待"></a>忙等待</h2><p>最简单的延迟方法是忙等待。但要注意该方法仅仅在想要延迟的时间是节拍的整数倍，或者精确率要求不高时才可以使用。<br>忙循环实现起来很简单—-在循环中不断旋转直到希望的时钟节拍数耗尽，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> timeout = jiffies + <span class="number">10</span>;   <span class="comment">//10个节拍</span></span><br><span class="line"><span class="keyword">while</span>(time_before(jiffies,timeout));</span><br></pre></td></tr></table></figure>
<p>循环不断执行，直到jiffies大于delay为止，总共的循环时间为10个节拍。在HZ值等于1000的x86体系结构上，耗时为10ms。类似地：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> delay = jiffies + <span class="number">2</span>*HZ;   <span class="comment">//2秒</span></span><br><span class="line"><span class="keyword">while</span>(time_before(jiffies,delay));</span><br></pre></td></tr></table></figure>
<p>程序循环要等待2*HZ个时钟节拍，也就说无论节拍率如何，都将等待2s。<br>对于系统的其他部分，忙循环方法算不上一个好办法。因为当代码等待时，处理器只能在原地选择等待—-它不会去处理其他任何任务！事实上，你几乎不会用到这种低效率的办法，这里介绍它仅仅是因为它是最简单最直接的延迟方法。当然你也可能在那些蹩脚的代码中发现它的身影。<br>更好的办法应该是在代码等待时，允许内核重新调度执行其他任务：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> delay = jiffies + <span class="number">5</span>*HZ;</span><br><span class="line"><span class="keyword">while</span>(time_before(jiffies,delay))</span><br><span class="line">    cond_resched();</span><br></pre></td></tr></table></figure>
<p>cond_resched()函数将调度一个新程序投入运行，但它只有在设置完need_resched()标志后才能生效。换句话说，该方法有效的条件是系统中存在更重要的任务需要运行。注意，因为该方法需要调用调度程序，所以它不能在中断上下文中使用—-只能在进程上下文中使用。事实上，所有延迟方法在进程上下文中使用得很好，因为中断处理程序都应该尽可能地快执行。另外，延迟执行不管在哪种情况下，都不应该在持有锁时或禁止中断时发生。<br>C语言的推崇者都会问：什么能保证前面的循环已经执行了。C编译器通常只将变量装载一次。一般情况下不能保证循环中的jiffies变量在每次循环中被读取时都重新被载入。但是我们要求jiffies在每次循环时都必须重新装载，因为在后台jiffies值会随时钟中断的发生而不断增加。为了解决这个问题，&lt;linux&#x2F;jiffies.h&gt;中jiffies变量被标记为关键字volatile。关键字volatile指示编译器在每次访问变量时都重新从主内存中获得，而不是通过寄存器中的变量别名来访问，从而确保前面的循环能按预期的方式执行。</p>
<h2 id="短延迟"><a href="#短延迟" class="headerlink" title="短延迟"></a>短延迟</h2><p>有时内核代码（通常也是驱动代码）不但需要很短暂的延迟（比时钟节拍还短），而且还要求延迟的时间很精确。这种情况多发生在和硬件同步时，也就是说需要短暂等待某个动作的完成（等待时间往往小于1ms），所以不可能使用像前面例子中那种基于jiffies的延迟方法。对于时钟频率为100HZ的时钟中断，它的节拍间隔时钟会超过10ms。即使频率为1000HZ的时钟中断，节拍间隔也只能到1ms，所以我们必须寻找其他方法满足更短、更精确的延迟要求。<br>幸运的是，内核提供了三个处理us、ns和ms级别的延迟函数，它们定义在文件&lt;linux&#x2F;delay.h&gt;和&lt;asm&#x2F;delay.h&gt;中，我们可以看到它们并不使用jiffies：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">udelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> usecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">ndelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> nsecs)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">mdelay</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> msecs)</span>;</span><br></pre></td></tr></table></figure>
<p>前一个函数利用忙循环将任务延迟指定的ms数后运行，后者指定延迟的ms数。众所周知，1s等于1000ms，等于10000000μs。这个函数用起来很简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">udelay(<span class="number">150</span>);    <span class="comment">//延迟150μs</span></span><br></pre></td></tr></table></figure>
<p>udelay()函数依靠执行数次循环达到延迟效果，而mdelay()函数又是通过udelay()函数实现的。因为内核知道处理器在1s内能执行多少次循环，所以udelay()函数仅仅需要根据指定的延迟时间在1秒内占的比例。就能决定需要进行多少次循环即可达到要求的推迟时间。<br><strong>我的BogoMIPS比你的大</strong><br>BogoMIPS值总让人觉得糊涂，也让人觉得很有意思。其实，计算BogoMIPS并不是为了表现你的机器性能，它主要被udelay()函数和mdelay()函数使用。它的名字取自bogus和MIPS（每秒处理百万天指令）。<br>BogoMIPS值记录处理器在给定时间内忙循环执行的次数。其实，BogoMIPS记录处理器在空闲时速度有多快。该值存放在变量loops_per_jiffy中，可以从文件<code>/proc/cpuinfo</code>中读到它。延迟循环函数使用loops_per_jiffy值来计算为提供精确延迟而需要进行多少次循环。<br>内核在启动时利用calibrate_delay()计算loops_per_jiffy值，该函数在文件<code>init/main.c</code>中。<br>udelay()函数应当只在小延迟中调用，因为在快速机器上的大延迟可能导致溢出。通常，超过1ms的范围不要使用udelay()进行延迟。对于较长的延迟，mdelay()工作良好。想其他忙等而延迟执行的方案，除非绝对必要，这两个函数都不应当使用。记住，持锁忙等或禁止中断是一种粗鲁的做法，因为系统响应时间和性能都会大受影响。不过，如果你需要精确的延迟，这些调用是最好的办法。这些忙等函数主要用在延迟小的地方，通常在μs范围内。</p>
<h2 id="schedule-timeout"><a href="#schedule-timeout" class="headerlink" title="schedule_timeout()"></a>schedule_timeout()</h2><p><code>更理想的延迟执行方法是使用schedule_timeout()函数</code>，该方法会让需要延迟执行的任务睡眠到指定的延迟时间耗尽后再重新运行。但该方法也不能保证睡眠时间正好等于指定的延迟时间，只能尽量使睡眠时间接近指定的延迟时间。当指定的时间到期后，内核唤醒被延迟的任务并将其重新放回任务队列，用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//将任务设置为可中断睡眠状态</span></span><br><span class="line">set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line"><span class="comment">//小睡一会，“s”秒后唤醒</span></span><br><span class="line">schedule_timeout(s*HZ);</span><br></pre></td></tr></table></figure>
<p>唯一的参数是延迟的相对时间，单位为jiffies，上例中将相应的任务推入可中断睡眠队列，睡眠s秒。因为任务处于可中断状态，所以如果任务收到信号将被唤醒。如果睡眠任务不想接收信号，可以将任务状态设置为TASK_UNINTERRUPTIBLE，然后睡眠。<code>注意，在调用schedule_timeout()函数之前必须首先将任务设置成上面的两种状态之一，否则任务不会睡眠</code>。<br>注意，由于schedule_timeout()需要调用调度程序，所以调用它的代码必须保证能够睡眠。简而言之，调用代码必须处于进程上下文中，并且不能持有锁。</p>
<h3 id="schedule-timeout-的实现"><a href="#schedule-timeout-的实现" class="headerlink" title="schedule_timeout()的实现"></a>schedule_timeout()的实现</h3><p>schedule_timeout()函数的用法相当简单、直接。其实，它是内核定时器的一个简单应用。请看下面的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">signed</span> <span class="type">long</span> <span class="title function_">schedule_timeout</span><span class="params">(<span class="type">signed</span> <span class="type">long</span> timeout)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">timer_t</span> timer;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> expire;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span>(timeout) &#123;</span><br><span class="line">        <span class="keyword">case</span> MAX_SCHEDULE_TIMEOUT:</span><br><span class="line">            schedule();</span><br><span class="line">            <span class="keyword">goto</span> out;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(timeout &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                printk(KERN_ERR<span class="string">&quot;schedule_timeout:wrong timeout&quot;</span></span><br><span class="line">                        <span class="string">&quot;value %lx from %p\n&quot;</span>,timeout,</span><br><span class="line">                        __builtin_return_address(<span class="number">0</span>));</span><br><span class="line">                current-&gt;state = TASK_RUNNING;</span><br><span class="line">                <span class="keyword">goto</span> out;</span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    expire = timeout + jiffies;</span><br><span class="line">    </span><br><span class="line">    init_timer(&amp;timer);</span><br><span class="line">    timer.expires = expire;</span><br><span class="line">    timer.data = (<span class="type">unsigned</span> <span class="type">long</span>)current;</span><br><span class="line">    timer.function = process_timeout;</span><br><span class="line"></span><br><span class="line">    add_timer(&amp;timer);</span><br><span class="line">    schedule();</span><br><span class="line">    del_timer_sync(&amp;timer);</span><br><span class="line"></span><br><span class="line">    timeout = expire - jiffies;</span><br><span class="line"></span><br><span class="line">out:</span><br><span class="line">    <span class="keyword">return</span> timeout &lt; <span class="number">0</span> ? <span class="number">0</span> : timeout;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数用原始的名字timer创建了一个定时器timer；然后设置它的超时时间timeout；设置超时执行函数process_timeout()；接着激活定时器而且调用schedule()。因为任务被标识为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE，所以调度程序不会再选择该任务投入运行，而会选择其他新任务运行。<br>当定时器超时时，process_timeout()函数会被调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">process_timeout</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    wake_up_process((<span class="type">task_t</span> *)data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数将任务设置为TASK_RUNNING状态，然后将其放入运行队列。<br>当任务重新被调度时，将返回代码进入睡眠前的位置继续执行（正好在调用schedule()后）。如果任务被提前唤醒，那么定时器被撤销，process_timeout()函数返回剩余的时间。<br>在switch()括号中的代码是为处理特殊情况而写的，正常情况下不会用到它们。MAX_SCHEDULE_TIMEOUT是用来检查任务是否无限期的睡眠，如果那样的话，函数不会为它设置定时器，而这时调度程序会立刻被调用。如果你需要无限期地让任务睡眠，最好使用其他方法来唤醒任务。</p>
<h3 id="设置超时时间，在等待队列上睡眠"><a href="#设置超时时间，在等待队列上睡眠" class="headerlink" title="设置超时时间，在等待队列上睡眠"></a>设置超时时间，在等待队列上睡眠</h3><p>第4章我们已经看到进程上下文中的代码为了等待特定事件的发生，可以将自己放入等待队列，然后调用调度程序去执行新任务。一旦事件发生后，内核调用wake_up()函数唤醒在睡眠队列上的任务，使其重新投入运行。<br>有时，等待队列上的某个任务可能既在等待一个特定事件到来，又在等待一个特定时间到期—-就看谁来的快。这种情况下，代码可以简单地使用schedule_timeout()函数代替schedule()函数，这样一来，当希望的指定时间到期，任务都会被唤醒。当然，代码需要检查被唤醒的原因（有可能是被事件唤醒，也有可能是因为延迟的时间到期，还可能是因为接收到了信号），然后执行相应的操作。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在本章中，我们考察了时间的概念，并知道了墙上时钟与计算机的正常运行时间如何管理。我们对比了相对时间和绝对时间以及绝对事件与周期事件。我们还涵盖了诸如时钟中断、时钟节拍、HZ以及jiffies等概念。<br>我们考察了定时器的实现，了解了如何把这些用到自己的内核代码中。本章最后，我们浏览了开发者用于延迟的其他方法。<br>你写的大多数内核代码都需要对时间及其走过的时间有一些了解。而最大的可能是，只要你编写驱动程序，就需要处理内核定时器。与其让时间悄悄溜走，还不如阅读本章。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第11章 定时器和时间管理</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>进程调度</title>
    <url>/2022/10/28/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>第3章讨论了进程，它在操作系统看来是程序的运行态表现形式。本章将讨论进程调度程序，它是确保进程能有效工作的一个内核子系统。<br>调度程序负责决定将哪个进程投入运行，何时运行以及运行多长时间。进程调度程序（常常简称调度程序）可看作在可运行态程序之间分配有限的处理器时间资源的内核子系统。调度程序是像Linux这样的多任务操作系统的基础。只有通过调度程序的合理调度，系统资源才能最大限度的发挥作用，多进程才会并发执行的效果。<br>调度程序没有太复杂的原理。最大限度地利用处理器时间的原则是，只要有可以执行的进程，那么总会有进程正在执行。但是只要系统中可运行的进程的数目比处理器的个数多，就注定某一给定时刻会有一些进程不能执行。这些进程在等待运行。这一组处于可运行状态的进程中选择一个来执行，是调度程序所需完成的基本工作。</p>
<span id="more"></span>
<h1 id="多任务"><a href="#多任务" class="headerlink" title="多任务"></a>多任务</h1><p>多任务操作系统就是能同时并发地交互执行多个进程的操作系统。在单处理机器上，这会产生多个进程在同时运行的幻觉。在多处理器机器上，这会使多个进程在不同的处理机上真正同时、并行的运行。无论在单处理器或者是多处理器机器上，多任务操作系统都能使多个进程处于堵塞或者睡眠状态，也就是说，实际上不被投入运行，直到工作确实就绪。这些任务尽管位于内存，但并不处于可运行状态。相反，这些进程利用内核阻塞自己，直到某一事件（键盘输入、网络数据、过一段时间等）发生。因此，现代Linux系统也许有100个进程在内存，但是只有一个处于可运行状态。<br>多任务系统可以划分为两类：非抢占式多任务（cooperative multitasking）和抢占式多任务（preemptive multitasking）。像所有Unix的变体和许多其他现代操作系统一样，Linux提供了抢占式的多任务模式。在此模式下，由调度程序来决定什么时候停止一个进程的运行，以便其他进程能够得到运行机会。这个强制的挂起动作就叫做抢占。进程在被抢占之前能够运行的时间都是预先设置好的，而且有一个专门的名字，叫进程的时间片（timeslice）。时间片实际上就是分配给每个可运行进程的处理器时间段。有效管理时间片能使调度程序从系统全局的角度做出调度决定，这样做还可以避免个别进程独占系统资源。当今众多现代操作系统对程序运行都采用了动态时间片计算的方式，并且引入了可配置的计算策略。不过我们将看到，Linux的独一无二的“公平”调度程序本身并没有采用时间片来达到公平调度。<br>相反，在非抢占式多任务模式下，除非进程自己主动停止运行，否侧它会一直运行。进程主动挂起自己的操作叫做让步（yielding）。理想情况下，进程通常做出让步，以便让每个可允许的进程都享有足够的处理器时间。但这种机制有很多缺点：调度程序无法对每个进程该执行多长时间做出统一规定，所以进程独占的处理器时间可能超出用户的预料；更糟糕的是，一个绝不做出让步的悬挂进程就能使系统崩溃。幸运的是，近20年来，绝大部分操作系统的设计都采用了抢占式多任务–除了Mac OS 9（以及其前身）、Windows 3.1（以及其前身）这些出名且麻烦的异端以外。毫无疑问，Unix从一开始就采用的是抢占式的多任务模式。</p>
<h1 id="Linux的进程调度"><a href="#Linux的进程调度" class="headerlink" title="Linux的进程调度"></a>Linux的进程调度</h1><p>从1991年Linux的第1版到后来的2.4内核系列，Linux的调度程序都相当简陋，设计几乎原始。当然它很容易理解，但是它在众多可允许进程或者多处理器的环境下都难以胜任。<br>正因为如此，在Linux2.5开发系列的内核中，调度程序做了大手术。开始采用了一种叫做O(1)调度程序的新调度程序–它是因为其算法的行为而得名的。它解决了先前版本Linux调度程序的许多不足，引入了许多强大的新特性和性能特征。这里主要感谢静态时间片算法和针对每一处理器的运行队列，它们帮助我们摆脱了先前调度程序设计上的限制。<br>O(1)调度器虽然在拥有数以十计的多处理器的环境下尚能表现得近乎完美的性能和可扩展性，但是时间证明该调度算法对于调度那些响应时间敏感的程序却有一些先天不足。这些程序我们称之为交互进程–它无疑包括了所有需要用户交互的程序。正因为如此，O(1)调度程序虽然对于大服务器的工作负载很理想，但是在很多交互程序运行的桌面系统中则表现不佳，因为其缺少交互进程。自2.6内核系统开发初期，开发人员为了提高对交互程序的调度性能引入了新的进程调度算法。其中最为著名的是“反转楼梯最后期限调度算法（Rotating Staircase Deadline scheduler）”（RSDL），该算法吸取了队列理论，将公平调度的概念引入了Linux调度程序。并且最终在2.6.23内核版本中替代了O(1)调度算法，它此刻被称为“完全公平调度算法”，或者称为CFS。<br>本章将讲解调度程序设计的基础和完全公平调度程序如何运用、如何设计、如何实现以及与它相关的系统调用。我们当然也会讲解O(1)调度程序，因为它毕竟是经典Unix调度程序模型的实现方式。</p>
<h1 id="策略"><a href="#策略" class="headerlink" title="策略"></a>策略</h1><p>策略决定调度程序在何时让什么进程运行。调度器的策略往往就决定系统的整体印象，并且，还要负责优化使用处理器时间。无论从哪个方面看，它都是至关重要的。</p>
<h2 id="I-x2F-O消耗型和处理器消耗型的进程"><a href="#I-x2F-O消耗型和处理器消耗型的进程" class="headerlink" title="I&#x2F;O消耗型和处理器消耗型的进程"></a>I&#x2F;O消耗型和处理器消耗型的进程</h2><p>进程可以被分为I&#x2F;O消耗型和处理器消耗型。前者指进程的大部分时间用来提交I&#x2F;O请求或者等待I&#x2F;O请求。因此，这样的进程经常处于可运行状态，但通常都是运行短短一会，因为它等待更多的I&#x2F;O请求时最后总会阻塞（这里所说的I&#x2F;O是指任何类型的可阻塞资源，比如键盘输入、或者是网络I&#x2F;O）。举例来说，多数用户图形界面程序（GUI）都属于I&#x2F;O密集型，即便它们从不读取或者写入硬盘，它们也会在多数时间等待来自键盘或者鼠标的用户交互操作。<br>相反，处理器消耗型进程把时间大多用在了执行代码上。除非被抢占，否则它们通常一直都不停的运行，因为它们没有太多的I&#x2F;O需求。但是，因为它们不属于I&#x2F;O驱动类型，所以从系统响应速度考虑，调度器不应该让它们经常运行。对于这类处理器消耗型的进程，调度策略往往就是尽量降低它们的调度频率，而延长其运行时间。处理器消耗型进程的极端例子就是无限循环地执行。更具代表性的例子就是那些执行大量数学计算的程序，如sshkeygen或者MATLAB。<br>当然，这种划分方法并非是绝对的。进程可以同时展示这两种行为：比如，X Window 服务器既是I&#x2F;O消耗型，也是处理器消耗型。还有些进程可以是I&#x2F;O消耗型，但属于处理器消耗型的范围。其典型的例子就是字处理器，其通常坐以等待键盘输入，但在任何一时刻可能又黏住处理器疯狂的进行拼写检查或宏计算。<br>调度策略通常要在两个矛盾的目标中间寻找平衡：<code>进程响应迅速（响应时间短）和最大系统利用率（高吞吐量）</code>。为了满足上述需求，调度程序通常采用一套非常复杂的算法来决定最值得运行的进程投入运行，但是它往往并不保证低优先级进程会被公平对待。Unix系统的调度程序更倾向于I&#x2F;O消耗型程序，以提供更好的程序响应速度。Linux为了保证交互式应用和桌面系统的性能，所以对进程的响应做了优化（缩短响应时间），更倾向于优先调度I&#x2F;O消耗型进程。虽然如此，但在下面你会到，调度程序也并非忽略处理器消耗型的进程。</p>
<h2 id="进程优先级"><a href="#进程优先级" class="headerlink" title="进程优先级"></a>进程优先级</h2><p>调度算法中最基本的一类就是基于优先级的调度。这是一种根据进程地价值和其对处理器时间的需求来对进程分级的想法。通常做法是（其并未被Linux系统完全采用）优先级高的进程先运行，低的后运行，相同优先级的进程按轮转方式进行调度（一个接一个，重复进行）。在某些系统中，优先级高的进程运行时间也长。调度程序总是选择时间片未用尽且优先级最高的进程运行。用户和系统都可以通过设置进程的优先级来影响系统的调度。<br>Linux采用两种不同的优先级范围。第一种是用nice值，它的范围是从-20到+19，默认值为0；越大的nice值意味着越低的优先级–nice似乎意味着你对系统中的其他进程更为“优待”。相比高nice值（低优先级）的进程，低nice值（高优先级）的进程能获得更多的处理器时间。nice值是所有Unix系统中标准化的概念–但不同的Unix系统中由于调度方式的不同，因此nice值的运用方式有所差异。比如一些基于Unix的操作系统，如Mac OS X，进程的nice值代表着分配给进程的时间片的绝对值；在Linux中，nice值代表时间片的比例。你可以通过<code>ps -el</code>命令查看系统中的进程列表，结果中标记N1的一列就是进程的nice值。<br>第二种范围是实时优先级，其值是可配置的，默认情况下它的变化范围值0到99。与nice值意义相反，越高的实时优先级代表着越高的进程优先级。任何实时进程的优先级都高于普通进程，也就是说实时优先级和nice值优先级属于两个互不相交的范畴。Linux实时优先级的实现参考的Unix相关标准–特别是POSIX.1b。大部分现代Unix操作系统都通过类似的机制。你可以通过命令：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ps -eo state,uid,pid,ppid,rtprio,time,comm.</span><br></pre></td></tr></table></figure>
<p>查看到你系统中的进程列表，以及它们对应的实时优先级（位于RTPRIO下），其中如果有对应列显示“-”，则说明它不是实时进程。</p>
<h2 id="时间片"><a href="#时间片" class="headerlink" title="时间片"></a>时间片</h2><p>时间片是一个数值，它表明进程在被抢占前所能持续运行的时间。调度策略必须规定一个默认的时间片，但这并不是一件简单的事情。时间片过长会导致系统对交互的响应表现欠佳，让人认为系统无法并发执行应用程序；时间片太短会导致明显增大进程切换带来的处理器耗时，因为肯定会有相当一部分系统时间用在了进程切换上，而这些进程能够用来运行的时间片却很少。此外，I&#x2F;O消耗型和处理器消耗型的进程之间的矛盾也再次显露出来：I&#x2F;O消耗型不需要长的时间片，而处理器消耗型的进程则希望越长越好，这样可以让它们的高速缓存的命中率更高。<br>从上面的争论可以看出，任何长时间片都将导致系统交互表现欠佳。很多操作系统都特别重视这一点，所以默认的时间片很短，如10ms。但是Linux的CFS调度器并没有分配时间片到进程，它是将处理器的使用比例划给进程。这样一来，进程所获得的处理器时间其实都是和系统负载密切相关的。这个比例还会进一步受nice值的影响，nice值作为权重将调制进程所使用的处理器时间比。具有高nice值（更低优先级）得进程将会被赋以更低的权重，从而丧失一小部分的处理器时间比；而具有低nice值（更高优先级）的进程将被赋以高权重，从而强的更高的处理器时间比。<br>像前面所说的，Linux系统是抢占式的。当一个进程进入可运行态，它就被准许投入运行。在多数操作系统中，是否要将一个进程投入运行（也就是抢占当前进程），则完全由进程优先级和是否有时间片决定的。而在Linux系统中使用新的CFS调度器，其抢占时间取决于新的可运行程序消耗了多少处理器时间比。如果消耗的使用比比当前进程小，则新进程立刻投入运行，抢占当前进程。否则，将推迟其运行。</p>
<h2 id="调度策略的活动"><a href="#调度策略的活动" class="headerlink" title="调度策略的活动"></a>调度策略的活动</h2><p>想象下面这样一个系统，它拥有两个可运行的进程：一个文件编辑程序和一个视频编码程序。文字编辑程序显然是I&#x2F;O消耗型的，因为它大部分时间都在等待用户的键盘输入（无论用户的输入速度有多快，都不可能赶上处理器速度）。用户总是希望按下按键就能马上得到响应。相反，视频编码程序是处理器消耗型的。除了最开始从磁盘上读出原始数据流和最后把处理好的视频输出外，程序所有的时间都用来对原始视频数据进行视频编码，处理器很轻易地被100%使用。它对什么时间开始运行没有太严格的要求–用户几乎分辨不出也不关心它到底是立刻就运行还是半秒钟之后才开始的。当然。它完成的越早越好，至于所花时间并不是我们所关心的主要问题。<br>在这样的场景中，理想情况是调度器应该给与文本编辑程序相比视频编码更多的处理器时间，因为它属于交互式应用。对于文本编辑器而言，我们有两个目标。第一是我们希望系统给它更多的处理器时间，这并非是因为它需要更多的处理器时间（其实它并不需要），是因为我们希望在它需要时总能得到处理器；第二是我们希望文本编辑器程序能在其被唤醒时（也就是用户开始打字时）抢占视频解码程序。这样才能确保文本编辑器具有很好的交互性能，以便能响应用户输入。在多数操作系统中，上述目标的达成是要依靠系统分配给文本编辑器更多的时间片和进程优先级。先进的操作系统可以自动发现文本编辑器是交互性程序，从而自动的完成上述分配动作。Linux操作系统同样追求上述目标，但是它采用不同的方法。它不再通过给文本编辑器分配给定的优先级和时间片，而是分配一个给定的处理器使用比。假如假如文本编辑器和视频解码程序是仅有的两个运行进程，并且又具有相同的nice值，那么处理器的使用比都将是50%–它们平分了处理器时间。但因为文本编辑器将大部分时间用于等待用户输入，因此它肯定不会用到处理器的50%。同时，视频解码程序无疑能够用到超过50%的处理器时间，以便它能更快速地完成解码任务。<br>这里关键的问题是，当文本编辑器被唤醒是将会发生什么。我们首要目标是确保其能在用户输入发生时立刻运行。在上述场景中，一旦文本编辑器被唤醒，CFS注意到给它的处理器时间比是50%，但其实它却用的少之又少。特别是，CFS发现文本编辑器比视频解码器运行的时间要短的多。这种情况下，为了兑现让所有进程公平分享处理器时间的承诺，它会立刻抢占视频解码程序，让文本编辑器程序投入运行。文本编辑器投入运行之后，立即处理了用户的按键输入，有一次进入了休眠等待用户的下一次输入。因为文本编辑器并没有消耗掉承诺给它的50%处理器使用比，因此情况依旧，CFS总毫不犹豫地让文本编辑器在需要时投入运行，而让视频处理程序只能在剩下的时刻运行。</p>
<h1 id="Linux调度算法"><a href="#Linux调度算法" class="headerlink" title="Linux调度算法"></a>Linux调度算法</h1><p>在前面的内容中，我们抽象的讨论了进程调度原理，只是偶尔提及Linux如何把给定的理论应用到实际中。在已有的调度原理基础上，我们进一步探讨具有Linux特色的进程调度程序。</p>
<h2 id="调度器类"><a href="#调度器类" class="headerlink" title="调度器类"></a>调度器类</h2><p>Linux调度器是以模块方式提供的，这样做的目的是允许不同类型的进程可以有针对性的选择调度算法.<br>这种模块化结构被称为调度器类（scheduler classes），它允许多种不同的可动态添加的调度算法并存，调度属于自己范畴的进程。每个调度器都有一个优先级，基础的调度器代码定义在<code>kernel/sched.c</code>中，它会按照优先级顺序遍历调度类，拥有一个可执行进程的最高优先级的调度器类胜出，并选择下面要执行的那一个程序。<br>完全公平调度算法（CFS）是一个针对普通进程的调度类，在Linux中被称为SCHED_NORMAL（在POSIX中被称为SCHED_OTHER），CFS算法算法实现定义在文件<code>kernel/sched_fair.c</code>中。下面我们将重点讨论CFS算法–该内容对于所有2.6.23以后的内核版本意义非凡。</p>
<h2 id="Unix系统中的进程调度"><a href="#Unix系统中的进程调度" class="headerlink" title="Unix系统中的进程调度"></a>Unix系统中的进程调度</h2><p>在讨论CFS算法之前，我们必须认识一下传统Unix系统的进程调度过程。正如前面所述，现代进程调度器有两个通用的概念：进程优先级和时间片。时间片是指进程运行多长时间，进程一旦启动就会有一个默认的时间片。具有更高优先级的进程将运行的更频繁，而且（在多数系统上）也会被赋予更多的时间片。在Unix系统上，优先级以nice值形式输出给用户空间。这点听起来简单，但是在现实中，却会导致很多反常的问题，我们下面具体讨论。<br>第一个问题，若要将nice值映射到时间片，就必然需要将nice单位值对应到处理器的绝对时间。但这样做就会导致进程切换无法最优化进行。举例说明，假定我们将默认nice值（0）分配给一个进程–对应的是一个100ms的时间片：同时再分配一个最高nice值（+20，最低的优先级）给另一个进程–对应的时间片是5ms。我们接着假定上述两个进程都处于可运行状态。那么默认优先级的进程将获得20&#x2F;21（105ms中的100ms）的处理器时间，而低优先级的进程将获得1&#x2F;21（105ms中的5ms）的处理器时间。我们本可以选择任意数值用于此例子中，但这个分配是最具有说服力的，所以我们选择它。现在，我们看看运行两个同等低优先级的进程情况将如何。我们是希望它们能各自获得一半的处理器时间，事实上也确实如此。但是任何一个进程每次仅仅只能获得5ms的处理器时间（10ms中各自占一半）。也就是说，相比刚才例子中的105ms内进行一次进程上下文切换，现在则需要在10ms内继续进行2次进程上下文切换。类推，如果是两个具有普通优先级的进程，它们同样会每个获得50%的处理器时间，但是是在100ms内获得一半。显然，我们看到这种时间片分配方式并不理想：它们是给定nice值到时间片映射与进程运行优先级混合的共同作用结果。事实上，给定高nice值的进程往往是后台进程，且多是计算密集型；而普通优先级的进程则更多是前台用户任务。所以这种时间片分配方式显然是和初衷背道而驰的。<br>第二个问题涉及相对nice值，同时和前面的nice值到时间片映射关系也脱不了干系。假设我们拥有两个进程，分别具有不同的优先级。第一个假设nice值只有0，第二个假设是1。它们将分别被映射到时间片值100ms和95ms（O(1)调度算法确实这么干了）。它们的时间片几乎一样，其差别微乎其微。但是如果我们的进程分别赋予18和19的nice值，那么它们分别被映射到时间片10ms和5ms。如果这样，前者相比后者获得了两倍的处理器时间！不过nice值通常都是用相对值（nice系统调用是在原值上增加或者减小，而不是在绝对值上操作），也就是说：“把进程的nice值减小1”所带来的效果极大的取决于其nice的初始值。<br>第三个问题，如果执行nice值到时间片的映射，我们需要能分配一个绝对时间片，而且这个绝对时间片必须能在内核的测试范围内。在多数操作系统中，上述要求意味着时间片必须是定时器节拍的整数倍。但这么做必然会引发了几个问题。首先，最小时间片必然是定时器节拍的整数倍，也就是10ms或者1ms的倍数。其次，系统定时器限制了两个时间片的差异：连续的nice值映射到时间片，其差别范围多至10ms或者少至1ms。最后，时间片还会随着定时器节拍改变。<br>第四个问题也是最后一个问题是关于基于优先级的调度器为了优化交互任务而唤醒相关进程的问题。这种系统中，你可能为了进程能更快的投入运行，而去对新要唤醒的进程提升优先级，即便它们的时间片已经用尽了。虽然上述方法确实能提升不少交互性能，但是一些例外情况也有可能发生，因为它同时也给某些特殊的睡眠&#x2F;唤醒用例一个玩弄调度器的后门，使得给定进程打破公平原则，获得更多的处理器时间，损害系统中其他进程的利益。<br>上述问题中的绝大多数都可以通过对传统Unix调度器进行改造解决，虽然这种改造不小，但也并非是结构性调整。比如，将nice值呈几何增加而非算数增加的方式解决第二个问题；采用一个新的度量机制将从nice值到时间片的映射与定时器节拍分离开来，以此解决第三个问题。但是这些解决方案都回避了实质问题–即分配绝对的时间片引发的固定的切换频率，给公平性造成了很大变数。CFS采用的方法是对时间片的分配方式进行根本性的重新设计：完全摒弃时间片而是给进程一个处理器使用比重。通过这种方式，CFS确保了进程调度中能有恒定的公平性，而将切换频率至于不断变换中。</p>
<h2 id="公平调度"><a href="#公平调度" class="headerlink" title="公平调度"></a>公平调度</h2><p>CFS的出发点基于一个简单的理念：进程调度的效果应当如同系统中具备了一个理想中的完美多任务处理器。在这种系统中，每个进程都将获得1&#x2F;n的处理器时间–n是指可运行进程的数量。同时，我们可以调度调度给它们无限小的时间周期，所以在任何可测量周期中，我们给与n个进程中每个进程同样多的运行时间。举例来说，假如我们有两个可运行进程。在标准Unix调度模型中，我们先运行其中一个5ms，再运行另一个5ms。但它们任何一个运行时都将占有100%的处理器。而在理想情况下，完美的多任务处理器模型应该时这样的：我们能在10ms内同时运行两个进程，它们各自使用处理器一半的能力。<br>当然，上述理想模型并非现实，因为我们无法真的在同一个处理器上同时运行多个进程。而且每个进程运行无限小的时间周期也是不高效的–因为调度时进程抢占会带来一定的代价：将一个进程换出，另一个换入本身有消耗，同时还会影响到缓存的效率。因此虽然我们希望所有的进程能只运行一个非常短的周期，但是CFS充分考虑了这将带来的额外消耗，实现中首要保证系统性能不受损失。CFS的做法是允许每一个进程运行一段时间、循环轮转、选择运行时间最少的进程作为下一个运行进程，而不再采用分配给每个进程时间片的做法了，CFS在所有可运行进程总数基础上计算出一个进程一个运行多久，而不是依靠nice值来计算时间片。nice值在CFS中被作为进程获得的处理器运行比的权重：越高的nice值（越低的优先级）进程获得更低的处理器使用权重，这是相对默认nice值进程的进程而言；相反，更低的nice值（越高的优先级）的进程获得更高的处理器使用权重。<br>每个进程都按其权重在全部可运行进程中所占比例的“时间片”来运行，为了计算准确的时间片，CFS为完美任务中的无限小调度周期的近似值设立了一个小目标。而这个目标称作目标延迟，越小的调度周期将带来越好的交互性，同时也更接近完美的多任务。但是你必须承受更高的切换代价和更差的系统吞吐总能力。让我们假定目标延时值是20ms，我们有两个同样优先级的可运行任务（无论这些任务的优先级是多少）。每个任务在被其他任务抢占之前运行10ms，如果我们有4个这样的任务，则每个只能运行5ms。进一步设想，如果有20个这样的任务，那么每个仅仅只能获得1ms的运行时间。<br>你一定注意到了，当可运行任务数量趋于无限时，它们各自所获得的处理器使用比和时间片都将趋于零。这样无疑造成了不可接受的切换消耗。CFS为此引入每个进程所获得的时间片底线，这个底线称为最小粒度。默认情况下这个值时1ms。这样一来，即便可运行进程的数量趋于无限，也能保证每个进程最少获得1ms的可运行时间。确保切换消耗被限制在一定的范围内。<br><strong>假如进程数量变得非常多的情况下，CFS并非一个完美的公平调度，因为这时处理器时间时间片再小也无法突破最小粒度。尽管修改过的公平队列方法确实能够提高这方面的公平性，但是CFS的算法本身其实已经决定在这方面做折中了。但是还好，因为通常情况下系统中只会有几百个可运行的进程，无疑，这时的CFS是公平的。</strong><br>现在，让我们再来看看具有不同的nice值的两个可运行进程的运行情况–比如一个具有默认nice值（0），另一个具有的nice值为5。这些不同的人nice值对应不同的权重，所以上述两个进程都将获得不同的处理器使用比。在这个例子中，nice值为5的进程的权重将是nice值为0的进程的1&#x2F;3。如果我们的目标延迟是20ms，那么这两个进程将分别获得15ms和5ms的处理器时间。再比如我们两个可运行进程的nice值是10和15，它们分配的时间片将会是多少呢？还是15ms和5ms！可见，绝对的nice值不再影响调度决策：只有相对值才会影响处理器时间的分配比例。<br>总结一下，任何进程所获得处理器时间是由它自己和其他可运行的进程的nice值的相对值差所决定的。nice值对时间片的作用不再是算术加权，而是几何加权。任何nice值对应的绝对时间不再是一个绝对值，而是处理器使用比。CFS被称为公平调度器是因为它确保给每个进程公平的处理器使用比。正如我们所知道的，CFS不是完美的公平，它只是近乎完美的多任务。但是它确实在多进程环境下，降低了调度延迟带来的不公平性。</p>
<h1 id="Linux调度的实现"><a href="#Linux调度的实现" class="headerlink" title="Linux调度的实现"></a>Linux调度的实现</h1><p>在讨论了采用CFS调度算法的动机和内部逻辑之后，我们现在可以开始探索CFS是如何得以实现的。其代码位于<code>kernel/sched_fair.c</code>中，我们将特别关注以下四部分：</p>
<ol>
<li>时间进账</li>
<li>进程选择</li>
<li>调度器入口</li>
<li>睡眠和唤醒</li>
</ol>
<h2 id="时间进账"><a href="#时间进账" class="headerlink" title="时间进账"></a>时间进账</h2><p>所有的调度器都必须对进程运行时间做记账。多数Unix系统，正如我们前面所述，分配一个时间片给每一个进程。那么每次当系统节拍发生时，时间片都会减少一个节拍周期。当一个进程的时间片被减少到0时，它就会被另一个尚未减少为0的时间片可运行进程抢占。</p>
<h3 id="调度器实体结构"><a href="#调度器实体结构" class="headerlink" title="调度器实体结构"></a>调度器实体结构</h3><p>CFS不再有时间片的概念，但是它也必须维护每个进程运行的时间记账，因为它需要确保每个进程只在公平分配给它的处理器时间内运行。CFS使用调度器实体结构（定义在文件&lt;linux&#x2F;sched.h&gt;的struct_sched_entity中）来追踪进程运行记账：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">load_wieght</span>  <span class="title">load</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span>      <span class="title">run_node</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">group_node</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        on_rq;</span><br><span class="line">    u64                 exec_start;</span><br><span class="line">    u64                 sum_exec_runtime;</span><br><span class="line">    u64                 vruntime;</span><br><span class="line">    u64                 prev_sum_exec_runtime;</span><br><span class="line">    u64                 last_wakeup;</span><br><span class="line">    u64                 avg_overlap;</span><br><span class="line">    u64                 nr_migrations;</span><br><span class="line">    u64                 start_runtime;</span><br><span class="line">    u64                 avg_wakeup;</span><br><span class="line">    <span class="comment">//这里省略了很多统计变量，只有在设置了CONFIG_SCHEDSTATS时才启用这些变量</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>调度器实体结构作为一个名为se的成员变量，嵌入在进程描述符struct task_struct内。</p>
<h3 id="虚拟实时"><a href="#虚拟实时" class="headerlink" title="虚拟实时"></a>虚拟实时</h3><p>vruntime变量存放进程的虚拟运行时间，该运行时间（花在运行上的时间和）的计算是经过了所有可运行进程总数的标准化（或者说是被加权的）。虚拟时间是以ns为单位的，所以vruntime不再与定时器节拍有关系。虚拟运行时间可以帮助我们逼近CFS模型追求的“理想多任务处理器”。如果我们真有这样一个理想的处理器，那么我们就不再需要vruntime了。因为优先级相同的所有可运行进程的虚拟运行时间都是相同的–所有任务都将接收到相等的处理器份额。但是因为处理器无法实现完美的多任务。它们必须依次运行每个任务。因此CFS使用vruntime变量来记录一个进程已经运行了多久以及它还能再运行多久。<br>定义在<code>kernel/sched_fair.c</code>文件中的update_curr()函数实现了该记账功能：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">update_curr</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">curr</span> =</span> cfs_rq-&gt;curr;</span><br><span class="line">    u64 now = rq_of(cfs_rq)-&gt;clock;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> delta_exec;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(unlikely(!curr))</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="comment">//获得最后一次修改负载后当前任务所占用的运行总时间（在32位系统上这不会溢出）</span></span><br><span class="line">    delta_exec = (<span class="type">unsigned</span> <span class="type">long</span>)(now - curr-&gt;exec_start);</span><br><span class="line">    <span class="keyword">if</span>(!delta_exec)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    __update_curr(cfs_rq,curr,delta_exec);</span><br><span class="line">    curr-&gt;exec_start = now;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(entity_is_task(curr)) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">curtask</span> =</span> task_of(curr);</span><br><span class="line">        trace_sched_stat_runtime(curtask,delta_exec,curr-&gt;vruntime);</span><br><span class="line">        cpuacct_charge(curtask,delta_exec);</span><br><span class="line">        account_group_exec_runtime(curtask,delta_task);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update_curr()计算了当前进程的执行时间，并且将其存放在变量delta_exec中。然后它又将运行时间传递给了__update_curr()，由后者再根据当前可运行进程总数对运行时间进行加权运算。最终将上述的权重值与当前运行进程的vruntime相加。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//更新当前任务的运行时统计数据。跳过不在调度类中的当前任务</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span></span><br><span class="line">__update_curr(<span class="keyword">struct</span> cfs_rq *cfs_rq, <span class="keyword">struct</span> sched_entity *curr,</span><br><span class="line">              <span class="type">unsigned</span> <span class="type">long</span> delta_exec)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> delta_exec_weighted;</span><br><span class="line"></span><br><span class="line">    schedstat_set(curr-&gt;exec_max,max((u64)delta_exec,curr-&gt;exec_max));</span><br><span class="line"></span><br><span class="line">    curr-&gt;sum_exec_runtime += delta_exec;</span><br><span class="line">    schedstat_add(cfs_rq,exec_clock,delta_exec);</span><br><span class="line">    delta_exec_weighted = calc_delta_fair(delta_exec,curr);</span><br><span class="line"></span><br><span class="line">    curr-&gt;vruntime += delta_exec_weighted;</span><br><span class="line">    update_min_vruntime(cfs_rq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>update_curr()是由系统定时器周期性调用的，无论是在进程处于可运行状态，还是被堵塞处于不可运行状态。根据这种方式，vruntime可以准确的测量给定的运行时间，而且可以知道谁应该是下一个被运行的进程。</p>
<h2 id="进程选择"><a href="#进程选择" class="headerlink" title="进程选择"></a>进程选择</h2><p>在前面内容中我们的讨论中谈到若存在一个完美的多任务处理器，所有可运行进程的vruntime值将一致。但是实际上我们并没有找到完美的多任务处理器，因此CFS试图利用一个简单的规则去均衡进程的虚拟运行时间：当CFS需要选择下一个运行进程时，它会挑一个具有最小vruntime的进程。这其实就是CFS调度算法的核心：选择具有最小vruntime的任务。那么剩下的内容我们就来讨论到底是如何实现选择具有最小vruntime值的进程。<br>CFS使用红黑树来组织可运行进程队列，并利用其迅速找到vruntime最小的进程。在Linux中，红黑树被称为rbtree，它是一个自平衡二叉搜索树。红黑树是一种以树形节点存储的数据结构，这些数据都会对应一个键值。我们可以通过这些键值来快速检索节点上的数据（重要的是，通过键值检索到对应节点的速度与整个树的节点规模成指数比关系）。</p>
<h3 id="挑选下一个任务"><a href="#挑选下一个任务" class="headerlink" title="挑选下一个任务"></a>挑选下一个任务</h3><p>我们先假设，有那么一个红黑树存储了系统中所有的可运行进程，其中节点的键值便是可运行进程的虚拟运行时间。CFS调度器选取待运行的下一个进程，是所有进程中vruntime最小的那个，它对应的便是在树中最左侧的叶子节点。也就是说，你从树的根节点沿着左边的子节点向下找，一直找到叶子节点，你便找到了其vruntime最小的那个进程。CFS的进程选择算法可简单总结为“运行rbtree树中最左边叶子节点所代表的那个进程”。实现这一过程的函数是__pick_next_entuty()，它定义在文件<code>kernel/sched_fail.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *__<span class="title">pick_next_entity</span>(<span class="keyword">struct</span> <span class="title">cfs_rq</span> *<span class="title">cfs_rq</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">left</span> =</span> cfs_rq-&gt;rb_leftmost;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(!left)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> rb_entity(left,<span class="keyword">struct</span> sched_entity, run_code);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>注意</strong><br><em>__pick_next_entity()函数本身并不会遍历树找到最左叶子节点，因为该值已经缓存在rb_leftmost字段中。虽然红黑树让我们可以很有效的找到最左叶子节点（O（树的高度）等于树节点总数的O（logn），这就是平衡树的优势），但是更容易的做法是把最左叶子节点缓存起来。这个函数的返回值便是CFS调度选择的下一个运行进程。如果该函数的返回值是NULL，那么表示没有最左叶子节点，也就是说树中没有任何节点了。这种情况下，表示没有可运行的进程，CFS调度器便选择idle任务运行。</em></p>
<h3 id="向树中加入进程"><a href="#向树中加入进程" class="headerlink" title="向树中加入进程"></a>向树中加入进程</h3><p>现在，我们来看CFS如何将进程加入rbtree中，以及如何缓存最左叶子节点。这一切发生在进程变成可运行状态（被唤醒）或者通过fork()调用第一次创建进程时。enqueue_entity()函数实现了它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">enqueue_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq,<span class="keyword">struct</span> sched_entity *se,<span class="type">int</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//通过调用update_curr()，在更新min_vruntime之前先更新规范的vruntime</span></span><br><span class="line">    <span class="keyword">if</span>(!(flags &amp; ENQUEUE_WAKEUP) || (flags &amp; ENQUEUE_MIGRATE))</span><br><span class="line">        se-&gt;vruntime += cfs_rq-&gt;min_vruntime;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//更新“当前任务”的运行时统计数据</span></span><br><span class="line">    update_curr(cfs_rq);</span><br><span class="line">    account_entity_enqueue(cfs_rq,se);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(flags &amp; ENQUEUE_WAKEUP) &#123;</span><br><span class="line">        place_entity(cfs_rq,se,<span class="number">0</span>);</span><br><span class="line">        enqueue_sleeper(cfs_rq,se);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    update_stats_enqueue(cfs_rq,se);</span><br><span class="line">    check_spread(cfs_rq,se);</span><br><span class="line">    <span class="keyword">if</span>(se != cfs_rq-&gt;curr)</span><br><span class="line">        __enqueue_entity(cfs_rq,se);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数更新运行时间和其他一些统计数据，然后调用__enqueue_entity()进行繁重的插入操作，把数据项真正的插入到红黑树中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//把一个调度实体插入到红黑树中</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> __enqueue_entity(<span class="keyword">struct</span> cfs_rq *cfs_rq,<span class="keyword">struct</span> sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> **<span class="title">link</span> =</span> &amp;cfs_rq-&gt;tasks_timeline.rb_node;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">parent</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sched_entity</span> *<span class="title">entry</span>;</span></span><br><span class="line">    s64 key = entity_key(cfs_rq,se);</span><br><span class="line">    <span class="type">int</span> leftmode = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在红黑树中查找合适的位置</span></span><br><span class="line">    <span class="keyword">while</span>(*link) &#123;</span><br><span class="line">        parent = *link;</span><br><span class="line">        entry = rb_entry(parent,<span class="keyword">struct</span> sched_entity,run_code);</span><br><span class="line">        <span class="comment">//我们不关心冲突。具有相同键值的节点呆在一起</span></span><br><span class="line">        <span class="keyword">if</span>(key &lt; entity_key(cfs_rq,entry)) &#123;</span><br><span class="line">            link = &amp;parent-&gt;rb_left;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            link = &amp;parent-&gt;rb_right;</span><br><span class="line">            leftmost = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//维护一个缓存，其中存放树最左叶子节点</span></span><br><span class="line">    <span class="keyword">if</span>(leftmost) </span><br><span class="line">        cfs_rq-&gt;rb_leftmost = &amp;se-&gt;run_code;</span><br><span class="line"></span><br><span class="line">    rb_link_code(&amp;se-&gt;run_code,parent,link);</span><br><span class="line">    rb_insert_color(&amp;se-&gt;run_code,&amp;cfs_rq-&gt;task_timeline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们来看看上述函数，while()循环中遍历树以寻找合适的匹配键值，该值就是被插入到进程的vruntime。平衡二叉树的基本规则是，如果键值小于当前节点的键值，则需转入树的左分支；相反，如果大于当前节点的键值，则转向右分支。如果一旦走过右边分支，哪怕一次，也说明新插入的进程不会是新的最左节点，因此可以设置leftmost为0。如果一直都是向左移动，那么leftmost维持1，这说明我们有一个新的最左节点，并且可以更新缓存–设置rb_leftmost指向被插入的进程。当我们沿着一个方向和一个没有子节点的节点比较后：link如果这时候是NULL，循环随之终止。当退出循环后，接着在父节点上调用rb_link_node(),以使得新插入的进程成为其子节点。最后函数rb_insert_color()更新树的自平衡相关属性。</p>
<h3 id="从树中删除进程"><a href="#从树中删除进程" class="headerlink" title="从树中删除进程"></a>从树中删除进程</h3><p>最后我们看看CFS是如何从红黑树中删除进程的。删除动作发生在进程堵塞（变为不可运行状态）或终止时（结束运行）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span></span><br><span class="line"><span class="title function_">dequeue_entity</span><span class="params">(<span class="keyword">struct</span> cfs_rq *cfs_rq,<span class="keyword">struct</span> sched_entity *se,<span class="type">int</span> sleep)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//更新“当前任务”的运行时统计数据</span></span><br><span class="line">    update_curr(cfs_rq);</span><br><span class="line"></span><br><span class="line">    update_stats_dequeue(cfs_rq,se);</span><br><span class="line">    clear_buddies(cfs_rq,se);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(se != cfs_rq-&gt;curr)</span><br><span class="line">        __dequeue_entity(cfs_rq,se);</span><br><span class="line">    account_entity_dequeue(cfs_rq,se);</span><br><span class="line">    update_min_vruntime(cfs_rq);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在更新min_vruntime之后对调度实体进行规范化，因为更新可以指向“-&gt;curr”项，我们需要在规范化的位置反映这一变化</span></span><br><span class="line">    <span class="keyword">if</span>(!sleep)</span><br><span class="line">        se-&gt;vruntime -= cfs_rq-&gt;min_vruntime;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>和给红黑树添加进程一样，实际工作是由辅助函数__dequeue_entity()完成的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __dequeue_entity(<span class="keyword">struct</span> cfs_rq *cfs_rq,<span class="keyword">struct</span> sched_entity *se)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(cfs_rq-&gt;rb_leftmost == &amp;se-&gt;run_code) &#123;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">next_node</span>;</span></span><br><span class="line"></span><br><span class="line">        next_node = rb_next(&amp;se-&gt;run_node);</span><br><span class="line">        cfs_rq-&gt;rb_leftmost = next_node;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rb_erase(&amp;se-&gt;run_node,&amp;cfs_rq-&gt;tasks_timeline);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从红黑树中删除进程要容易得多。因为rbtree实现了rb_erase()函数，它可完成所有工作。该函数的剩下工作就是更新rb_leftmost缓存。如果要删除的是最左节点，那么该函数要调用rb_next()按顺序遍历，这道谁是下一个节点，也就是当最左节点被删除后，新的最左节点。</p>
<h3 id="调度器入口"><a href="#调度器入口" class="headerlink" title="调度器入口"></a>调度器入口</h3><p>进程调度的主要入口点是函数schedule()，它定义在文件<code>kernel/sched.c</code>中。它正是内核其他部分用于调度进程调度器的入口：选择哪个进程可以运行，何时将其投入运行。schedule()通常都需要和一个具体的调度类相关联，也就是说，它会找到一个最高优先级的调度类–后者需要有自己的可运行队列，然后问后者谁是下一个该运行的进程。知道了这个背景，就不会吃惊为什么schedule()函数会实现的如此简单。该函数中唯一重要的事情是，它会调用pick_next_task()（也是定义在文件<code>kernel/sched.c</code>中）。<code>pick_next_task()会以优先级为序，从高到低，依次检查每一个调度类，并且从最高优先级的调度类中，选择最该优先级的进程：</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//挑选最高优先级的任务</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> task_struct *<span class="title function_">pick_next_task</span><span class="params">(<span class="keyword">struct</span> rq *rq)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">sched_class</span> *<span class="keyword">class</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//优化：我们知道如果所有任务都在公平类中，那么我们就可以直接调用那个函数</span></span><br><span class="line">    <span class="keyword">if</span>(likely(rq-&gt;nr_running == rq-&gt;cfs.nr_running)) &#123;</span><br><span class="line">        p = fair_sched_class.pick_next_task(rq);</span><br><span class="line">        <span class="keyword">if</span>(likely(p))</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> =</span> sched_class_highest;</span><br><span class="line">    <span class="keyword">for</span>(;;) &#123;</span><br><span class="line">        p = class-&gt;pick_next_task(rq);</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        <span class="comment">//永不会为NULL，因为idel类总会返回非NULL的p</span></span><br><span class="line">        <span class="class"><span class="keyword">class</span> =</span> <span class="class"><span class="keyword">class</span>-&gt;</span>next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意该函数开始部分的优化。因为CFS是普通进程的调度类，而系统运行的绝大多数进程都是普通进程，因此这里有一个小技巧用来加速选择下一个CFS提供的进程，前提是所有可运行进程数量等于CFS类对应的可运行进程数（这样就说明所有可运行进程都是CFS类的）。<br>该函数的核心是for循环，它以优先级为序，从最高的优先级类开始，遍历了每一个调度类，每一个调度类都实现了pick_next_task()函数，它会返回指向下一个可运行进程的指针，或者没有时返回NULL。我们会从第一个返回非NULL的类中选择下一个可运行的进程。CFS中pick_next_task()实现会调用pick_next_entity()，而该函数会再来调用我们前面内容讨论过的__pick_next_entity()函数。</p>
<h2 id="睡眠和唤醒"><a href="#睡眠和唤醒" class="headerlink" title="睡眠和唤醒"></a>睡眠和唤醒</h2><p>休眠（被阻塞）的进程处于一个特殊的不可执行状态。这点非常重要，如果没有这种特殊状态的话，调度程序就可能选择出本不愿意被执行的进程，更糟糕的是，休眠就必须以轮询的方式进行了。进程休眠有多种原因，但肯定就是为了等待一些事件。事件可能是一段时间从文件I&#x2F;O读更多数据，或者某个硬件事件。一个进程还有可能在尝试获取一个以被占用的内核信号量时被迫进入休眠。休眠的一个常见原因就是文件I&#x2F;O–如一个进程对文件进行read()操作，而这需要从磁盘读取。还有，进程在获取键盘输入的时候也需要等待。<code>无论哪种情况，内核的操作都相同：进程把自己标记成休眠状态，从可执行红黑树中移出，放入等待队列，然后调用schedule()选择和执行一个其他进程</code>。唤醒的过程刚好相反：进程被设置成可执行状态，然后再从等待队列中移到可执行红黑树中。<br>第3章有讨论过，休眠有两种相关的进程状态：TASK_INTERRUPTIBLE和TASK_UNINTERRUPTIBLE。他们的唯一区别是处于TASK_UNINTERRUPTIBLE的进程会忽略信号，而处于TASK_INTERRUPTIBLE状态的进程如果接收到一个信号，会被提前唤醒并响应该信号。两种状态的进程处于同一等待队列上，等到某些事件，不能够运行。</p>
<h3 id="等待队列"><a href="#等待队列" class="headerlink" title="等待队列"></a>等待队列</h3><p>休眠通过等待队列进行处理。等待队列是由某些等待事件发生的进程组成的简单链表。内核用wake_queue_head_t来代表等待队列。等待队列可以通过DECLARE_WAITQUEUE()静态创建，也可以由init_waitqueue_head()动态创建。进程把自己放入等待队列中并设置从不可执行状态。当与等待队列相关的事件发生时，队列上的进程会被唤醒。为避免产生竞争条件，休眠与唤醒的实现不能有纰漏。<br>针对休眠，以前曾经使用过一些简单的接口。但那些接口会带来竞争条件：有可能导致在判定条件为真后，进程却开始了休眠，那样就会使进程无限期休眠下去。所以，在内核中进行休眠的推荐操作就相对复杂一些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//&#x27;q&#x27;是我们希望休眠的等待队列</span></span><br><span class="line">DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line">add_wait_queue(q,&amp;wait);</span><br><span class="line"><span class="keyword">while</span>(!condition) &#123; <span class="comment">//&#x27;condition&#x27;是我们在等待的事件</span></span><br><span class="line">    prepare_to_wait(&amp;q,&amp;wait,TASK_INTERRUPTIBLE);</span><br><span class="line">    <span class="keyword">if</span>(signal_pending(current))<span class="comment">//处理信号</span></span><br><span class="line">        schedule();</span><br><span class="line">&#125;</span><br><span class="line">finish_wait(&amp;q,&amp;wait);</span><br></pre></td></tr></table></figure>
<p>进程通过执行以下几个步骤让自己加入等待队列中：</p>
<ol>
<li>调用宏DEFINE_WAIT()创建一个等待队列的项。</li>
<li>调用add_wait_queue()把自己加入到队列中。该队列会在进程等待的条件满足时唤醒它。当然我们必须在其他地方撰写相关代码，在事件发生时，对等待队列进行wake_up()操作。</li>
<li>调用prepare_to_wait()方法将进程的状态变更为TASK_INTERRUPTIBLE或TASK_UNINTERRUPTIBLE。而且该函数如果有必要的话会将进程加回到等待队列。这是在接下来的循环遍历中需要的。</li>
<li>如果状态被设置为TASK_INTERRUPTIBLE，则信号唤醒进程。这就是所谓的伪唤醒（唤醒不是因为事件的发生），因此检查并处理信号。</li>
<li>当进程被唤醒的时候，它会再次检查条件是否为真。如果是，它就退出循环；如果不是，它再次调用schedule()并一直重复这步操作。</li>
<li>当条件满足后，进程将自己设置为TASK_RUNNING并调用finish_wait()方法把自己移出等待队列。</li>
</ol>
<p>如果在进程开始休眠之前条件就已经达成，那么循环会退出，进程不会存在错误的进入休眠的倾向。需要注意的是，内核代码在循环体内常常需要完成一些其他任务，比如，它可能在调用schedule()之前需要释放掉锁，而在这以后在重新获取它们，或者响应其他事件。<br>函数inotify_read()，位于文件<code>fs/notify/inotify_user.c</code>中，负责从通知文件描述符中读取信息，它的实现无疑是等待队列的一个典型用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">ssize_t</span> <span class="title function_">inotify_read</span><span class="params">(<span class="keyword">struct</span> file *file,<span class="type">char</span> __user *buf,</span></span><br><span class="line"><span class="params">                            <span class="type">size_t</span>  count,<span class="type">loff_t</span> *pos)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_group</span> *<span class="title">group</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fsnotify_event</span> *<span class="title">kevent</span>;</span></span><br><span class="line">    <span class="type">char</span> __user *start;</span><br><span class="line">    <span class="type">int</span> ret;</span><br><span class="line">    DEFINE_WAIT(wait);</span><br><span class="line"></span><br><span class="line">    start = buf;</span><br><span class="line">    group = file-&gt;private_data;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>) &#123;</span><br><span class="line">        prepare_to_wait(&amp;group-&gt;notification_waitq,</span><br><span class="line">                        &amp;wait,</span><br><span class="line">                        TASK_INTERRUPTIBLE);</span><br><span class="line">        mutex_lock(&amp;group-&gt;notification_mutex);</span><br><span class="line">        kevent = geet_one_event(group,event);</span><br><span class="line">        mutex_unlock(&amp;group-&gt;notification_mutex);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(kevent) &#123;</span><br><span class="line">            ret = PTR_ERR(kevent);</span><br><span class="line">            <span class="keyword">if</span>(IS_ERR(kevent))</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            ret = copy_event_to_user(group,kevent,buf);</span><br><span class="line">            fsnotify_put_event(kevent);</span><br><span class="line">            <span class="keyword">if</span>(ret &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            buf += ret;</span><br><span class="line">            count -= ret;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ret = -EAGAIN;</span><br><span class="line">        <span class="keyword">if</span>(file-&gt;f_flags &amp; O_NONBLOCK)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        ret = -EINTR;</span><br><span class="line">        <span class="keyword">if</span>(signal_pending(current))</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(start != buf)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        </span><br><span class="line">        schedule();</span><br><span class="line">    &#125;</span><br><span class="line">    finish_wait(&amp;group-&gt;notification_waitq,&amp;wait);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(start != buf &amp;&amp; ret != -EFAULT)</span><br><span class="line">        ret = buf - start;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数遵循了我们例子中的使用模式，主要的区别是它在while循环中检查了状态，而不是在while循环条件语句中。原因是该条件的检测更复杂一些，并且需要获得锁。也正因为如此，循环是通过break完成的。</p>
<h3 id="唤醒"><a href="#唤醒" class="headerlink" title="唤醒"></a>唤醒</h3><p>唤醒操作通过函数wake_up()进行，它会唤醒指定的等待队列上的所有进程。它调用函数try_to_wake_up()，该函数将进程设置为TASK_RUNNING状态，调用enqueue_task()将进程放进红黑树中，如果被唤醒的进程的优先级比当前正在执行的进程的优先级高，还要设置need_resched标志。通常哪段代码促使等待条件达成，它就要负责随后调用wake_up()函数。举例来说，当磁盘数据到来时，VFS就要负责对等待队列调用wake_up()，以便唤醒队列中等待这些数据的进程。<br>关于休眠有一点需要注意，存在虚假的唤醒。有时候进程被唤醒并不是因为它所等待的条件达成了才需要用一个循环处理来保证它等待的条件真正达成。</p>
<h1 id="抢占和上下文切换"><a href="#抢占和上下文切换" class="headerlink" title="抢占和上下文切换"></a>抢占和上下文切换</h1><p>上下文切换，也就是从一个可执行进程切换到另一个可执行进程，由定义在<code>kernel/sched.c</code>中的context_switch()函数负责处理。每当一个新的进程被选出来准备投入运行的时候，schedule()就会调用该函数。它完成了两项基本的工作：</p>
<ol>
<li>调用声明在<code>&lt;asm/mmu_context.h&gt;</code>中的switch_mm()，该函数负责把虚拟内存从上一个进程映射切换到新进程中。</li>
<li>调用声明在<code>&lt;asm/system.h&gt;</code>中的switch_to()，该函数负责从上一个进程的处理器状态切换到新进程的处理器状态。这包括保存、恢复栈信息和寄存器信息，还有其他任何与体系结构相关的状态信息，都必须以每个进程为对象进行管理和保存。<br><img src="/2022/10/28/%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6/1.jpeg" alt="img not found"><br>内核必须知道在什么时候调用schedule()。如果仅靠用户程序代码显式地调用schedule()，它们可能就会永远的执行下去。相反，内核提供了一个need_resched标志来表明是否需要重新执行一次调度。当某个进程应该被抢占时，schedule_tick()就会设置这个标志；当一个优先级高的进程进入可执行状态时，try_to_wake_up()也会设置这个标志，内核检查该标志，确认其被设置，调用schedule()来切换到一个新的进程。该标志对内核来说是一个信息，它表示有其他进程应当被运行了，要尽快调用调度程序。<br><strong>用于访问和操作的need_resched的函数</strong><table>
<thead>
<tr>
<th>函数</th>
<th>目的</th>
</tr>
</thead>
<tbody><tr>
<td>set_tsk_need_resched()</td>
<td>设置指定进程中的need_resched标志</td>
</tr>
<tr>
<td>clear_tsk_need_resched()</td>
<td>清除指定进程中的need_resched标志</td>
</tr>
<tr>
<td>need_resched()</td>
<td>检查need_resched标志的值，如果被设置就返回真，否则返回假</td>
</tr>
</tbody></table>
</li>
</ol>
<p>在返回用户空间以及从中断返回的时候，内核也会检查need_resched标志。如果已被设置，内核会在继续执行之前调用调度程序。<br><code>每个进程都包含一个need_resched标志，这是因为访问进程描述符内的数值要比访问一个全局变量快（因为current宏速度很快并且描述符通常都在高速缓存中）</code>。在2.2以前的内核版本中，该标志曾经是一个全局变量。2.2到2.4版内核中它在task_struct中。而在2.6版本中，它被移到thread_info结构体里，用一个特别的标志变量中的一位来表示。</p>
<h2 id="用户抢占"><a href="#用户抢占" class="headerlink" title="用户抢占"></a>用户抢占</h2><p>内核即将返回用户空间的时候，如果need_resched标志被设置，会导致schedule()被调用，此时就会发生用户抢占。在内核返回用户空间的时候，它知道自己是安全的，因为既然它可以继续去执行当前进程，那么它当然可以再去选择一个新的进程去执行。所以，内核无论是在中断处理程序还是系统调用后返回，都会检查need_resched标志。如果它被设置了，那么，内核会选择一个其他的进程投入运行。从中断处理程序或者系统调用返回的返回路径都是更体系结构相关的，在entry.S（此文件不仅包含内核入口部分的程序，内核退出部分的相关代码也在其中）文件中通过汇编语言来实现。<br>简而言之，用户抢占在以下情况时产生：</p>
<ol>
<li>从系统调用返回用户空间时。</li>
<li>从中断处理程序返回用户空间时。</li>
</ol>
<h2 id="内核抢占"><a href="#内核抢占" class="headerlink" title="内核抢占"></a>内核抢占</h2><p>与其他大部分的Unix变体喝其他大部分的操作系统不同，Linux完整地支持内核抢占。在不支持内核抢占的其他内核中，内核代码可以一直执行，到它完成为止。也就是说，调度程序没有办法办法在一个内核级的任务正在执行地时候重新调度–内核中的各任务是以协作方式调度的，不具备抢占性。内核代码一直要执行到完成（返回用户空间）或明显的阻塞为止。在2.6版的内核中，内核引入了抢占内力；现在，只要重新调度是安全的，内核就可以在任何时刻抢占正在执行的任务。<br>那么，什么时候重新调度才是安全的呢？只要没有持有锁，内核就可以进行抢占。锁是非抢占区域的标志。由于内核是支持SMP的，所以，如果没有持有锁，正在执行的代码就是可以重新导入的，也就是可以抢占的。<br>为了支持内核抢占所做的第一处变动，就是为每一个进程的thread_info引入preempt_count计数器。该计数器初始值为0，每当使用锁的时候数值加1，释放锁的时候数值减1。当数值为0时，内核就可以抢占。从中断返回内核空间的时候，内核会检查need_resched和preempt_count的值。如果need_resched被设置，并且preempt_count为0的话，这说明有一个更为重要的任务需要执行且可以安全的抢占，此时，调度程序就会被调用。如果preempt_count不为0，说明当前任务持有锁，所以抢占是不安全的。这时，内核就会像通常那样直接从中断返回当前执行进程。如果当前进程持有的所有的锁都被释放了，preempt_count就会重新为0。此时，释放锁的代码会检查need_resched是否被设置。如果是的话，就会调用调度程序。有些内核代码需要允许或禁止内核抢占。<br>如果内核中的进程内阻塞了，或它显式的调用了schedule()，内核抢占也会显式地发生。这种形式的内核抢占从来都是受支持的，因为根本无须额外的逻辑来保证内核可以安全地被抢占。如果代码显式地调用了schedule()，那么它应该清楚自己是可以安全地被抢占的。<br>内核抢占发生在：</p>
<ol>
<li>中断处理程序正在执行，且返回内核空间之前。</li>
<li>内核代码再一次具有可抢占性的时候。</li>
<li>如果内核中的任务显式地调用schedule()。</li>
<li>如果内核中的任务阻塞（这样同样会导致调用schedule()）。</li>
</ol>
<h1 id="实时调度策略"><a href="#实时调度策略" class="headerlink" title="实时调度策略"></a>实时调度策略</h1><p>Linux提供了两种实时调度策略：SCHED_FIFO和SCHED_RR。而普通的、非实时的调度策略是SCHED_NORMAL。借助调度类的框架，这些实时策略并不被完全公平调度器来管理，而是被一个特殊的实时调度器来管理。具体的实现定义在文件<code>kernel/sched_rt.c</code>中，在接下来的内容中我们将讨论实时调度策略和算法。<br>SCHED_FIFO实现了一种简单的、先入先出的调度算法：它不使用时间片。处于可运行状态的SCHED_FIFO级的进程会比任何SCHED_NORMAL级的进程都先得到调度。一旦一个SCHED_FIFO级进程处于可执行状态，就会一直执行，直到它自己受阻塞或显式地释放处理器为止；它不基于时间片，可以一直执行下去。只有更高优先级的SCHED_FIFO或者SCHED_RR任务才能抢占SCHED_FIFO任务。如果有两个或者更多的同优先级的SCHED_FIFO级进程，它们会轮流执行，但是依然只有在它们愿意让出处理器的时候才会退出。只要有SCHED_FIFO级进程在执行，其他级别较低的进程就只能等待它变为不可运行态后才有机会运行。<br>SCHED_RR与SCHED_FIFO大体相同，只是SCHED_RR级的进程在耗尽事先分配给它的时间后就不能再继续执行了。也就是说。SCHED_RR是带有时间片的SCHED_FIFO–这是一种实时轮流调度算法。当SCHED_RR任务耗尽它的时间片时，在同一优先级的其他实时进程被轮流调度。时间片只用来调度同一优先级的进程。对于SCHED_FIFO进程，高优先级总是立即抢占低优先级，但低优先级进程绝不能抢占SCHED_RR任务，即使它的时间片耗尽。<br>这两种实时算法实现的都是静态优先级。内核不为实时进程计算动态优先级。这能保证给定级别的实时进程总能抢占优先级比它低的进程。<br>Linux的实时调度算法提供了一种软实时工作方式。软实时的含义是，内核调度进程，尽力使进程在它的限定时间到来前运行，但内核不保证总能满足这些进程的要求。相反，硬实时系统保证在一定条件下，可以满足任何调度的要求。Linux对于实时任务的调度不做任何保证。虽然不能保证硬实时工作方式，但Linux的实时调度算法的性能还是很不错的。2.6版的内核可以满足严格的时间要求。<br>实时优先级范围从0到MAX_RT_PRIO减1。默认情况下，MAX_RT_PRIO为100–所以默认的实时优先级范围是从0到99。SCHED_NORMAL级进程的nice值共享了这个取值空间；它的取值范围是从MAX_RT_PRIO到（MAX_RT_PRIO + 40）。也就是说，在默认情况下，nice值从-20到+19直接对应的是从100到139的实时优先级范围。</p>
<h1 id="与调度有关的系统调用"><a href="#与调度有关的系统调用" class="headerlink" title="与调度有关的系统调用"></a>与调度有关的系统调用</h1><p>Linux提供了一个系统调用族，用于管理与调度程序相关的参数。这些系统调用可以用来操作和处理进程优先级、调度策略及处理器绑定，同时还提供了显式地将处理器交给其他进程的机制。<br><strong>与调度相关的系统调用</strong></p>
<table>
<thead>
<tr>
<th>系统调用</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>nice()</td>
<td>设置进程的nice值</td>
</tr>
<tr>
<td>sched_setscheduler()</td>
<td>设置进程的调度策略</td>
</tr>
<tr>
<td>sched_getscheduler()</td>
<td>获取进程的调度策略</td>
</tr>
<tr>
<td>sched_setparam()</td>
<td>设置进程的实时优先级</td>
</tr>
<tr>
<td>sched_getparam()</td>
<td>获取进程的实时优先级</td>
</tr>
<tr>
<td>sched_get_priority_max()</td>
<td>获取实时优先级的最大值</td>
</tr>
<tr>
<td>sched_get_priority_min()</td>
<td>获取实时优先级的最小值</td>
</tr>
<tr>
<td>sched_rr_get_interval()</td>
<td>获取进程的时间片值</td>
</tr>
<tr>
<td>sched_setaffinity()</td>
<td>设置进程的处理器的亲和力</td>
</tr>
<tr>
<td>sched_getaffinity()</td>
<td>获取进程的处理器的亲和力</td>
</tr>
<tr>
<td>sched_yield()</td>
<td>暂时让出处理器</td>
</tr>
</tbody></table>
<h2 id="与调度策略和优先级相关的系统调用"><a href="#与调度策略和优先级相关的系统调用" class="headerlink" title="与调度策略和优先级相关的系统调用"></a>与调度策略和优先级相关的系统调用</h2><p>sched_setscheduler()和sched_getscheduler()分别用于设置和获取进程的调度策略和实时优先级。与其他的系统调用相似，它们的实现也是由许多参数检查、初始化和清理构成的。其实最重要的工作在于读取或改写进程task_struct的policy和rt_priority的值。<br>sched_setparam()和sched_getparam()分别用于设置和获取进程的实时优先级。这两个系统调用获取封装在sched_param特殊结构体的rt_priority中。sched_get_priority_max()和sched_get_priority_min()分别用于返回给定调度策略的的最大和最小优先级。实时调度策略的最大优先级是MAX_USER_RT_PRIO减1，最小优先级等于1。<br>对于一个普通的进程，nice()函数可以将给定进程的静态优先级增加一个给定的量。只有超级用户才能在调用它时使用负值，从而提高进程的优先级。nice()函数会调用内核的set_user_nice()函数，这个函数会设置进程的task_struct的static_prio和prio值。</p>
<h2 id="与处理器绑定相关的系统调用"><a href="#与处理器绑定相关的系统调用" class="headerlink" title="与处理器绑定相关的系统调用"></a>与处理器绑定相关的系统调用</h2><p>Linux调度程序提供强制的处理器绑定（processor affinity）机制。也就是说，虽然它尽力通过一种软的（或者说自然的）亲和性试图使进程尽量在同一个处理器上运行，但它也允许用户强制指定“这个进程无论如何都必须在这些处理器上运行”。这种强制的亲和性保存在进程task_struct的cpus_allowed这个位掩码标志中。该掩码标志的每一位对应一个系统可用的处理器。默认情况下，所有的位都被设置，进程可以在系统中所有的处理器上执行。用户可以通过sched_setaffinity()设置不同的一个或几个位组合的位掩码，而调用sched_getaffinity()则返回当前的cpus_allowed位掩码。<br>内核提供的强制处理器绑定的方法很简单。首先，当进程第一次创建时，它继承了父进程的相关掩码。由于父进程运行在特定的处理器上，子进程也运行在相应处理器上.其次，当处理器绑定关系改变时，内核会采用“移植线程”把任务推送到合法的处理器上。最后，加载平衡器只把任务拉到允许的处理器上，因此，进程只运行在指定处理器上，对处理器的指定是由该进程描述符的cpus_allowed域设置的。</p>
<h2 id="放弃处理器时间"><a href="#放弃处理器时间" class="headerlink" title="放弃处理器时间"></a>放弃处理器时间</h2><p>Linux通过sched_yield()系统调用，提供了一种让进程显式地将处理器时间让给其他等待执行进程的机制。它是通过将进程从活动队列中（因为进程在执行，所以它肯定在此活动队列中）移到过期队列中实现的。由此产生的效果不仅仅抢占了该进程并将其放入优先级队列的最后面，还将其放入过期队列中–这样能确保它在一段时间内不会再运行了。由于实时进程不会过期，所以属于例外。它们只被移动到其优先级队列的最后面（不会放到过期队列中）。在Linux的早期版本中，sched_yield()的语义有所不同，进程只会被放到优先级队列的末尾，放弃的时间往往不会太长。现在，应用程序甚至内核代码在调用sched_yield()前，应该仔细考虑是否真的希望放弃处理器时间。<br>内核代码为了方便，可以直接调用yield()，先要确定给定进程确实处于可执行状态，然后再调用sched_yield()。用户空间的应用程序直接使用sched_yield()系统调用就可以了。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>进程调度程序是内核重要的组成部分，因为运行着的进程首先在使用计算机（至少在我们大多数人看来）。然而，满足进程调度的各种需要绝不是轻而易举的：很难找到“一刀切”的算法，既适合众多的可运行进程，又具有可伸缩性，还能在调度周期和吞吐量之间求得平衡，同时还满足各种负载的需求。不过，Linux内核新的CFS调度程序尽量满足了各个方面的需求，并比较完善的可伸缩性和新颖的方法提供了最佳的解决方案。<br>前面的章节覆盖了进程管理的相关内容，本章则考察了进程调度所遵循的基本原理、具体实现、调度算法以及目前Linux内核所使用的接口。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第4章 进程调度</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>中断下半部和推后执行的工作</title>
    <url>/2022/11/11/%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在第7章中，我们讨论了内核为处理中断而提供的中断处理程序机制。中断处理程序是内核中很有用的部分。但是，由于本身存在一些局限，所以它只能完成整个中断处理流程的上半部分。这些局限包括：</p>
<ol>
<li>中断处理程序以异步方式执行，并且它有可能打断其他重要代码（甚至包括其他中断处理程序）的执行。因此，为了避免被打断的代码停止时间过长，中断执行程序应该执行得越快越好。</li>
<li>如果当前有一个中断处理程序正在执行，在最好的情况下（如果IRQF_DISABLED没有被设置），与该中断同级的其他中断会被屏蔽，在最坏的情况下（如果IRQF_DISABLED有被设置），当前处理器上所有其他中断都会被屏蔽。因为禁止中断后硬件与操作系统无法通信，因此，中断处理程序执行得越快越好。</li>
<li>由于中断处理函数往往需要对硬件进行操作，所以它们通常有很高的时限要求。</li>
<li>中断处理程序不在进程上下文中运行，所以它们不能阻塞。这限制了它们所做得事情。</li>
</ol>
<p>现在，为什么中断处理程序只能作为整个硬件中断处理流程一部分的原因就很明显了。操作系统必须有一个快速、异步、简单的机制负责对硬件做出迅速响应并完成那些时间要求很严格的操作。中断处理程序很适合于实现这些功能，可是，对于那些其他的、对时间要求相对宽松的任务，就应该推后到中断被激活以后再去运行。<br>这样，整个中断处理流程就被分为了两个部分，或叫两半。第一个部分是中断处理程序（上半部），就像我们在第7章讨论的那样，内核通过对它的异步执行完成对硬件中断的即时响应。在本章中，我们要研究的是中断处理流程中的另外那一部分，下半部（bottom halves）。</p>
<span id="more"></span>

<h1 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h1><p>下半部的工作就是执行与中断处理密切相关但中断处理程序本身不执行的工作。在理想情况下，最好是中断处理程序将所有工作都交给下半部分执行，因为我们希望在中断处理程序中完成的工作越少越好（也就是越快越好）。我们期望中断处理程序能够尽可能快的返回。<br>但是，中断处理程序注定要完成一部分工作。例如，中断处理程序几乎都需要通过操作硬件对中断的到达进行确认，有时它还会从硬件拷贝数据。因为这些工作对时间非常敏感，所以只能靠中断处理程序自己去完成。<br>剩下的几乎所有其他工作都是下半部执行的目标。例如，如果你在上半部中把数据从硬件拷贝到内存，那么当然应该在下半部中处理它们。遗憾的是，并不存在严格明确的规定来说明到底什么任务应该在哪个部分中完成–如何做决定完全取决于驱动程序开发者自己的判断。尽管在理论上不存在什么错误，但是轻率的实现效果往往不很理想。记住，中断处理程序会异步执行，并且在最好的情况下它也会锁定当前的中断线。因此将中断处理程序持续执行的时间缩短到最小程度显得非常重要。对于在上半部和下半部之间划分工作，尽管不存在某种严格的规则，但还是有一些提示可供借鉴：</p>
<ol>
<li>如果一个任务对时间非常敏感，将其放在中断处理程序中执行。</li>
<li>如果一个任务和硬件相关，将其放在中断处理程序中执行。</li>
<li>如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。</li>
<li>其他所有任务，考虑放置在下半部执行。</li>
</ol>
<p>当你开始尝试写自己的驱动程序的时候，读一下别人的中断处理程序和相应的下半部可能会让你受益匪浅。在决定怎样把你的中断处理流程中的工作划分到上半部和下半部中去的时候，问问自己什么必须放进上半部而什么可以放进下半部。通常，中断处理程序要执行得越快越好。</p>
<h2 id="为什么要用下半部"><a href="#为什么要用下半部" class="headerlink" title="为什么要用下半部"></a>为什么要用下半部</h2><p>理解为什么要让工作推后执行以及在什么时候推后执行非常关键。你希望尽量减少中断处理程序中需要完成的工作量，因为它在运行的时候，当前的中断线在所有处理器上都会被屏蔽。更糟糕的是，如果一个处理程序是IRQF_DISABLED类型，它执行的时候会禁止所有本地中断（而且把本地中断线全局的屏蔽掉）。而缩短中断被屏蔽的时间对系统的响应能力和性能都至关重要。再加上中断处理程序要与其他程序（甚至是其他的中断处理程序）异步执行，所以很明显，我们必须尽力缩短中断处理程序的执行。解决的办法就是把一些工作放到以后去做。<br>但具体放到以后什么时候去做呢？在这里，以后仅仅用来强调不是马上而已，理解这一点相当重要，下半部并不需要指明一个确切时间，只要把这些任务推迟一点，让它们在系统不太繁忙的并且中断恢复后执行就可以了。通常下半部在中断处理程序一返回就会马上运行。下半部执行的关键在于当它们运行的时候，允许响应所有的中断。<br>不仅仅是Linux，许多操作系统也把处理硬件中断的过程分为两部分。上半部分简单快速，执行的时候禁止一些或全部中断。下半部分稍后执行，而且执行期间可以响应所有的中断。这种设计可使系统处于中断屏蔽状态的时间尽可能的短，以此来提高系统的响应能力。</p>
<h2 id="下半部的环境"><a href="#下半部的环境" class="headerlink" title="下半部的环境"></a>下半部的环境</h2><p>和上半部只能通过中断处理程序实现不同，下半部可以通过多种机制实现。这些用来实现下半部的机制分别由不同的接口和子系统组成。在第7章中，我们了解到实现中断处理程序的方法只有一种，但在本章中你会发现，实现一个下半部会有许多不同的方法。实际上，在Linux发展的过程中曾经出现过多种下半部机制。让人备受困扰的是，其中不少机制名字起得很相像，甚至还有一些机制名字词不达意。这就需要专门的程序员来给下半部命名。<br>在本章中，我们将要讨论2.6版本的内核中的下半部机制是如何设计和实现的。同时我们也会讨论怎么在自己编写的内核代码中使用它们。而那些过去使用的、已经废除了有一段时间的机制，由于曾经闻名遐迩，所以在相关的时候我们还会有所提及。</p>
<h3 id="下半部的起源"><a href="#下半部的起源" class="headerlink" title="下半部的起源"></a>下半部的起源</h3><p>最早的Linux只提供“bottom half”这种机制用于实现下半部。这个名字在那时毫无异义，因为当时它是将工作推后的唯一方法。这种机制也被称为“BH”，我们现在也这么叫它，以避免和“下半部”这个通用词汇混淆。像过往的那段美好岁月中的许多东西一样，BH接口也非常简单。它提供了一个静态创建、由32个bottom havles组成的链表。上半部通过一个32位整数中的一位来标识出哪个bottom half可以执行。每个BH都在全局范围内进行同步。即使分属于不同的处理器，也不允许任何两个bottom half同时执行。这种机制使用方便却不够灵活，简单却有性能瓶颈。</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>不久，内核开发者们就引入了任务队列（task queue）机制来实现工作的推后执行，并用它来代替BH机制。内核为此定义了一组队列，其中每个队列都包含一个由等待调用的函数组成链表。根据其所处队列的位置，这些函数会在某个时刻执行。驱动程序可以把它们自己的下半部注册到合适的队列上去。这种机制表现得还不错，但仍不够灵活，没法代替整个BH接口。对于一些性能要求较高的子系统，像网络部分，它也不能胜任。</p>
<h2 id="软中断和tasklet"><a href="#软中断和tasklet" class="headerlink" title="软中断和tasklet"></a>软中断和tasklet</h2><p>在2.3这个开发版本中，内核开发者引入了软中断和tasklet。如果无需考虑和过去开发的驱动程序兼容的话，软中断和tasklet可以完全代替BH接口。软中断是一组静态定义的下半部接口，有32个，可以在任何处理器上同时执行–即使两个类型相同也可以。tasklet这一名称起得很糟糕，让人费解，它们是一种基于软中断实现的灵活性强、动态创建的下半部实现机制。两个不同类型的tasklet可以在不同的处理器上同时执行，但类型相同的tasklet不能同时执行。tasklet其实是一种在性能和易用性之间寻求平衡的产物。对于大多数下半部处理来说，用tasklet就足够了，像网络这样对性能要求非常高的情况下才需要使用软中断。可是，使用软中断需要特别小心，因为两个相同的软中断有可能同时被执行。此外，软中断还必须在编译期间就进行静态注册。与此相反，tasklet可以通过代码进行动态注册。<br>有些人别被这些概念彻底搞糊涂了，他们把所有的下半部都当成是软件产生的中断或软中断。换句话说，就是他们把软中断机制和下半部统统都叫软中断。软中断和BH与tasklet并驾齐名。<br>在开发2.5版本的内核时，BH接口最终被弃置了，所有的BH使用者必须转而使用其他下半部接口。此外，任务队列接口也被工作队列接口取代了。工作队列是一种简单但很有用的方法，它们先对要推后执行的工作排队，稍后在进程上下文中执行它们。<br>综上所述，在2.6这个当前版本中，内核提供了三种不同形式的下半部实现机制：软中断、tasklets和工作队列。内核过去曾经用过的BH和任务队列接口，现在已经湮没在记忆中了。</p>
<p><strong>内核定时器</strong><br>另外一个可以用于将工作推后执行的机制是内核定时器。不像本章到目前为止介绍到的所有这些机制，内核定时器把操作推迟到某个确定的时间段之后执行。也就是说，尽管本章讨论的其他机制可以把操作推后到除了现在以外的任何时间进行，但是当你必须保证在一个确定的时间段过去之后再运行时，你应该使用内核定时器。</p>
<h2 id="混乱的下半部概念"><a href="#混乱的下半部概念" class="headerlink" title="混乱的下半部概念"></a>混乱的下半部概念</h2><p>这些东西确实把人搅得很混乱，但它们其实只不过是一些起名的问题，让我们再来梳理一遍。<br>“下半部（bottom half）”是一个操作系统通用词汇，用于指代中断处理流程中推后执行的那一部分，之所以这样命名，是因为它表示中断处理方案一半的第二部分或者下半部。在Linux中，这个词目前确实就是这个含义。所有用于实现将工作推后执行的内核机制都被称为“下半部机制”。一些人错误地把所有的下半部机制都叫做“软中断”，真是自寻烦恼。<br>“下半部”这个词也指代Linux最早提供的那种将工作推后执行的实现机制。由于该机制也被叫做“BH”，所以，我们就使用它的这个名称，而让“下半部”这个词仍然保持它通常的含义。BH机制很早之前就被反对使用了，在2.5版本的内核中，它就被完全去除了。<br>当前，<code>有三种机制可以用来实现将工作推后执行：软中断、tasklet、工作队列</code>。tasklet通过软中断实现，而工作队列与它们完全不同。下表揭示了下半部机制的演化历程。</p>
<table>
<thead>
<tr>
<th>下半部机制</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>BH</td>
<td>在2.5中去除</td>
</tr>
<tr>
<td>任务队列（Task queues）</td>
<td>在2.5中去除</td>
</tr>
<tr>
<td>软中断（Softirq）</td>
<td>在2.3中开始引入</td>
</tr>
<tr>
<td>tasklet</td>
<td>在2.3中开始引入</td>
</tr>
<tr>
<td>工作队列（Work queues）</td>
<td>在2.5中开始引入</td>
</tr>
</tbody></table>
<p>在搞清楚这些混乱的命名之后，让我们开始具体研究各个机制。</p>
<h1 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h1><p>我们的讨论从实际的下半部实现–软中断方法开始。软中断使用得比较少；而tasklet是下半部更常用的一种形式。但是，由于tasklet是通过软中断实现的，所以我们先来研究软中断。软中断的代码位于<code>kernel/softirq.c</code>文件中。</p>
<h2 id="软中断的实现"><a href="#软中断的实现" class="headerlink" title="软中断的实现"></a>软中断的实现</h2><p>软中断是在编译期间静态分配的。它不像tasklet那样能被动态地注册或注销。软中断由softirq_action结构表示，它定义在&lt;linux&#x2F;interrupt.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>kernel/softirq.c</code>中定义了一个包含有32个该结构体的数组。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span></span><br></pre></td></tr></table></figure>
<p>每个被注册的软中断都占据该数组的一项，因此最多有可能有32个软中断。注意，这是一个定值–注册的软中断数目的最大值没法动态改变。在当前的内核版本中，这32个项中只用到9个。</p>
<h3 id="软中断处理程序"><a href="#软中断处理程序" class="headerlink" title="软中断处理程序"></a>软中断处理程序</h3><p>软中断处理程序action的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *)</span>;</span><br></pre></td></tr></table></figure>
<p>当内核运行一个软中断处理程序的时候，它就会执行这个action函数，其唯一的参数为指向相应的softirq_action结构体的指针。例如，如果my_softirq指向softirq_vec数组的某项，那么内核会用如下的方式调用软中断处理程序中的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">my_softirq-&gt;action(my_softirq);</span><br></pre></td></tr></table></figure>
<p>当你看到内核把整个结构体都传递给软中断处理程序而不是仅仅传递数据值的时候，你可能会很吃惊。这个小技巧可以保证将来在结构体中加入新的域时，无须对所有的软中断处理程序都进行变动。如果需要，软中断处理程序可以方便地解析它的参数，从数据成员中提取数值。<br>一个软中断不会抢占另一个软中断。实际上，唯一可以抢占软中断的是中断处理程序。不过，其他的软中断（甚至是相同类型的软中断）可以在其他处理器上同时执行。</p>
<h3 id="执行软中断"><a href="#执行软中断" class="headerlink" title="执行软中断"></a>执行软中断</h3><p>一个注册的软中断必须在被标记后才会执行。这被称为触发软中断（raising the softirq）。通常，中断处理程序会在返回前标记它的软中断，使其在稍后被执行。于是，在合适的时刻，该软中断就会运行。在下列地方，待处理的软中断会被检查和执行：</p>
<ol>
<li>从一个硬件中断代码出返回。</li>
<li>在ksoftirqd内核线程中。</li>
<li>在那些显式检查和执行待处理的软中断的代码中，如网络子系统中</li>
</ol>
<p>不管是用什么方法唤起，软中断都要在do_softirq()中执行。该函数很简单。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的处理程序。让我观察一下do_softirq()经过简化后的核心部分：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u32 pending;</span><br><span class="line"></span><br><span class="line">pending = local_softirq_pending();</span><br><span class="line"><span class="keyword">if</span>(pending) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重设待处理的位图</span></span><br><span class="line">    set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    h = softirq_vec;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pending &amp; l)</span><br><span class="line">            h-&gt;action(h);</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(pending);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上摘录的是软中断处理的核心部分。它检查并执行所有待处理的软中断，具体要做的包括：</p>
<ol>
<li>用局部变量pending保存local_softirq_pending()宏的返回值。它是待处理的软中断的32位位图–如果第n位被设置为1，那么第n位对应类型的软中断等待处理。</li>
<li>现在待处理的软中断位图已经被保存，可以将实际的软中断位图清零了。</li>
<li>将指针n指向softirq_vec的第一项。</li>
<li>如果pending第一位被置为1，则h-&gt;action(h)被调用。</li>
<li>指针加1，所以现在它指向softirq_vec数组的第二项。</li>
<li>位掩码pending右移一位。这样会丢弃第一位，然后让其他各位依次向后移动一个位置。于是，原来的第二位现在就在第一位的位置上了。</li>
<li>现在指针h指向数组的第二项，pending位掩码的第二位现在也到了第一位上。重复执行上面的步骤。</li>
<li>一直重复下去，直到pengding变为0，这表明已经没有待处理的软中断了，我们的任务也就完成了。注意，这种检查足以保证h总指向softirq_vec的有效项，因为pending最多只可能设置32位，循环最多也只执行32次。</li>
</ol>
<h2 id="使用软中断"><a href="#使用软中断" class="headerlink" title="使用软中断"></a>使用软中断</h2><p><code>软中断保留给系统中对时间要求最严格以及最重要的下半部使用</code>。目前，只有两个子系统（网络和SCSI）直接使用软中断。此外，内核定时器和tasklet都是建立在软中断上的。如果你想加入一个新的软中断，首先应该问问自己为什么用tasklet实现不了。tasklet可以动态生成，由于它们对加锁的要求不高，所以使用起来也很方便，而且它们的性能也非常不错。当然，对于时间要求严格并能自己高效地完成加锁工作的应用，软中断会是正确的选择。</p>
<h3 id="分配索引"><a href="#分配索引" class="headerlink" title="分配索引"></a>分配索引</h3><p>在编译期间，通过在&lt;linux&#x2F;interrupts.h&gt;中定义的一个枚举类型来静态地声明软中断。内核用这些从0开始的索引表示一种相对优先级。索引号小的软中断在索引号大的软中断之前执行。<br>建立一个新的软中断必须在此枚举类型中加入新的项。而加入时，你不能像在其他地方一样，简单地把新项加到列表的末尾。相反，你必须根据希望赋予它地优先级来决定加入的位置。习惯上，HI_SOFTIRQ通常作为第一项，而RCU_SOFTIRQ作为最后一项。新项可能插在BLOCK_SOFTIRQ和TASKLET_SOFTIRQ之间。下表列出了已有的tasklet类型。<br><strong>tasklet类型列表</strong></p>
<table>
<thead>
<tr>
<th>tasklet</th>
<th>优先级</th>
<th>软中断描述</th>
</tr>
</thead>
<tbody><tr>
<td>HI_SOFTIRQ</td>
<td>0</td>
<td>优先级高的tasklet</td>
</tr>
<tr>
<td>TIMER_SOFTIRQ</td>
<td>1</td>
<td>定时器的下半部</td>
</tr>
<tr>
<td>NET_TX_SOFTIRQ</td>
<td>2</td>
<td>发送网络数据包</td>
</tr>
<tr>
<td>NET_RX_SOFTIRQ</td>
<td>3</td>
<td>接收网络数据包</td>
</tr>
<tr>
<td>BLOCK_SOFTIRQ</td>
<td>4</td>
<td>BLOCK装置</td>
</tr>
<tr>
<td>TASKLET_SOFTIRQ</td>
<td>5</td>
<td>正常优先级的tasklets</td>
</tr>
<tr>
<td>SCHED_SOFTIRQ</td>
<td>6</td>
<td>调度程度</td>
</tr>
<tr>
<td>HRTIMER_SOFTIRQ</td>
<td>7</td>
<td>高分辨率定时器</td>
</tr>
<tr>
<td>RCU_SOFTIRQ</td>
<td>8</td>
<td>RCU锁定</td>
</tr>
</tbody></table>
<h3 id="注册你的处理程序"><a href="#注册你的处理程序" class="headerlink" title="注册你的处理程序"></a>注册你的处理程序</h3><p>接着，在运行时通过调用open_softirq()注册软中断处理程序，该函数有两个参数：软中断的索引号和处理函数。如网络子系统，在net&#x2F;coreldev.c通过以下方式注册自己的软中断：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">open_softirq(NET_TX_SOFTIRQ,net_tx_action);</span><br><span class="line">open_softirq(NET_RX_SOFTIRQ,net_rx_action);</span><br></pre></td></tr></table></figure>
<p>软中断处理程序执行的时候，允许响应中断，但它自己不能休眠。在一个处理程序运行的时候，当前处理器上的软中断被禁止。但其他的处理器仍可以执行别的软中断。实际上，如果同一个软中断在它被执行的同时再次被触发了，那么另外一个处理器可以同时运行其处理程序。这意味着任何共享数据（甚至是仅在软中断处理程序内部使用的全局变量）都需要严格的锁保护。这点很重要，它也是tasklet更受青睐的原因。单纯地禁止你的软中断处理程序同时执行不是很理想。如果仅仅通过互斥的加锁方式来防止它自身的并发执行，那么使用软中断就没有任何意义了。因此，大部分中断处理程序，都通过采取单处理器数据（仅属于某一个处理器的数据，因此根本不需要加锁）或其他的一些技巧来避免显式的加锁，从而提供更出色的性能。<br>引入软中断的主要原因是其可扩展性。如果不需要扩展到多个处理器，那么，就使用tasklet吧。tasklet本质上也是软中断，只不过同一个处理程序的多个实例不能在多个处理器上同时运行。</p>
<h3 id="触发你的软中断"><a href="#触发你的软中断" class="headerlink" title="触发你的软中断"></a>触发你的软中断</h3><p>通过在枚举类型的列表中添加新项以及调用open_softirq()进行注册之后，新的软中断处理程序就能够运行。raise_softirq()函数可以将一个软中断设置为挂起状态，让它在下次调用do_softirq()函数时投入运行。举个例子，网络子系统可能会调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">raise_softirq(NET_TX_SOFTIRQ);</span><br></pre></td></tr></table></figure>
<p>这会触发NET_TX_SOFTIRQ软中断。它的处理程序net_tx_action()就会在内核下一次执行软中断时投入运行。该函数在触发一个软中断之前先要禁止中断，触发后再恢复原来的状态。如果中断本来就已经被禁止了，那么可以调用另一函数raise_softirq_irqoff()，这会带来一些优化效果。如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//中断已经被禁止</span></span><br><span class="line">raise_softirq_irqoff(NET_TX_SOFTIRQ);</span><br></pre></td></tr></table></figure>
<p>在中断处理程序中触发软中断是最常见的形式。在这种情况下，中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序之后，马上就会调用do_softirq()函数。于是软中断开始执行中断处理程序留给它去完成的剩余任务。在这个例子中，“上半部”和“下半部”名字的含义一目了然。</p>
<h1 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h1><p>tasklet是利用软中断实现的一种下半部机制。我们之前提到过，它和进程没有任何关系。tasklet和软中断在本质上很相似，行为表现也相近，但是，它的接口更简单，锁保护也比较低。<br>选择到底是用软中断还是tasklet其实很简单：通常你应该用tasklet。就像我们在前面看到的，软中断的使用者屈指可数。它只在那些执行频率很高和连续性要求很高的情况下才需要使用。而tasklet却有更广泛的用途。大多数情况下用tasklet效果都还不错，而且它们还非常容易使用。</p>
<h2 id="tasklet的实现"><a href="#tasklet的实现" class="headerlink" title="tasklet的实现"></a>tasklet的实现</h2><p>因为tasklet是通过软中断实现的，所以它们本身也是软中断。前面讨论过了，tasklet由两类软中断代表：HI_SOFTIRQ和TASKLET_SOFTIRQ。这两者之间唯一的实际区别在于，HI_SOFTIRQ类型的软中断先于TASKLET_SOFTIRQ类型的软中断执行。</p>
<h3 id="tasklet结构体"><a href="#tasklet结构体" class="headerlink" title="tasklet结构体"></a>tasklet结构体</h3><p>tasklet由tasklet_struct结构表示。每个结构体单独代表一个tasklet，它在&lt;linux&#x2F;interrupt.h&gt;中定义为：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span>        <span class="comment">//链表中的下一个tasklet</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;                <span class="comment">//tasklet的状态</span></span><br><span class="line">    <span class="type">atomic_t</span> count;                     <span class="comment">//引用计数器</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);        <span class="comment">//tasklet处理函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;                 <span class="comment">//给tasklet处理函数的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中的func成员是tasklet的处理程序（像软中断中的action一样），data是它唯一的参数。<br>state成员只能在0、TASKLET_STATE_SCHED和TASKLET_STATE_RUN之间取值。TASKLET_STATE_SCHED表明tasklet已被调度，正准备投入运行，TASKLET_STATE_RUN表示该tasklet正在运行。TASKLET_STATE_RUN只有在多处理器的系统上才会作为一种优化来使用，单处理器系统任何时候都清楚单个tasklet是不是正在运行（它要么就是当前正在执行的代码，要么不是）。<br>count成员是tasklet的引用计数器。如果它不为0，则tasklet被禁止，不允许执行；只有当它为0时，tasklet才被激活，并且被设置为挂起状态时，该tasklet才能够被执行。</p>
<h3 id="调度tasklet"><a href="#调度tasklet" class="headerlink" title="调度tasklet"></a>调度tasklet</h3><p>已调度的tasklet（等同于被触发的软中断）存放在两个单处理器数据结构：tasklet_vec（普通tasklet）和tasklet_hi_vec（高优先级的tasklet）。这两个数据结构都是由tasklet_struct结构体组成的链表。链表中的每个tasklet_struct代表一个不同的tasklet。<br>tasklet_struct结构体构成的链表。链表中的每个tasklet_struct代表一个不同的tasklet。<br>tasklet由tasklet_schedule()和tasklet_hi_schedule()函数进行调度，它们接受一个指向tasklet_struct结构的指针作为参数。两个函数非常相似（区别在于一个使用TASKLET_SOFTIRQ，而另一个用HI_SOFTIRQ）。在接下来的内容中我们将仔细研究怎么编写和使用tasklet。现在，让我们先考察一下task_schedule()的细节：<br>tasklet_schedule()的执行步骤：</p>
<ol>
<li>检查tasklet的状态是否为TASKLET_STATE_SCHED。如果是，说明tasklet已经被调度过了，函数立即返回。</li>
<li>调用_tasklet_schedule()。</li>
<li>保存中断状态，然后禁止本地中断。在我们执行tasklet代码时，这么做能够保证当tasklet_struct()处理这些tasklet时，处理器上的数据不会弄乱。</li>
<li>把需要调度的tasklet加到每个处理器一个的tasklet_vec链表或tasklet_hi_vec链表的表头上去。</li>
<li>唤起TASKLET_SOFTIRQ或HI_SOFTIRQ软中断，这样在下一次调用do_softirq()时就会执行该tasklet。</li>
<li>恢复中断到原状态并返回。</li>
</ol>
<p>在前面的内容中我们曾经提起过挂起，do_softirq()会尽可能早地在下一个合适地时机运行。由于大部分tasklet和软中断都是在中断处理程序中被设置成待处理状态，所以最近一个中断返回的时候看起来就是执行do_softirq()的最佳时机。因为TASKLET_SOFTIRQ和HI_SOFTIRQ已经被触发了，所以do_softirq()会执行相应的软中断处理程序。而这两个处理程序，taklet_action()和tasklet_hi_action()，就是tasklet处理的核心。让我们观察它们做了什么：</p>
<ol>
<li>禁止中断（没有必要首先保存其状态，这是因为这里的代码总是作为软中断被调用，而且中断总是被激活的），并为当前处理器检索tasklet_vec或tasklet_hi_vec链表。</li>
<li>将当前处理器上的该链表设置为NULL，达到清空的效果。</li>
<li>允许响应中断。没有必要再恢复它们回原始状态，这是因为这段程序本身就是作为软中断处理程序被调用的，所以中断是应该被允许的。</li>
<li>循环遍历获得链表上的每一个待处理的tasklet。</li>
<li>如果是多处理器系统，通过检查TASKLET_STATE_RUN来判断这个tasklet是否正在其他处理器上运行。如果它正在运行，那么现在就不要执行，跳到下一个待处理的tasklet去（回忆一下，同一时间里，相同类型的tasklet只能有一个执行）。</li>
<li>如果当前这个tasklet没有执行，将其状态设置为TASKLET_STATE_RUN，这样别的处理器就不会再去执行它了。</li>
<li>检查count值是否为0，确保tasklet没有被禁止。如果tasklet被禁止了，则跳到下一个挂起的tasklet去。</li>
<li>我们已经清楚地知道这个tasklet没有在其他地方执行，并且被我们设置成执行状态，这样它在其他部分就不会被执行，并且引用计数为0，现在可以执行tasklet的处理程序了。</li>
<li>tasklet运行完毕，清除tasklet的state域的TASKLET_STATE_RUN状态标志。</li>
<li>重复执行下一个tasklet，直至没有剩余的等待处理的tasklet。</li>
</ol>
<p>taslet的实现很简单，但非常巧妙。我们可以看到，所有的tasklet都通过重复运用HI_SOFTRIRQ和TASKLET_SOFTIRQ这两个软中断实现。当一个tasklet被调度时，内核就会唤起这两个软中断中的一个。随后，该软中断会被特定的函数处理，执行所有已调度的tasklet。这个函数保证同一时间里只有一个给定类别的tasklet会被执行（但其他不同的tasklet可以同时执行）。所有的这些复杂性都被一个简洁的接口隐藏起来了。</p>
<h2 id="使用tasklet"><a href="#使用tasklet" class="headerlink" title="使用tasklet"></a>使用tasklet</h2><p>大多数情况下，为了控制一个寻常的硬件设备，tasklet机制都是实现自己的下半部的最佳选择。tasklet可以动态创建，使用方便，执行起来还算快。此外，尽管它们的名字使人混淆，但能加深你的印象。</p>
<h3 id="声明你自己的tasklet"><a href="#声明你自己的tasklet" class="headerlink" title="声明你自己的tasklet"></a>声明你自己的tasklet</h3><p>你既可以静态地创建tasklet，也可以动态地创建它。选择哪种方式取决于你到底是有（或者想要）一个对tasklet的直接引用还是间接引用。如果你准备静态地创建一个tasklet（也就是有一个它的直接引用），使用下面&lt;linux&#x2F;interrupt.h&gt;中定义的两个宏中的一个：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_TASKLET(name,func,data)</span><br><span class="line">DECLARE_TASKLET_DISABLE(name,func,data);</span><br></pre></td></tr></table></figure>
<p>这两个宏都能根据给定的名称静态的创建一个tasklet_struct结构。当该tasklet被调度之后，给定的函数func就会被执行，它的参数由data给出。这两个宏之间的区别在于引用计数器的初始值设置不同。前面一个宏把创建的tasklet引用计数器设置为0，该tasklet处于激活状态。另一个把引用计数器设置为1，所以该tasklet处于禁止状态。下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_TASKLET(my_tasklet,my_tasklet_handler,dev);</span><br></pre></td></tr></table></figure>
<p>这行代码其实等价于</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span> =</span> &#123;</span><br><span class="line">    <span class="literal">NULL</span>,<span class="number">0</span>,ATOMIC_INIT(<span class="number">0</span>),</span><br><span class="line">    my_tasklet_handler,dev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就创建了一个名为my_tasklet，处理程序为tasklet_handler并且是已被激活的tasklet。当处理程序被调用的时候，dev就会被传递给它。<br>还可以通过将一个间接引用（一个指针）赋给一个动态创建的tasklet_struct结构的方式来初始化一个tasklet_init()：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_init(t,tasklet_handler,dev);<span class="comment">//动态而不是静态创建</span></span><br></pre></td></tr></table></figure>

<h3 id="编写你自己的tasklet处理程序"><a href="#编写你自己的tasklet处理程序" class="headerlink" title="编写你自己的tasklet处理程序"></a>编写你自己的tasklet处理程序</h3><p>tasklet处理程序必须符合规定的函数类型：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br></pre></td></tr></table></figure>
<p>因为是靠软中断实现，所以tasklet不能睡眠。这意味着你不能在tasklet中使用信号量或者其他什么阻塞式的函数。由于tasklet运行时允许响应中断，所以你必须做好预防工作（如屏蔽中断然后获取一个锁），如果你的tasklet和中断处理程序之间共享了某些数据的话。两个相同的tasklet绝不会同时执行，这点和软中断不同–尽管两个不同的tasklet可以在两个处理器上同时执行。如果你的tasklet和其他的tasklet或者软中断共享了数据，你必须进行适当地锁保护。</p>
<h3 id="调度你自己的tasklet"><a href="#调度你自己的tasklet" class="headerlink" title="调度你自己的tasklet"></a>调度你自己的tasklet</h3><p>通过调用tasklet_schedule()函数并传递给它相应的tasklet_struct的指针，该tasklet就会被调度以便执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_schedule(&amp;my_tasklet);<span class="comment">//把my_tasklet标记为挂起</span></span><br></pre></td></tr></table></figure>
<p>在tasklet被调度之后，只要有机会它就会尽可能早地运行。在它还没得到运行机会之前，如果有一个相同的tasklet又被调度了，那么它仍然只会运行一次。而如果这时它已经开始运行了，比如说在另外一个处理器上，那么这个新的tasklet会被重新调度并再次被运行。作为一种优化措施，一个tasklet总在调度它的处理器上执行–这是希望能更好地利用处理器的高速缓存。<br>你可以调用tasklet_disable()函数来禁止某个指定的tasklet。如果该tasklet当前正在执行，这个函数会等到它执行完毕再返回。你也可以调用tasklet_disable_nosync()函数，它也用来禁止指定的tasklet，不过它无须在返回前等待tasklet执行完毕。这么做往往不太安全，因为你无法估计该tasklet是否仍在执行。调用tasklet_enable()函数可以激活一个tasklet，如果希望激活DECLARE_TASKLET_DISABLE()创建的tasklet，你也得调用这个函数，如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tasklet_diasble(&amp;my_tasklet);   <span class="comment">//tasklet现在被禁止</span></span><br><span class="line"><span class="comment">//我们毫无疑问地知道tasklet不能运行</span></span><br><span class="line">tasklet_enable(&amp;my_tasklet);    <span class="comment">//tasklet现在被激活</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用tasklet_kill()函数从挂起的队列中去掉一个tasklet。该函数的参数是一个指向某个tasklet的tasklet_struct的长指针。在处理一个经常调度它自身的tasklet的时候，从挂起的队列中移去已调度的tasklet会很有用。这个函数首先等待该tasklet执行完毕，然后再将它移去。当然，没有什么可以阻止其它地方的代码重新调度该tasklet。由于该函数可能会引起休眠，所以禁止在中断上下文中使用它。</p>
<h3 id="ksoftirq"><a href="#ksoftirq" class="headerlink" title="ksoftirq"></a>ksoftirq</h3><p>每个处理器都有一组辅助处理软中断（或tasklet）的内核线程。当内核中出现大量软中断的时候，这些内核线程就会辅助处理它们。因为tasklet通过用软中断实施，下面的讨论同样适用于软中断和tasklet。简洁起见，我们将主要参考软中断。<br>我们前面阐述过，对于软中断，内核会选择在几个特殊时机进行处理。而在中断处理程序返回时是最常见的。软中断被触发的频率有时可能很高（像在进行大流量的网络通信期间）。更不利的是，处理函数有时还会自行重复触发。也就是说，当一个软中断执行的时候，它可以重新触发自己以便再次得到执行（事实上，网络子系统就会这么做）。如果软中断本身出现的频率就高，再加上它们又将自己重新设置为可执行状态的能力，那么就会导致用户空间进程无法获得足够的处理器时间，因而处于饥饿状态。而且，单纯的对重新触发的软中断采取不立即处理的策略，也无法让人接受。当软中断最初提出时，就是一个让人进退维谷的问题，亟待解决，而直观的解决方案又都不理想。首先，就让我们看看两种最容易想到的直观的方案。<br>第一种方案是，只要还有被触发并等待处理的软中断，本次执行就要负责处理，重新触发的软中断也在本次执行返回前被处理。这样做可以保证对内核的软中断采取即时处理的方式，关键在于，对重新触发的软中断也会立即处理。当负载很高的时候这样做就会出问题，此时会有大量被触发的软中断，而它们本身又被重复触发。系统可能会一直处理软中断，根本不能完成其他任务，用户空间的任务被忽略了–实际上，只有软中断和中断处理程序轮流执行，而系统的用户只能等待。只有在系统永远处于低负载的情况下，这种方案才会有理想的运行效果；只要系统有哪怕是中等程度的负载量，这种方案就无法让人满意。用户空间根本不能容忍有明显的停顿出现。<br>第二种方案选择不处理重新触发的软中断。在从中断返回的时候，内核和平常一样，也会检查所有挂起的软中断并处理它们。但是，任何自行重新触发的软中断都不会马上处理。它们会被放到下一个软中断执行时去处理。而这个时机通常也就是下一次中断返回的时候，这等于就是说，一定得等一段时间，新的（或者重新触发的）软中断才能被执行。可是，在比较空闲的系统中，立即处理软中断才是比较好的做法。很不幸，这个方案显然又是一个时好时坏的选择。尽管它能保证用户空间不处于饥饿状态，但它却让软中断忍受饥饿的痛苦，而根本没有好好利用闲置的系统资源。<br>在设计软中断时，开发者就意识到需要一些折中。最终在内核实现的方案是不会立即处理重新触发的软中断。而作为改进，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最低的优先级上运行（nice值为19），这能避免它们跟其他重要的任务抢夺资源。但是它们最终肯定会被执行，所以，这个这种方案能够保证软中断负担很重的时候，用户程序不会因为得不到处理时间而处于饥饿状态。相应的，也能保证“过量”的软中断终究会得到处理。最后，在空闲系统上，这个方案同样表现良好，软中断处理的非常迅速（因为仅存的内核线程肯定会马上调度）。<br>每个处理器都有一个这样的线程。所有的线程名字都叫做ksoftirqd&#x2F;n，区别在于n，它对应的是处理器的编号。在一个双CPU的机器上就有两个这样的线程，分别叫做ksoftirqd&#x2F;0和ksoftirqd&#x2F;1。为了保证只要有空闲的处理器，它们就会处理软中断，所以给每个处理器都分配一个这样的线程。一旦该线程被初始化，它就会执行类似下面这样的死循环：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!softirq_pending(cpu))</span><br><span class="line">        schedule();</span><br><span class="line">    </span><br><span class="line">    set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(softirq_pending(cpu)) &#123;</span><br><span class="line">        do_softirq();</span><br><span class="line">        <span class="keyword">if</span>(need_resched())</span><br><span class="line">            schedule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要有待处理的软中断（由softirq_pending()函数负责发现），ksoftirq就会调用do_softirq()去处理它们。通过重复执行这样的操作，重复触发的软中断也会被执行。如果有必要的话，每次迭代后都会调用schedule()以便让更重要的进程得到处理机会。当所有需要执行的操作都完成以后，该内核进程将自己设置为TASK_INTERRUPT状态，唤起调度程序选择其他可执行进程投入运行。<br>只要do_softirq()函数发现已经执行过的内核线程重新触发了它自己，软中断内核线程就会被唤醒。</p>
<h2 id="老的BH机制"><a href="#老的BH机制" class="headerlink" title="老的BH机制"></a>老的BH机制</h2><p>尽管BH机制令人欣慰的退出了历史舞台，在2.6版内核中已经难觅踪迹。可是，它毕竟曾经经历了漫长的时光–从最早版本的内核就开始了。由于其余威尚存，所以仅仅不经意地提起它是不够的，尽管在2.6版本中已经不再使用它了，但历史就是历史，应该被了解。<br>BH很古老，但它能揭示一些东西。所有BH都是静态定义的，最多可以有32个。由于处理函数必须在编译时就被定义好，所以实现模块时不能直接使用BH接口。不过业已存在的BH倒是可以利用。随着时间的推移，这种静态要求和最大为32个的数目限制最终妨碍了它们的应用。<br>每个BH处理程序都严格的按顺序执行–不允许任何两个BH处理程序同时执行，即使它们的类型不同。这样做倒是使同步变得简单了，可是却不利于多处理的可扩展性，也不利于大型SMP的性能。使用BH的驱动程序很难从多个处理器上收益，特别是网络层，可以说为此饱受困扰。<br>除了这些特点，BH机制和tasklet就很像了。实际上，在2.4内核中，BH就是基于tasklet实现的。所有可能的32个BH都通过在&lt;linux&#x2F;interrupt.h&gt;中定义的常量表示。如果需要将一个BH标志为挂起状态，可以把相应的BH号传给mark_bh()函数。在2.4内核中，这将导致随后调度BH tasklet，具体工作是由函数bh_action()完成的。而在2.4内核之前，BH机制独立实现，不依赖任何低级BH机制，这和现在的软中断很像。<br>由于这种形式的下半部机制存在缺点，内核开发者们希望引入任务队列机制来代替它。尽管任务队列得到了不少使用者的认可，但它实际上并没有达成这个目的。在2.3版本的内核中，引入了新的软中断和tasklet机制也就结束了对BH的使用。BH机制基于tasklet重新实现。不幸的是，因为新接口本身降低了对执行的序列化保障，所以从BH接口移植到tasklet或软中断接口上操作起来非常复杂。在2.5版中，这种移植最终在定时器和SCSI（最后的BH使用者）转换到软中断机制后完成了。于是内核开发者们立即除去了BH接口。</p>
<h1 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h1><p>工作队列（work queue）是另外一种将工作推后执行的形式，它和我们前面讨论的所有其他形式都不相同。工作队列可以把工作推后，交给一个内核线程去执行–这个下半部总是会在进程上下文中执行。这样，通过工作队列执行的代码能占尽进程上下文的所有优势。最重要的就是工作队列允许重新调度甚至是睡眠。<br><code>通常，在工作队列和软中断tasklet中做出选择非常容易。如果推后执行的任务需要睡眠，那么就选择工作队列。如果推后执行的任务不需要睡眠，那么就选择软中断或tasklet。</code>实际上，工作队列通常可以用内核线程去替换。但是由于内核开发者们非常反对创建新的内核线程（在有些场合，使用这种冒失的办法可能会吃到苦头），所以我们也推荐使用工作队列。当然，这种接口也的确很容易使用。<br><code>如果你需要用一个可以重新调度的实体来执行你的下半部处理，你应该使用工作队列。</code>它是唯一能在进程上下文中运行的下半部实现机制，也只有它才可以睡眠。这意味着在你需要获得大量的内存时，在你需要获取信号量时，在你需要执行阻塞式的I&#x2F;O操作时，它都会非常有用，如果你不需要用一个内核线程来推后执行工作，那么就考虑使用tasklet吧。</p>
<h2 id="工作队列的实现"><a href="#工作队列的实现" class="headerlink" title="工作队列的实现"></a>工作队列的实现</h2><p>工作队列子系统是一个用于创建内核线程的接口，通过它创建的进程负责执行由内核其他部分排到队列里的任务。它创建的这些内核线程称作工作者线程（worker thread）。工作队列可以让你的驱动程序创建一个专门的工作者线程来处理需要退后的工作。不过，工作队列子系统提供了一个缺省的工作者线程来处理这些工作。因此，工作队列最基本的表现形式，就转变成了一个把需要推后执行的任务交给特定的通用线程的这样一种接口。<br>缺省的工作者线程叫做events&#x2F;n，这里n是处理器的编号；每个处理器对应一个线程。例如，单处理器的系统只有events&#x2F;0这样一个线程。而双处理器的系统就会多一个events&#x2F;1线程。缺省的工作者线程会从多个地方得到被推后的工作。许多内核驱动程序都把它们的下半部交给缺省的工作者线程去做。除非一个驱动程序或者子系统必须建立一个属于它自己的内核线程，否则最好使用缺省线程。<br>不过并不存在什么东西能够阻止代码创建属于自己的工作者线程。如果你需要在工作者线程中执行大量的处理操作，这样做或许会带来好处。处理器密集型和性能要求严格的任务会因为拥有自己的工作者线程而获得好处。此时这么做也有助于减轻缺省线程的负担，避免工作队列中其他需要完成的工作处于饥饿状态。</p>
<h3 id="表示线程的数据结构"><a href="#表示线程的数据结构" class="headerlink" title="表示线程的数据结构"></a>表示线程的数据结构</h3><p>工作者线程用workqueue_struct结构表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    外部可见的工作队列抽象是</span></span><br><span class="line"><span class="comment">    由每个CPU的工作队列组成的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> <span class="title">cpu_wq</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> singlethread;</span><br><span class="line">    <span class="type">int</span> freezeable;</span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构内是一个由cpu_workqueue_struct结构组成的数组，它定义在<code>kernel/workqueue.c</code>中，数组的每一项对应系统中的一个处理器。由于系统中每个处理器对应一个工作者线程，所以对于给定的某台计算机来说，就是每个处理器，每个工作者线程对应一个这样的cpu_workqueue_struct结构体。cpu_workqueue_struct是<code>kernel/workqueue.c</code>中的核心数据结构：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;                    <span class="comment">//锁保护这种结构</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">worklist</span>;</span>          <span class="comment">//工作列表</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> more_work;        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_struct</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>        <span class="comment">//关联工作队列结构</span></span><br><span class="line">    <span class="type">task_t</span> *thread;                     <span class="comment">//关联线程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，每个工作者线程类型关联一个自己的workqueue_struct。在结构体里面，给每个线程分配一个cpu_workqueue_struct，因而也就是给每个处理器分配一个，因为每个处理器都有一个该类型的工作者线程。</p>
<h3 id="表示工作的数据结构"><a href="#表示工作的数据结构" class="headerlink" title="表示工作的数据结构"></a>表示工作的数据结构</h3><p>所有的工作者线程都是普通的内核线程实现的，它们都要执行worker_thread()函数。在它初始化完之后，这个函数执行一个死循环并开始休眠。当有操作被插入到队列里的时候，线程就会被唤醒，以便执行这些操作。当没有剩余的操作时，它又会继续休眠。<br>工作用&lt;linux&#x2F;workqueue.h&gt;中定义的work_struct结构体表示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">work_func_t</span> func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些结构体被连接成链表，在每个服务器上的每种类型的队列都对应这样一个链表。比如，每个处理器上用于执行被推后的工作的那个通用线程都有一个这样的链表。当一个工作者线程被唤醒时，它会执行它的链表上的所有工作。工作被执行完毕，它就将相应的work_struct对象从链表上移去，当链表上不再有对象时，它就会继续休眠。<br>我们可以看一下worker_thread()函数的核心流程，简化如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    prepare_to_wait(&amp;cwq-&gt;more_work,&amp;wait,TASK_INTERRUPTIBLE);</span><br><span class="line">    <span class="keyword">if</span>(list_empty(&amp;cwq-&gt;worklist))</span><br><span class="line">        schedule();</span><br><span class="line">    finish_wait(&amp;cwq-&gt;more_work,&amp;wait);</span><br><span class="line">    run_workqueue(cwq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数在死循环中完成了以下功能：</p>
<ol>
<li>线程将自己设置为休眠状态（state被设成TASK_INTERRUPTIBLE），并把自己加入到等待队列中。</li>
<li>如果工作链表是空的，线程调用schedule()函数进入睡眠状态。</li>
<li>如果链表中有对象，线程不会睡眠。相反，它将自己设置成TASK_RUNNNING，脱离等待队列。</li>
<li>如果链表非空，调用run_workqueue()函数执行被推后的工作。</li>
</ol>
<p>下一步，由run_workqueue()函数来实际完成推后到此的工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">while</span>(!list_empty(&amp;cwq-&gt;worklist)) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span>;</span></span><br><span class="line">    <span class="type">work_func_t</span> f;</span><br><span class="line">    <span class="type">void</span> *data;</span><br><span class="line"></span><br><span class="line">    work = list_entry(cwq-&gt;worklist.next,<span class="keyword">struct</span> work_struct,entry);</span><br><span class="line">    f = work-&gt;func;</span><br><span class="line">    list_del_init(cwq-&gt;worklist.next);</span><br><span class="line">    work_clear_pending(work);</span><br><span class="line">    f(work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数循环遍历链表上每个待处理的工作，执行链表每个节点上的workqueue_struct中的成员函数：</p>
<ol>
<li>当链表不为空时，选取下一个节点对象。</li>
<li>获取我们希望执行的函数func及其参数data。</li>
<li>把该节点从链表上解下来，将待处理标志位pending清零。</li>
<li>调用函数。</li>
<li>重复执行。</li>
</ol>
<h3 id="工作队列实现机制的总结"><a href="#工作队列实现机制的总结" class="headerlink" title="工作队列实现机制的总结"></a>工作队列实现机制的总结</h3><p>这些数据之间的关系确实让人觉得混乱，难以理清头绪。下面的示意图把所有的这些关系放在一起进行解释。<br><img src="/2022/11/11/%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C/1.jpeg" alt="img not found"><br>位于最高一层的是工作者线程。系统允许有多种类型的工作者线程存在。对于指定的一个类型，系统的每个CPU上都有一个该类的工作者线程。内核中有些部分可以根据需要来创建工作者线程，而在默认情况下内核只有event这一种类型的工作者线程。每个工作者线程都由一个cpu_workqueue_struct结构体表示。而workqueue_struct结构体则表示给定类型的所有工作者线程。<br>例如，除系统默认的通用events工作者类型之外，我还自己加入了一种falcon工作者类型。并且使用的是一个拥有四个处理器的计算机。那么，系统中现有四个event类型的线程（因而也就有四个cpu_workqueue_struct结构体）和四个falcon类型的线程（因而会有另外四个cpu_workqueue_struct）。同时，有一个对应event类型的workqueue_struct和一个对应falcon类型的workqueue_struct。<br>工作处于最底层，让我们从这里开始。你的驱动程序创建这些需要推后执行的工作。它们用work_struct结构来表示。这个结构体中最重要的部分是一个指针，它指向一个函数，而正是该函数负责处理需要推后执行的具体任务。工作会被提交给某个具体的工作者线程–在这种情况下，就是特殊的falcon线程。然后这个工作者线程会被唤醒并执行这些排好的工作。<br>大部分驱动程序都使用的是现存的默认工作者线程。它们使用起来简单、方便。可是，在有些要求更严格的情况下，驱动程序需要自己的工作者线程。比如说XFS文件系统就为自己创建了两种新的工作者线程。</p>
<h2 id="使用工作队列"><a href="#使用工作队列" class="headerlink" title="使用工作队列"></a>使用工作队列</h2><p>工作队列的使用非常简单。我们先来看一下缺省的events任务队列，然后再看看创建新的工作者线程。</p>
<h3 id="创建推后的工作"><a href="#创建推后的工作" class="headerlink" title="创建推后的工作"></a>创建推后的工作</h3><p>首先要做的是实际创建一些需要推后完成的工作。可以通过DECLARE_WORK在编译时静态的创建该结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_WORK(name,<span class="type">void</span>(*func)(<span class="type">void</span> *),<span class="type">void</span> *data);</span><br></pre></td></tr></table></figure>
<p>这样就会静态地创建一个名为name，处理函数为func，参数为data的work_struct结构体。<br>同样，也可以在运行时通过指针创建一个工作：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">INIT_WORK(<span class="keyword">struct</span> work_struct *work,<span class="type">void</span> (*func),<span class="type">void</span> *data);</span><br></pre></td></tr></table></figure>
<p>这会动态的初始化一个由work指向的工作，处理函数为func，参数为data。</p>
<h3 id="工作队列处理函数"><a href="#工作队列处理函数" class="headerlink" title="工作队列处理函数"></a>工作队列处理函数</h3><p>工作队列处理函数的原型是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">work_handler</span><span class="params">(<span class="type">void</span> *data)</span></span><br></pre></td></tr></table></figure>
<p>这个函数会由一个工作者线程执行，因此，函数会运行在进程上下文中。默认情况下，允许响应中断，并且不持有任何锁。如果需要，函数可以睡眠。需要注意的是，尽管操作处理函数运行在进程上下文中，但它不能访问用户空间，因为内核线程在用户空间没有相关的内存映射。通常发生在系统调用时，内核会代表用户空间的进程运行，此时它才能访问用户空间，也只有在此时它才会映射用户空间的内存。<br>在工作队列和内核其他部分之间使用锁机制就像在其他的进程上下文中使用锁机制一样方便。这使编写处理函数变得相对容易。</p>
<h3 id="对工作进行调度"><a href="#对工作进行调度" class="headerlink" title="对工作进行调度"></a>对工作进行调度</h3><p>现在工作已经被创建，我们可以调度它了。想要把给定工作的处理函数提交给缺省的events工作线程，只需调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">schedule_work(&amp;work);</span><br></pre></td></tr></table></figure>
<p>work马上就会被调度，一旦其所在的处理器上的工作者线程被唤醒，它就会被执行。<br>有时候你并不希望工作马上就被执行，而是希望它经过一段延迟以后在执行。在这种情况下，你可以调度它在指定的时间执行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">schedule_delayed_work(&amp;work,delay);</span><br></pre></td></tr></table></figure>
<p>这时，&amp;work指向的work_struct直到delay指定的时钟节拍用完以后才会执行。</p>
<h3 id="刷新操作"><a href="#刷新操作" class="headerlink" title="刷新操作"></a>刷新操作</h3><p>排入队列的工作会在工作者线程下一次被唤醒的时候执行。有时，在继续下一步工作之前，你必须保证一些操作已经执行完毕了。这一点对模块来说就很重要，在卸载之前，它就有可能需要调用下面的函数。而在内核的其他部分，为了防止竞争条件的出现，也可能需要确保不再有待处理的工作。<br>处于以上目的，内核准备了一个用于刷新指定工作队列的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">flush_schedule_work</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>函数会一直等待，直到队列中所有对象都被执行以后才返回。在等待所有待处理的工作执行的时候，该函数会进入休眠状态，所以只能在进程上下文中使用它。<br>注意，该函数并不取消任何延迟执行的工作。就是说，任何通过schedule_delayed_work()调度的工作，如果其延迟时间未结束，它并不会因为调用flush_schedule_work()而被刷新掉。取消延迟执行的工作应该调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">cancle_delayed_work</span><span class="params">(<span class="keyword">struct</span> work_struct *work)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数可以取消任何与work_struct相关的挂起工作。</p>
<h3 id="创建新的工作队列"><a href="#创建新的工作队列" class="headerlink" title="创建新的工作队列"></a>创建新的工作队列</h3><p>如果缺省的队列不能满足你的需要，你应该创建一个新的工作队列和与之相应的工作者线程。由于这么做会在每个处理器上都创建一个工作者线程，所以只有在你明确了必须要靠自己的一套线程来提高性能的情况下，在创建自己的工作队列。<br>创建一个新的任务队列和与之相关的工作者线程，你只需调用一个简单的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> workqueue_struct *<span class="title function_">create_workqueue</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure>
<p>name参数用于该内核线程的命名。比如，缺省的events队列的创建就调用的是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">keventd_wq</span>;</span></span><br><span class="line">keventd_wq = create_workqueue(<span class="string">&quot;events&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这样就会创建所有的工作者线程（系统中的每个处理器都有一个），并且做好所有开始处理工作之前的准备工作。<br>创建一个工作的时候无须考虑工作队列的类型。在创建之后，可以调用下面列举的函数。这些函数与schedule_work()以及schedule_delayed_work()相近，唯一的区别就在于它们针对给定的工作队列而不是缺省的events队列进行操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">queue_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,<span class="keyword">struct</span> work_struct *work)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">queue_delayed_work</span><span class="params">(<span class="keyword">struct</span> workqueue_struct *wq,</span></span><br><span class="line"><span class="params">                        <span class="keyword">struct</span> work_struct *work,</span></span><br><span class="line"><span class="params">                        <span class="type">unsigned</span> <span class="type">long</span> delay)</span>;</span><br></pre></td></tr></table></figure>
<p>最后，你可以调用下面的函数刷新指定的工作队列：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">flush_workqueue(<span class="keyword">struct</span> workqueue_struct *wq);</span><br></pre></td></tr></table></figure>
<p>该函数和前面讨论过的flush_schedule_work()作用相同，只是在它返回前等待清空的是给定的队列。</p>
<h2 id="老的任务队列机制"><a href="#老的任务队列机制" class="headerlink" title="老的任务队列机制"></a>老的任务队列机制</h2><p>像BH接口被软中断和tasklet代替一样，由于任务队列接口存在的种种缺陷，它也被工作队列接口取代了。像tasklet一样，任务队列接口（内核中常常被称为tq）其实也和进程没什么相关之处。任务队列接口的使用者在2.5开发版本中分为两部分，其中一部分转向了使用tasklet，还有另一部分继续使用任务队列接口。而目前任务队列接口剩余的部分已经演化成了工作队列接口。由于任务队列在内核中曾经使用过一段时间，出于了解历史的目的，我们对它进行了大体回顾。<br>任务队列机制通过定义一组队列来实现其功能。每个队列都有自己的名字，比如调度程序队列、立即队列和定时器队列。不同的队列在内核中的不同场合使用。keventd内核线程负责执行调度程序队列的相关任务。它是整个工作队列接口的先驱。定时器队列会在系统定时器的每个时间节拍执行，而立即队列能够得到双倍的运行机会，以保证它能够“立即执行”。当然，还有其他一些队列。此外，你还可以动态地创建自己的新队列。<br>这些听起来都挺有用，但任务队列，接口实际上是一团乱麻。这些队列基本上都是些随意创建的抽象概念，散落在内核各处，就像飘散在空气中。唯有调度队列有点意义，它能用来把工作推后到进程上下文完成。<br>任务队列唯一的好处就是接口特别简单。如果不考虑这些队列的数量和执行时随心所欲的规则，它的接口确实够简单。但这也就是全部意义所在了–任务队列剩下的东西乏善可陈。<br>许多任务队列接口的使用者都已经转向使用其他的下半部实现机制了，大部分选择了tasklet，只有调度程序队列的使用者在苦苦支撑。最终，keventd代码演化成了我们今天使用的工作队列机制，而任务队列最终推出了历史舞台。</p>
<h1 id="下半部机制的选择"><a href="#下半部机制的选择" class="headerlink" title="下半部机制的选择"></a>下半部机制的选择</h1><p>在各种不同的下半部实现机制之间做出选择是很重要的。在当前的2.6版的内核中，有三种可能的选择：<code>软中断、tasklet和工作队列</code>。tasklet基于软中断实现，所以两者很相近。工作队列机制与它们完全不同，它靠内核线程实现。<br>从设计的角度考虑，软中断提供的执行序列化的保障最少。这就要求软中断处理函数必须格外小心地采取一些步骤确保共享数据的安全，两个甚至更多相同类别的软中断有可能在不同的处理器上同时执行。<code>如果被考察的代码本身多线索化的工作就做得非常好，比如网络子系统，它完全使用单处理器变量，那么软中断就是非常好的选择。</code>对于时间要求严格和执行频率很高的应用来说，它执行得也最快。<br><code>如果代码多线索化考虑得并不充分，那么选择tasklet意义更大。</code>它的接口非常简单，而且，由于两个同种类型的tasklet不能同时执行，所以实现起来也会简单一些。<code>tasklet是有效的软中断，但不能并发运行。</code>驱动程序开发者应当尽可能选择tasklet而不是软中断，当然，如果准备利用每一处理器上的变量或者类似的情形，以确保中断能安全地在多个处理器上并发地运行，那么还是选择软中断。<br><code>如果你需要把任务推后到进程上下文中完成，那么这三者中就只能选择工作队列了。如果进程上下文并不是必须的条件（就是如果并不需要睡眠），那么软中断和tasklet可能更适合。工作队列造成的开销最大，因为它要牵扯到内核线程甚至是上下文切换。这并不是说工作队列的效率低，如果每秒有几千次中断，就像网络子系统时常经历的那样，那么采用其他的机制可能更合适一些。尽管如此，针对大部分情况，工作队列都能提供足够的支持。</code><br>如果讲到易于使用，工作队列就当仁不让了。使用缺省的events队列简直不费吹灰之力。接下来是tasklet，它的接口也很简单。最后才是<code>软中断，它必须静态创建</code>，并且需要慎重考虑其实现。<br><strong>对下半部的比较</strong></p>
<table>
<thead>
<tr>
<th>下半部</th>
<th>上下文</th>
<th>顺序执行保障</th>
</tr>
</thead>
<tbody><tr>
<td>软中断</td>
<td>中断</td>
<td>没有</td>
</tr>
<tr>
<td>tasklet</td>
<td>中断</td>
<td>同类型不能同时执行</td>
</tr>
<tr>
<td>工作队列</td>
<td>进程</td>
<td>没有（和进程上下文一样被调度）</td>
</tr>
</tbody></table>
<p><code>简单的说，一般的驱动程序的编写者需要做出两个选择。首先，你是不是需要一个可调度的实体来执行需要推后完成的工作--从根本上来说，你有休眠的需要吗？要是有，工作队列就是你的唯一选择。否则最好用tasklet。要是必须专注于性能的提高，那么就考虑软中断吧。</code></p>
<h1 id="在下半部之间加锁"><a href="#在下半部之间加锁" class="headerlink" title="在下半部之间加锁"></a>在下半部之间加锁</h1><p>到现在为止，我们还没讨论过锁机制，这是一个非常有趣且广泛的话题。在使用下半部机制时，即使是在一个单处理器的系统上，避免共享数据被同时访问也是至关重要的。记住，一个下半部实际上可能在任何时候执行。<br>使用tasklet的一个好处在于，它自己负责执行的序列化保障：两个相同类型的tasklet不允许同时执行，即使在不同的处理器上也不行。这意味着你无须为intra-tasklet的同步问题操心了。tasklet之间的同步（就是当两个不同类型的tasklet共享同一数据时）需要正确使用锁机制。<br>如果进程上下文和一个下半部共享数据，在访问这些数据之前，你需要禁止下半部的处理并得到锁的使用权。做这些是为了本地和SMP的保护并且防止死锁的出现。<br>如果中断上下文和一个下半部共享数据，在访问数据之前，你需要禁止中断并得到锁的使用权。所做的这些也是为了本地和SMP的保护并且防止死锁的出现。<br>任何在工作队列中被共享的数据也需要使用锁机制。其中有关锁的要点和在一般内核代码中没什么区别，因为工作队列本来就是在进程上下文中执行的。</p>
<h1 id="禁止下半部"><a href="#禁止下半部" class="headerlink" title="禁止下半部"></a>禁止下半部</h1><p>一般单纯禁止下半部的处理是不够的。为了保证共享数据的安全，更常见的做法是，先得到一个锁然后再禁止下半部的处理。驱动程序中通常使用的都是这种方法。然而，如果你编写的是内核的核心代码，你也可能仅需要禁止下半部就可以了。<br>如果需要禁止所有的下半部处理（明确点说，就是所有的软中断和所有的tasklet），可以调用local_bh_disable()函数。允许下半部进行处理，可以调用local_bh_enale()函数。没错，这些函数的命名也有问题；可是既然BH接口早就让位给软中断了，那么谁又会去改这些名称呢？</p>
<p><strong>下半部机制控制函数的清单</strong></p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>void local_bh_disable()</td>
<td>禁止本地处理器的软中断和tasklet的处理</td>
</tr>
<tr>
<td>void local_bh_enale()</td>
<td>激活本地处理器的软中断和tasklet的处理</td>
</tr>
</tbody></table>
<p>这些函数有可能被嵌套使用–最后被调用的local_bh_enable()最终被激活下半部。比如，第一次调用local_bh_disable()，则本地软中断处理被禁止；如果local_bh_disable()被调用三次，则本地处理仍然被禁止；只有当第四次调用local_bh_enable()时，软中断处理才被重新激活。<br>函数通过preempt_count（很有意思，还是这个计数器，内核抢占的时候用的也是它）为每个进程维护一个计数器。当计数器变为0时，下半部才能够被处理。因为下半部的处理已经被禁止，所以local_bh_enable()还需要检查所有现存的待处理的下半部并执行它们。<br>这些函数与硬件体系结构相关，它们位于&lt;asm&#x2F;softirq.h&gt;中，通常由一些复杂的宏实现。下面是为那些好奇的人准备了C语言的近似描述：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    通过增加preempt_count禁止本地下半部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">local_bh_disable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">t</span> =</span> current_thread_info();</span><br><span class="line">    t-&gt;preempt_count += SOFTIRQ_OFFSET;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    减少preempt_count如果返回值为0，将导致自动激活下半部</span></span><br><span class="line"><span class="comment">    执行挂起的下半部</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">local_bh_enable</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">thread_info</span> *<span class="title">t</span> =</span> current_thread_info();</span><br><span class="line">    t-&gt;preempt_count -= SOFTIRQ_OFFSET;</span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">        preempt_count是否为0，另外是否有挂起的下半部，如果都满足，则执行</span></span><br><span class="line"><span class="comment">        待执行的下半部</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="keyword">if</span>(unlikely(!t-&gt;preemt_count &amp;&amp; softirq_pending(smp_processer_id())))</span><br><span class="line">        do_softirq();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这些函数并不能禁止工作队列的执行。因为工作队列是在进程上下文中执行的，不会涉及异步执行的问题，所以也就没有必要禁止它们执行。由于软中断和tasklet是异步发生的（就是说，在中断处理返回的时候），所以，内核代码必须禁止它们。另一方面，对于工作队列来说，它保护共享数据所做的工作和其他进程上下文中所做的都差不多。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>在本章中，我们涵盖了用于延迟Linux内核工作的三种机制：软中断、tasklet和工作队列。我们考察了其设计和实现，讨论了如何把这些机制应用到代码中，也调侃了易于混淆的命名。为了完整起见，我们也考察了曾经的下半部机制：BH和任务队列–这些用在以前的Linux内核版本中。<br>因为下半部中相当程度地用到了同步和并发，所以本章谈了很多相关的话题。我们甚至围绕本章讨论了禁止下半部的问题，这是由并发保护引起的，这一话题到此只是刚刚引入的。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第8章 中断下半部和推后执行的工作</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内核同步方法</title>
    <url>/2022/11/18/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>上一章讨论了竞争条件为何会产生以及怎么去解决。幸运的是，Linux内核提供了一组相当完备的同步方法，这些方法使得内核开发者们能编写出高效而又自由竞争的代码。本章讨论的就是这些方法，包括它们的接口、行为和用途。</p>
<span id="more"></span>

<h1 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h1><p>我们首先介绍同步方法中的原子操作，因为它是其他同步方法的基石。原子操作可以保证指令以原子的方式执行–执行过程不被打断。众所周知，原子原本指的是不可分割的微粒，所以原子操作也就是不能够被分割的指令。例如，上一章曾提到过原子操作的加操作，它通过把读取和增加变量的行为包含在一个单步中执行，从而防止了竞争的发生保证了操作结果总是一致的。一起来回忆一下这个整数增加递加过程中遇到的竞争吧：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1               线程2</span><br><span class="line">获得i(T)            获得i(7)</span><br><span class="line">增加i(7-&gt;8)         ----</span><br><span class="line">----                增加i(8-&gt;9)</span><br><span class="line">写回i(8)            ----</span><br><span class="line">----                写回i(8)</span><br></pre></td></tr></table></figure>
<p>使用原子操作，上述的竞争不会发生—事实上不可能发生。从而，计算过程无疑会是下述之一：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">线程1                                   线程2</span><br><span class="line">获得、增加和存储i(7-&gt;8)                  ----</span><br><span class="line">----                                    获得、增加和存储i(8-&gt;9)</span><br><span class="line"></span><br><span class="line">或者是</span><br><span class="line">线程2                                   线程1</span><br><span class="line">获得、增加和存储i(7-&gt;8)                  ----</span><br><span class="line">----                                    获得、增加和存储i(8-&gt;9)</span><br></pre></td></tr></table></figure>
<p>最后得到的是9，毫无疑问是正确结果。两个原子操作绝对不可能并发地访问同一个变量，这样加操作也就绝不可能引起竞争。<br>内核提供了两组原子操作接口—-一组针对整数进行操作，另一组针对单独的位进行操作。在Linux支持的所有体系结构上都实现了这两组接口。大多数体系结构会提供支持原子操作的简单算数指令。而有些体系结构确实缺少简单的原子操作指令，但是也为单步执行提供了锁内存总线的指令，这就确保了其他改变内存的操作不能同时发生。</p>
<h2 id="原子整数操作"><a href="#原子整数操作" class="headerlink" title="原子整数操作"></a>原子整数操作</h2><p>针对整数的原子操作只能对atomic_t类型的数据进行处理。在这里之所以引入了一个特殊数据类型，而没有直接使用C语言的int类型，主要是出于两个原因：首先，让原子函数只接收atomic_t类型的操作数，可以确保原子操作只与这种特殊类型数据一起使用。同时，这也保证了该类型的数据不会被传递给任何非原子函数。实际上，对一个数据一会儿要采用原子操作，一会儿又不用原子操作，这又能有什么好处？其次，使用atomic_t类型确保编译器不对（不能说完美地完成了任务但不乏自知之明）相应的值进行访问优化—-这点使得原子操作最终接收到正确的内存地址，而不只是个别名。最后，在不同体系结构上实现原子操作的时候，使用atomic_t可以屏蔽其间的差异。atomic_t类型定义在文件&lt;linux&#x2F;types.h&gt;中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">int</span> counter;</span><br><span class="line">&#125;<span class="type">atomic_t</span>;</span><br></pre></td></tr></table></figure>
<p>尽管Linux支持的所有机器上的整形数据都是32位的，但是使用atomic_t的代码只能将该类型的数据当作24位来使用。这个限制完全是因为在SPARC体系结构上，原子操作的实现不同于其他其他体系结构：32位int类型的低8位被嵌入了一个锁，如下图所示：<br><img src="/2022/11/18/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/1.jpeg" alt="img not found"><br>因为SPARC体系结构对原子操作缺乏指令级的支持，所以只能利用该锁来避免对原子类型数据的并发访问。所以在SPARC机器上就是只能使用24位了。虽然其他机器上的代码完全可以使用全部的32位，但在SPARC机器上却可能造成了一些奇怪和微妙的错误—-这简直太不和谐了。最近，机灵的黑客已经允许SPARC提供全32位的atomic_t，这一限制不存在了。<br>使用原子整形操作需要的声明都在&lt;asm&#x2F;atomic.h&gt;文件中。有些体系结构会提供一些只能在该体系结构上使用的额外原子操作方法，但所有的体系结构都能保证内核使用到的所有操作的最小集。在写内核代码时，可以肯定，这个最小操作集在所有体系结构上都已经实现了。<br>定义一个atomic_t类型的数据方法很平常，你还可以定义时给它设定初值：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">atomic_t</span> v;                     <span class="comment">//定义v</span></span><br><span class="line"><span class="type">atomic_t</span> u = ATOMIC_INIT(<span class="number">0</span>);    <span class="comment">//定义u并把它初始化为0</span></span><br></pre></td></tr></table></figure>
<p>操作也都非常简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">atomic_set</span>(&amp;v,<span class="number">4</span>);       <span class="comment">//v = 4（原子地）</span></span><br><span class="line"><span class="type">atomic_add</span>(<span class="number">2</span>,&amp;v);       <span class="comment">//v = v + 2 = 6（原子地）</span></span><br><span class="line"><span class="type">atomic_inc</span>(&amp;v);         <span class="comment">//v = v + 1 = 7（原子地）</span></span><br></pre></td></tr></table></figure>
<p>如果需要将atomic_t转换成int型，可以使用atomic_read()来完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">printk(<span class="string">&quot;%d\n&quot;</span>,<span class="type">atomic_read</span>(&amp;v)); <span class="comment">//会打印“7”</span></span><br></pre></td></tr></table></figure>
<p>原子操作最常见的用途就是实现计数器。使用复杂的锁机制来保护一个单纯的计数器显然杀鸡用了宰牛刀，所以，开发者最好使用atomic_inc()和atomic_dec()这两个相对来说轻便一点的操作。<br>还可以用原子整数操作原子地执行一个操作并检查结果。一个常见的例子就是原子地减操作和检查。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">atomic_dec_and_test</span><span class="params">(<span class="type">atomic_t</span> *v)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数将给定的原子变量减1，如果结果为0，就返回真；否则返回假。下表列出了所有的标准原子整数操作（所有体系结构都包含这些操作）。某种特定的体系结构上实现的所有操作可以在文件&lt;asm&#x2F;atomic.h&gt;中找到。<br><strong>原子整数操作列表</strong><br><img src="/2022/11/18/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/2.jpeg" alt="img not found"><br>原子操作通常是内联函数，往往是通过内嵌汇编指令来实现的。如果某个函数本来就是原子的，那么它往往就会被定义成一个宏。例如，在大部分体系结构上，读取一个字本身就是一种原子操作，也就是说，在对一个字进行写入操作期间不可能完成对该字的读取。这样，把atomic_read()定义成一个宏，只须返回atomic_t类型的整数值就可以了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    atomic_read - read atomic variable</span></span><br><span class="line"><span class="comment">    @v: pointer of type atomic_t</span></span><br><span class="line"><span class="comment">    Atomically reads the value of @v</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">int</span> <span class="title function_">atomic_read</span><span class="params">(<span class="type">const</span> <span class="type">atomic_t</span> *v)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> v-&gt;counter;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>原子性和顺序性的比较</strong><br>关于原子读取的上述讨论引发了原子性和顺序性之间差异的讨论。正如所讨论的，一个字长的读取总是原子的发生，绝不可能对同一个字交错的进行写；读总是返回一个完整的字，这或者发生在写操作之前，或者之后，绝不可能发生在写的过程中。例如，如果一个整数初始化为42，然后又置为365，那么读取这个整数肯定会返回42或者365，而绝不会是二者的混合。这就是我们所谓的原子性。<br>也许代码比这又更多的要求。或许要求读必须在待定的写之前发生—-这种需求其实不属于原子性要求，也是顺序要求。原子性确保指令执行期间不被打断，要么全部执行完，要么根本不执行。另一方面，顺序性确保即使两条或多条指令出现在独立的执行线程中，甚至独立的处理器上，它们本该的执行顺序却依然要保持。<br>在本小节讨论的原子操作只保证</p>
<p>在编写代码的时候，能使用原子操作时，就尽量不要使用复杂的加锁机制。对多数体系结构来讲，原子操作与更复杂的同步方法相比较，给系统带来的开销小，对高速缓存行的影响也小。但是，对于那些有高性能要求的代码，对多种同步方法进行测试比较，不失为一种明智的做法。</p>
<h2 id="64位原子操作"><a href="#64位原子操作" class="headerlink" title="64位原子操作"></a>64位原子操作</h2><p>随着64位体系结构越来越普及，内核开发者确实在考虑原子变量除32位atomic_t类型外，也应引入64位的atomic64_t。因为移植性原因，atomic_t变量大小无法在体系结构之间改变。所以，atomic_t类型即便在64位体系结构下也是32位的，若要使用64位的原子变量，则要使用atomic64_t类型—-其功能和其32位的兄弟无异，使用方法完全相同，不同的只有整形变量大小从32位变成了64位。几乎所有的经典32位原子操作都有64位的实现，它们被冠以atomic64前缀，而32位实现冠以atomic前缀。下表是所有标准原子操作列表；有些体系结构实现的方式更多，但是没有移植性。与atomic_t一样，atomic64_t类型其实是对长整型的一个简单封装类。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">volatile</span> <span class="type">long</span> counter;</span><br><span class="line">&#125;<span class="type">atomic64_t</span>;</span><br></pre></td></tr></table></figure>
<p><strong>原子操作整形</strong><br><img src="/2022/11/18/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/3.jpeg" alt="img not found"></p>
<p>所有64位体系结构都提供了atomic64_t类型，以及一组对应的算法操作方法。但是多数32位体系结构不支持atomic64_t类型—-不过，x86-32是一个众所周知的例外。为了便于在Linux支持的各种体系结构之间移植代码，开发者应该使用32位的atomic_t类型。把64位的atomic64_t类型留给那些特殊体系结构和需要64位的代码吧。</p>
<h2 id="原子位操作"><a href="#原子位操作" class="headerlink" title="原子位操作"></a>原子位操作</h2><p>除了原子整数操作之外，内核也提供了一组针对位这一级数据进行操作的函数。没什么好奇怪的，它们是与体系结构相关的操作，定义在文件&lt;asm&#x2F;bitops.h&gt;中。<br>令人感到奇怪的是位操作函数是对普通的内存地址进行操作的。它的参数是一个指针和一个位号，第0位是给定地址的最低有效位。在32位机上，第31位是给定地址的最高有效位而第32位是下一个字的最低有效位。虽然使用原子位操作在多数情况下是对一个字长的内存进行访问，因而位号应该位于0-31（在64位机器上是0-63），但是，对位号的范围并没有限制。<br>由于原子位操作是对普通的指针进行的操作，所以不像原子整形对应atomic_t，这里没有特殊的数据类型。相反，只要指针指向了任何你希望的数据，你就可以对它进行操作。来看下一个例子：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> word = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">set_bit(<span class="number">0</span>,&amp;word);           <span class="comment">//第0位被设置（原子地）</span></span><br><span class="line">set_bit(<span class="number">1</span>,&amp;word);           <span class="comment">//第1位被设置（原子地）</span></span><br><span class="line">printk(<span class="string">&quot;%u1\n&quot;</span>,word);       <span class="comment">//打印3</span></span><br><span class="line">clear_bot(<span class="number">1</span>,&amp;word);         <span class="comment">//清空第1位</span></span><br><span class="line">change_bot(<span class="number">0</span>,&amp;word);        <span class="comment">//翻转第0位的值，这里它被清空</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//原子地设置第0位并且返回设置前的值(0)</span></span><br><span class="line"><span class="keyword">if</span>(test_and_set_bit(<span class="number">0</span>,&amp;word)) &#123;</span><br><span class="line">    <span class="comment">//永远不为真</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//下面的语句是合法的；你可以把原子位指令与一般的C语句混在一起</span></span><br><span class="line">word = <span class="number">7</span>;</span><br></pre></td></tr></table></figure>
<p>下表给出了标准原子位操作列表。<br><img src="/2022/11/18/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/4.jpeg" alt="img not found"></p>
<p>为方便起见，内核还提供了一组与上述操作对应的非原子位函数。非原子位函数与原子位函数的操作完全相同，但是，前者不保证原子性，但其名字前缀多两个下划线。例如，与test_bit()对应的非原子形式是__test_bit()。如果你不需要原子性操作（比如说，你已经用锁保护了自己的数据），那么这些非原子的位函数相比原子的位函数可能会执行的更快些。</p>
<p><strong>非原子位操作到底是什么？</strong><br>乍一看，非原子位操作没有任何意义。因为仅仅涉及一个位，所以不存在发生矛盾的可能。只要其中的一个操作成功，还会有什么事情？的确，顺序性可能是重要的，但我们在此正谈论原子性。到了最后，如果这一位有了任一条指令所设置的值，我们应当友好的离开，对吗？<br>让我们跳回到原子性看看到底意味着什么。原子性意味着，或者指令完整地成功执行完，不被打断，或者根本不执行。所以，如果你连续执行两个原子位操作，你会希望两个操作都成功。在操作都完成后，位的值应该是第二个操作所赋予的。但是，在最后一个操作发生前的某个时间点，位的值应该维持第一个操作所赋予的。但是，在最后一个操作发生前的某个时间点，位的值应该维持第一个操作所赋予的。换句话说，真正的原子操作需要的是—-所有中间结果都正确无误。<br>例如，假定给出的两个原子位操作：先对某位置位，然后清零。如果没有原子操作，那么，这一位可能的确清零了，但是也可能根本没有置位。置位操作可能与清除操作同时发生，但没有成功。清除操作可能成功了，这一位如愿呈现位清零。但是，有了原子操作，置位会真正发生，可能有那么一刻，读操作显示所置的位，然后清除操作才执行，该位变为0了。<br>这种行为可能是重要的，尤其当顺序性开始起作用的时候，或者当操作硬件寄存器的时候。</p>
<p>内核还提供了两个例程用来从指定的地址开始搜索第一个被设置（或未被设置）的位。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">find_first_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *addr,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">find_first_zero_bit</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> *addr,<span class="type">unsigned</span> <span class="type">int</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>这两个函数中第一个参数是一个指针，第二个参数是要搜索的总位数，返回值分别是第一个被设置好的（或没被设置的）位的位号。如果你的搜索范围仅限于一个字，使用_ffs()和ffz()这两个函数更好，它们只需要给定一个要搜索的地址做参数。<br>与原子整数操作不同，代码一般无法选择是否使用位操作，它们是唯一的、具有可移植性的设置特定位方法，需要选择的是使用原子位操作还是非原子位操作。如果你的代码本身已经避免了竞争条件，你可以使用非原子位操作，通常这样执行更快，当然，这还要取决于具体的体系结构。</p>
<h1 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h1><p>如果每个临界区都能像增加变量那样简单就好了，可以现实总是残酷的。现实世界里，临界区甚至可以跨越多个函数。举个例子，我们经常会碰到这种情况：先得从一个数据结构中移出数据，对其进行格式转换和解析，最后再把它加入到另一个数据结构中。整个执行过程必须是原子的，在数据被更新完之前，不能有其他代码来读取这些数据。显然，简单的原子操作对此无能为力，这就需要使用更为复杂的同步方法—-锁来提高保护。<br>Linux内核中最常见的锁是自旋锁（spin lock）。自旋锁最多只能被一个可执行线程持有。如果一个执行线程试图获得一个被已经持有的（即所谓的争用）自旋锁，那么该线程就会一直进行忙循环–旋转–等待锁重新可用。要是锁未被争用，请求锁的执行线程便能立刻得到它，继续执行。在任意时间，自旋锁都可以防止多于一个的执行线程同时进入临界区。同一个锁可以用在多个位置，例如，对于给定数据的所有访问都可以得到保护和同步。<br>再回到上一章门和锁的例子，自旋锁相当于坐在门外等待同伴从里面出来，并把钥匙交给你。如果你到了门口，发现里面没人，就可以抓到钥匙进入房间。如果你到了门口发现里面正好有人，就必须在门外等待钥匙，不断地检查房间是否为空。当房间为空时，你就可以抓到钥匙进入。正是因为有了钥匙（相当于自旋锁），才允许一次只有一个人（相当于执行线程）进入房间（相当于临界区）。<br>一个被争用的自旋锁使得请求它的线程在等待锁重新可用时自旋（特别浪费处理器时间），这种行为是自旋锁的要点。所以自旋锁不应该被长时间持有。事实上，这点正是使用自旋锁的初衷：在短期间内进行轻量级加锁。还可以采取另外的方式来处理对锁的争用：让请求线程睡眠，直到锁重新可用时再唤醒它。这样处理器就不必循环等待了，可以去执行其他代码。这也会带来一定的开销–这里有两次明显的上下文切换，被阻塞的线程要换出和换入，与实现自旋锁的少数几行代码相比，上下文切换当然有较多的代码。因此，持有自旋锁的时间最好小于完成两次上下文切换的耗时。当然我们大多数人都不会无聊到去测量上下文切换的耗时，所以我们让持有自选锁的时间应尽可能的短就可以了。在下面的内容中我们将讨论信号量，信号量提供了上述第二种锁机制，它使得发生争用时，等待的线程能投入睡眠，而不是旋转。</p>
<h2 id="自旋锁方法"><a href="#自旋锁方法" class="headerlink" title="自旋锁方法"></a>自旋锁方法</h2><p>自旋锁的实现和体系结构密切相关，代码往往通过汇编实现。这些与体系结构相关的代码定义在文件&lt;asm&#x2F;spinlock.h&gt;中，实际需要用到的接口定义在文件&lt;linux&#x2F;spinlock.h&gt;中。自旋锁的基本使用形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SPINLOCK(mr_lock);</span><br><span class="line">spin_lock(&amp;mr_lock);</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">spin_unlock(&amp;mr_lock);</span><br></pre></td></tr></table></figure>
<p>因为自旋锁在同一时刻至多被一个执行线程持有，所以一个时刻只能有一个线程位于临界区内，这就为多处理器机器提供了防止并发访问所需的保护机制。注意在单处理器机器上，编译的时候并不会加入自旋锁。它仅仅被当作一个设置内核抢占机制是否被启用的开关。如果禁止内核抢占，那么在编译时自旋锁会被完全剔除出内核。</p>
<p><strong>警告：自旋锁是不可递归的！</strong><br>Linux内核实现的自旋锁是不可递归的，这点不同于自旋锁在其他操作系统中的实现。所以如果你试图得到一个你正持有的锁，你必须自旋，等待你自己释放这个锁。但你处于自旋忙等待中，所以你永远没有机会释放锁，于是你被自己锁死了。千万小心自旋锁。</p>
<p>自旋锁可以使用中断处理程序中（此处不能用信号量，因为它会导致睡眠）。在中断处理程序中使用自旋锁时，一定要在获取锁之前，首先禁止本地中断（在当前处理器上的中断请求），否则，中断处理程序就会打断正持有锁的代码，有可能会试图去争用这个已经被持有的自旋锁。这样一来，中断处理程序就会自旋，等待该锁重新可用，但是锁的持有者在这个中断处理程序执行完毕之前不可能运行。这正是我们在前面的内容中提到的双重请求死锁。注意，需要关闭的只是当前处理器上的中断。如果中断发生在不同的处理器上，即使中断处理程序在同一锁上自旋，也不会妨碍锁的持有者（在不同处理器上）最终释放锁。<br>内核提供的禁止中断同时请求锁的接口，使用起来很方便，方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SPINLOCK(mr_lock);</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> flags;</span><br><span class="line"></span><br><span class="line">spin_lock_irqsave(&amp;mr_lock,flags);</span><br><span class="line"><span class="comment">//临界区</span></span><br><span class="line">spin_unlock_irqrestore(&amp;mr_lock,flags);</span><br></pre></td></tr></table></figure>
<p>函数spin_lock_irqsave()保存中断的当前状态，并禁止本地中断，然后再去获取指定的锁。反过来spin_unlock_irqrestore()对指定的锁解锁，然后让中断恢复到加锁前的状态。所以即使中断最初是被禁止的，代码也不会错误地激活它们，相反，会继续让它们禁止。注意，flags变量看起来像是由数值传递的，这是因为这些锁函数有些部分是通过宏的方式实现的。<br>在单处理器系统上，虽然在编译时抛弃掉了锁机制，但在上面例子中仍需要关闭中断，以禁止中断处理程序访问共享数据。加锁和解锁分别可以禁止和允许内核抢占。</p>
<p><strong>锁什么？</strong><br>使用锁的时候一定要对症下药，要有针对性。要知道需要保护的是数据而不是代码。尽管本章的例子讲的都是保护临界区的重要性，但是真正需要保护的其实是临界区中的数据，而不是代码。<br>大原则：<code>针对代码加锁会使得程序难以理解，并且容易引发竞争条件，正确的做法应该是对数据而不是代码加锁</code>。<br>既然不是对代码加锁，那就一定要用特定的锁来保护自己的共享资源。例如，“struct foo 由loo_lock加锁”。无论你何时需要访问共享数据，一定要先保证数据是安全的。而保证数据安全往往就意味着在对数据进行操作前，首先占用恰当的锁，完成操作后再释放它。</p>
<p>如果你能确定中断在加锁前是激活的，那就不需要在解锁后恢复中断以前的状态了。你可以无条件地在解锁时激活中断。这时，使用spin_lock_irq()和spin_unlock_irq()会更好一些。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_SPINLOCK(mr_lock);</span><br><span class="line"></span><br><span class="line">spin_lock_irq(&amp;mr_lock);</span><br><span class="line"><span class="comment">//关键节</span></span><br><span class="line">spin_unlock_irq(&amp;mr_lock);</span><br></pre></td></tr></table></figure>
<p>由于内核变得庞大而复杂，因此，在内核的执行路线上，你很难搞清楚中断在当前调用点上到底是不是处于激活状态。也正因为如此，我们并不提倡使用spin_lock_irq()方法。如果你一定要使用它，那你应该确定中断原来就处于激活状态，否则当其他人期望中断处于未激活状态时却发现处于激活状态，可能会很不开心。</p>
<p><strong>调试自旋锁</strong><br>配置选项CONFIG_DEBUG_SPINLOCK为使用自旋锁的代码加入许多调试检查手段。例如，激活了该选项，内核就会检查是否使用了未初始化的锁，是否在还没加锁的时候就要对锁执行开锁操作。在测试代码时，总是应该激活这个选项。如果需要进一步全程调试锁，还应该打开CONFIG_DEBUG_LOCK_ALLOC选项。</p>
<h2 id="其他针对自旋锁的操作"><a href="#其他针对自旋锁的操作" class="headerlink" title="其他针对自旋锁的操作"></a>其他针对自旋锁的操作</h2><p>你可以使用是spin_lock_init()方法来初始化动态创建的自旋锁（此时你只有一个指向spinlock_t类型的指针，没有它的实体）。<br>spin_try_lock()试图获得某个特定的自旋锁，如果该锁已经被争用，那么该方法会立刻返回一个非0值，而不会自旋等待锁被释放；如果成功获得了这个自旋锁，该函数返回0。同理，spin_is_locked()方法用于检查特定的锁当前是否已经被占用，如果已经被占用，返回非0值；否则返回0。该方法只做判断，并不实际占用。<br>下表给出了标准的自旋锁操作的完整列表。</p>
<p><strong>自旋锁方法列表</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>spin_lock()</td>
<td>获取指定的自旋锁</td>
</tr>
<tr>
<td>spin_lock_irq()</td>
<td>禁止本地中断并获取指定的锁</td>
</tr>
<tr>
<td>spin_lock_irqsave()</td>
<td>保存本地中断的当前状态，禁止本地中断，并获取指定的锁</td>
</tr>
<tr>
<td>spin_unlock()</td>
<td>释放指定的锁</td>
</tr>
<tr>
<td>spin_unlock_irq()</td>
<td>释放指定的锁，并激活本地中断</td>
</tr>
<tr>
<td>spin_unlock_irqrestore()</td>
<td>释放指定的锁，并让本地中断恢复到以前状态</td>
</tr>
<tr>
<td>spin_lock_init()</td>
<td>动态初始化指定的spinlock_t</td>
</tr>
<tr>
<td>sping_trylock()</td>
<td>试图获取指定的锁，如果未获取，则返回非0</td>
</tr>
<tr>
<td>spin_is_locked()</td>
<td>如果指定的锁当前正在被获取，则返回非0，否则返回0</td>
</tr>
</tbody></table>
<h2 id="自旋锁与下半部"><a href="#自旋锁与下半部" class="headerlink" title="自旋锁与下半部"></a>自旋锁与下半部</h2><p>在第8章中曾经提到过，在于下半部配合使用时，必须小心地使用锁机制。函数spin_lock_bh()用于获取指定锁，同时它会禁止所有下半部的执行。相应的spin_unlock_bh()函数执行相反的操作。<br>由于下半部可以抢占进程上下文中的代码，所以当下半部和进程上下文共享数据时，必须对进程上下文中的共享数据进行保护，所以需要加锁的同时还要禁止下半部执行，同样，由于中断处理程序可以抢占下半部，所以如果中断处理程序和下半部共享数据，那么就必须在获取恰当的锁的同时还要禁止中断。<br>回忆一下，同类的tasklet不可能同时运行，所以对于同类tasklet中的共享数据不需要保护。但是当数据被两个不同种类的tasklet共享时，就需要在访问下半部中的数据前先获得一个普通的自旋锁。这里不需要禁止下半部，因为在同一个处理器上绝不会有tasklet相互强占的情况。<br>对于软中断，无论是否同种类型，如果数据被软中断共享，那么它必须得到锁的保护。这是因为，即使是同种类型的两个软中断也可以同时运行在一个系统的多个处理上。但是，同一处理器上的一个软中断绝不会抢占另一个软中断，因此，根本没有必要禁止下半部。</p>
<h1 id="读-写自旋锁"><a href="#读-写自旋锁" class="headerlink" title="读-写自旋锁"></a>读-写自旋锁</h1><p>有时，锁的用途可以明确地分为读取和写入两个场景。例如，对一个链表可能既要更新又要检索。当更新（写入）链表时，不能有其他代码并发地写链表或从链表中读取数据，写操作要求完全互斥。另一方面，当对其检索（读取）链表时，只要其他程序不对链表进行写操作就行了。只要没有写操作，多个并发的读操作都是安全的。任务链表的存取模式就非常类似于这种情况，它就是通过读-写自旋锁获得保护的。<br>当对某个数据结构的操作可以像这样被划分为读&#x2F;写或者消费者&#x2F;生产者两种类别时，类似读&#x2F;写锁这样的机制就很有帮助了。为此，Linux内核提供了专门的读-写自旋锁。这种自旋锁为读和写分别提供了不同的锁。一个或多个读任务可以并发地持有读者锁；相反，用于写的锁最多只能被一个写任务持有，而且此时不能有并发的读操作。有时把读&#x2F;写锁叫做共享&#x2F;排斥锁，或者并发&#x2F;排斥锁，因为这种锁以共享和排斥的形式获得使用。<br>读&#x2F;写自旋锁的使用方法类似于普通自旋锁，它们通过下面的方法初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_RWLOCK(mr_rwlock);</span><br></pre></td></tr></table></figure>
<p>然后，在读者的代码分支中使用如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read_lock(&amp;mr_rwlock);</span><br><span class="line"><span class="comment">//临界区（只读）</span></span><br><span class="line">read_unlock(&amp;mr_rwlock);</span><br></pre></td></tr></table></figure>
<p>最后，在写者的代码分支中使用如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write_lock(&amp;mr_rwlock);</span><br><span class="line"><span class="comment">//临界区（读写）</span></span><br><span class="line">write_unlock(&amp;mr_rwlock);</span><br></pre></td></tr></table></figure>
<p>通常情况下，读锁和写锁会位于完全分割开的代码分支中，如上例所示。<br>注意，不能把一个读锁“升级”为写锁。比如考虑下面这段代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">read_lock(&amp;mr_rwlock);</span><br><span class="line">write_lock(&amp;mr_rwlock);</span><br></pre></td></tr></table></figure>
<p>执行上述两个函数将会带来死锁，因为写锁会不断自旋，等待所有的读者释放锁，其中也包括它自己。所以当确实需要写操作时，要在一开始就请求写锁。<code>如果写和读不能清晰地分开的话，那么就使用一般的自旋锁就行了，不要使用读写-自旋锁。</code><br>多个读者可以安全地获得同一个锁，事实上，即使一个线程递归地同一读锁也是安全的。这个特性使得读-写自旋锁真正地成为一种有用并且常用的优化手段。如果在中断处理程序中只有读操作而没有写操作，那么，就可以混合使用“中断禁止”锁，使用read_lock()而不是read_lock_irqsave()对读进行保护。不过，你还是需要用write_lock_irqsave()禁止有写操作的中断，否则，中断里的读操作就有可能锁死在写锁上。下表列出了针对读-写自旋锁的所有操作。<br><img src="/2022/11/18/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/5.jpeg" alt="img not found"><br>在使用Linux读-写自旋锁时，最后要考虑的一点是这种锁机制照顾读比照顾写要多一点。当读锁被持有时，写操作为了互斥访问只能等待，但是，读者却可以继续成功地占用锁。而自旋等待的写者在所有读者释放锁之前是无法获得锁的。所以，大量读者必定会使挂起的写者处于饥饿状态，在你自己设计锁时一定要记住这一点–有些时候这种行为是有益的，有时则会带来灾难。<br>自旋锁提供了一种快速简单的锁实现方法。如果加锁的时间不长并且代码不会睡眠（比如中断处理程序），利用自旋锁是最佳选择。如果加锁时间可能很长或者代码在持有锁时有可能睡眠，那么最好使用信号量来完成加锁功能。</p>
<h1 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h1><p>Linux中的信号量是一种睡眠锁。如果有一个任务试图获得一个不可用（已经被占用）的信号量时，信号量会将其推进一个等待队列，然后让其睡眠。这时处理器能重获自由，从而去执行其他代码。当持有的信号量可用（被释放）后，处于等待队列中的那个任务将被唤醒，并获得该信号量。<br>让我们再一次回到门和钥匙的例子。当某个人到了门前，他抓取钥匙，然后进入房间。最大的差异在于当另一个人到了门前，但无法得到钥匙时会发生什么情况。在这种情况下，这家伙不是在徘徊等待，而是把自己的名字写在一个列表中，然后打盹去了。当里面的人离开房间时，就在门口查看一下列表。如果列表上有名字，他就对第一个名字仔细检查，并在胸部给他一拳，叫醒他，让他进入房间。在这种方式中，钥匙（信号量）继续确保一次只有一个人（执行线程）进入房间（临界区）。这就比自旋锁提供了更好的处理器利用率，因为没有把时间花费在忙等待上，但是，信号量比自旋锁有更大的开销。<br>我们可以从信号量的睡眠特性得出一些有意思的结论：</p>
<ol>
<li>由于争用信号量的进程在等待锁重新变为可用时会睡眠，所以信号量适用于锁会被长时间持有的情况。</li>
<li>相反，锁被短时间持有时，使用信号量就不太适宜了。因为睡眠、维护等待队列以及唤醒所花费的开销可能比锁占用的全部时间还要长。</li>
<li>由于执行线程在锁被争用会睡眠，所以只能在进程上下文中才能获得信号量锁，因为在中断上下文中是不能进行调度的。</li>
<li>你可以在持有信号量时去睡眠（当然你也可能并不需要睡眠），因为当其他进程试图获得同一信号量时不会因此而死锁（因为该进程也只是去睡眠而已，而你最终会继续执行的）。</li>
<li>在你占用信号量的同时不能占用自旋锁。因为你在等待信号量时可能会睡眠，而在持有自旋锁时是不允许睡眠的。</li>
</ol>
<p>以上这些结论阐明了信号量和自旋锁在使用上的差异，在使用信号量的大多数时候，你的选择余地不大。往往在需要和用户空间同步时，你的代码会需要睡眠，此时使用信号量是唯一的选择。由于不受睡眠的限制，使用信号量通常来说更加容易一些。如果需要在自旋锁和信号量中做选择，应该根据锁被持有的时间长短做判断。理想情况当然是所有的锁定操作都应该越短越好。但如果你用的是信号量，那么锁定的时间长一点也能接受。另外，信号量不同于自旋锁，它不会禁止内核抢占，所以持有信号量的代码可以被抢占。这意味着信号量不会对调度的等待时间带来负面影响。</p>
<h2 id="计数信号量和二值信号量"><a href="#计数信号量和二值信号量" class="headerlink" title="计数信号量和二值信号量"></a>计数信号量和二值信号量</h2><p>最后要讨论的是信号量的一个有用特性，它可以同时允许任意数量的锁持有者，而自旋锁在一个时刻最多允许一个任务持有它。信号量同时允许的持有者数量可以在声明信号量时指定。这个值称为使用者数量（usage count）或简单地叫数量（count）。通常情况下，信号量和自旋锁一样，在一个时刻仅允许一个持有者。这时计数等于1，这样的信号量被称为二值信号量（因为它或者由一个任务持有，或者根本没有任务持有它）或者称为互斥信号量（因为它强制进行互斥）。另一方面，初始化的时候也可以把数量设置为大于1的非0值。这种情况，信号量被称为计数信号量，它允许在一个时刻至多有count个锁持有者。计数信号量不能用来进行强制互斥，因为它允许多个执行线程同时访问临界区。相反，这种信号量用来对特定代码加以限制，内核中使用它的机会不多。在使用信号量时，基本上用到的都是互斥信号量（计数等于1的信号量）。<br>信号量在1968年由Edsger Wybe Dijkstra提出，此后它逐渐成为一种常用的锁机制。<code>信号量支持两个原子操作P()和V()，这两个名字来自荷兰语Proberen和Vershogen</code>。前者叫做测试操作，后者叫做增加操作。后来的系统把两种操作分别叫做down()和up()，Linux也遵从这种叫法。down()操作通过对信号量计数减1来请求获得一个信号量。如果结果是0或者大于0，获得信号量锁，任务就可以进入临界区。如果结果是负数，任务会被放入等待队列，处理器执行其他任务。该函数如同一个动词，降低（down）一个信号量就等于获取该信号量。相反，当临界区中的操作完成后，up()操作用来释放信号量，该操作也被称作是提升信号量，因为它会增加信号量的计数值。如果在该信号量上的等待队列不为空，那么处于队列中等待的任务在被唤醒的同时会获得该信号量。</p>
<h2 id="创建和初始化信号量"><a href="#创建和初始化信号量" class="headerlink" title="创建和初始化信号量"></a>创建和初始化信号量</h2><p>信号量的实现与体系结构相关的，具体实现定义在文件&lt;asm&#x2F;semaphore.h&gt;中。struct semaphore类型用来表示信号量。可以通过一下方式静态地声明信号量—-其中name是信号量变量名，count是信号量的使用数量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">name</span>;</span></span><br><span class="line">sema_init(&amp;name,count);</span><br></pre></td></tr></table></figure>
<p>创建更为普通的互斥信号可以使用一下快捷方式，不用说，name仍然是互斥信号量的变量名：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_MUTEX</span><span class="params">(name)</span>;</span><br></pre></td></tr></table></figure>
<p>更常见的情况是，信号量作为一个大数据结构的一部分动态创建。此时，只有指向该动态创建的信号量的间接指针，可以使用如下函数来对它进行初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">sema_init(sem,count);</span><br></pre></td></tr></table></figure>
<p>sem是指针，count是信号量的使用者数量。<br>与前面类似，初始化一个动态创建的互斥信号量时使用如下函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init_MUTEX(sem);</span><br></pre></td></tr></table></figure>
<p>我不明白为什么“mutex”在init_MUTEX()中是大写，或者为什么“init”在这个函数名中放在前面，而在sema_init()中放在后面。</p>
<h2 id="使用信号量"><a href="#使用信号量" class="headerlink" title="使用信号量"></a>使用信号量</h2><p>函数down_interruptible()试图获取指定的信号量，如果信号量不可用，它将把调用进程置成TASK_INTERRUPTIBLE状态—-进入睡眠。这种进程状态意味着任务可以被信号唤醒，一般来说这是一件好事。如果进程在等待获取信号量的时候接收到了信号，那么该进程就会被唤醒，而函数down_interruptible()会返回-EINTR。另外一个函数down()会让进程在TASK_UNINTERRUPTIBLE状态下睡眠。你应该不希望这种情况发生，因为这样一来，进程在等待信号量的时候就不再响应信号了。因此，使用down_interruptible()比使用down()更为普遍（也更正确）。<br>使用down_trylock()函数，你可以尝试以堵塞方式来获取指定的信号量。在信号量已被占用时，它立刻返回非0值；否则，它返回0，而且让你成功持有信号量锁。<br>要释放指定的信号量，需要调用up()函数，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//定义并声明一个信号量，名字为mr_sem，用于信号量计数</span></span><br><span class="line"><span class="type">static</span> <span class="title function_">DECLAER_MUTEX</span><span class="params">(mr_sem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图获取信号量</span></span><br><span class="line"><span class="keyword">if</span>(down_interruptible(&amp;mr_sem)) &#123;</span><br><span class="line">    <span class="comment">//信号被接收，信号量还未获取</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*临界区*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放给定的信号量</span></span><br><span class="line">up(&amp;mr_sem);</span><br></pre></td></tr></table></figure>
<p>下表给出了针对信号量的方法的完整列表。<br><strong>信号量方法列表</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>sema_init(struct semaphore *,int)</td>
<td>以指定的计数值初始化动态创建的信号量</td>
</tr>
<tr>
<td>init_MUTEX(struct semaphore *)</td>
<td>以计数值1初始化动态创建的信号量</td>
</tr>
<tr>
<td>init_MUTEX_LOCKED(struct semaphore *)</td>
<td>以计数值0初始化动态创建的信号量（初始为加锁状态）</td>
</tr>
<tr>
<td>down_interruptible(struct semaphore *)</td>
<td>以试图获得指定的信号量，如果信号量以被争用，则进入可中断睡眠状态</td>
</tr>
<tr>
<td>down(struct semaphore *)</td>
<td>以试图获得指定的信号量，如果信号量已被争用，则进入不可中断睡眠状态</td>
</tr>
<tr>
<td>donw_trylock(struct semaphore *)</td>
<td>以试图获得指定的信号量，如果信号量已被争用，则立刻返回非0值</td>
</tr>
<tr>
<td>up(struct semaphore *)</td>
<td>以释放指定的信号量，如果睡眠队列不为空，则唤醒其中一个任务</td>
</tr>
</tbody></table>
<h1 id="读-写信号量"><a href="#读-写信号量" class="headerlink" title="读-写信号量"></a>读-写信号量</h1><p>与自旋锁一样，信号量也有区分读-写访问的可能。与读-写自旋锁和普通自旋锁之间的关系差不多，读-写信号量也要比普通信号量更具优势。<br>读-写信号量在内核中是由rw_semaphore结构表示的，定义在文件&lt;linux&#x2F;rwsem.h&gt;中。通过以下语句可以创建静态声明的读-写信号量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_RWSEM</span><span class="params">(name)</span>;</span><br></pre></td></tr></table></figure>
<p>其中name是新信号量名。<br>动态创建的读-写信号量可以通过一下函数初始化：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init_rwsem(<span class="keyword">struct</span> rw_semaphore *sem);</span><br></pre></td></tr></table></figure>
<p>所有的读-写信号量都是互斥信号量—-也就是说，它们的引用计数等于1，虽然它们只对写者互斥，不对读者。只要没有写者，并发持有读锁的读者数不限。相反，只有唯一的写者（在没有读者时）可以获得写锁。所有读-写锁的睡眠都不会被信号打断，所以它只有一个版本的down()操作，例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="title function_">DECLARE_RWSEM</span><span class="params">(mr_rwsem)</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图获取信号量用于读</span></span><br><span class="line">down_read(&amp;mr_rwsem);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*临界区（只读）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line">up_read(&amp;mr_rwsem);</span><br><span class="line"></span><br><span class="line"><span class="comment">//试图获取信号量用于写</span></span><br><span class="line">down_write(&amp;mr_rwsem);</span><br><span class="line"></span><br><span class="line"><span class="comment">/*临界区（读和写）*/</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//释放信号量</span></span><br><span class="line">up_write(&amp;mr_rwsem);</span><br></pre></td></tr></table></figure>
<p>与标准信号量一样，读-写信号量也提供了down_read_trylock()和down_write_trylock()方法。这两个方法都需要一个指向读-写信号量的指针作为参数。如果成功获得了信号量锁，它们返回非0值；如果信号量锁被争用，则返回0。这与普通信号量的取消完全相反。<br>读-写信号量相比读-写自旋锁多一种特有的操作：downgrade_write()。这个函数可以动态地将获取的写锁转换为读锁。<br>读-写信号量与读-写自旋锁一样，除非代码中的读写操作能明白无误的区分开来，否则最好不要使用它们。再强调一次，读-写机制是有条件的，只有在你的代码可以自然地界定出读-写时才有价值。</p>
<h1 id="互斥体"><a href="#互斥体" class="headerlink" title="互斥体"></a>互斥体</h1><p>直到最近，内核中唯一允许睡眠的锁是信号量。多数用户使用信号量只使用计数1，说白了是把其作为一个互斥的排他锁使用—-好比允许睡眠的自旋锁。不幸的是，信号量用途更通用，没多少使用限制。这点使得信号量适合用于那些较复杂的、未明情况下的互斥访问，比如内核于用户空间复杂的交互行为。但这也意味着简单的锁定而使用信号量并不方便，而信号量也缺乏强制的规则来形式任何形式的自动调试，即便是受限的调试也不可能。为了找到一个更简单的睡眠锁，内核开发者们引入了互斥体（mutex）。确实，这个名字容易和我们的习惯称呼混淆。所以这里我们澄清一下，“互斥体”这个称谓所指的是任何可以睡眠的强制互斥锁，比如使用计数是1的信号量。但在最新的Linux内核中，“互斥体”这个称谓现在也用于一种实现互斥的特定睡眠锁。也就是说，互斥体是一种互斥信号。<br>mutex在内核中对应数据结构mutex，其行为和使用计数为1的信号量类似，但操作接口更为简单，实现也更高效，而且使用限制更强。<br>静态地定义mutex，你需要做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DEFINE_MUTEX(name);</span><br></pre></td></tr></table></figure>
<p>动态初始化mutex，你需要做：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex_init(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>对互斥锁锁定和解锁都不难：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">mutex_lock(&amp;mutex);</span><br><span class="line"><span class="comment">/*临界区*/</span></span><br><span class="line">mutex_unlock(&amp;mutex);</span><br></pre></td></tr></table></figure>
<p>它就是一个简化版的信号量，因为不再需要管理任何使用计数。<br>下表是基本的mutex操作列表。</p>
<p><strong>Mutex方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>mutex_lock(struct mutex *)</td>
<td>为指定的mutex上锁，如果锁不可用则睡眠</td>
</tr>
<tr>
<td>mutex_unlock(struct mutex *)</td>
<td>为指定的mutex解锁</td>
</tr>
<tr>
<td>mutex_trylock(struct mutex *)</td>
<td>试图获取指定的mutex，如果成功则返回1；否则锁被获取，返回值是0</td>
</tr>
<tr>
<td>mutex_is_locked(struct mutex *)</td>
<td>如果锁已被争用，则返回1；否则返回0</td>
</tr>
</tbody></table>
<p>mutex的简洁性和高效性源自于相比使用信号量更多的受限性。它不同于信号量，因为mutex仅仅实现了Dijkstra设计初衷中的最基本的行为。因此mutex的使用场景相对而言更严格、更定向了。</p>
<ol>
<li>任何时刻中只有一个任务可以持有mutex，也就是说，mutex的使用计数永远是1。</li>
<li>给mutex上锁者必须负责给其再解锁—-你不能在一个上下文中锁定一个mutex，而在另一个上下文中给它解锁。这个限制使得mutex不适合内核同用户空间复杂的同步场景。最常使用的方式是：在同一个上下文中上锁和解锁。</li>
<li>递归地上锁和解锁是不允许的。也就是说，你不能递归地持有同一个锁，同样你也不能再去解锁一个已经被解开的mutex。</li>
<li>当持有一个mutex时，进程不可以退出。</li>
<li>mutex不能在中断或者下半部使用，即使使用mutex_trylock()也不行。</li>
<li>mutex只能通过官方API管理：它只能使用上下节中描述的方法初始化，不可被拷贝、手动初始化或者重复初始化。</li>
</ol>
<p>也许mutex结构最有用的特色是：通过一个特殊的调试模式，内核可以采用编程方式检查和警告任何践踏其约束法则的不老师行为。当打开内核配置选项CONFIG_DEBUG_MUTEXES后，就会有多种检测来确保这些约束得以遵守。这些调试手段无一能帮助你和其他mutex使用者们都能以规范的、简单化的使用模式对其使用。</p>
<h2 id="信号量和互斥体"><a href="#信号量和互斥体" class="headerlink" title="信号量和互斥体"></a>信号量和互斥体</h2><p>互斥体和信号量很相似，内核中两者共存会令人混淆。所幸，它们的标准使用方式都有简单的规范：除非mutex的某个约束妨碍你使用，否则相比信号量要优先使用mutex。当你写新代码时，只有碰到特殊场合（一般是很底层代码）才会需要使用信号量。因此建议首选mutex。如果发现不能满足其约束条件，且没有其他别的选择时，再考虑选择信号量。</p>
<h2 id="自旋锁和互斥体"><a href="#自旋锁和互斥体" class="headerlink" title="自旋锁和互斥体"></a>自旋锁和互斥体</h2><p>了解何时使用自旋锁，何时使用互斥体（或信号量）对编写优良代码很重要，但是多数情况下，并不需要太多的考虑，因为中断上下文中只能使用自旋锁，而在任务睡眠时只能使用互斥体。下表回顾一下各种锁的需求情况：<br><strong>使用什么，自旋锁与信号量的比较</strong></p>
<table>
<thead>
<tr>
<th>需求</th>
<th>建议的加锁方法</th>
</tr>
</thead>
<tbody><tr>
<td>低开销加锁</td>
<td>优先使用自旋锁</td>
</tr>
<tr>
<td>短期锁定</td>
<td>优先使用自旋锁</td>
</tr>
<tr>
<td>长期加锁</td>
<td>优先使用互斥体</td>
</tr>
<tr>
<td>中断上下文中加锁</td>
<td>使用自旋锁</td>
</tr>
<tr>
<td>持有锁需要睡眠</td>
<td>使用互斥体</td>
</tr>
</tbody></table>
<h1 id="完成变量"><a href="#完成变量" class="headerlink" title="完成变量"></a>完成变量</h1><p>如果在内核中一个任务需要发出信号通知另一个任务发生了某个特定事件，利用<em>完成变量</em>是使两个任务得以同步的简单方法。如果一个任务要执行一些工作时，另一个任务就会在完成变量上等待。当这个任务完成工作之后，会使用完成变量去唤醒在等待的任务。这听起来很像一个信号量，的确如此—-思想是一样的。事实上，完成变量仅仅提供了代替信号量的的一个简单的解决方法。例如，当子进程执行或者退出时，vfork()系统调用使用完成变量唤醒父进程。<br>完成变量由结构completion表示，定义在&lt;linux&#x2F;completion.h&gt;中。通过以下宏静态地创建完成变量并初始化它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_COMPLETION(mr_comp);</span><br></pre></td></tr></table></figure>
<p>通过init_completion()动态创建并初始化完成变量。<br>在一个指定的完成变量上，需要等待的任务调用wait_for_completion()来等待特定事件。当特定事件发生后，产生事件的任务调用complete()来发送信号唤醒正在等待的任务。下表列出了完成变量的方法。<br><strong>完成变量方法</strong></p>
<table>
<thead>
<tr>
<th>方法</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>init_completion(struct completion *)</td>
<td>初始化指定的动态创建的完成变量</td>
</tr>
<tr>
<td>wait_for_completion(struct completion *)</td>
<td>等待指定的完成变量接收信号</td>
</tr>
<tr>
<td>complete(struct completion *)</td>
<td>发信号唤醒任何等待任务</td>
</tr>
</tbody></table>
<p>使用完成变量的例子可以参考<code>kernel/sched.c</code>和<code>kernel/fork.c</code>。完成变量的通常用法是，将完成变量作为数据结构中的一项动态创建，而完成数据结构初始化工作的内核代码将调用wait_for_completion()进行等待。初始化完成之后。初始化函数调用completion()唤醒在等待的内核任务。</p>
<h1 id="BKL（Big-Kernel-Lock）：大内核锁"><a href="#BKL（Big-Kernel-Lock）：大内核锁" class="headerlink" title="BKL（Big Kernel Lock）：大内核锁"></a>BKL（Big Kernel Lock）：大内核锁</h1><p>欢迎来到内核的原始混沌时期。BKL是一个全局自旋锁，使用它主要是为了方便实现从Linux最初的SMP过渡到细粒度加锁机制。我们下面来介绍BKL的一些有趣的特性：</p>
<ol>
<li>持有BKL的任务仍然可以睡眠。因为当任务无法被调度时，所加锁会自动被丢弃；当任务被调度时，锁又会被重新获得。当然，这并不是说，当任务持有BKL时，睡眠是安全的，仅仅是可以这样做，因为睡眠不会造成任务死锁。</li>
<li>BKL是一种递归锁。一个进程可以多次请求一个锁，并不会像自旋锁那样产生死锁现象。</li>
<li>BKL只可以用在进程上下文中。和自旋锁不同，你不能在中断上下文中申请BKL。</li>
<li>新的用户不允许使用BKL。随着内核版本的不断前进，越来越少的驱动和子系统在依赖于BKL。</li>
</ol>
<p>这些特性有助于2.0版本的内核向2.2版本过渡。在SMP支持被引入到2.0版本时，内核中一个时刻上只能有一个任务运行（当然，经过长期发展，现在内核已经被很好地线程化了）。2.2版本的目标是允许多处理器在内核中并发地执行程序。引入BKL是为了使到细粒度加锁机制的过渡更容易些，虽然当时BKL对内核过渡很有帮助，但是目前它已成为内核可扩展性的障碍了。<br>在内核中不鼓励使用BKL。事实上，新代码中不再使用BKL了，但是这种锁仍然在部分内核代码中得到沿用，所以我们仍然需要理解BKL以及它的接口。除了前面提到的以外，BKL的使用方式和自旋锁类似。函数lock_kernel()请求锁，unlock_kernel()释放锁。一个执行线程可以递归地请求锁，但是，释放锁时也必须调用同样次数的unlock_kernel()操作，在最后一个解锁操作完成后，锁才会被释放。函数kernel_locked()检测锁当前是否被持有，如果被持有，返回一个非0值，否则返回0。这些接口被声明在文件&lt;linux&#x2F;smp_lock.h&gt;中，简单的用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">lock_kernel();</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    临界区，对所有其他的BKL用户进行同步</span></span><br><span class="line"><span class="comment">    注意，你可以安全地在此睡眠，锁会悄无声息地被释放</span></span><br><span class="line"><span class="comment">    当你的任务被重新调度时，锁又会被悄无声息地获取</span></span><br><span class="line"><span class="comment">    这意味着你不会处于死锁状态，但是，如果你需要锁保护这里的数据</span></span><br><span class="line"><span class="comment">    你还是不需要睡眠</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">unlock_kernel();</span><br></pre></td></tr></table></figure>
<p>BKL在被持有时同样会禁止内核抢占。在单一处理器内核中，BKL并不执行实际的加锁操作。下表列出了所有BKL函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>lock_kernel()</td>
<td>获得BKL</td>
</tr>
<tr>
<td>unlock_kernel()</td>
<td>释放BKL</td>
</tr>
<tr>
<td>kernel_locked()</td>
<td>如果锁被持有返回非0值，否则返回0</td>
</tr>
</tbody></table>
<p>对于BKL最主要的问题是确定BKL锁保护的到底是什么。多数情况下，BKL更像是保护代码而不保护数据。这个问题给利用自旋锁取代BKL造成了很大困难，因为很难判断BKL到底锁的是什么，更难的是，发现所有使用BKL的用户之间的关系。</p>
<h1 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h1><p>顺序锁，通常简称seq锁，是在2.6版本内核中才引入的一种新型锁。这种锁提供了一种很简单的机制，用于读写共享数据。实现这种锁主要依靠一个序列计数器。当有疑义的数据被写入时，会得到一个锁，并且序列值会增加。在读取数据之前和之后，序列号都被读取。如果读取的序列号值相同，说明在读操作进行的过程中没有被写操作打断过。此外，如果读取的值是偶数，那么就表明写操作没有发生。<br>定义一个seq锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">seqlock_t</span> mr_seq_lock = DEFINE_SEQLOCK(mr_seq_lock);</span><br></pre></td></tr></table></figure>
<p>然后，写锁的方法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write_seqlock(&amp;mr_seq_lock);</span><br><span class="line"><span class="comment">//写锁被获取</span></span><br><span class="line">write_sequnlock(&amp;mr_seq_lock);</span><br></pre></td></tr></table></figure>
<p>这和普通自旋锁类似。不同的情况发生在读时，并且与自旋锁有很大不同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> seq;</span><br><span class="line"><span class="keyword">do</span> &#123;</span><br><span class="line">    seq = read_seqbegin(&amp;mr_seq_lock);</span><br><span class="line">    <span class="comment">//读这里的数据</span></span><br><span class="line">&#125;<span class="keyword">while</span>(read_seqretry(&amp;mr_seq_lock,seq));</span><br></pre></td></tr></table></figure>
<p>在多个读者和少数写者共享一把锁的时候，seq锁有助于提供一种非常轻量级和具有可扩展性的外观。但是seq锁对写者更有利。只要没有其他写者，写锁总是能够被成功获得。读者不会影响写锁，这点和读-写自旋锁及信号量一样。另外，挂起的写者会不断地使得读操作循环，直到不再有任何写者持有锁为止。<br>Seq锁在你遇到如下需求时将是最理想的选择：</p>
<ol>
<li>你的数据存在很多读者。</li>
<li>你的数据写者很少。</li>
<li>虽然写者很少，但是你希望写优先于读，而且不允许读者让写者饥饿。</li>
<li>你的数据很简单，如简单结构，甚至是简单的整形—-在某些场合，你是不能使用原子量的。</li>
</ol>
<p>使用seq锁中最有说服力的是jiffies。该变量存储了Linux机器启动到当前的时间。Jiffies是使用一个64位的变量，记录了自系统启动以来的时钟节拍累加数。对于那些能自动读取全部64位jiffies_64变量的机器来说，需要用get_jiffies_64()方法完成，而且该方法的实现就是用了seq锁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">u64 <span class="title function_">get_jiffies_64</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> seq;</span><br><span class="line">    u64 ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        seq = read_seqbegin(&amp;xtime_lock);</span><br><span class="line">        ret = jiffies_64;</span><br><span class="line">    &#125;<span class="keyword">while</span>(read_seqretry(&amp;xtime_lock,seq));</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>定时器中断会更新jiffies的值，此刻，也需要使用seq变量：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">write_seqlock(&amp;xtime_lock);</span><br><span class="line">jiffies_64 += <span class="number">1</span>;</span><br><span class="line">write_sequnlock(&amp;xtime_lock);</span><br></pre></td></tr></table></figure>

<h1 id="禁止抢占"><a href="#禁止抢占" class="headerlink" title="禁止抢占"></a>禁止抢占</h1><p>由于内核是抢占性的，内核中的进程在任何时刻都可能停下来以便另一个具有更高优先级的进程运行。这意味着一个任务与被抢占的任务可能会在同一临界区内运行。为了避免这种情况，内核抢占代码使用自旋锁作为非抢占区域的标记。如果一个自旋锁被持有，内核便不能进行抢占。因为内核抢占和SMP面对相同的并发问题，并且内核已经是SMP安全的，所以，这种简单的变化使得内核也是抢占安全的。<br>或许这就是我们希望的。实际中，某些情况并不需要自旋锁，但是仍然需要关闭内核抢占。最频繁出现的情况就是每个处理器上的数据。如果数据对每个处理器是唯一的，那么，这样的数据可能就不需要使用锁来保护，因为数据只能被一个处理器访问。如果自旋锁没有被持有，内核又是抢占式的，那么一个新调度的任务就可能访问同一个变量，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">任务A对每个处理器中未被锁保护的变量foo进行操作</span><br><span class="line">任务A被抢占</span><br><span class="line">任务B被调度</span><br><span class="line">任务B操作变量foo</span><br><span class="line">任务B完成</span><br><span class="line">任务A被调度</span><br><span class="line">任务A继续操作变量foo</span><br></pre></td></tr></table></figure>
<p>这样，即使这是一个单处理器计算机，变量foo也会被多个进程以伪并发的方式访问。通常，这个变量会请求得到一个自旋锁（防止多处理器机器上的真并发）。但是如果这是每个处理器上独立的变量，可能就不需要锁。<br>为了解决这个问题，可以通过preempt_disable()禁止内核抢占。这是一个可以嵌套调用的函数，可以调用任意次。每次调用都必须有一个相应的preempt_enable()调用。当最后一次preempt_enable()被调用后，内核抢占才重新启用。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">preempt_disable();</span><br><span class="line"><span class="comment">//抢占被禁止</span></span><br><span class="line">preempt_enabel();</span><br></pre></td></tr></table></figure>
<p>抢占计数存放着被持有锁的数量和preempt_disable()的调用次数，如果计数是0，那么内核可以进行抢占；如果为1或者更大的值，那么，内核就不会进行抢占。这个计数非常有用—-它是一种对原子操作和睡眠很有效的调试方法。函数preempt_count()返回这个值。下表列出了内核抢占相关的函数。</p>
<table>
<thead>
<tr>
<th>函数</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>preempt_disable()</td>
<td>增加抢占计数值，从而禁止内核抢占</td>
</tr>
<tr>
<td>preempt_enable()</td>
<td>减少抢占计数，并当该值降为0时检查和执行被挂起的需调度的任务</td>
</tr>
<tr>
<td>preempt_enable_no_resched()</td>
<td>激活内核抢占但是不再检查任何被挂起的需调度任务</td>
</tr>
<tr>
<td>preempt_count()</td>
<td>返回抢占计数</td>
</tr>
</tbody></table>
<p>为了用更简洁的方式解决每个处理器上的数据访问问题，可以通过get_cpu()获得处理器编号（假定是用这种编号来对每个处理器的数据进行索引的）。这个函数在返回当前处理器号前首先会关闭内核抢占。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"><span class="comment">//禁止内核抢占，并将CPU设置为当前处理器</span></span><br><span class="line">cpu = get_cpu();</span><br><span class="line"><span class="comment">//对每个处理器的数据进行操作</span></span><br><span class="line"><span class="comment">//再给予内核抢占性，“CPU”可改变，故它不再有效</span></span><br><span class="line">put_cpu();</span><br></pre></td></tr></table></figure>

<h1 id="顺序和屏障"><a href="#顺序和屏障" class="headerlink" title="顺序和屏障"></a>顺序和屏障</h1><p>当处理多处理器之间或硬件之间的同步问题时，有时需要在你的程序代码中以指定的顺序发出读内存（读入）和写内存（存储）指令。在和硬件交互时，时常需要确保一个给定的读操作发生在其他读操作或写操作之前。另外，在多处理器上，可能需要按写数据的顺序读数据（通常确保后来以同样的顺序进行读取）。但是，编译器和处理器为了提高效率，可能对读和写重新排序，这无疑使问题复杂化了。幸好，所有可能重新排序和写的处理器提供了机器指令来确保顺序要求。同样也可以指示编译器不要对给定点周围的指令序列进行重新排序。这些确保顺序的指令称作屏障。<br>基本上，在某些处理器上存在以下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a=<span class="number">1</span>;</span><br><span class="line">b=<span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>有可能会在a中存放新值之前就在b中存放新值。<br>编译器和处理器都看不出a和b之间的关系。编译器会在编译时按这种顺序编译，这种顺序会是静态的，编译的目标代码就只把a放在b之前。但是，处理器会重新动态排序，因为处理器在执行指令期间，会在取指令和分派时，把表面上看似无关的指令按自认为最好的顺序排列。大多数情况下，这样的排序是最佳的，因为a和b之间没有明显的关系。尽管有些时候程序员知道什么是最好的顺序。<br>尽管前面的例子可能被重新排序，但是在处理器和编译器绝不会对下面的代码重新排序：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">a = <span class="number">1</span>;</span><br><span class="line">b = a;</span><br></pre></td></tr></table></figure>
<p>此处a和b均为全局变量，因为a与b之间有明确的数据依赖关系。<br>但是不管是编译器还是处理器都不知道其他上下文中的相关代码。偶然情况下，有必要让写操作被其他代码识别，也让所期望的指定顺序之外的代码识别。这种情况常常发生在硬件设备上，但是在多处理器上也很常见。<br>rmb()方法提供了一个“读”内存屏障，它确保跨越rmb()的载入动作不会发生重排序。也就是说，在rmb()之前的载入操作不会被重新排在该调用之后，同理，在rmb()之后的载入操作不会被重新排在该调用之前。<br>wmb()方法提供了一个“写”内存屏障，这个函数的功能和rmb()类似，区别仅仅是它是针对存储而非载入—-它确保跨越屏障的存储不发生重新排序。<br>mb()方法既提供了读屏障也提供了写屏障。载入和存储动作都不会跨越屏障重新排序。这是因为一条单独的指令（通常和rmb()使用同一指令）既可以提供载入屏障，也可以提供存储屏障。<br>read_barrier_depends()是rmb()的变种，它提供了一个读屏障，但是仅仅是针对后续读操作所依靠的那些载入。因为屏障后的读操作依赖于屏障前的读操作，因此，该屏障确保屏障前的读操作在屏障后的读操作之前完成。基本上说，该函数设置了一个读屏障，如rmb()，但是只针对特定的读—-也就是那些相互依赖的读操作。在有些体系结构上，read_barrier_depends()比rmb()执行得快，因为它仅仅是个空操作，实际并不需要。<br>看看使用了mb()和rmb()的一个例子，其中a的初始值是1，b的初始值是2。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">线程<span class="number">1</span>               线程<span class="number">2</span></span><br><span class="line">a = <span class="number">3</span>;              ----</span><br><span class="line">mb();               ----</span><br><span class="line">b = <span class="number">4</span>;              c = b;</span><br><span class="line">----                rmb();</span><br><span class="line">----                d = a;</span><br></pre></td></tr></table></figure>
<p>如果不使用内存屏障，在某些处理器上，c可能接收了b的新值，而d接收了a原来的值。比如c可能等于4（正是我们希望的），然而d可能等于1（不是我们希望的）。使用mb()能确保a和b按照预定的顺序写入，而rmb()确保c和d按照预定的顺序读取。<br>这种重排序的发生是因为现代处理器为了优化器传送管道（pipeline），打乱了分派和提交指令的顺序。如果上例中读入a、b时的顺序被打乱的话，又会发生什么情况呢？rmb()或wmb()函数相当于指令，它们告诉处理器在继续执行前提交所有尚未处理的载入或存储指令。<br>看到一个类似的例子，但是其中一个线程用read_barrier_depends()代替了rmb()。例子中a的初始值是1，b是2，p是&amp;b。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">线程<span class="number">1</span>               线程<span class="number">2</span></span><br><span class="line">a = <span class="number">3</span>;              ----</span><br><span class="line">mb();               ----</span><br><span class="line">p = &amp;a;             pp = p;</span><br><span class="line">----                read_barrier_depends();</span><br><span class="line">----                b = *pp;</span><br></pre></td></tr></table></figure>
<p>再一次声明，如果没有内存屏障，有可能在pp被设置成p前，b就被设置为pp了。由于载入*pp依靠载入p，所以read_barrier_depends()提供了一个有效的屏障。虽然使用rmb()同样有效，但是因为读是数据相关的，所以我们使用read_barrier_depends()可能更快。注意，不管在哪种情况下，左边的线程都需要mb()操作来确保预定的载入或存储顺序。<br>宏smp_rmb()、smp_wmb()、smp_mb()和smp_read_barrier_depends()提供了一个有用的优化。在SMP内核中它们被定义成常用的内存屏障，而在单处理机内核中，它们被定义成编译器的屏障。对于SMP系统，在有顺序限定要求时，可以使用SMP的变种。<br>barrier()方法可以防止编译器跨屏障对载入或存储操作进行优化。编译器不会重新组织存储或载入操作，为防止改变C代码的效果和现有数据的依赖关系。但是，它不知道在当前上下文之外会发生什么事。例如，编译器不可能知道有中断发生，这个中断有可能在读取正在被写入的数据。这时就要求存储操作发生在读取操作前。前面讨论的内存屏障可以完成编译器屏障的功能，但是编译器屏障要比内存屏障轻量得多。实际上，编译器屏障几乎是空闲的，因为它只防止编译器可能重排指令。<br>下表给出了内核中所有体系结构提供的完整的内存和编译器屏障方法。<br><strong>内存和编译器屏障方法</strong><br><img src="/2022/11/18/%E5%86%85%E6%A0%B8%E5%90%8C%E6%AD%A5%E6%96%B9%E6%B3%95/6.jpeg" alt="img not found"><br>注意，对于不同体系结构，屏障的实际效果差别很大。例如，如果一个体系结构不执行打乱存储，那么wmb()就什么都不做。但应该为最坏的情况使用恰当的内存屏蔽，这样代码才能在编译时执行针对体系结构的优化。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章应用了第9章的概念和原理，这使得你能理解Linux内核用于同步和并发的具体方法。我们一开始先讲述了最简单的确保同步的方法—-原子操作，然后考察了自旋锁，这是内核中最普通的锁，它提供了轻量级单独持有者的锁，即争用时忙等。我们接着还讨论了信号量（这是一种睡眠锁）以及更通用的衍生锁—-mutex。至于专用的加锁原语像完成变量、seq锁，只是稍稍提及。我们取笑BKL，考察了禁止抢占，并理解了屏障，它曾难以驾驭。<br>以第9章和第10章的同步方法为基础，就可以编写避免竞争条件、确保正确同步，而且能在多处理器上安全运行的内核代码了。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第10章 内核同步方法</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>内存管理</title>
    <url>/2022/11/26/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>在内核里分配内存可不像在其他地方分配内存那么容易。造成这种局面的因素很多。从根本上讲，是因为内核本身不能像用户空间那样奢侈地使用内存。内核与用户空间不同，它不具备这种能力，它不支持简单便捷的内存分配方式。比如，内核一般不能睡眠。此外，处理内存分配错误对内核来说也绝非易事。正是由于这种限制，再加上内存分配机制不能太复杂，所以在内核中获取内存要比在用户空间复杂得多。不过，从程序开发者角度来看，也不是说内核的内存分配就困难得不得了，只是在用户空间中的内存分配不太一样而已。<br>本章讨论的是在内核之中获取内存的方法。在深入探究实际的分配接口之前，我们需要理解内核是如何管理内存的。</p>
<span id="more"></span>

<h1 id="页"><a href="#页" class="headerlink" title="页"></a>页</h1><p>内核把物理页作为内存管理的基本单位。尽管处理器的最小可寻址单位通常为字（甚至是字节），但是，内存管理单元（MMU，管理内存并把物理内存转换为虚拟内存的硬件）通常以页为单位进行处理。正因为如此，MMU以页（page）大小为单位来管理系统中的页表（这也是页表名的来由）。从虚拟内存的角度来看，页就是最小单位。<br>在第19章我们将会看到，体系结构不同，支持的页的大小也不尽相同，还有些体系结构甚至支持几种不同的页大小。大多数32位体系结构支持4KB的页，而64位体系结构一般会支持8KB的页。这就意味着，在支持4KB页大小并有1GB物理内存的机器上，物理内存会被划分为262144个页。<br>内核用<code>struct page</code>结构表示系统中的每个物理页，该结构位于&lt;linux&#x2F;mm_types.h&gt;中—-我简化了定义，去除了两个容易混淆我们讨论主题的联合结构体：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           flags;</span><br><span class="line">    <span class="type">atomic_t</span>                _count;</span><br><span class="line">    <span class="type">atomic_t</span>                _mapcount;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           private;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">address_space</span>    *<span class="title">mapping</span>;</span></span><br><span class="line">    <span class="type">pgoff_t</span>                 index;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">lru</span>;</span></span><br><span class="line">    <span class="type">void</span>                    *virtual;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>让我们看一下其中比较重要的域。flag域用来存放页的状态。这些状态包括页是不是脏的，是不是被锁定在内存中等。flag的每一位单独表示一种状态，所以它至少可以同时表示出32种不同的状态。这些标志定义在&lt;linux&#x2F;page-flags&gt;中。<br>_count域存放页的引用计数—-也就是这一页被引用了多少次。当计数值变为-1时，就说明当前内核并没有引用这一页，于是，在新的分配中就可以使用它。内核代码不应当直接检查该域，而是调用page_count()函数检查，该函数唯一的参数就是page结构。当页空闲时，尽管该结构内部的_count值是负的，但是对page_count()函数而言，返回0表示页空闲，返回一个正整数表示页在使用。一个页可以由页缓存使用（这时，mapping域指向和这个页关联的address_space对象），或者作为私有数据（由private指向），或者作为进程页表中的映射。<br>virtual域是页的虚拟地址。通常情况下，它就是页在虚拟内存中的地址。有些内存（即所谓的高端内存）并不永久地映射到内核地址空间上。在这种情况下，这个域的值为NULL，需要的时候，必须动态地映射这些页。稍后我们将谈论高端内存。<br>必须要理解的一点是page结构与物理页有关，而并非与虚拟页相关。因此，该结构对页的描述只是短暂的。即使页中所包含的数据继续存在，由于交换等原因，它们也可能并不再和同一个page结构相关联。内核仅仅用这个数据结构来描述当前时刻在相关物理页中存放的东西。这个数据结构的目的在于描述物理内存本身，而不是描述包含在其中的数据。<br>内核用这一结构来管理系统中所有的页，因为内核需要直到一个页是否空闲（也就是页有没有被分配）。如果页已经被分配，内核还需要直到谁拥有这个页。<code>拥有者可能是用户空间进程、动态分配的内核数据、静态内核代码或页高速缓存等</code>。<br>系统中的每个物理页都要分配一个这样的结构体，开发者常常对此感到惊讶。他们会想“这得浪费多少内存呀”！让我们来算算对所有这些页都这么做，到底要消耗多少内存。就算<code>struct page</code>占40字节的内存吧，假定系统的物理页为8KB大小，系统有4GB物理内存。那么，系统中共有页面524288个，而描述这么多页面的page结构体消耗的内存只不过是20MB：也许绝对值不小，而相对系统4GB内存而言，仅是很小的一部分罢了。因此，要管理系统中这么多物理页面，这个代价并不算太高。</p>
<h1 id="区"><a href="#区" class="headerlink" title="区"></a>区</h1><p>由于硬件的限制，内核并不能对所有的页一视同仁。有些页位于内存中特定的物理地址上，所以不能将其用于一些特定的任务。由于存在这种限制，所以内核把页划分为不同的区（zone）。内核使用区对具有相似特性的页进行分组。Linux必须处理如下两种由于硬件存在缺陷而引起的内存寻址问题：</p>
<ol>
<li>一些硬件只能用某些特定的内存地址来执行DMA（直接内存访问）。</li>
<li>一些体系结构的内存的物理寻址范围比虚拟寻址范围大得多。这样，就有一些内存不能永久地映射到内核空间上。</li>
</ol>
<p>因为存在这些制约条件，Linux主要使用了四种区：</p>
<ol>
<li>ZONE_DMA—-这个区包含的页能用来执行DMA操作。</li>
<li>ZONE_DMA32—-和ZONE_DMA类似，该区包含的页面可用来执行DMA操作；而和ZONE_DMA不同之处在于，这些页面只能被32位设备访问。在某些体系结构中，该区将比ZONE_DMA更大。</li>
<li>ZONE_NORMAL—-这个区包含的都是能正常映射的页。</li>
<li>ZONE_HIGHMEM—-这个区包含“高端内存”，其中的页并不能永久地映射到内核地址空间。</li>
</ol>
<p>这些区（还有两种不大重要的）在&lt;linux&#x2F;mmzone.h&gt;中定义。<br>区的实际使用和分布是与体系结构相关的。例如，某些体系结构在内存的任何地址上执行DMA都没有问题。在这些体系结构中，ZONE_DMA为空，ZONE_NORMAL就可以直接用于分配。与此相反，在x86体系结构上，ISA设备就不能在整个32位的地址空间中执行DMA，因为ISA设备只能访问物理内存的前16MB。因此，ZONE_DMA在x86上包含的页都在0-16MB的内存范围里。<br>ZONE_HIGHMEM的工作方式也差不多。能否直接映射取决于体系结构。在32位x86系统上，ZONE_HIGHMEM为高于896MB的所有物理内存。在其他体系结构上，由于所有内存都被直接映射，所以ZONE_HIGHMEM为空。ZONE_HIGHMEM所在的内存就是所谓的高端内存（high memory）。系统的其余内存就是所谓的低端内存（low memory）。<br>前两个区各取所需后，剩余的就由ZONE_NORMAL区独享了。在x86上，ZONE_NORMAL是从16MB到896MB的所有物理内存。在其他的体系结构上，ZONE_NORMAL是所有的可用物理地址。下表是每个区及其在x86-32上所占的页的列表。</p>
<table>
<thead>
<tr>
<th>区</th>
<th>描述</th>
<th>物理内存</th>
</tr>
</thead>
<tbody><tr>
<td>ZONE_DMA</td>
<td>DMA使用的页</td>
<td>&lt;16MB</td>
</tr>
<tr>
<td>ZONE_NORMAL</td>
<td>正常可寻址的页</td>
<td>16-896MB</td>
</tr>
<tr>
<td>ZONE_HIGHMEM</td>
<td>动态映射的页</td>
<td>&gt;896MB</td>
</tr>
</tbody></table>
<p>Linux把系统的页划分为区，形成不同的内存池，这样就可以根据用途进行分配了。例如，ZONE_DMA内存池让内核有能力为DMA分配所需的内存。如果需要这样的内存，那么，内核就可以从ZONE_DMA中按照请求的数目取出页。注意，区的划分没有任何物理意义，这只不过是内核为了管理而采取的一种逻辑上的分组。<br>某些分配可能需要从特定的区中获取页，而另外一些分配则可以从多个区中获取页。比如，尽管用于DMA的内存必须从ZONE_DMA中进行分配，但是一般用途的内存却既能从ZONE_DMA分配，也能从ZONE_NORMAL分配，不过不可能同时从两个区分配，因为分配是不能跨区界限的。当然，内核更希望一般用途的内存从常规区分配，这样能节省ZONE_DMA中的页，保证满足DMA的使用需求。但是，如果可供分配的资源不够用了（如果内存已经变得很少了），那么，内核就会占用其他可用区的内存。<br>不是所有的体系结构都定义了全部区，有些64位的体系结构，如Intel的x86-64体系结构可以映射和处理64位的内存空间，所以x86-64没有ZONE_HIGHMEM区，所有的物理内存都处于ZONE_DMA和ZONE_NORMAL区。<br>每个区都用<code>struct zone</code>表示，在&lt;linux&#x2F;mmzone.h&gt;中定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               watermark[NR_WMARK];</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span>      <span class="title">pageset</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line">    <span class="type">spinlock_t</span>                  lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>            <span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">    <span class="type">spinlock_t</span>                  lru_lock;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone_lru</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">list</span>;</span></span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span>           nr_saved_scan;</span><br><span class="line">    &#125;lru[NR_LRU_LISTS];         </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zone_reclaim_stat</span>    <span class="title">reclaim_stat</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               pages_scanned;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               flags;</span><br><span class="line">    <span class="type">atomic_long_t</span>               vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line">    <span class="type">int</span>                         prev_priority;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>                inactive_ratio;</span><br><span class="line">    <span class="type">wait_queue_head_t</span>           *wait_table;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               wait_table_hash_nr_entries;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               wait_table_bits;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>          *<span class="title">zone_pgdat</span>;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               zone_start_pfn;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               spanned_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>               present_pages;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span>                  *name;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个结构体很大，但是，系统中只有三个区，因此，也只有三个这样的结构。让我们看一下其中一些重要的域。<br>lock域是一个自旋锁，它防止该结构被并发访问。注意，这个域只保护结构，而不保护驻留在这个区中的所有页。没有特定的锁来保护单个页，但是，部分内核可以锁住在页中驻留的数据。<br>watermark数值持有该区的最小值、最低和最高水位值。内核使用水位为每个内存区设置合适的内存消耗基准。该水位随空闲内存的多少而变化。<br>name域是一个以NULL结束的字符串表示这个区的名字。内核启动期间初始化这个值，其代码位于<code>mm/page_alloc.c</code>中。三个区的名字分别为“DMA”、“Normal”和“HighMem”。</p>
<h1 id="获得页"><a href="#获得页" class="headerlink" title="获得页"></a>获得页</h1><p>我们已经对内核如果管理内存（页、区等）有所了解了，现在让我们看一下内核实现的接口，我们正是通过这些接口在内核内分配和释放内存的。<br>内核提供了一种请求内存地底层机制，并提供了对它进行访问的几个接口。所有这些接口都以页为单位分配内存，定义于&lt;linux&#x2F;gfp.h&gt;中。最核心的函数是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask,<span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数分配2的order（1 &lt;&lt; order）次方个连续的物理页，并返回一个指针，该指针指向第一个页page结构体；如果出错，就返回NULL。在12.4节中我们再研究gft_t类型和gft_mask参数，你可以用下面这个函数把给定的页转换为它的逻辑地址：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数返回一个指针，指向给定物理页当前所在的逻辑地址。如果你无须用到<code>struct page</code>，你可以调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_pages(<span class="type">gfp_t</span> gfp_mask,<span class="type">unsigned</span> <span class="type">int</span> order);</span><br></pre></td></tr></table></figure>
<p>这个函数与alloc_pages()作用相同，不过它直接返回所请求的第一个页的逻辑地址。因为页是连续的，所以其他页也会紧随其后。<br>如果你只需要一页，就可以用下面两个封装好的函数，它能让你少敲几下键盘：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> page *<span class="title function_">alloc_page</span><span class="params">(<span class="type">gfp_t</span> gfp_mask)</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> __get_free_page(<span class="type">gfp_t</span> gfp_mask);</span><br></pre></td></tr></table></figure>
<p>这两个函数与其兄弟函数工作方式相同，只不过传递给order的值为0。</p>
<h2 id="获得填充为0的页"><a href="#获得填充为0的页" class="headerlink" title="获得填充为0的页"></a>获得填充为0的页</h2><p>如果你需要让返回的页的内容全为0，请用下面的这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> <span class="title function_">get_zeroed_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">int</span> gfp_mask)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数与__get_free_page()工作方式相同，只不过把分配好的页都填充成了0—-字节中的每一位都要取消设置。如果分配的页是给用户空间的，这个函数就非常有用了。虽说分配好的页应该包含的都是随机产生的垃圾信息，但其实这些信息可能并不是完全随机的—-它很可能“随机地”包含某些敏感数据。用户空间的页在返回之前，所有数据必须填充为0，或做其他清理工作，在保障系统安全这一点上，我们绝不妥协。下表是所有底层的页分配方法的列表。</p>
<p><strong>低级页分配方法</strong></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>alloc_page(gfp_mask)</td>
<td>只分配一页，返回指向页结构的指针</td>
</tr>
<tr>
<td>alloc_pages(gfp_mask,order)</td>
<td>分配2的order次方个页，返回指向第一页页机构的指针</td>
</tr>
<tr>
<td>__get_free_page(gfp_mask)</td>
<td>只分配一页，返回指向其逻辑地址的指针</td>
</tr>
<tr>
<td>__get_free_pages(gfp_mask,order)</td>
<td>分配2的order次方个页，返回指向第一页逻辑地址的指针</td>
</tr>
<tr>
<td>get_zeroed_page(gfp_mask)</td>
<td>只分配一页，让其内容填充0，返回指向其逻辑地址的指针</td>
</tr>
</tbody></table>
<h2 id="释放页"><a href="#释放页" class="headerlink" title="释放页"></a>释放页</h2><p>当你不再需要页时可以用下面的函数释放它们：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __free_pages(<span class="keyword">struct</span> page *page,<span class="type">unsigned</span> <span class="type">int</span> order);</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr,<span class="type">unsigned</span> <span class="type">int</span> order)</span>;</span><br><span class="line"><span class="type">void</span> <span class="title function_">free_page</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr)</span>;</span><br></pre></td></tr></table></figure>
<p>释放页时要谨慎，只能释放属于你的页。传递了错误的<code>struct page</code>或地址，用了错误的order值，这些都可能导致系统崩溃。请记住，内核是完全信赖自己的。这点与用户空间不同，如果你有非法操作，内核会开开心心地把自己挂起来，停止运行。<br>让我们看一个例子。其中，我们想得到8个页：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> page;</span><br><span class="line"></span><br><span class="line">page = __get_free_pages(GFP_KERNEL,<span class="number">3</span>);</span><br><span class="line"><span class="keyword">if</span>(!page) &#123;</span><br><span class="line">    <span class="comment">//没有足够的内存，你必须处理这种错误</span></span><br><span class="line">    <span class="keyword">return</span> -ENOMEM;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//page 现在指向8个连续页的第1个页的地址</span></span><br></pre></td></tr></table></figure>
<p>在此，我们使用完这8个页之后释放它们：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">free_page(page,<span class="number">3</span>);</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    页已经被释放了，我们不应该再访问存放在“page”中的地址了</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
<p>GFP_KERNEL参数是gfp_mask标志中的一个例子。前面我们已经简要讨论过了。<br>调用__get_free_pages()之后要注意进行错误检查。内核分配可能失败，因此你的代码必须进行检查并做相应的处理。这意味在此之前，你所做的所有工作可能前功尽弃，甚至还需要回归到原来的状态。正因为如此，在程序开始时就先进行内存分配是很有意义的，这能让错误处理得容易一点。如果你不这么做，那么在你想要分配内存的时候如果失败了，局面可能就难以控制了。<br>在你需要以页为单位的一族连续物理页时，尤其是在你只需要一两页时，这些低级页函数就很有用。对于常用的以字节为单位的分配来说，内核提供的函数是kmalloc()。</p>
<h1 id="kmalloc"><a href="#kmalloc" class="headerlink" title="kmalloc()"></a>kmalloc()</h1><p>kmalloc()函数与用户空间的malloc()一族函数非常类似，只不过它多了一个flags参数。kmalloc()函数是一个简单的接口，用它可以获得以字节为单位的一块内核内存。如果你需要整个页，那么，前面讨论的页分配接口可能是更好的选择。但是，对于大多数内存来说，kmalloc()接口用的更多。<br>kmalloc()在&lt;linux&#x2F;slab.h&gt;中声明：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmalloc</span><span class="params">(<span class="type">size_t</span> size,<span class="type">gfp_t</span> flags)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数返回的一个指向内存块的指针，其内存块至少要有size大小。所分配的内存区在物理上是连续的。在出错时，它返回NULL。除非没有足够的内存可用，否则内核总能分配成功。在对kmalloc()调用之后，你必须检查返回的是不是NULL，如果是，要适当地处理错误。<br>让我们看一个例子。我们随便假定存在一个dog结构体，现在需要为它动态地分配足够的空间：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dog</span> *<span class="title">p</span>;</span></span><br><span class="line">p = kmalloc(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> dog),GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!p)</span><br><span class="line">    <span class="comment">//处理错误</span></span><br></pre></td></tr></table></figure>
<p>如果kmalloc()调用成功，那么，ptr现在指向一个内存块，内存块的大小至少为所请求的大小。GFP_KERNEL标志表示在试图获取内存并返回给kmalloc()的调用者的过程中，内存分配器将要采取的行为。</p>
<h2 id="gfp-mask标志"><a href="#gfp-mask标志" class="headerlink" title="gfp_mask标志"></a>gfp_mask标志</h2><p>我们已经看过几个例子，发现不管是在低级页分配函数中，还是在kmalloc()函数中，都用到了分配器的标志。现在我们就深入讨论一下这些标志。<br>这些标志可分为三类：行为修饰符、区修饰符及类型。行为修饰符表示内核应当如何分配所需的内存。在某种特定情况下，只能使用某些特定的方法分配内存。例如，中断处理程序就要求内存在分配内存的过程中不能睡眠（因为中断处理程序不能被重新调度）。区修饰符表示从哪儿分配内存。前面我们已经看到，内核把物理内存分为多个区，每个区用于不同的目的。区修饰符表示从哪儿分配内存。前面我们已经看到，内核把物理内存分为多个区，每个区用于不同的目的。区修饰符指明到底从这些区中的哪一区进行分配。类型标志组合了行为修饰符和区修饰符，将各种可能用到的组合归纳为不同类型，简化了修饰符的使用；这样，你只需指定一个类型标志就可以了。GFP_KERNEL就是一种类型标志，内核中进程上下文相关的代码可以使用它。我们来看一下这些标志。</p>
<h3 id="行为修饰符"><a href="#行为修饰符" class="headerlink" title="行为修饰符"></a>行为修饰符</h3><p>所有这些标志，包括行为描述符都是在&lt;linux&#x2F;gfp.h&gt;中声明的。不过，在&lt;linux&#x2F;slab.h&gt;中包含有这个头文件，因此，你一般不必直接包含引用它。实际上，一般只使用类型修饰符就够了，我们随后会看到这点。因此，最好对每个标志都有所了解。下表是行为修饰符的列表。<br><strong>行为修饰符</strong></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_GFP_WAIT</td>
<td>分配器可以睡眠</td>
</tr>
<tr>
<td>_GFP_HIGH</td>
<td>分配器可以访问紧急事件缓冲池</td>
</tr>
<tr>
<td>_GFP_IO</td>
<td>分配器可以启动磁盘I&#x2F;O</td>
</tr>
<tr>
<td>_GFP_FS</td>
<td>分配器可以启动文件系统I&#x2F;O</td>
</tr>
<tr>
<td>_GFP_COLD</td>
<td>分配器应该使用高速缓存中快要淘汰出去的页</td>
</tr>
<tr>
<td>_GFP_NOWARN</td>
<td>分配器将不打印失败警告</td>
</tr>
<tr>
<td>_GFP_REPEAT</td>
<td>分配器在分配失败时重复进行分配，但是这次分配还存在失败的可能</td>
</tr>
<tr>
<td>_GFP_NOFALL</td>
<td>分配器将无限地重复进行分配。分配不能失败</td>
</tr>
<tr>
<td>_GFP_NORETRY</td>
<td>分配器在分配失败时绝不会重新分配</td>
</tr>
<tr>
<td>_GFP_NO_GROW</td>
<td>在slab层内部使用</td>
</tr>
<tr>
<td>_GFP_COMP</td>
<td>添加混合页元数据，在hugetlb的代码内部使用</td>
</tr>
</tbody></table>
<p>可以同时指定这些分配标志。例如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ptr = kmalloc(size,_GFP_WAIT | _GFP_IO | _GFP_FS);</span><br></pre></td></tr></table></figure>
<p>说明页分配器（最终调用alloc_pages()）在分配时可以阻塞、执行I&#x2F;O。在必要时还可以执行文件系统操作。这就让内核有很大的自由度，以便它尽可能找到空闲的内存来满足分配请求。<br>大部分分配都会指定这些修饰符，但一般不是这样指定的，而是采用我们随后讨论的类型标志。别担心，你不会在分配内存时为怎样使用这些标志而犯愁的。</p>
<h3 id="区修饰符"><a href="#区修饰符" class="headerlink" title="区修饰符"></a>区修饰符</h3><p>区修饰符表示内存区应当从何处分配。通常，分配可以从任何区开始。不过，内核优先从ZONE_NORMAL开始，这样可以确保其他区在需要时有足够的空闲页可供使用。<br>实际上只有两个区修饰符，因为除了ZONE_NORMAL之外只有两个区（默认都是从ZONE_NORMAL区进行分配）。下表是区修饰符的列表。<br><strong>区修饰符</strong></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>_GFP_DMA</td>
<td>从ZONE_DMA分配</td>
</tr>
<tr>
<td>_GFP_DMA32</td>
<td>只在ZONE_DMA32分配</td>
</tr>
<tr>
<td>_GFP_HIGHMEM</td>
<td>从ZONE_HIGHMEM或ZONE_NORMAL分配</td>
</tr>
</tbody></table>
<p>指定以上标志中的一个就可以改变内核试图进行分配的区。_GFP_DMA标志强制内核从ZONE_DMA分配。这个标志在说，有了这种奇怪的标识，我们绝对可以拥有进行DMA的内存。相反，如果指定_GFP_HIGHMEN标志，则从ZONE_HIGHMEM（优先）或ZONE_NORMAL分配。这个标志在说，我可以使用高端内存，因此，我可以是一个玩偶，给你退还一些内存，但是，常规内存还照常工作。如果没有指定任何标志，则内核从ZONE_DMA或ZONE_NORMAL进行分配，当然优先从ZONE_NORMAL进行分配。不管区标志说什么了，只要它行为正常，我就不关心了。<br>不能给_get_free_pages()或kmalloc()指定ZONE_HIGHMEM，因为这两个函数返回的都是逻辑地址，而不是page结构，这两个函数分配的内存当前有可能还没有映射到内核的虚拟地址空间，因此，也可能根本没有逻辑地址。只有alloc_pages()才能分配高端内存。实际上，你的分配在大多数情况下都不必指定修饰符，ZONE_NORMAL就足矣。</p>
<h3 id="类型标志"><a href="#类型标志" class="headerlink" title="类型标志"></a>类型标志</h3><p>类型标志指定所需的行为和区描述符以完成特殊类型的处理。正因为这一点，内核代码趋向于使用正确的类型标志，而不是一味地指定它可能需要用到的多个描述符。这么做既简单又不容易出错误。下表是类型标志的列表，下下表显示了每个类型标志与哪些修饰符相关联。<br><strong>类型标志</strong></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>GFP_ATOMIC</td>
<td>这个标志用在中断处理程序、下半部、持有自旋锁以及其他不能睡眠的地方。</td>
</tr>
<tr>
<td>GFP_NOWAIT</td>
<td>与GFP_ATOMIC类似，不同之处在于。调用不会退给紧急内存池。这就增加了内存分配失败的可能性。</td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>这种分配可以阻塞，但不会启动磁盘I&#x2F;O。这个标志在不能引发更多磁盘I&#x2F;O时能阻塞I&#x2F;O代码，这可能导致令人不愉快的递归。</td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td>这种分配在必要时可能阻塞，也可能启动磁盘I&#x2F;O，但是不会启动文件系统操作。这个标志在你不能再启动另一个文件系统的操作时，用在文件系统部分的代码中。</td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td>这是一种常规分配方式，可能会阻塞。这个标志在睡眠安全时用在进程上下文代码中。为了获得调用者所需的内存，内核会尽力而为。这个标志应当是首选标志。</td>
</tr>
<tr>
<td>GFP_USER</td>
<td>这是一种常规分配方式，可能会阻塞。这个标志用于为用户空间进程分配内存。</td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td>这是从ZONE_HIGHMEM进行分配，可能会阻塞。这个标志用于为用户空间进程分配内存。</td>
</tr>
<tr>
<td>GFP_DMA</td>
<td>这是从ZONE_DMA进行分配。需要获取能供DMA使用的内存的设备驱动程序使用这个标志，通常与以上的某个标志组合在一起使用。</td>
</tr>
</tbody></table>
<p><strong>在每种类型标志后隐含的修饰符列表</strong></p>
<table>
<thead>
<tr>
<th>标志</th>
<th>修饰符标志</th>
</tr>
</thead>
<tbody><tr>
<td>GFP_ATOMIC</td>
<td>_GFP_HIGH</td>
</tr>
<tr>
<td>GFP_NOWAIT</td>
<td>0</td>
</tr>
<tr>
<td>GFP_NOIO</td>
<td>_GFP_WAIT</td>
</tr>
<tr>
<td>GFP_NOFS</td>
<td>(_GFP_WAIT</td>
</tr>
<tr>
<td>GFP_KERNEL</td>
<td>(_GFP_WAIT</td>
</tr>
<tr>
<td>GFP_USER</td>
<td>(_GFP_WAIT</td>
</tr>
<tr>
<td>GFP_HIGHUSER</td>
<td>(_GFP_WAIT</td>
</tr>
<tr>
<td>GFP_DMA</td>
<td>_GFP_DMA</td>
</tr>
</tbody></table>
<p>让我们看一下做常用的标志以及你什么时候、为什么需要使用它们。内核中最常用的标志是GFP_KERNEL。这种分配可能会引起睡眠，它使用的是普通优先级。因为调用可能阻塞，因此这个标志只用在可以重新安全调度的进程上下文中（也就是没有锁被持有的等情况）。因为这个标志对内核如何获取请求的内存没有任何约束，所以内存分配成功的可能性很高。<br>另一个截然相反的标志是GFP_ATOMIC。因为这个标志表示不能睡眠的内存分配，因此想要满足调用者获取内存的请求将会受到很严格的限制，即使没有足够的连续内存块可供使用，内核也很可能释放出可用内存来，因为内核不能让调用者睡眠。相反，GFP_KERNEL分配可以让调用者睡眠、交换、刷新一些页到硬盘等。因为GFP_ATOMIC不能执行以上任何操作，因此与GFP_KERNEL相比较，它分配成功的机会比较小（尤其在内存短缺时）。即便如此，在当前代码（例如中断处理程序、软中断和tasklet）不能睡眠时，也只能选择GFP_ATOMIC。<br>在以上两种标志中间的是GFP_NOIO和GFP_NOFS。以这两个标志进行的分配可能会引起阻塞，但它们会避免执行某些其他操作。GFP_NOIO分配绝不启动任何磁盘I&#x2F;O来帮助满足请求。而GFP_NOFS可能会启动磁盘I&#x2F;O，但是它不会启动文件系统I&#x2F;O。你为什么需要这些标志？它们分别用在某些低级块I&#x2F;O或文件系统的代码中。设想，如果文件系统代码中需要分配内存，但没有使用GFP_NOFS。这种分配可能会引起更多的文件系统操作，而这些操作又会导致另外的分配，从而再引起更多的文件系统操作！这会一直持续下去。这样的代码在调用分配器的时候。必须确保分配器不会再执行到代码本身，否则，分配就可能产生死锁。也别紧张，内核使用这两个标志的地方是极少的。<br>GFP_DMA标志表示分配器必须满足从ZONE_DMA进行分配的请求。这个标志用在需要DMA的内存的设备驱动程序中。一般你会把这个标志与GFP_ATOMIC和GFP_KERNEL结合起来使用。<br>在你编写的绝大多数代码中，用到的要么是GFP_KERNEL，要么是GFP_ATOMIC。下表是通常情形和所用标志的列表。不管使用哪种分配类型，你都必须进行检查，并对错误进行处理。<br><strong>什么时候用哪种标志</strong></p>
<table>
<thead>
<tr>
<th>情形</th>
<th>相应标志</th>
</tr>
</thead>
<tbody><tr>
<td>进程上下文，可以睡眠</td>
<td>使用GFP_KERNEL</td>
</tr>
<tr>
<td>进程上下文，不可以睡眠</td>
<td>使用GFP_ATOMIC，在你睡眠之前或之后以GFP_KERNEL执行内存分配</td>
</tr>
<tr>
<td>中断处理程序</td>
<td>使用GFP_ATOMIC</td>
</tr>
<tr>
<td>软中断</td>
<td>使用GFP_ATOMIC</td>
</tr>
<tr>
<td>tasklet</td>
<td>使用GFP_ATOMIC</td>
</tr>
<tr>
<td>需要用于DMA的内存，可以睡眠</td>
<td>使用（GFP_DMA</td>
</tr>
<tr>
<td>需要用于DMA的内存，不可以睡眠</td>
<td>使用（GFP_DMA</td>
</tr>
</tbody></table>
<h2 id="kfree"><a href="#kfree" class="headerlink" title="kfree()"></a>kfree()</h2><p>kmalloc()的另一端就是kfree()，kfree()声明于&lt;linux&#x2F;slab.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *ptr)</span>;</span><br></pre></td></tr></table></figure>
<p>kfree()函数释放由kmalloc()分配出来的内存块。如果想要释放的内存不是由kmalloc()分配的，或者想要释放的内存早就被释放了，比如说释放属于内核其他部分的内存，调用这个函数就会导致严重的后果。与用户空间类似，分配和回收要注意配对使用，以避免内存泄漏和其他bug。注意，<code>调用kfree(NULL)是安全的</code>。<br>让我们看一个在中断处理程序中分配内存的例子。在这个例子中，中断处理程序想分配一个缓冲区来保存输入数据。BUF_SIZE预定义为以字节为单位的缓冲区长度，它应该是大于两个字节的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line">buf = kmalloc(BUF_SIZE,GFP_ATOMIC);</span><br><span class="line"><span class="keyword">if</span>(!buf)</span><br><span class="line">    <span class="comment">//内存分配出错</span></span><br></pre></td></tr></table></figure>
<p>之后，当我们不再需要这个内存时，别忘了释放它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kfree(buf);</span><br></pre></td></tr></table></figure>

<h1 id="vmalloc"><a href="#vmalloc" class="headerlink" title="vmalloc()"></a>vmalloc()</h1><p><code>vmalloc()函数的工作方式类似于kmalloc()，只不过前者分配的内存虚拟地址是连续的，而物理地址则无须连续。这也是用户空间分配函数的工作方式：由malloc()返回的页在进程的虚拟地址空间内是连续的，但是，这并不保证它们在物理RAM中也是连续的。kmalloc()函数确保页在物理地址上是连续的（虚拟地址自然也是连续的）。</code>vmalloc()函数只确保页在虚拟地址空间内是连续的。它通过分配非连续的物理内存块，再修正页表，把内存映射到逻辑地址空间的连续区域中，就能做到这点。<br>大多数情况下，只有硬件设备需要得到物理地址连续的内存。在很多体系结构中，硬件设备存在于内存管理单元之外，它们根本不理解什么是虚拟地址。<code>因此，硬件设备用到的任何内存区都必须是物理上连续的块，而不仅仅是虚拟地址上连续的内存块</code>。而仅供软件使用的内存块（例如与进程相关的缓冲区）就可以使用只有虚拟地址连续的内存块。但在你的编程中，根本察觉不到这种差异。<code>对内核而言，所有内存看起来都是逻辑上连续的</code>。<br>尽管在某些情况下才需要物理上连续的内存块，但是，很多内核代码都用kmalloc()来获得内存，而不是vmalloc()。这主要是处于性能的考虑。vmalloc()函数为了把物理上不连续的页转化为虚拟地址空间上连续的页，必须专门建立页表项。糟糕的是，通过vmalloc()获得的页必须一个一个地进行映射（因为它们物理上是不连续的），这就会导致比直接内存映射大得多的TLB抖动。因为这些原因，<code>vmalloc()仅在不得已时才会使用----典型的就是为了获得大块内存时</code>，例如，当模块被动态插入到内核中时，就把模块装载到由vmalloc()分配的内存上。<br>vmalloc()函数声明在&lt;linux&#x2F;vmalloc.h&gt;中，定义在&lt;mm&#x2F;vmalloc.c&gt;中。用法与用户空间的malloc()相同：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">vmalloc</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> size)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数返回一个指针，指向逻辑上连续的一块内存区，其大小至少为size。在发生错误时，函数返回NULL。<code>函数可能睡眠，因此，不能从中断上下文中进行调用，也不能从其他不允许阻塞的情况下进行调用</code>。<br>要释放通过vmalloc()所获得的内存，使用下面的函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">vfree</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *addr)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数会释放从addr开始的内存块，其中addr是以前由vmalloc()分配的内存块的地址。这个函数也可以睡眠，因此，不能从中断上下文中调用。它没有返回值。<br>这个函数用起来比较简单：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *buf;</span><br><span class="line"></span><br><span class="line">buf = vmalloc(<span class="number">16</span>*PAGE_SIZE);    <span class="comment">//get 16 pages</span></span><br><span class="line"><span class="keyword">if</span>(!buf)</span><br><span class="line">    <span class="comment">//错误，不能分配内存</span></span><br><span class="line"><span class="comment">//buf现在指向虚拟地址连续的一块内存区，其大小至少为16*PAGE_SIZE</span></span><br></pre></td></tr></table></figure>
<p>在分配内存之后，一定要释放它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vfree(buf);</span><br></pre></td></tr></table></figure>

<h1 id="slab层"><a href="#slab层" class="headerlink" title="slab层"></a>slab层</h1><p>分配和释放数据结构是所有内核中最普遍的操作之一。为了便于数据的频繁分配和回收，编程人员常常会用到空闲链表。空闲链表包含可供使用的、已经分配好的数据结构块。当代码需要一个新的数据结构实例时，就可以从空闲链表抓取一个，而不需要分配内存，再把数据放进去。以后，当不再需要这个数据结构的实例时，就把它放回空闲链表而不是释放它。从这个意义上说，空闲链表相当于对象高速缓存—-快速存储频繁使用的对象类型。<br>在内核中，空闲链表面临的主要问题之一是不能全局控制。当可用内存变得紧缺时，内核无法通知每个空闲链表，让其收缩缓存的大小以便释放出一些内存来。实际上，内核根本就不知道存在任何空闲链表。为了弥补这一缺陷，也为了使代码更加稳固，Linux内核提供了slab层（也就是所谓的slab分配器）。slab分配器扮演了通用数据结构缓存层的角色。<br>slab分配器的概念首先在Sun公司的SunOS 5.4操作系统中得以实现。Linux数据结构缓存层具有同样的名字和基本设计思想。<br>slab分配器试图在几个基本原则之间寻求一种平衡：</p>
<ol>
<li>频繁使用的数据结构也会频繁分配和释放，因此应当缓存它们。</li>
<li>频繁分配和回收必然导致内存碎片（难以找到大块连续的可用内存）。为了避免这种现象，空闲链表的缓存会连续地存放。因为已释放的数据结构又会放回空闲链表，因此不会导致碎片。</li>
<li>回收的对象可以立即投入下一次分配，因此，对于频繁的分配和释放，空闲链表能够提高其性能。</li>
<li>如果分配器知道对象大小、页大小和总的高速缓存的大小这样的概念，它会做出更明智的决策。</li>
<li>如果让部分缓存专属于单个处理器（对系统上的每个处理器独立而唯一），那么，分配和释放就可以不加SMP锁的情况下进行。</li>
<li>如果分配器是与NUMA相关的，它就可以从相同的内存节点为请求者进行分配。 </li>
<li>对存放的对象进行着色，以防止多个对象映射到相同的高速缓存行。</li>
</ol>
<p>Linux的slab层在设计和实现时充分考虑了上述原则。</p>
<h2 id="slab层的设计"><a href="#slab层的设计" class="headerlink" title="slab层的设计"></a>slab层的设计</h2><p>slab层把不同的对象划分为所谓高速缓存组，其中每个高速缓存组都存放不同类型的对象。每种对象类型对应一个高速缓存。例如，一个高速缓存用于存放进程描述符（task_struct结构的一个空闲链表），而另一个高速缓存存放索引节点对象（struct inode）。有趣的是，kmalloc()接口建立在slab层上，使用了一组通用高速缓存。<br>然后，这些高速缓存又被划分为slab。slab由一个或多个物理上连续的页组成。一般情况下，slab也就仅仅由一页组成。每个高速缓存可以由多个slab组成。<br>每个slab都包含一些对象成员，这里的对象指的是被缓存的数据结构。每个slab处于三种状态之一：满、部分满或空。一个满的slab没有空闲的对象（slab中所有对象都已经被分配）。一个空的slab没有分配出任何对象（slab中的所有对象都是空闲的）。一个部分满的slab有一些对象已分配出去，有些对象还空闲着。当内核的某一部分需要一个新的对象时，先从部分满的slab中进行分配。如果没有部分满的slab，就从空的slab中进行分配。如果没有空的slab，就要创建一个slab了。显然，满的slab无法满足请求，因为它根本就没有空闲的对象。这种策略能减少碎片。<br>作为一个例子，让我们考察一下inode结构，该结构是磁盘索引节点在内存中的体现。这些数据结构会频繁地创建和释放，因此，用slab分配器来管理它们就很必要。因而<code>struct inode</code>就由<code>inode_cachep</code>高速缓存进行分配。这种高速缓存由一个或多个slab组成—-由多个slab组成的可能性大一些，因为这样的对象数量很大。每个slab包含尽可能多的<code>struct inode</code>对象。当内核请求分配一个新的inode结构时，内核就从部分满的slab或空的slab返回一个指向已分配但未使用的结构的指针。当内核用完inode对象后，slab分配器就把该对象标记为空闲。下图显示了高速缓存、slab及对象之间的关系。<br><img src="/2022/11/26/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/1.jpeg" alt="img not found"><br>每个高速缓存都使用<code>kmem_cache</code>结构来表示。这个结构包含三个链表：slab_full、slabs_partial和slabs_empty，均存放在kmem_list3结构内，该结构在<code>mm/slab.c</code>中定义。这些链表包含高速缓存中的所有slab。slab描述符<code>struct slab</code>用来描述每个slab：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">slab</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>    <span class="title">list</span>;</span>           <span class="comment">//满、部分满或空链表</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>       colouroff;      <span class="comment">//slab着色的偏移量</span></span><br><span class="line">    <span class="type">void</span>                *s_mem;         <span class="comment">//在slab中的第一个对象</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span>        inuse;          <span class="comment">//slab中已分配的对象数</span></span><br><span class="line">    <span class="type">kmem_bufctl_t</span>       <span class="built_in">free</span>;           <span class="comment">//第一个空闲对象</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>slab描述符要么在slab之外另行分配，要么就放在slab自身开始的地方。如果slab很小，或者slab内部有足够的空间容纳slab描述符，那么描述符就存放在slab里面。<br>slab分配器可以创建新的slab，这是通过__get_free_pages()低级内核页分配器进行的：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> *<span class="title function_">kmem_getpages</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep,<span class="type">gfp_t</span> flags,<span class="type">int</span> nodeid)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line"></span><br><span class="line">    flags |= cachep-&gt;gfpflags;</span><br><span class="line">    <span class="keyword">if</span>(likely(nodeid == <span class="number">-1</span>)) &#123;</span><br><span class="line">        addr = (<span class="type">void</span> *)__get_free_pages(flags,cachep-&gt;gfporder);</span><br><span class="line">        <span class="keyword">if</span>(!addr)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        page = virt_to_page(addr);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        page = alloc_pages_node(nodeid,flags,cachep-&gt;gfporder);</span><br><span class="line">        <span class="keyword">if</span>(!page)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        addr = page_address(page);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    i = (<span class="number">1</span> &lt;&lt; cachep-&gt;gfporder);</span><br><span class="line">    <span class="keyword">if</span>(cachep-&gt;flags &amp; SLAB_RECLAIM_ACCOUNT)</span><br><span class="line">        <span class="type">atomic_add</span>(i,&amp;slab_reclaim_pages);</span><br><span class="line">    add_page_state(nr_slab,i);</span><br><span class="line">    <span class="keyword">while</span>(i--) &#123;</span><br><span class="line">        SetPageSlab(page);</span><br><span class="line">        page++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>该函数使用__get_free_pages()来为高速缓存分配足够多的内存。该函数的第一个参数就指向需要很多页的特定高速缓存。第二个参数是要传给__get_free_pages()的标志，注意这个标志是如何与另一个值进行二进制“或”运算的，这相当于把高速缓存需要的缺省标志加到flags参数上。分配的页大小为2的幂次方，存放在cachep-&gt;gfporder中。由于与分配器NUMA相关的代码的关系前面的这个函数比想象的要复杂一些。当nodeid是一个非负数时，分配器就试图对从相同的内存节点给发出的请求进行分配。这在NUMA系统上提供了较好的性能，但是访问节点之外的内存会导致性能的损失。<br>为了便于理解，我们可以忽略与NUMA相关的代码，写一个简单的kmem_getpages()函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">kmem_getpages</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep,<span class="type">gfp_t</span> flags)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">void</span> *addr;</span><br><span class="line"></span><br><span class="line">    flags |= cachep-&gt;gfpflags;</span><br><span class="line">    addr = (<span class="type">void</span> *)__get_free_pages(flags,cachep-&gt;gfporder);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> addr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接着，调用kmem_freepages()释放内存，而对给定的高速缓存页，kmem_freepages()最终调用的是free_pages()。当然，slab层的关键就是避免频繁分配和释放页。由此可知，slab层只有当给定的高速缓存部分中既没有满也没有空的slab时才会调用页分配函数。而只有在下列情况下才会调用释放函数：当可用内存变得紧缺时，系统企图释放出更多内存以供使用；或者当高速缓存显式地被撤销时。<br>slab层的管理是在每个高速缓存的基础上，通过提供给整个内核一个简答接口来完成的。通过接口就可以创建和撤销新的高速缓存，并在高速缓存内分配和释放对象。高速缓存及其内部slab的复杂管理完全通过slab层的内部机制来处理。当你创建了一个高速缓存后，slab层所起的作用就像是一个专用的分配器，可以为具体的对象类型进行分配。</p>
<h2 id="slab分配器的接口"><a href="#slab分配器的接口" class="headerlink" title="slab分配器的接口"></a>slab分配器的接口</h2><p>一个新的高速缓存通过以下函数创建：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">struct</span> kmem_cache *<span class="title function_">kmem_cache_create</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *name,</span></span><br><span class="line"><span class="params">                                     <span class="type">size_t</span> size,</span></span><br><span class="line"><span class="params">                                     <span class="type">size_t</span> align,</span></span><br><span class="line"><span class="params">                                     <span class="type">unsigned</span> <span class="type">long</span> flags,</span></span><br><span class="line"><span class="params">                                     <span class="type">void</span> (*ctor)(<span class="type">void</span> *))</span>;</span><br></pre></td></tr></table></figure>
<p>第一个参数是一个字符串，存放着高速缓存的名字；第二个参数是高速缓存中每个元素的大小；第三个参数是slab内第一个对象的偏移，它用来确保在页内进行特定的对齐。通常情况下，0就可以满足要求，也就是标准对齐。flags参数是可选的设置项，用来控制高速缓存的行为。它可以为0，表示没有特殊的行为，或者与以下标志中的一个或多个进行“或”运算：</p>
<ol>
<li>SLAB_HWCACHE_ALIGN 这个标志命令slab层把一个slab内的所有对象按高速缓存行对齐。这就防止了“错误的共享”（两个或多个对象尽管位于不同的内存地址，但映射到相同的高速缓存行）。这可以提高性能，但以增加内存开销为代价，因为对齐越严格，浪费的内存就越多。到底会浪费多少内存，取决于对象的大小以及对象相对于系统高速缓存行对齐的方式。对于会频繁使用高速缓存，而且代码本身对性能要求又很严格的情况，设置该选项是理想的选择；否则，请三思而后行。</li>
<li>SLAB_POISON 这个标志使slab层用已知的值（a5a5a5a5）填充slab。这就是所谓的“中毒”，有利于对未初始化内存的访问。</li>
<li>SLAB_RED_ZONE 这个标志导致slab层在已分配的内存周围插入“红色警戒区”以探测缓冲越界。</li>
<li>SLAB_PANIC 这个标志当分配失败时提醒slab层。这在要求分配只能成功的时候非常有用。比如，在系统初启动时分配一个VMA结构的高速缓存。</li>
<li>SLAB_CACHE_DMA 这个标志命令slab层使用可以执行DMA的内存给每个slab分配空间。只有在分配的对象用于DMA，而且必须驻留在ZONE_DMA区时才需要这个标志。否则，你既不需要也不应该设置这个标志。</li>
</ol>
<p>最后一个参数ctor是高速缓存的构造函数，只有在新的页追加到高速缓存时，构造函数才被调用。实际上，Linux内核的高速缓存不使用构造函数。事实上这里曾经还有过一个析构函数参数，但是由于内核代码并不需要它，因此已经抛弃掉了。你可以将ctor参数赋值为NULL。<br><code>kmem_cache_create()</code>在成功时会返回一个指向所创建高速缓存的指针；否则，返回NULL。这个函数不能在中断上下文中调用，因为它可能会睡眠。<br>要撤销一个高速缓存，则调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">kmem_cache_destroy</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep)</span>;</span><br></pre></td></tr></table></figure>
<p>顾名思义，这样就可以撤销给定的高速缓存。这个函数通常在模块的注销代码中被调用，当然，这里指创建了自己的高速缓存的模块。同样，也不能从中断上下文中调用这个函数，因为它也可能睡眠。调用该函数之前必须确保存在以下两个条件：</p>
<ol>
<li>高速缓存中的所有slab都必须为空。其实，不管哪个slab中，只要还有一个对象被分配出去并正在使用的话，那怎么可能撤销这个高速缓存呢？</li>
<li>在调用<code>kmem_cache_destroy()</code>过程中（更不用说在调用之后了）不再访问这个高速缓存。调用者必须确保这种同步。</li>
</ol>
<p>该函数在成功时返回0，否则返回非0值。</p>
<h3 id="从缓存中分配"><a href="#从缓存中分配" class="headerlink" title="从缓存中分配"></a>从缓存中分配</h3><p>创建高速缓存之后，就可以通过下列函数获取对象：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmem_cache_alloc</span><span class="params">(<span class="keyword">struct</span> kemem_cache *cachep,<span class="type">gfp_t</span> flags)</span></span><br></pre></td></tr></table></figure>
<p>该函数从给定的高速缓存cachep中返回一个指向对象的指针。如果高速缓存的所有slab中都没有空闲的对象，那么slab层必须通过kmem_geipages()获取新的页，flags的值传递给_get_free_pages()。这与我们前面看到的标志相同，你用到的应该是GFP_KERNEL或GFP_ATOMIC。<br>最后一个释放对象，并把它返回给原先的slab，可以使用下面这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kmem_cache_free</span><span class="params">(<span class="keyword">struct</span> kmem_cache *cachep,<span class="type">void</span> *objp)</span>;</span><br></pre></td></tr></table></figure>
<p>这样就能把cachep中的对象objp标记为空闲。</p>
<h3 id="slab分配器的使用实例"><a href="#slab分配器的使用实例" class="headerlink" title="slab分配器的使用实例"></a>slab分配器的使用实例</h3><p>让我们考察一个鲜活的实例，这个例子用的是task_struct结构（进程描述符）。代码稍微有些复杂，取自<code>kernel/fork.c</code>。<br>首先，内核用一个全局变量存放指向task_struct高速缓存的指针：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> *<span class="title">task_struct_cachep</span>;</span></span><br></pre></td></tr></table></figure>
<p>在内核初始化期间，在定义于<code>kernel/fork.c</code>的fork_init()中创建高速缓存：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">task_struct_cachep = kmem_cache_create(<span class="string">&quot;task_struct&quot;</span>,</span><br><span class="line">                                        <span class="keyword">sizeof</span>(<span class="keyword">struct</span> task_struct),</span><br><span class="line">                                        ARCH_MIN_TASKALIGN,</span><br><span class="line">                                        SLAB_PANIC | SLAB_NOTRACK,</span><br><span class="line">                                        <span class="literal">NULL</span>);</span><br></pre></td></tr></table></figure>
<p>这样就创建了一个名为task_struct的高速缓存，其中存放的就是类型为struct task_struct的对象。该对象被创建后存放在slab中偏移量为ARCH_MIN_TASKALIGN个字节的地方，ARCH_MIN_TASKALIGN预定义值于体系结构相关。通常将它定义为L1_CACHE_BYTES—-L1高速缓存的字节大小。没有构造函数或析构函数。注意不用检查返回值是否为失败标记NULL，因为SLAB_PANIC标志已经被设置了。如果分配失败，slab分配器就调用panic()函数。如果没有提供SLAB_PANIC标志，就必须自己检查返回值。SLAB_PANIC标志用在这儿是因为这是系统操作必不可少的高速缓存。<br>每当进程调用fork()时，一定会创建一个新的进程描述符。这是在dup_task_struct()中完成的，而该函数会被do_fork()调用：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span></span><br><span class="line"></span><br><span class="line">tsk = kmem_cache_alloc(task_struct_cachep,GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span>(!tsk)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br></pre></td></tr></table></figure>
<p>进程执行完后，如果没有子进程在等待的话，它的进程描述符就会被释放，并返回给task_struct_cachep slab高速缓存。这是在free_task_struct()中执行的（这里，tsk是现有的进程）：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">kmem_cache_free(task_struct_cachep,tsk);</span><br></pre></td></tr></table></figure>
<p>由于进程描述符是内核的核心组成部分，时刻要用到，因此task_struct_cachep高速缓存绝不会被撤销掉。即使真能撤销，我们也要通过下列函数阻止其被撤销：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> err;</span><br><span class="line"></span><br><span class="line">err = kmem_cache_destroy(task_struct_cachep);</span><br><span class="line"><span class="keyword">if</span>(err)</span><br><span class="line">    <span class="comment">//出错，撤销高速缓存</span></span><br></pre></td></tr></table></figure>
<p>很容易吧？slab层负责内存紧缺情况下所有底层的对齐、着色、分配、释放和回收等。如果你要频繁创建很多相同类型的对象，那么，就应该考虑使用slab高速缓存。也就是说，不要自己去实现空闲链表。</p>
<h1 id="在栈上的静态分配"><a href="#在栈上的静态分配" class="headerlink" title="在栈上的静态分配"></a>在栈上的静态分配</h1><p>在用户空间，我们以前所讨论到的那些分配的例子，有不少都可以在栈上发生。因为我们毕竟可以实现知道所分配空间的大小。用户空间能够奢侈地负担起非常大的栈，而且栈空间还可以动态增长，相反，内核却不能这么奢侈—-内核栈小而且固定。当给每个进程分配一个固定大小的小栈后，不但可以减少内存的消耗，而且内核也无须负担太重的栈管理任务。<br>每个进程的内核栈大小既依赖体系结构，也与编译时的选项有关。历史上，每个进程都有两页的内核栈。因为32位和64位体系结构的页面大小分别是4KB和8KB，所以通常它们的内核栈的大小分别是8KB和16KB。</p>
<h2 id="单页内核栈"><a href="#单页内核栈" class="headerlink" title="单页内核栈"></a>单页内核栈</h2><p>但是，在2.6系列内核的早期，引入了一个选项设置单页内核栈。当激活这个选项时，每个进程的内核栈只有一页那么大，根据体系结构的不同，或为4KB，或为8KB。这么做出于两个原因：首先，可以让每个进程减少内存消耗。其次，也是最重要的，随着机器运行时间的增加，寻找两个未分配的、连续的页变得越来约困难。物理内存渐渐变为碎片，因此，给一个新进程分配虚拟内存（VM）的压力也在增大。<br>还有一个更复杂的原因。继续跟随我：我们几乎掌握了关于内核栈的全部知识。现在，每个进程的整个调用链必须放在自己的内核栈中。不过，中断处理程序也曾经使用它们所中断的进程的内核栈，这样，中断处理程序也要放在内核栈中。这当然有效而简单，但是，这同时会把更严格的约束条件加在这可怜的内核栈上。当我们转而使用只有一个页面的内核栈时，中断处理程序就不放在栈中了。<br>为了矫正这个问题，内核开发者们实现了一个新功能：中断栈。中断栈为每个进程通过一个用于中断处理程序的栈。有了这个选项，中断处理程序不用再和被中断进程共享一个内核栈，它们可以使用自己的栈了。对每个进程来说仅仅耗费了一页而已。<br>总的来说，内核栈可以是1页，也可以是2页，这取决于编译时配置选项。栈大小因此在4-16KB的范围内。历史上，中断处理程序和被中断进程共享一个栈。当1页栈的选项激活时，中断处理程序获得了自己的栈。在任何情况下，无限制的递归和alloca()显然是不被允许的。</p>
<h2 id="在栈上光明正大的工作"><a href="#在栈上光明正大的工作" class="headerlink" title="在栈上光明正大的工作"></a>在栈上光明正大的工作</h2><p>在任意一个函数中，你都必须节省栈资源。这并不难，<code>也没有什么窍门，只需要在具体的函数中让所有局部变量所占空间之和不要超过几百字节</code>。在栈上进行大量的静态分配是很危险的。要不然，在内核中和在用户空间中进行栈分配就没什么差别了。栈溢出时悄无声息，但势必会引起严重的问题。因为内核没有在管理内核栈上做足工作，因此，当栈溢出时，多出的数据就会直接溢出来，覆盖掉紧邻堆栈末端的东西。首先面临考验的就是thread_info结构。在堆栈之外，任何内核数据都可能存在潜在的风险。当栈溢出时，最好情况是机器宕机，最坏的情况是悄无声息地破坏数据。<br><code>因此，进行动态分配是一种明智的选择，本章前面有关大块内存的分配就是采用这种方式。</code></p>
<h1 id="高端内存的映射"><a href="#高端内存的映射" class="headerlink" title="高端内存的映射"></a>高端内存的映射</h1><p>根据定义，在高端内存中的页不能永久地映射到内核地址空间上。因此，通过alloc_pages()函数以__GFP_HIGHMEM标志获得的页贝不可能有逻辑地址。<br>在x86体系结构上，高于896MB的所有物理内存的范围大都是高端内存，它并不会永久地或自动地映射到内核地址空间，尽管x86处理器能够寻址物理RAM的范围达到4GB。一旦这些页被分配，就必须映射到内核的逻辑地址空间上。在x86上，高端内存中的页被映射到3GB-4GB。</p>
<h2 id="永久映射"><a href="#永久映射" class="headerlink" title="永久映射"></a>永久映射</h2><p>要映射一个给定的page结构到内核地址空间，可以使用定义在文件&lt;linux&#x2F;highmem.h&gt;中的这个函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap</span><span class="params">(<span class="keyword">struct</span> page *page)</span></span><br></pre></td></tr></table></figure>
<p>这个函数在高端内存和低端内存上都能用。如果page结构对应的是低端内存中的一页，函数只会单纯地返回该页的虚拟地址。如果页位于高端内存，则会建立一个永久映射，再返回地址。这个函数可以睡眠，因此kmap()只能用在进程上下文中。<br>因为允许永久映射的数量是有限的，当不再需要高端内存时，应该解除映射，这可以通过下列函数完成：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kunmap</span><span class="params">(<span class="keyword">struct</span> page *page)</span>;</span><br></pre></td></tr></table></figure>

<h2 id="临时映射"><a href="#临时映射" class="headerlink" title="临时映射"></a>临时映射</h2><p>当必须创建一个映射而当前的上下文又不能睡眠时，内核提供了临时映射（也就是所谓的原子映射）。有一组保留的映射，它们可以存放新创建的临时映射。内核可以原子地把高端内存中的一个页映射到某个保留的映射中。因此，临时映射可以用再不能睡眠的地方，比如中断处理程序中，因为获取映射时绝不会阻塞。<br>通过下列函数建立一个临时映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> *<span class="title function_">kmap_atomic</span><span class="params">(<span class="keyword">struct</span> page *page,<span class="keyword">enum</span> km_type type)</span>;</span><br></pre></td></tr></table></figure>
<p>参数type是下列枚举类型之一，这些枚举类型描述了临时映射的目的。它们定义于&lt;asm&#x2F;kmap_types.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">enum</span> <span class="title">km_type</span> &#123;</span></span><br><span class="line">    KM_BOUNCE_READ,</span><br><span class="line">    KM_SKB_SUNRPC_DATA,</span><br><span class="line">    KM_SKB_DATA_SOFTIRQ,</span><br><span class="line">    KM_USER0,</span><br><span class="line">    KM_USER1,</span><br><span class="line">    KM_BIO_SRC_IRQ,</span><br><span class="line">    KM_BIO_DST_IRQ,</span><br><span class="line">    KM_PTE0,</span><br><span class="line">    KM_PTE1,</span><br><span class="line">    KM_PTE2,</span><br><span class="line">    KM_IRQ0,</span><br><span class="line">    KM_IRQ1,</span><br><span class="line">    KM_SOFTIRQ0,</span><br><span class="line">    KM_SOFTIRQ1,</span><br><span class="line">    KM_SYNC_ICACHE,</span><br><span class="line">    KM_SYNC_DCAHCE,</span><br><span class="line">    KM_UML_USERCOPY,</span><br><span class="line">    KM_IRQ_PTE,</span><br><span class="line">    KM_NMI,</span><br><span class="line">    KM_NMI_PTE,</span><br><span class="line">    KM_TYPE_NR</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这个函数不会阻塞，因此可以用在中断上下文和其他不能重新调度的地方。它也禁止内核抢占，这是有必要的，因为映射对每个处理器都是唯一的。通过下列函数取消映射：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">kunmap_atomic</span><span class="params">(<span class="type">void</span> *kvaddr,<span class="keyword">enum</span> km_type type)</span>;</span><br></pre></td></tr></table></figure>
<p>这个函数也不会阻塞。在很多体系结构中，除非激活了内核抢占，否则kmap_atomic()根本就无事可做，因为只有在下一个临时映射到来前上一个临时映射才有效。因此，内核完全可以“忘掉”kmap_atomic()映射，kunmap_atomic()也无须做什么实际的事情。下一个原子映射将自动覆盖前一个映射。</p>
<h1 id="每个CPU的分配"><a href="#每个CPU的分配" class="headerlink" title="每个CPU的分配"></a>每个CPU的分配</h1><p>支持SMP的现代操作系统使用每个CPU上的数据，对于给定的处理器其数据是唯一的。一般来说，每个CPU的数据存放在一个数组中。数组的每一项对应着系统上一个存在的处理器。按当前处理器号确定这个数组的当前元素这就是2.4内核处理每个CPU数据的方式。这种方式还不错，因此，2.6内核的很多代码依然用它。可以声明数据如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">unsigned</span> <span class="type">long</span> my_percpu[NR_CPUS];</span><br></pre></td></tr></table></figure>
<p>然后，按如下方式访问它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> cpu;</span><br><span class="line"></span><br><span class="line">cpu = get_cpu();        <span class="comment">//获得当前处理器，并禁止内核抢占</span></span><br><span class="line">my_percpu[cpu] ++;      <span class="comment">//或者无论什么</span></span><br><span class="line">printk(<span class="string">&quot;my_percpu on cpu = %d is %lu\n&quot;</span>,cpu,my_percpu[cpu]);</span><br><span class="line">put_cpu();              <span class="comment">//激活内核抢占</span></span><br></pre></td></tr></table></figure>
<p>注意，上面的代码中并没有出现锁，这是因为所操作的数据对当前处理器来说是唯一的。除了当前处理器之外，没有其他处理器可接触到这个数据，不存在并发访问问题，所以当前处理器可以在不用锁的情况下安全访问它。<br>现在，内核抢占成为了唯一需要关注的问题了，内核抢占会引起下面提到的两个问题：</p>
<ol>
<li>如果你的代码被其他处理器抢占并重新调度，那么这时CPU变量就会无效，因为它指向的是错误的处理器（通常，代码获得当前处理器之后是不可以睡眠的）。</li>
<li>如果另一个任务抢占了你的代码，那么就有可能在同一个处理器上发生并发访问my_percpu的情况，显然这属于一个竞争条件。</li>
</ol>
<p>虽然如此，但是你大可不必惊慌，因为在获取当前处理器号，即调用get_cpu()时，就已经禁止了内核抢占。相应的在调用put_cpu()时又会重新激活当前处理器号。注意，只要你总使用上述方法来保护数据安全，那么，内核抢占就不需要你自己去禁止。</p>
<h1 id="新的每个CPU接口"><a href="#新的每个CPU接口" class="headerlink" title="新的每个CPU接口"></a>新的每个CPU接口</h1>]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第12章 内存管理</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
        <tag>操作系统</tag>
      </tags>
  </entry>
  <entry>
    <title>移植Linux内核</title>
    <url>/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统移植之移植Linux内核</p>
<p>《嵌入式Linux应用完全开发手册》第3篇第16章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解内核源码结构，了解内核启动过程</li>
<li>掌握内核配置方法</li>
<li>移植内核同时支持S3C2410、S3C2440</li>
<li>掌握MTD设备的分区方法</li>
<li>掌握YAFFS文件系统的移植方法</li>
</ol>
<h1 id="Linux-版本及特点"><a href="#Linux-版本及特点" class="headerlink" title="Linux 版本及特点"></a>Linux 版本及特点</h1><p>Linux内核的版本号可以从源代码的顶层目录下的Makefile中看到，比如下面几行它们构成了Linux的版本号：2.6.22.6。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VERSION = <span class="number">2</span></span><br><span class="line">PATCHLEVEL = <span class="number">6</span></span><br><span class="line">SUBLEVEL = <span class="number">22</span></span><br><span class="line">EXTRAVERSION = <span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p>其中的“VERSION”和“PATCHLEVEL”组成主版本号，比如2.4、2.5、2.6等，稳定版本的主版本号用偶数表示（比如2.4、2.6），每隔2-3年出现一个稳定版本。开发中的版本用技术表示（2.3、2.5），它是下一个稳定版本的前身。<br>“SUBLEVEL”称为此版本号，它不分奇偶顺序递增。每隔1-2个月发布一个稳定版本。<br>“EXTRAVERSION”称为扩展版本号，它不分奇偶，顺序递增。每周发布几次扩展版本号，修正最新的稳定版本的问题。<br>Linux内核的最初版本在1991年发布，这是Linus Torvalds为他开发的386开发的一个类Minix的操作系统。<br>Linux 1.0的官方版发行于1994年3月，包含了386的官方支持，仅支持单CPU系统。<br>Linux 1.2发行于1995年3月，它是第一个包含多平台（Alpha、Sparc、Mips等）支持的官方版本。<br>Linux 2.0发行于1996年6月，包含很多新的平台支持，但是最重要的是，它是第一个支持SMP（对称多处理器）体系的版本。<br>Linux 2.2发行于1999年1月，它带来了SMP系统性能的极大提升，同时支持更多的硬件。<br>Linux 2.2发行于2001年1月，它进一步提升了SMP系统的扩展性，同时它集成了很多用于支持桌面系统的特性：USB、PC卡（PCMCIA）的支持，内置的即插即用等。<br>Linux 2.6发行于2003年12月，在Linux 2.4的基础上作了极大的改进。2.6内核支持更多的平台，从小规模的嵌入式系统到服务器级的64位的系统；使用新的调度器，进程的切换更高效；内核可被抢占，使得用户的操作可以得到更快速的响应；I&#x2F;O子系统也经历很大的修改，使得它在各种工作负荷下都更具响应性；模块子系统、文件系统都做了大量的改进。另外，以前使用Linux的变种μClinux来支持没有MMU的处理器，现在2.6版本的Linux中已经合入了μClinux的功能，也可以支持没有MMU的处理器。</p>
<h1 id="Linux移植准备"><a href="#Linux移植准备" class="headerlink" title="Linux移植准备"></a>Linux移植准备</h1><h2 id="获取Linux内核源码"><a href="#获取Linux内核源码" class="headerlink" title="获取Linux内核源码"></a>获取Linux内核源码</h2><p>登录Linux内核的官方网站<code>http://www.kernel.org/</code>，可以看到下图所示的内容：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/1.jpeg" alt="img not found"><br>上面标明了Linux内核的最新稳定版本、正在开发的测试版本，图中间的版本号就是各种补丁的链接地址。各种标记符的意义如下表所示：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>全部代码，单击“F”即可下载全部内核代码</td>
</tr>
<tr>
<td>B</td>
<td>当前补丁基于哪个版本的内核，单击“B”可以下载这个内核</td>
</tr>
<tr>
<td>V</td>
<td>查看补丁文件的信息，修改了哪些文件</td>
</tr>
<tr>
<td>VI</td>
<td>查看与上一个扩展版本相比，修改了哪些文件</td>
</tr>
<tr>
<td>C</td>
<td>当前的修改记录</td>
</tr>
<tr>
<td>ChangeLog</td>
<td>正式的修改记录，由开发者提供</td>
</tr>
</tbody></table>
<p>一般而言，各种补丁文件都是基于内核的某个正式版本生成的，除非使用标记符“B”指明了它所基于的版本。比如有补丁文件patch-2.6.xx.1、patch-2.6.xx.2、patch-2.6.xx.3，它们都是基于内核2.6.xx生成的补丁文件。使用时可以在内核2.6.xx上直接打补丁patch-2.6.xx.3，并不需要先打上补丁文件patch-2.6.xx.1、patch-2.6.xx.2；相应的，如果已经打上了补丁文件patch-2.6.xx.2，在打补丁之前，要先去除补丁文件patch-2.6.xx.2。<br>本书在Linux2.6.22.6上进行移植开发。下载linux-2.6.22.6.tar.bz2后如下解压即可得到目录linux-2.6.22.6，里面存放了内核源码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tar xjf linux<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>.tar.bz2</span><br></pre></td></tr></table></figure>
<p>也可以先下载内核源文件linux-2.6.22.tar.bz2、补丁文件patch-2.6.22.6.bz2，然后解压、打补丁：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tar xjf linux<span class="number">-2.6</span><span class="number">.22</span>.tar.bz2</span><br><span class="line">tar xjf patch<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>.bz2</span><br><span class="line">cd linux<span class="number">-2.6</span><span class="number">.22</span></span><br><span class="line">patch -p1 &lt; ../patch<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span></span><br></pre></td></tr></table></figure>

<h2 id="内核源码结构及Makefile分析"><a href="#内核源码结构及Makefile分析" class="headerlink" title="内核源码结构及Makefile分析"></a>内核源码结构及Makefile分析</h2><h3 id="内核源码结构"><a href="#内核源码结构" class="headerlink" title="内核源码结构"></a>内核源码结构</h3><p>Linux内核文件有近2万，出去其他架构CPU的相关文件，支持S3C2410、S3C2440这两款芯片的完整内核文件有1万多个。这些文件的组织结构并不复杂，它们分别位于顶层目录下的17个子目录，各个目录功能独立。下表描述各目录的功能，最后两个目录不包含代码。</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>体系结构相关的代码，对于每个架构的CPU，arch下有一个对应的子目录，比如<code>arch/arm</code>、<code>arch/i386</code>。</td>
</tr>
<tr>
<td>block</td>
<td>块设备的通用函数</td>
</tr>
<tr>
<td>crypto</td>
<td>常用的加密和散列算法（AES、SHA），还有一些压缩和CRC校验算法</td>
</tr>
<tr>
<td>drivers</td>
<td>所有的设备驱动程序，里面的每一个子目录对应一类驱动程序，比如<code>drivers/block</code>为块设备驱动程序，<code>drivers/char</code>为字符设备驱动程序，<code>drivers/mtd</code>为NOR Flash、NAND Flash等存储设备的驱动程序</td>
</tr>
<tr>
<td>fs</td>
<td>Linux支持的文件系统的代码，每一个子目录对应一种文件系统，比如<code>fs/jffs2</code>、<code>fs/ext2</code>、<code>fs/ext3</code></td>
</tr>
<tr>
<td>include</td>
<td>内核头文件，有基本头文件（存放在<code>include/linux</code>目录下）、各种驱动或功能部件的头文件（比如<code>include/media</code>、<code>include/mtd</code>、<code>include/net</code>）、各种体系相关的头文件（比如<code>include/asm-arm</code>、<code>include/asm-i386</code>）。当配置内核之后，<code>include/asm</code>是某个<code>include/asm-xxx</code>的链接</td>
</tr>
<tr>
<td>init</td>
<td>内核的初始化代码（不是系统的引导代码），其中的<code>main.c</code>文件中的<code>start_kernel</code>函数是内核引导后运行的第一个函数</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间的通信代码</td>
</tr>
<tr>
<td>Kernel</td>
<td>内核管理的核心代码，与处理器相关的代码位于<code>arch/*/kernel</code></td>
</tr>
<tr>
<td>lib</td>
<td>内核用到的一些库函数的代码，比如<code>crc32.c</code>、<code>string.c</code>，与处理器相关的库函数代码位于<code>arch/*/lib</code>目录下</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理代码，与处理器相关的内存管理代码位于<code>arch/*/mm</code>目录下</td>
</tr>
<tr>
<td>net</td>
<td>网络支持代码，每个子目录对应与网络的一个方面</td>
</tr>
<tr>
<td>security</td>
<td>安全、密钥相关的代码</td>
</tr>
<tr>
<td>sound</td>
<td>音频设备的驱动代码</td>
</tr>
<tr>
<td>usr</td>
<td>用来制作一个压缩的cpio归档文件：initrd的镜像，它可以作为内核启动后挂接的第一个文件系统</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核文档</td>
</tr>
<tr>
<td>scripts</td>
<td>用于配置、编译内核的脚本文件</td>
</tr>
</tbody></table>
<p>对于ARM架构的S3C2410、S3C2440，其体系相关的代码在<code>arch/arm</code>目录下，在后面进行Linux移植时，开始的工作正是修改这个目录下的文件。内核代码的层次结构如下图：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/2.jpeg" alt="img not found"></p>
<h3 id="Linux-Makefile-分析"><a href="#Linux-Makefile-分析" class="headerlink" title="Linux Makefile 分析"></a>Linux Makefile 分析</h3><p>内核中的哪些文件将被编译，怎样被编译，连接顺序如何确定，哪个文件在最前面，哪些文件或函数先执行。这些都是通过Makefile来管理的。</p>
<ol>
<li>决定编译哪些文件</li>
<li>怎样编译这些文件</li>
<li>怎样连接这些文件</li>
</ol>
<p>Linux内核源码中含有很多个Makefile文件，这些Makefile文件又要包含其他一些文件（比如配置信息、通用的规则等 ）。这些文件构成了Linux的Makefile体系：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>顶层Makefile</td>
<td>它是所有Makefile文件的核心，从总体上控制着内核的编译、连接</td>
</tr>
<tr>
<td>.config</td>
<td>配置文件，在配置内核时生成，所有的Makefile文件（包括顶层目录及各级子目录）都是根据.config文件来决定使用哪些文件</td>
</tr>
<tr>
<td>arch&#x2F;$(ARCH)&#x2F;Makefile</td>
<td>对应体系结构的Makefile，它用来决定哪些体系结构相关的文件参与内核的生成，并提供一些规则来生成特定格式的内核映像</td>
</tr>
<tr>
<td>scipts&#x2F;Makefile.*</td>
<td>Makefile共用的通用规则、脚本等</td>
</tr>
<tr>
<td>kbuild Makefiles</td>
<td>各级子目录下的Makefile，它们相对简单，被上一层Makefile调用来编译当前子目录下的文件</td>
</tr>
</tbody></table>
<p>内核文档<code>Documentation/kbuild/makefiles.txt</code>对内核中的Makefile作用、用法讲解的非常透彻，以下根据前面总结的Makefile的3大作用分析这5类文件。</p>
<ol>
<li>决定编译哪些文件<br>Linux 内核的编译过程从顶层Makefile开始，然后递归进入各级子目录调用它们的Makefile，分为3个步骤。<br>①顶层Makefile决定内核根目录下哪些子目录将被编进内核。<br>②<code>arch/$(ARCH)/Makefile</code>决定<code>arch/$(ARCH)</code>目录下哪些文件、哪些目录将被编进内核。<br>③各级子目录下的Makefile决定所在目录下哪些文件将被编进内核，哪些文件将被编成模块（即驱动程序），进入哪些子目录继续调用它们的Makefile。</li>
</ol>
<p>先看步骤①，在顶层Makefile中可以看到如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init-y          :   init/</span><br><span class="line">drivers-y       :   drivers/    sound/</span><br><span class="line">net-y           :   net/</span><br><span class="line">libs-y          :   lib/</span><br><span class="line">core-y          :   usr/</span><br><span class="line">...</span><br><span class="line">core-y          +=  kernerl/    mm/ fs/ ipc/    security/   crypto/ block/</span><br></pre></td></tr></table></figure>
<p>可见，顶层Makefile将这13个子目录分为5类：init-y、drivers-y、net-y、libs-y和core-y。之前上表中的17个子目录，出去<code>include</code>目录和后面两个不包含内核代码的目录外，还有一个<code>arch</code>目录没有出现在内核中。它在<code>arch/$(ARCH)/Makefile</code>中被包含进内核，在顶层Makefile中直接包含了这个Makefile，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include $(srctree)/arch/$(ARCH)/Makefile</span><br></pre></td></tr></table></figure>
<p>对于ARCH变量，可以在执行make命令时传入，比如“make ARCH&#x3D;arm …”。另外，对于非x86平台，还需要指定交叉编译工具，这也可以在执行make命令时传入，比如“make CROSS_COMPILE&#x3D;arm-linux- …”。为了方便，常在顶层Makefile中进行修改。<br>修改前：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARCH    ?= $(SUBARCH)</span><br><span class="line">CROSS_COMPILE   ?= </span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARCH    ?= arm</span><br><span class="line">CROSS_COMPILE   ?= arm-linux-</span><br></pre></td></tr></table></figure>
<p>对于步骤②的<code>arch/$(ARCH)/Makefile</code>，以ARM体系为例，在<code>arch/arm/Makefile</code>中可以看到如下内容：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">head-y  := arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o </span><br><span class="line">...</span><br><span class="line">core-y  += arch/arm/kernel/ arch/arm/mm/ arch/arm/common/</span><br><span class="line">core-y  += $(MACHINE)</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2400/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2412/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2440/</span><br><span class="line">...</span><br><span class="line">libs-y  := arch/arm/lib/    $(libs-y)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>由第1行可知，除前面的5类子目录外，又出现了另一类：<code>head-y</code>，不过它是直接以文件名出现。MMUEXT在<code>arch/arm/Makefile</code>前面定义，对于没有MMU的处理器，MMUEXT的值为-nommu，使用文件head-nommu.S；对于有MMU的处理器，MMUEXT的值为空，使用文件head.S。<br><code>arch/arm/Makefile</code>中类似第3、4、5行的代码进一步扩展了<code>core-y</code>的内容，第9行扩展了<code>libs-y</code>的内容，这些都是体系结构相关的目录。第5-7行中的CONFIG_ARCH_S3C2410在配置内核时定义，它的值有3种：y、m、空。y表示编进内核，m表示编为模块，空表示不使用。<br>编译内核时，将依次进入init-y、core-y、libs-y、drivers-y和net-y所列出的目录执行它们的Makefile，每个子目录都会生成一个build-in.o（libs-y所列目录下，有可能lib.a文件）。最后，<code>head-y</code>所表示的文件将和这些build-in.o、lib.a一起被连接成内核映像文件vmlinux。<br>最后，步骤③是如何进行的。<br>在配置内核时，生成配置文件<code>.config</code>。内核顶层Makefile使用如下语句间接包含<code>.config</code>文件，以后就根据<code>.config</code>中定义的各个变量来决定编译哪些文件。之所以说是“间接”包含，是因为包含的是<code>include/config/auto.conf</code>文件，而它只是将<code>.config</code>文件中的注释去掉，并根据顶层Makefile中定义的变量增加一些变量而已。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Read in config</span><br><span class="line">-include include/config/<span class="keyword">auto</span>.conf</span><br></pre></td></tr></table></figure>
<p><code>include/config/auto.conf</code>文件的生成过程不再描述，它与<code>.config</code>的格式相同，摘选部分内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_ARCH_SMDK2410=y</span><br><span class="line">CONFIG_ARCH_S3C2440=y</span><br><span class="line"># .config中没有下面这行，它是根据顶层Makefile中定义的内核的版本号增加的</span><br><span class="line">CONFIG_KERNELVERSION=<span class="string">&quot;2.6.22.6&quot;</span></span><br><span class="line"># .config中没有下面这行，它是根据顶层Makefile中定义的ARCH变量增加的</span><br><span class="line">CONFIG_ARCH=<span class="string">&quot;arm&quot;</span></span><br><span class="line">CONFIG_JFFS2_FS=y</span><br><span class="line">CONFIG_LEDS_S3C24XX=m</span><br></pre></td></tr></table></figure>

<p>在<code>include/config/auto.conf</code>文件中，变量的值主要有两类：“y”和“m”。各级子目录的Makefile使用这些变量来决定哪些文件被编译进内核中，哪些文件被编成模块（即驱动程序），要进入哪些下一级子目录继续编译，这通过以下4种方法来确定（obj-y、obj-m、lib-y是Makefile中的变量）。</p>
<p>①obj-y用来定义哪些文件被编进（build-in）内核。<br>obj-y中定义的.o文件由当前目录下的.c或.S文件编译生成，它们连同下级子目录的build-in.o文件一起被组合成（使用“$(LD) -r”命令）当前目录下的build-in.o文件。这个build-in.o文件将被它的上一层Makefile使用。<br>obj-y中各个.o文件的顺序是有意义的，因为内核中用<code>moudule_init</code>或<code>__initcall</code>定义的函数将按照它们的连接顺序被调用。<br><strong>例子1</strong>，当下面的CONFIG_ISDN、CONFIG_ISDN_PPP_BSDCOMP在<code>.config</code>中被定义为y时，isdn.c或isdn.S、isdn_bsdcomp.c或isdn_bsdcomp.S被编译成isdn.o、isdn_bssdcomp.o。这两个.o文件被组合进buidl-in.o文件中，最后被链接进入内核。假如isdn.o、isdn_bsdcomp.o中分别用<code>moudule_init(A)</code>、<code>moudule_init(B)</code>定义了函数A、B，则内核启动时A先被调用，然后是B。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_ISDN)      += isdn.o</span><br><span class="line">obj-$(CONFIG_ISDN_PPP_BSDCOMP)      += isdn_bsdcomp.o</span><br></pre></td></tr></table></figure>

<p>②obj-m用来定义哪些文件被编译成可加载模块（Loadable module）。<br>obj-m中定义的.o文件有当前目录下的.c或.S文件编译生成，它们不会被编进build-in.o中，而是被编成可加载模块。<br>一个模块可以由一个或多个.o文件组成。对于只有一个源文件的模块，在obj-m中直接增加它的.o文件即可。对于有多个源文件的模块，除在obj-m中增加一个.o文件外，还要定义一个<module_name>-objs变量来告诉Makefile这个.o文件由哪些文件组成。<br><strong>例子2</strong>，当下面的CONFIG_ISDN_PPP_BSDCOMP在.config文件中被定义为m时，isdn_bsdcomp.c或isdn_bsdcomp.S将被编译成isdn_bsdcomp.o文件，它最后被制作成isdn_bsdcomp.ko模块。</module_name></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#drivers/isdn/i4l/Makefile</span></span><br><span class="line">obj-$(CONFIG_ISDN_PPP_BSDCOMP)  += isdn_bsdcomp.o</span><br></pre></td></tr></table></figure>
<p><strong>例子3</strong>，当下面的CONFIG_ISDN在.config文件中被定义为m时，将会生成一个isdn.o文件，它由isdn-objs中定义的isdn-net-lib.o、isdn_v110.o、isdn_common.o等3个文件组合而成。isdn.o最后被制作成isdn.ko模块。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#drivers/isdn/i4l/Makefile</span></span><br><span class="line">obj-$(CONFIG_ISDN)  += isdn.o</span><br><span class="line">isdn-objs   :=  isdn_net_lib.o isdn_v110.o isdn_common.o</span><br></pre></td></tr></table></figure>

<p>③lib-y用来定义哪些文件被编成库文件<br>lib-y中定义的.o文件由当前目录下的.c或.S文件编译生成，它们被打包成当前目录下的一个库文件：lib.a。<br>同时出现在obj-y、lib-y中的.o文件，不会被包含进lib.a中。<br>要把这个lib.a编译进入内核中，需要在顶层Makefile中libs-y变量中列出当前目录。要编成库文件的内核代码一般都在这两个目录下：<code>lib/</code>、<code>arch/$(ARCH)/lib</code>。</p>
<p>④obj-y、obj-m还可以用来指定要进入的下一级子目录。<br>Linux中一个Makefile文件只负责生成当前目录下的目标文件，子目录下的目标文件由子目录的Makefile生成。Linux的编译系统会自动进入这些子目录调用他们的Makefile，只是需要在进入之前指定这些子目录。<br>这要用到obj-y、obj-m，只要在其中增加这些子目录名即可。<br><strong>例子4</strong>，<code>fs/Makefile</code>中有如下一行，当CONFIG_JFFS2_FS被定义为y或m时，在编译时将会进入<code>jffs2</code>目录进行编译。Linu的编译系统只会根据这些信息决定是否进入下一级目录，而下一级目录的文件如何编译成build-in.o或模块由它的Makefile决定。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_JFFS2_FS)      += jffs2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>怎么编译这些文件<br>即编译选项、连接选项是什么。这些选项分为3类：全局的，适用于整个内核代码树；局部的，仅适用于某个Makefile中的所有文件；个体的，仅适用于某个文件。<br>全局选项在顶层Makefile和<code>arch/$(ARCH)/Makefile</code>中定义，这些选项的名称为：CFLAGS、AFLAGS、LDFLAGS、ARFLAGS，它们分别是编译C文件的选项、编译汇编文件的选项、连接文件的选项、制作库文件的选项。<br>需要使用局部选项时，它们在各个子目录中定义，名称为：EXTRA_FLAGS、EXTRA_ALAGS、EXTRA_LDFLAGS、EXTRA_ARFLAGS，它们的用途与前述选项相同，只是适用范围比较小，它们针对当前的Makefile中的所有文件。<br>另外，如果想针对某个文件定义它的编译选项，可以使用CFLAGS_$@,AFLAGS_$@。前者用于编译某个C文件，后者用于编译某个汇编文件。$@表示某个目标文件名，比如以下代码表示编译aha152x.c时，选项中要额外加上“-DAHA152X_STAT -DAUTOCONF”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta"># drivers/scsi/Makefile</span></span><br><span class="line">CFLAGS_aha152x.o = -DAHA152X_STAT -DAUTOCONF</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这3类选项是一起用的，在<code>scropts/Makefile.lib</code>中可以看到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_c_flags  = $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$(basetarget).o)</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎样连接这些文件，它们的顺序如何<br>前面分析有哪些文件需要编译进入内核时，顶层Makefile和<code>arch/$(ARCH)/Makefile</code>定义了6类目录（或文件）：head-y、init-y、drivers-y、net-y、libs-y和core-y。它们的初始值如下（以ARM体系为例）：<br><code>arch/arm/Makefile</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">head-y    := arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o</span><br><span class="line">...</span><br><span class="line">core-y    := arch/arm/kernel/ arch/arm/mm/ arch/arm/common/</span><br><span class="line">core-y    := $(MACHINE)</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2400/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2412/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2440/</span><br><span class="line">...</span><br><span class="line">libs-y				:= arch/arm/lib/ $(libs-y)</span><br></pre></td></tr></table></figure>
<p>顶层Makefile中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init-y  :=  init/</span><br><span class="line">drivers :=  drivers/  sound/</span><br><span class="line">net-y   :=  net/</span><br><span class="line">libs-y  :=  lib/</span><br><span class="line">core-y  :=  usr/</span><br><span class="line">...</span><br><span class="line">core-y  +=  kernel/ mm/ fs/ ipc/  security/ crypto/ block/</span><br></pre></td></tr></table></figure>
<p>可见，除head-y之外，其余的init-y、drivers-y等都是目录名。在顶层Makefile中，这些目录名的后面直接加上build-in.o或lib.a，表示要连接进内核的文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">init-y  :=  $(patsubst %/, %/build-in.o, $(init-y))</span><br><span class="line">core-y  :=  $(patsubst %/, %/build-in.o, $(core-y))</span><br><span class="line">drivers-y  :=  $(patsubst %/, %/build-in.o, $(drivers-y))</span><br><span class="line">net-y  :=  $(patsubst %/, %/lib.a, $(net-y))</span><br><span class="line">libs-y1  :=  $(patsubst %/, %/build-in.o, $(libs-y))</span><br><span class="line">libs-y2  :=  $(patsubst %/, %/build-in.o, $(libs-y))</span><br><span class="line">libs-y  :=  $(libs-y1 $(libs-y2))</span><br></pre></td></tr></table></figure>
<p>上面的patsubst是个字符串处理函数，它的用法如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure>
<p>表示寻找“text”中符合格式“pattern”的字，用“replacement”替换它们。比如上面的init-y初值为“init&#x2F;”，经过交换之后，“init-y”变为“init&#x2F;build-in.o”。<br>顶层Makefile中，继续往下看：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">vmlinux-init  :=  $(head-y) $(init-y)</span><br><span class="line">vmlinux-main  :=  $(core-y) $(libs-y) $(drivers-y)  $(net-y)</span><br><span class="line">vmlinux-all   :=  $(vmlinux-linux)  $(vmlinux-main)</span><br><span class="line">vmlinux-lds   :=  arch/$(ARCH)/kernel/vmlinux.lds</span><br></pre></td></tr></table></figure>
<p>第3行的<code>vmlinux-all</code>表示所有构成内核映像文件vmlinux的目标文件，从第1-3行可知这些目标文件的顺序为：head-y、init-y、core-y、libs-y、drivers-y、net-y，即<code>arch/arm/kernel/head.o</code>（假设有MMU，否则为head-nommu.o）、<code>arch/arm/kernel/init_task.o</code>、<code>init/build-in.o</code>、<code>usr/build-in.o</code>等。<br>第4行表示连接脚本为<code>arch/$(ARCH)/kernel/vmlinux.lds</code>。对于ARM体系，连接脚本就是<code>arch/arm/kernel/vmlinux.lds</code>，它由<code>arch/arm/kernel/vmlinux.lds.S</code>文件生成。规则在<code>scripts/Makefile.build</code>中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$(obj)/%.lds: $(src)/%.lds.S  FORCE</span><br><span class="line">      $(call if_changed_dep,cpp_lds_S)</span><br></pre></td></tr></table></figure>
<p>现将生成的<code>arch/arm/kernel/vmlinux.lds</code>摘录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	. = 0xc0000000 + 0x00008000;                  /* 代码段起始地址，这是个虚拟地址 */</span><br><span class="line"></span><br><span class="line">	.text.head : &#123;</span><br><span class="line">		_stext = .;</span><br><span class="line">		_sinittext = .;</span><br><span class="line">		*(.text.head)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.init : &#123;			                                /* 内核初始化的代码和数据 */</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	.text : &#123;			                                /* 真正的代码段 */</span><br><span class="line">		_text = .;		                              /* 代码段和只读数据段的开始地址	*/</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 只读数据 */</span><br><span class="line">  . = ALIGN((4096)); .rodata:AT(ADDR(.rodata) - 0) &#123;......&#125; . = ALIGN((4096));</span><br><span class="line"></span><br><span class="line">	_etext = .;			                              /* 代码段和只读数据段的结束地址 */</span><br><span class="line">... ...</span><br><span class="line">	.data : AT(__data_loc) &#123;                      /* 数据段 */</span><br><span class="line">		__data_start = .;	                          /* 数据段起始地址 */</span><br><span class="line">... ...</span><br><span class="line">		_edata = .;                                 /* 数据段结束地址 */</span><br><span class="line">	&#125;</span><br><span class="line">	_edata_loc = __data_loc + SIZEOF(.data);      /* 数据段结束地址 */</span><br><span class="line"></span><br><span class="line">	.bss : &#123;                                      /* BSS段，没有初始化或初值为0的全局、静态变量 */</span><br><span class="line">		__bss_start = .;	                          /* BSS段起始地址 */</span><br><span class="line">		*(.bss)</span><br><span class="line">		*(COMMON)</span><br><span class="line">		_end = .;                                   /* BSS段结束地址 */</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.stab 0 : &#123; *(.stab) &#125;                        /* 调试信息段	*/</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>下面对本节分析Makefile的结果作一下总结。</p>
</li>
<li><p>配置文件.config中定义了一系列的变量，Makefile将结合它们来决定哪些文件被编进内核、哪些文件被编成模块、涉及哪些子目录。</p>
</li>
<li><p>顶层Makefile和<code>arch/$(ARCH)/Makefile</code>决定根目录下哪些子目录、<code>arch/$(ARCH)</code>目录下哪些文件和目录将被编进内核。</p>
</li>
<li><p>最后，各级子目录下的Makefile决定所在目录下哪些文件将被编进内核，哪些文件将被编成模块（驱动程序），进入哪些子目录继续调用它们的Makefile。</p>
</li>
<li><p>顶层Makefile和<code>arch/$(ARCH)/Makefile</code>设置了可以影响所有文件的编译、连接选项：CFLAGS、AFLAGS、LDFLAGS、ARFLAGS。</p>
</li>
<li><p>各级子目录下的Makefile中可以设置能够影响当前目录下所有文件的编译、连接选项：EXTRA_CFLAGS、EXTRA_AFLAGS、EXTRA_LDFLAGS、EXTRA_ARFLAGS；还可以设置可以影响某个文件的编译选项：CFLAGS_$@，AFLAGS_$@。</p>
</li>
<li><p>顶层Makefile按照一定的顺序组织文件，根据连接脚本<code>arch/$(ARCH)/kernel/vmlinux.lds</code>生成内核映像文件vmlinux。</p>
</li>
</ol>
<h2 id="内核的Kconfig分析"><a href="#内核的Kconfig分析" class="headerlink" title="内核的Kconfig分析"></a>内核的Kconfig分析</h2><p>在内核目录下执行“make menuconfig ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-”时，就会看到一个如下图所示的菜单：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/3.jpeg" alt="img not found"><br>这就是内核的配置界面。通过配置界面，可以选择芯片类型、选择需要支持的文件系统，去除不需要的选项等，这就称为“配置内核”。注意，也有其他形式的配置界面，比如“make config”命令启动字符配置界面，对于每个选项都会依次出现一行提示信息，逐个回答；“make xconfig”命令启动X-windows图形配置界面。<br>所有配置工具都是通过读取<code>arch/$(ARCH)/Kconfig</code>文件来生成配置界面，这个文件是所有配置文件的总入口，它会包含其他目录的Kconfig文件。配置界面如上图所示。<br>内核源码的每个子目录中，都有一个Makefile文件和Kconfig文件。Makefile的作用前面已经讲述，Kconfig用于配置内核，它就是各种配置界面的源文件。内核的配置工具读取各个Kconfig文件，生成配置界面供开发人员配置内核，最后生成配置文件.config。<br>内核的配置界面以树状的菜单形式组织，主菜单下有若干子菜单，子菜单下又有子菜单或配置选项。每个子菜单或选项可以有依赖关系，这些依赖关系用来确定它们上是否显示。只有被依赖项的父项已经被选中，子项才会显示。<br>Kconfig文件的语法可以参考<code>Documentation/kbuild/kconfig-language.txt</code>文件，下面讲述几个常用的语法，并在最后介绍菜单形式的配置界面操作方法。</p>
<h3 id="Kconfig-文件的基本要素：config条目（entry）"><a href="#Kconfig-文件的基本要素：config条目（entry）" class="headerlink" title="Kconfig 文件的基本要素：config条目（entry）"></a>Kconfig 文件的基本要素：config条目（entry）</h3><p>config条目常被其他条目包含，用来生成菜单、进行多项选择等。<br>config条目用来配置一个选项，或者这么说，它用于生成一个变量，这个变量会连同它的值一起被写入配置文件.config中。比如有一个config条目用来配置CONFIG_LEDS_S3C24XX，根据用户的选择，.config文件中可能出现下面3种配置结果中的一个。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">CONFIG_LEDS_S3C24XX=y         # 对应的文件被编进内核</span><br><span class="line">CONFIG_LEDS_S3C24XX=m         # 对应的文件被编成模块</span><br><span class="line">#CONFIG_LEDS_S3C24XX          # 对应的文件没有被使用</span><br></pre></td></tr></table></figure>
<p>以一个例子说明config条目格式，下面代码选自<code>fs/Kconfig</code>文件，它用于配置CONFIG_JFFS2_FS_POSIX_ACL选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config JFFS2_FS_POSIX_ACL</span><br><span class="line">	bool &quot;JFFS2 POSIX Access Control Lists&quot;</span><br><span class="line">	depends on JFFS2_FS_XATTR</span><br><span class="line">	default y</span><br><span class="line">	select FS_POSIX_ACL</span><br><span class="line">	help</span><br><span class="line">	  Posix Access Control Lists (ACLs) support permissions for users and</span><br><span class="line">	  groups beyond the owner/group/world scheme.</span><br><span class="line">	  </span><br><span class="line">	  To learn more about Access Control Lists, visit the Posix ACLs for</span><br><span class="line">	  Linux website &lt;http://acl.bestbits.at/&gt;.</span><br><span class="line">	  </span><br><span class="line">	  If you don&#x27;t know what Access Control Lists are, say N</span><br></pre></td></tr></table></figure>
<p>代码中包含了几乎所有的元素，下面一一说明：<br>第1行中，config是关键字，表示一个配置选项的开始；紧跟着的JFFS2_FS_POSIX_ACL是配置选项的名称，省略了前缀“CONFIG_”。<br>第2行中，boot表示变量类型，即CONFIG_JFFS2_FS_POSIX_ACL的类型。有5种类型：bool、tristate、string、hex和int，其中的tristate和string是基本的类型，其他类型是它们的变种。boot变量取值有两种：y和n；tristate变量取值有3种：y、n和m；string变量取值为字符串；hex变量取值为十六进制的数据；int变量取值为十进制的数据。<br>“boot”之后的字符串是提示信息，在配置界面中上下移动光标选中它时，就可以通过按空格或回车来设置CONFIG_JFFS2_FS_POSIX_ACL的值。提示信息的完整格式如下，如果使用“if<expr>”，则当expr为真时才显示提示信息。在实际使用时，prompt关键字可以省略。</expr></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;prompt&quot;</span> &lt;prompt&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第3行表示依赖关系，格式如下。只有JFFS2_FS_XATTR配置选项被选中时，当前配置选项中的提示信息才会出现，才能设置当前配置选项。注意，如果依赖条件不满足，则它取默认值。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;depend on &quot;</span>/<span class="string">&quot;requires&quot;</span> &lt;expr&gt;</span><br></pre></td></tr></table></figure>
<p>第4行的表示默认值为y，格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;default&quot;</span> &lt;expr&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第5行表示当前配置选项JFFS2_FS_POSIX_ACL被选中时，配置选项FS_POSIX_ACL也会被自动选中，格式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;select&quot;</span> &lt;symbol&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第6行表示下面几行是帮助信息，帮助信息的关键字有如下两种，它们完全一样。当遇到一行的缩进距离比第一行帮助信息的缩进距离小时，表示帮助信息已经结束。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="string">&quot;help&quot;</span> or <span class="string">&quot;---help---&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="menu-条目"><a href="#menu-条目" class="headerlink" title="menu 条目"></a>menu 条目</h3><p>menu条目用于生成菜单，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;menu&quot; &lt;prompt&gt;</span><br><span class="line">&lt;menu options&gt;</span><br><span class="line">&lt;menu block&gt;</span><br><span class="line">&quot;endmenu&quot;</span><br></pre></td></tr></table></figure>
<p>它的实际使用并不如它的标准格式那样复杂，下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu &quot;Floating point emulation&quot;</span><br><span class="line"></span><br><span class="line">config FPE_NWFPE</span><br><span class="line">      ... ...</span><br><span class="line">config FPE_NWFPE_XP</span><br><span class="line">      ... ... </span><br><span class="line">... ...</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>
<p>menu之后的字符串是菜单名，“menu”和“endmenu”之间有很多config条目。在配置界面会出现如下字样的菜单，移动光标选中它后按回车键进入，就会看到这些config条目定义的配置选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Floating point emulation  ---&gt;</span><br></pre></td></tr></table></figure>
<h3 id="choice-条目"><a href="#choice-条目" class="headerlink" title="choice 条目"></a>choice 条目</h3><p>choice条目将多个类似的配置选项组合在一起，供用户单选或多选，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;choice&quot;</span><br><span class="line">&lt;choice options&gt;</span><br><span class="line">&lt;choice block&gt;</span><br><span class="line">&quot;endchioce&quot;</span><br></pre></td></tr></table></figure>
<p>实际使用中，也是在“choice”和“endchoice”之间定义多个config条目，比如<code>arch/arm/Kconfig</code>中有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">choice </span><br><span class="line">      prompt &quot;ARM system type&quot;</span><br><span class="line">      default ARCH_VERSATILE</span><br><span class="line"></span><br><span class="line">config ARCH_AAEC2000</span><br><span class="line">      ...</span><br><span class="line">config ARCH_INTEGRATOR</span><br><span class="line">      ...</span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>
<p>prompt“ARM system type”给出提示信息“ARM system type”，光标选中它之后按回车键进入，就可以看到多个config条目定义的配置选项。<br>choice条目中定义的变量类型只能有两种：bool和tristate，不能同时有这两种类型的变量。对于bool类型的choice条目，只能在多个选项中选择一个；对于tristate类型的choice条目，要么就把一个或多个选项色设为m；要么就像bool类型的choice条目一样，只能选择一个。这是可以理解的，比如对于同一个硬件，它有多个驱动程序，可以选择将其中之一编译进内核（配置选项设置为y），也可以都将它们编译成模块（配置选项设置为m）。</p>
<h3 id="comment-条目"><a href="#comment-条目" class="headerlink" title="comment 条目"></a>comment 条目</h3><p>comment条目用于定义一些帮助信息，它在配置过程中出现界面的第一行；并且这些帮助信息会出现在配置文件中，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;comment&quot; &lt;prompt&gt;</span><br><span class="line">&lt;comment options&gt;</span><br></pre></td></tr></table></figure>
<p>实际使用也很简单，比如<code>arch/arm/Kconfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">menu &quot;Floating point emulation&quot;</span><br><span class="line"></span><br><span class="line">comment &quot;At least one emulation must be selected&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>进入菜单“Floating point emulation —&gt;”之后，在第一行会看到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">--- At least one emulation must be selected</span><br></pre></td></tr></table></figure>
<p>而在.config文件中也会看到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># At least one emulation must be selected</span><br><span class="line"># </span><br></pre></td></tr></table></figure>
<h3 id="source-条目"><a href="#source-条目" class="headerlink" title="source 条目"></a>source 条目</h3><p>source 条目用于读入另一个Kconfig文件，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">&quot;source&quot; &lt;prompt&gt;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子，取自<code>arch/arm/Kconfig</code>，它读入<code>net/Kconfig</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;net/Kconfig&quot;</span><br></pre></td></tr></table></figure>

<h3 id="菜单形式的配置界面操作方法"><a href="#菜单形式的配置界面操作方法" class="headerlink" title="菜单形式的配置界面操作方法"></a>菜单形式的配置界面操作方法</h3><p>配置界面的开始几行就是它的操作方法，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/4.jpeg" alt="img not found"><br>内核<code>scripts/kconfig/mconf.c</code>文件的注释给出了更详细的操作方法，讲解如下：<br>一些特定功能的文件可以直接编译进内核中，或者编译成一个可加载模块，或者根本不使用它们。还有一些内核参数，必须给它们赋一个值：十进制数、十六进制数，或者一个字符串。<br>配置界面中，以<code>[*]</code>、<code>&lt;M&gt;</code>或<code>[]</code>开头的选项表示相应的功能被编译进内核中、被编译成一个模块，或者没有使用。尖括号<code>&lt;&gt;</code>表示相应功能的文件可以被编译成模块。<br><code>↑</code>、<code>↓</code>方向键用来高亮选中某个配置选项，如果要进入某个子菜单，先选中它，然后按回车键进入。配置选项的名字后有<code>---&gt;</code>表示它是一个子菜单。配置选项的名称中有一个高亮的字母，它被称为<code>热键(hotkey)</code>,直接输入热键就可以选中该配置选项，或者循环选中具有相同热键的配置选项。<br>可以使用翻页键<code>&lt;Page Up&gt;</code>、<code>&lt;Page Down&gt;</code>来移动配置界面中的内容。<br>要退出配置界面，使用<code>←</code>、<code>→</code>方向键选中<code>&lt;Exit&gt;</code>按钮，然后按回车键。如果没有配置选项使用后面这些按键作为热键的话，也可以按两次<code>&lt;ESC&gt;</code>或<code>&lt;E&gt;&lt;X&gt;</code>键退出。<br>按<code>&lt;TAB&gt;</code>键可以在<code>&lt;Select&gt;</code>、<code>Exit</code>、<code>Help</code>这3个按钮中循环选中它们。<br>要想阅读某个配置选项的帮助信息，选中它之后，再选中<code>&lt;Help&gt;</code>按钮，按回车键；也可以选中配置选项后，直接按<code>&lt;H&gt;</code>或<code>&lt;?&gt;</code>键。<br>对于choice条目中的多个配置选项，使用方向键高亮选中某个配置选项，按<code>&lt;S&gt;</code>或空格键选中它；也可以通过输入配置选项的首字母，按<code>&lt;S&gt;</code>或空格键选中它。<br>对于int、hex或string类型的配置选项，要输入它们的值时，先高亮选中选中它，按回车键，输入数据，再按回车键。对于十六进制数据，前缀0x可以省略掉。<br>配置界面的最下面，如下图红框所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/5.jpeg" alt="img not found"><br>前者用于加载某个配置文件，后者用于将当前的配置保存到某个配置文件中去。需要注意的是，如果不使用这两个选项，配置的加载文件、输出文件都默认为.config文件；如果加载了其他的文件（假设文件名为A），然后在它的基础上进行修改，最后退出保存时，这些变化会保存到A中去，而不是.config。<br>当然，可以先加载文件A，然后修改，最后保存到.config中去。</p>
<h2 id="Linux-内核配置选项"><a href="#Linux-内核配置选项" class="headerlink" title="Linux 内核配置选项"></a>Linux 内核配置选项</h2><p>Linux内核配置选项多达上千个，一个个的进行选择既耗费时间，对开发人员的要求也比较高（需要了解每个配置选项的作用）。一般的做法是在某个默认配置文件的基础上进行修改，比如我们可以先加载配置文件<code>arch/arm/configs/s3c2410_defconfig</code>，再增加、去除某些配置选项。</p>
<h3 id="配置界面主菜单的类别"><a href="#配置界面主菜单的类别" class="headerlink" title="配置界面主菜单的类别"></a>配置界面主菜单的类别</h3><p>下表讲解了主菜单的类别，以后读者配置内核时，可以根据自己所要设置的功能进入某个菜单，然后根据其中的各个配置选项的帮助信息进行配置。</p>
<table>
<thead>
<tr>
<th>配置界面主菜单</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Code maturity level options</td>
<td>代码成熟度选项：用于包含一些正在开发的或者不成熟的代码、驱动程序。一般不设置</td>
</tr>
<tr>
<td>Genaral setup</td>
<td>常规设置：比如增加附加的内核版本号、支持	内存交换功能、System V进程间通信等。除非很熟悉其中的内容，否则一般使用默认配置</td>
</tr>
<tr>
<td>Loadable module support</td>
<td>可加载模块支持：一般都会打开可加载模块支持（Enable loadable module support）、允许卸载已经加载到模块（Module unloading）、让内核通过运行modprobe来自动加载所需要的模块（Automatic kernel module loading）</td>
</tr>
<tr>
<td>Block layer</td>
<td>块设备层：用于设置块设备的一些总体参数，比如是否支持大于2TB的块设备、是否支持大于2TB的文件、设置I&#x2F;O调度器等。一般使用默认值即可</td>
</tr>
<tr>
<td>System Type</td>
<td>系统类型：选择CPU的架构、开发板类型等与开发板相关的配置选项</td>
</tr>
<tr>
<td>Bus support</td>
<td>PCMCIA&#x2F;CardBus总线的支持</td>
</tr>
<tr>
<td>Kernel Features</td>
<td>用于设置内核的一些参数，比如是否支持内核抢占、是否支持动态修改系统时钟等</td>
</tr>
<tr>
<td>Boot options</td>
<td>启动参数：比如设置默认的命令行参数等</td>
</tr>
<tr>
<td>Floating point emulation</td>
<td>浮点运算仿真功能：目前Linux 还不支持硬件浮点运算，所以要选择一个浮点仿真器，一般选择“NWFPE math emulation”</td>
</tr>
<tr>
<td>Userspace binary formats</td>
<td>可执行文件格式：一般都支持ELF、a.out格式</td>
</tr>
<tr>
<td>Power management options</td>
<td>电源管理选项</td>
</tr>
<tr>
<td>Networking</td>
<td>网络协议选项：一般选择“Networking support”以支持网络功能，选择“Packet socket”以支持socket接口功能，选择“TCP&#x2F;IP networking”以支持TCP&#x2F;IP网络协议。通常可以在选择“Networking support”后使用默认配置</td>
</tr>
<tr>
<td>Device Drivers</td>
<td>设备驱动程序：几乎包含了Linux的所有驱动程序</td>
</tr>
<tr>
<td>File systems</td>
<td>文件系统：可以在里面选择要支持的文件系统，比如EXT2、JFFS2等</td>
</tr>
<tr>
<td>Profiling support</td>
<td>对系统的活动进行分析，仅供内核开发者使用</td>
</tr>
<tr>
<td>Kernel hacking</td>
<td>调试内核时的各种选项</td>
</tr>
<tr>
<td>Security options</td>
<td>安全选项，一般使用默认配置</td>
</tr>
<tr>
<td>Cryptographic options</td>
<td>加密选项</td>
</tr>
<tr>
<td>Library routines</td>
<td>库子程序：比如CRC32检验函数、zlib压缩函数等。不包含在内核源码中的第三方内核模块可能需要这些库，可以全不选，内核中若有其他部分依赖它，会自动选上</td>
</tr>
</tbody></table>
<h3 id="“System-Type”-菜单：系统类型"><a href="#“System-Type”-菜单：系统类型" class="headerlink" title="“System Type” 菜单：系统类型"></a>“System Type” 菜单：系统类型</h3><p>对于arm平台（在顶层Makefile中修改“ARCH ?&#x3D; arm”）,执行“make menuconfig”后，在配置界面可以看到“System Type”字样，进入它得到另一个界面，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/6.jpeg" alt="img not found"><br>第一行“ARM system type”用来选择体系结构，进入它之后选中“Samsung S3C2410，S3C2412，S3C2413，S3C2440，S3C2442，S3C2443”，查看帮助信息可以知道它对应CONFIG_ARCH_S3C2410配置项。<br>下面几行用来设置S3C2410（包括S3C2412等）系统的特性，比如选中“S3C2410 UART to use for low-level message”后按回车键，可以输入数字，表示使用哪个串口来输入内核打印信息：选中“S3C2410 DMA support”表示支持DMA功能。<br>再往下的“S3C2410 Machine —&gt;”、“S3C2440 Machine —&gt;”表示这又是一个菜单，它们用来选择开发板类型。比如进入“S3C2410 Machine”菜单后，可以看到如下内容：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/7.jpeg" alt="img not found"><br>它们表示目前内核中支持S3C2410的8种开发板。选中某个开发板之后，它相应的文件就会被编译进内核中。比如对于开发板<code>SMDK2410/A9M2410</code>，它的配置项为CONFIG_ARCH_SMDK2410，在<code>arch/arm/mach-s3c2410/Makefile</code>中可以看到如下一行，表示如果选择支持该开发板，则<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code>文件被编进内核中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_ARCH_SMDK2410) 	+= mach-smdk2410.o</span><br></pre></td></tr></table></figure>
<p>在移植内核时，可以选中某个配置相似的开发板，然后在上面进行修改。</p>
<h3 id="“Device-Drivers”-菜单：设备驱动程序"><a href="#“Device-Drivers”-菜单：设备驱动程序" class="headerlink" title="“Device Drivers” 菜单：设备驱动程序"></a>“Device Drivers” 菜单：设备驱动程序</h3><p>执行“make menuconfig”后，在配置界面可以看到“Device Drivers”字样，进入它得到另一个界面，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/8.jpeg" alt="img not found"><br>图中的各个子菜单与内核源码<code>drivres/</code>目录下各个子目录一一对应，如下表所示，在配置过程中可以参考这个表格找到对应的配置选项，在添加新驱动时，也可以参考它来决定代码放在哪个目录下。</p>
<table>
<thead>
<tr>
<th>Device Drivers 子菜单</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Generic Driver Options</td>
<td>对应<code>divers/base</code>目录，这是设备驱动程序中一些基本和通用的配置选项</td>
</tr>
<tr>
<td>Connector - undefined userspace &lt;-&gt; kernelspace linker</td>
<td>对应<code>divers/connector</code>目录</td>
</tr>
<tr>
<td>Memory Technology Device （MTD）support</td>
<td>对应<code>divers/mtd</code>目录，用于支持各种新型的存储设备，比如NOR Flash、NAND Flash等</td>
</tr>
<tr>
<td>Parallel port support</td>
<td>对应<code>divers/parport</code>目录，用于支持各种并口设备</td>
</tr>
<tr>
<td>Plug and Play support</td>
<td>对应<code>divers/pnp</code>目录，支持各种“即插即用”设备</td>
</tr>
<tr>
<td>Block devices</td>
<td>对应<code>divers/block</code>目录，包括回环设备、RAMDISK等的驱动</td>
</tr>
<tr>
<td>ATA&#x2F;ATAPI&#x2F;MFM&#x2F;RLL support</td>
<td>对应<code>divers/ide</code>目录，它用来支持ATA&#x2F;ATAPI&#x2F;MFM&#x2F;RLL 接口的硬盘、软盘、光盘等</td>
</tr>
<tr>
<td>SCSI device support</td>
<td>对应<code>divers/scsi</code>目录，支持各种scsi接口的设备</td>
</tr>
<tr>
<td>Serial ATA（prod）and parallel ATA （experiment）drivers</td>
<td>对应<code>divers/ata</code>目录，支持SATA与PATA设备</td>
</tr>
<tr>
<td>Multi-device support （RAID and LVM）</td>
<td>对应<code>divers/md</code>目录，表示多设备支持（RAID和LVM），RAID和LVM的作用是使多个物理设备组建成一个单独的逻辑磁盘</td>
</tr>
<tr>
<td>Network device support</td>
<td>对应<code>divers/net</code>目录，用来支持各种网络设备，比如CS8900、DM9000等</td>
</tr>
<tr>
<td>ISDN subsystem</td>
<td>对应<code>divers/isdn</code>目录，用来提供综合业务数字网（Integrate Service Digital Network）的驱动程序</td>
</tr>
<tr>
<td>Input device support</td>
<td>对应<code>divers/input</code>目录，支持各类输入设备，比如键盘、鼠标等</td>
</tr>
<tr>
<td>Character devices</td>
<td>对应<code>divers/char</code>目录，它包含各种字符设备驱动程序。串口的配置也是从这个菜单调用的，但是串口的代码在<code>drivers/serial</code>下</td>
</tr>
<tr>
<td>I2C support</td>
<td>对应<code>divers/i2c</code>目录，支持各类I2C设备</td>
</tr>
<tr>
<td>SPI support</td>
<td>对应<code>divers/spi</code>目录，支持各类SPI设备</td>
</tr>
<tr>
<td>Dallas’s 1-wire bus</td>
<td>对应<code>divers/w1</code>目录，支持一线总线</td>
</tr>
<tr>
<td>Hardware Monitoring support</td>
<td>对应<code>divers/hwmon</code>目录</td>
</tr>
<tr>
<td>Misc devices</td>
<td>对应<code>divers/misc</code>目录，用来支持一些不好分类的设备，称为杂项设备</td>
</tr>
<tr>
<td>Multifuction device drivers</td>
<td>对应<code>divers/mfd</code>目录，用来支持多功能的设备，比如SM501，它既可以用于显示图像，也可以用作串口</td>
</tr>
<tr>
<td>LED devices</td>
<td>对应<code>divers/leds</code>目录，包含各种LED驱动程序</td>
</tr>
<tr>
<td>Multimedia devices</td>
<td>对应<code>divers/media</code>目录，包含多媒体驱动，比如V4L（Video for Linux），它用于向上提供统一的图像、声音接口</td>
</tr>
<tr>
<td>Graphics support</td>
<td>对应<code>divers/video</code>目录，提供图形设备&#x2F;显卡的支持</td>
</tr>
<tr>
<td>Sound</td>
<td>对应<code>sound/</code>目录（它不在drivers下），用来支持各种声卡</td>
</tr>
<tr>
<td>HID Devices</td>
<td>对应<code>divers/hid</code>目录，用来支持各种USB-HID设备，或者符合USB-HID规范的设备（蓝牙）。HID（Human Interface Device），比如各种USB接口的鼠标&#x2F;键盘&#x2F;游戏杆&#x2F;手写板等输入设备</td>
</tr>
<tr>
<td>USB support</td>
<td>对应<code>divers/usb</code>目录，包括各种USB Host和USB Device 设备</td>
</tr>
<tr>
<td>MMC&#x2F;SD card support</td>
<td>对应<code>divers/mmc</code>目录，用来支持各种MMC&#x2F;SD卡</td>
</tr>
<tr>
<td>Real Time Clock</td>
<td>对应<code>divers/rtc</code>目录，用来支持各种实时时钟设备。比如S3C24x0上就集成了RTC芯片</td>
</tr>
</tbody></table>
<h1 id="Linux-内核移植"><a href="#Linux-内核移植" class="headerlink" title="Linux 内核移植"></a>Linux 内核移植</h1><p>本节将修改Linux-2.6.22.6内核，使得它可以同时在本书使用的S3C2410、S3C2440开发板上运行，并修改相关驱动使它支持网络功能、支持JFFS2、YAFFS文件系统，同时修改MTD设备分区，使得内核可以挂接NAND Flash上的文件系统。</p>
<h2 id="Linux-内核启动过程概述"><a href="#Linux-内核启动过程概述" class="headerlink" title="Linux 内核启动过程概述"></a>Linux 内核启动过程概述</h2><p>与移植U-Boot的过程相似，在移植Linux之前，先了解它的启动过程。Linux的启动过程可以分为两部分：架构&#x2F;开发板相关的引导过程、后续的通用启动过程。下图所示是ARM架构处理器上Linux内核vmlinux的启动过程。之所以强调是vmlinux，是因为其他格式的内核在进行与vmlinux相同的流程之前会有一些独特的操作。比如对于压缩格式的内核zImage，它首先进行自解压得到vmlinux，然后执行vmlinux开始正常的启动流程。<br>引导阶段通常使用汇编语言编写，它首先检查内核是否支持当前架构的处理器，然后检查是否支持当前开发板。通过检查后，就为调用下一阶段的<code>start_kernel</code>函数准备了。主要分为如下两个步骤。</p>
<ol>
<li>连接内核时使用的虚拟地址，所以要设置页表、使能MMU。</li>
<li>调用C函数<code>start_kernel</code>之前的常规工作，包括复制数据段、清除BSS段、调用<code>start_kernel</code>函数。</li>
</ol>
<p>第二阶段的关键代码主要使用C语言编写。它进行内核初始化的全部工作，最后调用<code>rest_init</code>函数启动init过程，创建系统第一个进程：init进程。在第二阶段，仍有部分架构&#x2F;开发板相关的代码，比如下图中的<code>setup_arch</code>函数用于进行架构&#x2F;开发板相关的设置（重新设置页表、设置系统时钟、初始化串口等）。<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/9.jpeg" alt="img not found"></p>
<h2 id="修改Linux内核以支持S3C2410-x2F-S3C2440开发板"><a href="#修改Linux内核以支持S3C2410-x2F-S3C2440开发板" class="headerlink" title="修改Linux内核以支持S3C2410&#x2F;S3C2440开发板"></a>修改Linux内核以支持S3C2410&#x2F;S3C2440开发板</h2><p>首先配置、编译内核，确保内核可以正确编译。得到内核源码后，先修改顶层Makefile，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ARCH 	?= $(SUBARCH)</span><br><span class="line">CROSS_COMPILR	?= </span><br><span class="line">改为</span><br><span class="line">ARCH 	?= arm</span><br><span class="line">CROSS_COMPILR	?= arm-linux- </span><br></pre></td></tr></table></figure>
<p>然后执行如下命令，使用<code>arch/arm/configs/smdk2410_defconfig</code>文件来配置内核，它生成.config配置文件，后面就可以直接使用“make menuconfig”修改配置了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make smdk2410_defconfig</span><br></pre></td></tr></table></figure>
<p>最后是编译生成内核，执行“make”命令将在顶层目录下生成内核映像文件vmlinux；执行“make uImage”除生成vmlinux外，还在<code>arch/arm/boot</code>目录下生成U-Boot格式的内核映像文件uImage。<br>对于S3C2410开发板，上面生成的uImage是可以使用的。在U-Boot控制界面中使用如下命令下载uImage并启动它：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x32000000</span> uImage 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/uImage/</span><br><span class="line">bootm <span class="number">0x32000000</span></span><br></pre></td></tr></table></figure>
<p>在串口可以看到内核的启动信息，只是在最后看到如下的panic信息，这是因为没有修改MTD分区，没有增加对yaffs文件系统的支持。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">VFS: Uable to mount root fs via NFS, trying flopping</span><br><span class="line">VFS: Cannot open root device <span class="string">&quot;mtdblock/2&quot;</span> or unknown-block(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">Please append a correct <span class="string">&quot;root=&quot;</span> boot option;here are the availaable partitions:</span><br><span class="line"><span class="number">1f</span>00			<span class="number">16</span> 		mtdblock0	(driver?)</span><br><span class="line"><span class="number">1f</span>01			<span class="number">2048</span> 	mtdblock1	(driver?)</span><br><span class="line"><span class="number">1f</span>02			<span class="number">4096</span> 	mtdblock2	(driver?)</span><br><span class="line"><span class="number">1f</span>03			<span class="number">2048</span> 	mtdblock3	(driver?)</span><br><span class="line"><span class="number">1f</span>04			<span class="number">4096</span> 	mtdblock4	(driver?)</span><br><span class="line"><span class="number">1f</span>05			<span class="number">10240</span> 	mtdblock5	(driver?)</span><br><span class="line"><span class="number">1f</span>06			<span class="number">24576</span> 	mtdblock6	(driver?)</span><br><span class="line"><span class="number">1f</span>07			<span class="number">16384</span> 	mtdblock7	(driver?)</span><br><span class="line">Kernel panic - not syncing: VFS: Uable to mount root fs on unkown-block(<span class="number">2</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>对于S3C2440开发板，使用同样的命令启动uImage，在打印如下信息之后（U-Boot打印），就会出现一大堆乱码：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/10.jpeg" alt="img not found"><br>所以，Linux 2.6.22.6还不支持本书所用的S3C2440开发板，这个开发板的配置与内核所支持的开发板不一致。<br>要让内核支持当前的S3C2410开发板，需要进行一些修改。</p>
<h3 id="引导阶段代码分析"><a href="#引导阶段代码分析" class="headerlink" title="引导阶段代码分析"></a>引导阶段代码分析</h3><p>由前面对内核Makefile的分析，可知<code>arch/arm/kernel/head.S</code>是内核执行的第一个文件。另外。U-Boot调用内核时，r1寄存器中存储“机器类型ID”，内核会用到它。<br>移植Linux内核时，对于<code>arch/arm/kernel/head.S</code>，只需要关注开头几条命令，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">msr cpsr_c, PSR_F_BIT | PSR_I_BIT | SVC_MODE	@确保进入管理（SVC）模式，并禁止中断</span><br><span class="line">mrc p15, 0, r9, c0, c0							@读取CPU ID，存入r9寄存器</span><br><span class="line">bl __lookup_processor_type						@调用函数，输入参数r9=cpuid，返回值r5=procinfo</span><br><span class="line">movs r10,r5										@如果不支持当前CPU，则返回值r5=0</span><br><span class="line">beq __error_p									@如果r5=0，则打印错误</span><br><span class="line">bl __lookup_machine_type						@调用函数，返回值r5=machinfo</span><br><span class="line">movs r8, r5										@如果不支持当前机器，则返回值r5=0</span><br><span class="line">beq __error_a									@如果r5=0，则打印错误</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>第2行通过设置CPSR寄存器来确保处理器进入管理（SVC）模式，并且禁止中断。<br>第3行读取协处理器CP15的寄存器C0获得CPU ID，CPU ID格式如下所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/11.jpeg" alt="img not found"></p>
<table>
<thead>
<tr>
<th>位</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[31:24]</td>
<td>厂商编号有如下值。<br>0x41 &#x3D; A，表示ARM公司 <br>0x44 &#x3D; D，表示Digital Equipment公司 <br> 0x69 &#x3D; 1，表示Intel公司</td>
</tr>
<tr>
<td>[23:20]</td>
<td>由厂商定义，当产品编号相同时，使用子编号来区分不同的产品子类，如产品中不同的高速缓存大小等</td>
</tr>
<tr>
<td>[19:16]</td>
<td>ARM体系版本号，目前取值如下。<br>0x01，表示ARM体系版本4 <br>0x02，表示ARM体系版本4T <br>0x03，表示ARM体系版本5 <br>0x04，表示ARM体系版本5 <br>0x05，表示ARM体系版本5T <br>0x06，表示ARM体系版本5TE</td>
</tr>
<tr>
<td>[15:4]</td>
<td>产品主编号</td>
</tr>
<tr>
<td>[3:0]</td>
<td>处理器版本号</td>
</tr>
</tbody></table>
<p>比如S3C2410的CPU ID为0x41129200，S3C2440的CPU ID也是0x41129200。注意，S3C2410和S3C2440称为片山系统（SOC），除CPU外，还集成了UART、USB控制器、NAND Flash控制器等设备。从它们的CPU ID可知，它们的CPU是相同的，只是片上外设不一样。<br>第4行调用<code>__lookup_processor_type</code>函数，确定内核是否支持当前CPU。如果支持，r5寄存器将会返回一个用来描述处理器的结构体的地址，否则r5的值为0。<br>第7行调用<code>__lookup_machine_type</code>函数，确定内核是否支持当前开发板。如果支持，r5寄存器将会返回一个用来描述这个开发板的结构体的地址，否则r5的值为0。<br>如果<code>__lookup_processor_type</code>、<code>__lookup_machine_type</code>这两个函数中有一个返回值为0，则内核不能启动，如果配置内核时选择了CONFIG_DEBUG_ALL，还会打印一些提示信息。<br><code>__lookup_processor_type</code>、<code>__lookup_machine_type</code>函数都是在<code>arch/arm/kernel/head-common.S</code>中定义的。<br>内核映像中，定义了若干个<code>proc_info_list</code>结构（结构体原型在include&#x2F;asm-arm&#x2F;procinfo.h中定义），表示它支持的CPU。对于ARM架构的CPU，这些结构体的源码在<code>arch/arm/mm/</code>目录下，比如<code>proc-arm920.S</code>中的如下代码，它表示arm920 CPU的proc_info_list结构。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.section &quot;.proc.info.init&quot;, #alloc, #execinstr</span><br><span class="line"></span><br><span class="line">.type __arm920_proc_info, #object</span><br><span class="line">__arm920_proc_info:</span><br><span class="line">.long 0x41009200</span><br><span class="line">.long 0xff00fff0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>不同的<code>proc_info_list</code>结构被用来支持不同的CPU，它们都是定义在“.proc.info.init”段中。在连接内核时，这些结构体被组织在一起，开始地址为<code>__proc_info_begin</code>，结束地址为<code>__proc_info_end</code>。这可以从连接脚本<code>arch/arm/kernel/vmlinux.lds</code>中看出来。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">__proc_info_begin = .;		//proc_info_init结构的开始地址</span><br><span class="line">*(.proc.info.init)</span><br><span class="line">__proc_info_end = .;		//proc_info_init结构的结束地址</span><br></pre></td></tr></table></figure>
<p><code>__lookup_processor_type</code>函数就是根据前面读出的CPU ID （存在r9 寄存器中），从这些<code>proc_info_init</code>结构中找出匹配的，它的代码如下（<code>arch/arm/kernel/head-common.S</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">	.type	__lookup_processor_type, %function</span><br><span class="line">__lookup_processor_type:</span><br><span class="line">	adr	r3, 3f							@ r3 = 最后一行代码的物理地址（3）</span><br><span class="line">	ldmda	r3, &#123;r5 - r7&#125;				@ r5 = __proc_info_begin,r6 = __proc_info_end,它们是虚拟地址。r7 = 最后一行代码的虚拟地址</span><br><span class="line">	sub	r3, r3, r7						@ r3 = r3 - r7，即物理地址和虚拟地址的差值</span><br><span class="line">	add	r5, r5, r3						@ r5 = __proc_info_begin 对应的物理地址</span><br><span class="line">	add	r6, r6, r3						@ r6 = __proc_info_end 对应的物理地址</span><br><span class="line">1:	ldmia	r5, &#123;r3, r4&#125;				@ r3、r4 = proc_info_list结构中的cpu_val、cpu_mask</span><br><span class="line">	and	r4, r4, r9						@ r4 = (r4 &amp; r9) = (cpu_mask &amp; 传入的CPU ID)</span><br><span class="line">	teq	r3, r4							@ 比较</span><br><span class="line">	beq	2f								@ 如果相等，表示找到匹配的proc_info_list结构，跳到（2）</span><br><span class="line">	add	r5, r5, #PROC_INFO_SZ			@ r5指向下一个proc_info_list结构 PROC_INFO_SZ = sizeof（proc_info_list）</span><br><span class="line">	cmp	r5, r6							@ 是否已经比较完所有的proc_info_list结构</span><br><span class="line">	blo	1b								@ 没有则继续比较</span><br><span class="line">	mov	r5, #0							@ 比较完毕，但是没有匹配的proc_info_list结构，r5 = 0</span><br><span class="line">2:	mov	pc, lr							@ 返回</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Look in include/asm-arm/procinfo.h and arch/arm/kernel/arch.[ch] for</span><br><span class="line"> * more information about the __proc_info and __arch_info structures.</span><br><span class="line"> */</span><br><span class="line">	.long	__proc_info_begin			@ proc_info_list结构的开始地址，这是连接地址，也是虚拟地址</span><br><span class="line">	.long	__proc_info_end				@ proc_info_list结构的结束地址，这是链接地址，也是虚拟地址</span><br><span class="line">3:	.long	.							@ “.”表示当前这行代码编译连接后的虚拟地址</span><br></pre></td></tr></table></figure>
<p>在调用<code>__enable_mmu</code>函数之前使用的都是物理地址，而内核却是以虚拟地址连接的。所以在访问<code>proc_info_list</code>结构前，先将它的虚拟地址转换为物理地址，第3-7行就是用来转换地址的。<br>第3行用来获得第26行代码的物理地址。adr指令基于pc寄存器计算地址值，由于这时候还没使能MMU，pc寄存器中使用的还是物理地址，所以执行“adr,r3,3f”后，r3寄存器中存放的就是第26行代码的物理地址。<br>第4行用来获得第24-26行定义的数据：__proc_info_begin、__proc_info_end和“.”。这3个数据都是在连接内核时确定，它们是虚拟地址，前两个表示<code>proc_info_list</code>结构的开始地址和结束地址，“.”表示当前行的代码在编译连接后的虚拟地址。<br>第5行计算物理地址和虚拟地址的差值，第6-7行根据这个差值计算<code>__proc_info_begin</code>、<code>__proc_info_end</code>的物理地址。<br>下面的代码依次读取每个<code>proc_info_list</code>结构前面的两个成员（cpu_val和cpu_mask），判断cpu_val是否等于(r9 &amp; cpu_mask)，r9是<code>arch/arm/kernel/head.S</code>中调用<code>__lookup_processor_type</code>时传入的CPU ID。如果比较相等，则表示当前<code>proc_info_list</code>结构适用于这个CPU，直接返回这个结构的地址（存在r5中）。如果<code>__proc_info_begin</code>、<code>__proc_info_end</code>之间的所有<code>proc_info_list</code>结构都不支持这个CPU，则返回0(r5)。<br>对于S3C2410、S3C2440开发板，它们的CPU ID都是0x41129200，而在<code>arch/arm/mm/proc-arm920.S</code>中定义的<code>__arm920_proc_info</code>结构中，cpu_val、cpu_mask等于0x41009200、0xff00fff0，刚好匹配。内核中要包含这个文件，在<code>arch/arm/mm/Makefile</code>中可以看到下面这行，它表示需要配置CONFIG_CPU_ARM920T（配置菜单中System Type-&gt;Support ARM920T procrssor）。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_CPU_ARM920T)      += proc_arm920.o</span><br></pre></td></tr></table></figure>
<p>下面讲解<code>__	lookup_machine_type</code>,它和<code>__lookup_processor_type</code>函数代码相似。<br>内核中对于每种支持的开发板都会使用宏MACHINE_START、MACHINE_END来定义一个<code>machine_desc</code>结构，它定义了开发板相关的一些属性和函数。比如机器类型ID、起始I&#x2F;O物理地址，Bootloader传入的参数的地址、中断初始化函数、I&#x2F;O映射函数等。比如对于SDMK2440开发板，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">MACHINE_START(S3C2440, &quot;SMDK2440&quot;)</span><br><span class="line">	/* Maintainer: Ben Dooks &lt;ben@fluff.org&gt; */</span><br><span class="line">	.phys_io	= S3C2410_PA_UART,</span><br><span class="line">	.io_pg_offst	= (((u32)S3C24XX_VA_UART) &gt;&gt; 18) &amp; 0xfffc,</span><br><span class="line">	.boot_params	= S3C2410_SDRAM_PA + 0x100,</span><br><span class="line"></span><br><span class="line">	.init_irq	= s3c24xx_init_irq,</span><br><span class="line">	.map_io		= smdk2440_map_io,</span><br><span class="line">	.init_machine	= smdk2440_machine_init,</span><br><span class="line">	.timer		= &amp;s3c24xx_timer,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure>
<p>宏<code>MACHINE_START</code>、<code>MACHINE_END</code>在<code>include/asm-arm/mach/arch.h</code>文件中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set of macros to define architecture features.  This is built into</span></span><br><span class="line"><span class="comment"> * a table by the linker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACHINE_START(_type,_name)			\</span></span><br><span class="line"><span class="meta">static const struct machine_desc __mach_desc_##_type	\</span></span><br><span class="line"><span class="meta"> __used							\</span></span><br><span class="line"><span class="meta"> __attribute__((__section__(<span class="string">&quot;.arch.info.init&quot;</span>))) = &#123;	\</span></span><br><span class="line"><span class="meta">	.nr		= MACH_TYPE_##_type,		\</span></span><br><span class="line"><span class="meta">	.name		= _name,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACHINE_END				\</span></span><br><span class="line"><span class="meta">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>所以上一段代码扩展开来就是：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> __<span class="title">mach_desc_S3C2440</span>	\</span></span><br><span class="line"><span class="class"> __<span class="title">used</span>							\</span></span><br><span class="line"><span class="class"> __<span class="title">attribute__</span>((__<span class="title">section__</span>(&quot;.<span class="title">arch</span>.<span class="title">info</span>.<span class="title">init</span>&quot;))) =</span> &#123;	\</span><br><span class="line">	.nr		= MACH_TYPE_S3C2440,		\</span><br><span class="line">	.name		= _name,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的MACH_TYPE_S3C2440在<code>arch/arm/tools/mach-types</code>中定义，它最后会被换成一个头文件<code>include/asm-arm/mach-types.h</code>供其他文件包含。machine_desc在<code>include/asm-arm/mach/arch.h</code>文件中定义。所有的machine_desc结构都处于“.arch.info.init”段中，在连接内核时，它们被组织在一起，开始地址为<code>__arch_info_begin</code>，结束地址为<code>__arch_info_end</code>。这可以从连接脚本文件<code>arch/arm/kernel/vmlinux.lds</code>中看出来：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__arch_info_begin = .;				<span class="comment">//machine_desc结构的开始地址</span></span><br><span class="line">	*(.arch.info.init)</span><br><span class="line">__arch_info_end = .;				<span class="comment">//machine_desc结构的结束地址</span></span><br></pre></td></tr></table></figure>
<p>不同的machine_desc结构用于不同的开发板，U-Boot调用内核时，会在r1寄存器中给出开发板的标记（机器类型ID）。<code>__loockup_machine_type</code>函数将这个值与machine_desc中的nr成员比较，如果两者相等则表示找到匹配的machine_desc结构，于是返回它的地址（存在r5中）。如果<code>__arch_info_begin</code>和<code>__arch_info_end</code>之间所有的machine_desc结构的nr成员都不等于r1寄存器的值，则返回0（r5）。<br>对于本书所用的S3C2410、S3C2440开发板，U-Boot传入的机器类型ID为MACH_TYPE_SMDK2410、MACH_TYPE_SMDK2440。它们对应的machine_desc结构分别在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>和<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code>中定义，所以两个文件要编进内核。在配置菜单中，选中下面两个开发板即可。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">System Type --&gt; S3C2410 Machines --&gt; SMDK2410/A9M2410</span><br><span class="line">System Type --&gt; S3C2440 Machines --&gt; SMDK2440</span><br></pre></td></tr></table></figure>
<p><code>__lookup_machine_type</code>函数的代码如下（<code>/arch/arm/kernel/head-common.S</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">3:	.long	.</span><br><span class="line">	.long	__arch_info_begin</span><br><span class="line">	.long	__arch_info_end</span><br><span class="line">...</span><br><span class="line">	.type	__lookup_machine_type, %function</span><br><span class="line">__lookup_machine_type:</span><br><span class="line">	adr	r3, 3b								@ r3 = 第1行的物理地址</span><br><span class="line">	ldmia	r3, &#123;r4, r5, r6&#125;				@ r4 = 第1行的虚拟地址	r5 = __arch_info_begin r6 = __arch_info_end 它们是虚拟地址</span><br><span class="line">	sub	r3, r3, r4							@ r3 = r3 - r4 即物理地址和虚拟地址的差值</span><br><span class="line">	add	r5, r5, r3							@ r5 = __arch_info_begin 对应的物理地址</span><br><span class="line">	add	r6, r6, r3							@ r6 = __arch_info_end 对应的物理地址</span><br><span class="line">1:	ldr	r3, [r5, #MACHINFO_TYPE]			@ r5是machine_desc 结构的地址 r3 = machine_desc 结构中定义的nr成员，即机器类型ID</span><br><span class="line">	teq	r3, r1								@ r1是Bootloader调用内核时传入的机器类型ID，测试是否相等</span><br><span class="line">	beq	2f									@ 若相等，跳到（2）</span><br><span class="line">	add	r5, r5, #SIZEOF_MACHINE_DESC		@ 否则，r5指向下一个machine_desc结构，SIZEOF_MACHINE_DESC = sizeof(machine_desc)</span><br><span class="line">	cmp	r5, r6								@ 是否比较完所有的machine_desc结构</span><br><span class="line">	blo	1b									@ 没有则继续比较</span><br><span class="line">	mov	r5, #0								@ 比较完毕，但是没有匹配的machine_desc结构，r5 = 0</span><br><span class="line">2:	mov	pc, lr								@ 返回</span><br></pre></td></tr></table></figure>
<p>如果<code>__lookup_processor_tyep</code>、<code>__lookup_machine_type</code>函数都返回成功，则后续引导程序将继续执行下去。其中的<code>__create_page_tables</code>函数用来创建一级页表以建立虚拟地址到物理地址的映射关系，它用到<code>__lookup_processor_type</code>函数返回的proc_info_list结构。在引导的最后，调用<code>start_kernel</code>函数进入内核启动的第二阶段。<code>__lookup_machine_type</code>函数确定的machine_desc结构将在第二阶段多次使用。</p>
<h3 id="start-kernel-函数部分代码分析"><a href="#start-kernel-函数部分代码分析" class="headerlink" title="start_kernel 函数部分代码分析"></a>start_kernel 函数部分代码分析</h3><p>进入<code>start_kernel</code>函数（<code>init/main.c</code>）之后，如果串口上没有看到内核的启动信息，一般而言有两个原因：Bootloader传入的命令行参数不对，或者<code>setup_arch</code>函数（<code>arch/arm/kernel/setup.c</code>）针对开发板的设置不正确。<br>在调用<code>setup_arch</code>函数之前就已经调用<code>“printk(linux_banner)”</code>了，但是这个时候printk函数只是将打印信息放在缓存区中，并没有打印到控制台上（串口、LCD屏等），因为这个时候控制台还未初始化。printk打印的内容在<code>console_init</code>函数注册、初始化控制台之后才真正输出。<br>移植U-Boot时，U-Boot传给内核的参数有两类：预先存在某个地址的tag列表和调用内核时在r1寄存器中指定的机器类型ID。后者在引导阶段的<code>__lookup_machine_type</code>函数已经用到。而tag列表将在<code>setup_arch</code>函数中进行初步处理。本节将重点介绍<code>setup_arch</code>函数、<code>console_init</code>函数、以tag列表的处理（内存tag、命令行tag）、串口控制台的初始化为主线。</p>
<h4 id="setup-arch-函数分析"><a href="#setup-arch-函数分析" class="headerlink" title="setup_arch 函数分析"></a>setup_arch 函数分析</h4><p><code>setup_arch</code>函数在<code>arch/arm/kernel/setup.c</code>中定义，其部分代码及流程图如下：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/12.jpeg" alt="img not found"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	setup_processor();											<span class="comment">//进行处理器相关的一些设置</span></span><br><span class="line">	mdesc = setup_machine(machine_arch_type);					<span class="comment">//获得开发板的machine_desc结构</span></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;boot_params)										<span class="comment">//定义了Bootloader传入参数的地址</span></span><br><span class="line">		tags = phys_to_virt(mdesc-&gt;boot_params);				<span class="comment">//这个地址就是tag列表的首地址</span></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (tags-&gt;hdr.tag == ATAG_CORE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (meminfo.nr_banks != <span class="number">0</span>)								<span class="comment">//如果已经在内核中定义了meminfo结构</span></span><br><span class="line">			squash_mem_tags(tags);								<span class="comment">//则忽略内存tag</span></span><br><span class="line">		parse_tags(tags);										<span class="comment">//解释每一个tag</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="built_in">memcpy</span>(boot_command_line, from, COMMAND_LINE_SIZE);</span><br><span class="line">	boot_command_line[COMMAND_LINE_SIZE<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	parse_cmdline(cmdline_p, from);								<span class="comment">//对命令行进行一些先期的处理</span></span><br><span class="line">	paging_init(&amp;meminfo, mdesc);								<span class="comment">//重新初始化页表</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，第[4]行的<code>setup_processor</code>函数被用来进行处理器相关的一些设置，它会调用引导阶段的<code>lookup_processor_type</code>函数以获得该处理器的proc_info_list结构。<br>接下来，第[5]行的<code>setup_machine</code>函数被用来获得开发板的machine_desc结构，这通过调用引导阶段<code>lookup_machine_type</code>函数来实现。以后就会根据开发板的machine_desc结构来进行一些开发板的相关操作，<br>第[7]-[8]行用来确定Bootloader传入的启动参数的地址，它在开发板的machine_desc结构中指定，第[8]行将它转换为虚拟地址。比如对于S3C2440开发板，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中有如下定义。启动参数的地址就是（S3C2410_SDRAM_PA + 0x100），即0x30000100。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MACHINE_START(S3C2440,<span class="string">&quot;SMDK2440&quot;</span>)</span><br><span class="line">...</span><br><span class="line">	.bootm_params = S3C2440_SDRAM_PA + <span class="number">0x100</span>,</span><br></pre></td></tr></table></figure>
<p>第[13]行处理每个tag。文件<code>arch/arm/kernel/setup.c</code>对每种tag都定义了相应的处理函数，比如对于内存tag、命令行tag，使用如下两行代码指定了它们的处理函数为<code>parse_tag_mem32、parse_tag_cmdline</code>。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__tagtable(ATAG_MEM,parse_tag_mem32);</span><br><span class="line">__tagtable(ATAG_CMDLINE,parse_tag_cmdline);</span><br></pre></td></tr></table></figure>
<p><code>parse_tag_mem32</code>函数根据内存tag定义的内存起始地址、长度，在全局结构变量meminfo中增加内存的描述信息。以后内核就可以通过meminfo结构了解开发板的的内存信息。<br><code>parse_tag_cmdline</code>只是简单的将命令行tag的内容复制到字符串default_command_line中保存下来，后面才进一步处理。<br>第[18]行扫描命令行参数，对其中的一些参数进行先期的处理。这些参数使用“__early_param”来定义，比如<code>arch/arm/kernel/setup.c</code>中下面的一行代码，它表示如果命令行中有“mem&#x3D;…”的字样，就调用<code>early_mem</code>（在<code>include/asm-arm/setup.h</code>中定义）对它进行处理：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__early_param(<span class="string">&quot;mem=&quot;</span>,early_mem);</span><br></pre></td></tr></table></figure>
<p>“mem&#x3D;…”用来强制限制Linux系统所能使用的内存总量，比如“mem&#x3D;60M”使得系统只能使用60MB的内存，即使内存tag中指明了共有64MB内存。类似的参数还有“initrd&#x3D;”等。<br>此时命令行的处理还没有结束，在setup_arch函数之外还会进行一系列后续处理，比如<code>start_kernel</code>函数中调用如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setup_command_line(command_line);</span><br><span class="line">...</span><br><span class="line">parse_early_param();</span><br><span class="line">parse_args(<span class="string">&quot;Booting kernel&quot;</span>, static_command_line, __start___param,</span><br><span class="line">		   __stop___param - __start___param,</span><br><span class="line">		   &amp;unknown_bootoption);</span><br></pre></td></tr></table></figure>
<p>比如对于命令行中的“console&#x3D;ttySAC0”，它的处理过程就是第[4]行的<code>parse_args</code>函数调用第[6]行传入的<code>unknown_bootoption</code>函数，最后调用下面代码指定的处理函数<code>console_setup</code>（在<code>kernel/printk.c</code>中定义）。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__setup(<span class="string">&quot;console=&quot;</span>,console_setup);</span><br></pre></td></tr></table></figure>
<p>命令行参数“console&#x3D;…”用来指定要使用的控制台的名称、序号、参数。比如对于“console&#x3D;ttySAC0,115200”，表示要使用的控制台名称为ttySAC，序号为0（第一个串口），波特率为115200。经过<code>console_setup</code>处理后，会在全局结构变量console_cmdline中保存这些信息，在后面<code>console_init</code>函数初始化控制台时会根据这些信息选择要使用的控制台。<br><code>setup_arch</code>函数后面会调用<code>paging_init</code>函数，这也是一个开发板相关的函数。</p>
<h4 id="paging-init函数分析"><a href="#paging-init函数分析" class="headerlink" title="paging_init函数分析"></a>paging_init函数分析</h4><p>这个函数在<code>setup_arch</code>函数中的调用形式如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">paging_init(&amp;meminfo,mdesc);</span><br></pre></td></tr></table></figure>
<p>meminfo中存放内存的信息，前面解释内存tag时确定了构建这个全局结构。<br>mdesc就是前面<code>lookup_machine_type</code>函数返回的machine_desc结构。对于S3C2440开发板，这个结构在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中有如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">MACHINE_START(S3C2440, <span class="string">&quot;SMDK2440&quot;</span>)</span><br><span class="line">	<span class="comment">/* Maintainer: Ben Dooks &lt;ben@fluff.org&gt; */</span></span><br><span class="line">	.phys_io	= S3C2410_PA_UART,</span><br><span class="line">	.io_pg_offst	= (((u32)S3C24XX_VA_UART) &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0xfffc</span>,</span><br><span class="line">	.boot_params	= S3C2410_SDRAM_PA + <span class="number">0x100</span>,</span><br><span class="line"></span><br><span class="line">	.init_irq	= s3c24xx_init_irq,</span><br><span class="line">	.map_io		= smdk2440_map_io,</span><br><span class="line">	.init_machine	= smdk2440_machine_init,</span><br><span class="line">	.timer		= &amp;s3c24xx_timer,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure>
<p>上面几行代码是移植Linux必须关注的数据结构。对于S3C2410开发板，它在<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code><br><code>paging_init</code>函数在<code>arch/arm/mm/mmu.c</code>中定义，根据我们的移植目的–让内核可以在S3C2440上运行。关注如下流程：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">paging_init -&gt; devicemaps_init -&gt; mdesc -&gt; map_io()</span><br></pre></td></tr></table></figure>
<p>对于S3C2440开发板，就是调用<code>smdk2410_map_io</code>函数，它也是<code>arch/arm/mach-s3c2440/mach-s3c2440.c</code>中定义。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">smdk2440_map_io</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	s3c24xx_init_io(smdk2440_iodesc, ARRAY_SIZE(smdk2440_iodesc));</span><br><span class="line">	s3c24xx_init_clocks(<span class="number">16934400</span>);</span><br><span class="line">	s3c24xx_init_uarts(smdk2440_uartcfgs, ARRAY_SIZE(smdk2440_uartcfgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述三个函数所实现的功能，从名字就可以看出，第四行中参数值表示开发板晶振的频率。当前开发板所使用的晶振频率是12MHz，不是16934400，这就是S3C2440开发板上启动uImage时串口输出乱码的原因，将它改为12000000即可。</p>
<h4 id="console-init-函数分析"><a href="#console-init-函数分析" class="headerlink" title="console_init 函数分析"></a>console_init 函数分析</h4><p>虽然上面已经找到内核无法正常输出信息的原因，但我们不该止步于此。在2.4的内核中，命令行参数常用“console&#x3D;ttyS0”来指定控制台为串口0，在2.6版本的内核中改为“console&#x3D;ssySAC0”。分析<code>console_init</code>函数的功能就可以了解这点。<br><code>console_init</code>函数被<code>start_kernel</code>函数调用，它在<code>drivers/char/tty_io.c</code>文件中定义</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">initcall_t</span> *call;</span><br><span class="line">...</span><br><span class="line">	call = __con_initcall_start;</span><br><span class="line">	<span class="keyword">while</span> (call &lt; __con_initcall_end) &#123;</span><br><span class="line">		(*call)();</span><br><span class="line">		call++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用地址范围<code>__con_initcall_start</code>至<code>__con_initcall_end</code>之间的定义的每个函数，这些函数使用<code>console_initcall</code>宏来指定。比如<code>drivers/serial/s3c2410.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">console_initcall(s3c24xx_serial_initconsole);</span><br></pre></td></tr></table></figure>
<p><code>s3c24xx_serial_initconsole</code>函数也是在<code>drivers/serial/s3c2410.c</code>中定义，它初始化S3C24xx类SoC的串口控制台，部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_serial_initconsole</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	register_console(&amp;s3c24xx_serial_console);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s3c24xx_serial_console结构在<code>drivers/serial/s3c2410.c</code>中定义如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console</span> <span class="title">s3c24xx_serial_console</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">	.name		= S3C24XX_SERIAL_NAME,				<span class="comment">//即“ttySAC”</span></span><br><span class="line">	.device		= uart_console_device,				<span class="comment">//以后使用/dev/console时，用来构造设备节点</span></span><br><span class="line">	.flags		= CON_PRINTBUFFER,					<span class="comment">//控制台可用之前，printk已经在缓冲区打印了很多信息，CON_PRINTBUFFER表示注册控制台之后</span></span><br><span class="line">													<span class="comment">//打印这些“过去”的信息</span></span><br><span class="line">	.index		= <span class="number">-1</span>,								<span class="comment">//-1可以匹配任意序号。比如ttySAC0/1/2</span></span><br><span class="line">	.write		= s3c24xx_serial_console_write,		<span class="comment">//打印函数</span></span><br><span class="line">	.setup		= s3c24xx_serial_console_setup		<span class="comment">//设置函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>register_console(&amp;s3c24xx_serial_console);</code>在内核中注册控制台，就是把s3c24xx_serial_console结构链入一个全局链表console_drivers中（它在<code>kernel/printf.c</code>中定义）。并且使用其中的name和index与前面的“console&#x3D;…”指定的控制台相比较，如果相符，则以后的printk信息从这个控制台输出。<br>对于本书的情况，“console&#x3D;ttySAC0”，而s3c24xx_serial_console结构中名字为“ttySAC”，序号为-1（可取任意值），所以两者匹配，printk信息将从串口0输出。<br>现在总结一下上面分析的<code>内核启动第二阶段的函数调用过程</code>，相同的缩进表示它们是在同一个函数中被调用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">start_kernel -&gt;</span><br><span class="line">	setup_arch -&gt;</span><br><span class="line">		setup_processor</span><br><span class="line">		setup_machine</span><br><span class="line">		...</span><br><span class="line">		parse_tags</span><br><span class="line">		...</span><br><span class="line">		parse_cmdline</span><br><span class="line">		paging_init -&gt;</span><br><span class="line">			devicemaps_init -&gt;</span><br><span class="line">				mdesc_map_io() -&gt;</span><br><span class="line">					s3c24xx_init_io</span><br><span class="line">					s3c24xx_init_clocks</span><br><span class="line">					s3c24xx_init_uarts</span><br><span class="line">		...</span><br><span class="line">		console_init -&gt;</span><br><span class="line">			s3c24xx_serial_initconsole -&gt;</span><br><span class="line">				register_console(&amp;s3c24xx_serial_initconsole)</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<h3 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h3><p>在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中做如下修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3c24xx_init_clocks(<span class="number">16934400</span>);</span><br><span class="line">改为</span><br><span class="line">s3c24xx_init_clocks(<span class="number">12000000</span>);</span><br></pre></td></tr></table></figure>
<p>然后执行“make uImage”生成uImage。<br>对于S3C2410、S3C2440开发板，上面生成的uImage都可以使用了。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x32000000</span> uImage 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/uImage</span><br><span class="line">bootm <span class="number">0x32000000</span></span><br></pre></td></tr></table></figure>
<p>可以看到内核的启动信息，最后出现panic信息（这需要修改mtd分区、增加对yaffs文件系统的支持）。</p>
<h2 id="修改-MTD-分区"><a href="#修改-MTD-分区" class="headerlink" title="修改 MTD 分区"></a>修改 MTD 分区</h2><p>MTD（Memory Technology Device），即内存技术设备，是Linux中对ROM、NOR Flash、NAND Flash等存储设备抽象出来的设备层。它向上提供统一的访问接口：读、写、擦除等；屏蔽了底层硬件的操作、各类存储设备的差别。得益于MTD设备的作用，重新划分NAND Flash的分区很简单。</p>
<h3 id="驱动对设备的识别过程"><a href="#驱动对设备的识别过程" class="headerlink" title="驱动对设备的识别过程"></a>驱动对设备的识别过程</h3><p>驱动程序识别设备时，有以下两种方法。</p>
<ol>
<li>驱动程序本身带有设备的信息，比如开始地址、中断号等；加载驱动程序时，就可以根据这些信息来识别设备。</li>
<li>驱动程序本身没有设备的信息，但是内核中已经根据其他方式确定了很多设备的信息；加载驱动程序时，将驱动程序与这些设备逐个比较，确定两者是否匹配，如果成功匹配，那么就可以通过驱动程序操作这个设备了。<br>内核常使用第二种方法来识别设备，这可以将各种设备集中在一个文件中管理，当开发板的配置改变时，便于修改代码。在内核文件<code>include/linux/paltform/device.h</code>中，定义了两个数据结构来表示这些设备和驱动程序：paltform_device结构用来描述设备的名称、ID、所占用的资源（内存地址&#x2F;大小、中断号）等；platform_driver结构用来描述各种操作函数，比如枚举函数、移除设备函数、驱动的名称等。<br>内核启动后，首先构造链表将描述设备的platform_device结构组织起来，得到一个设备的列表；当加载某个驱动程序的platform_driver结构时，使用一些匹配函数来检查驱动程序能否支持这些设备，常用的检察方式很简单：比较驱动程序和设备的名称。<br>以S3C2440开发板为例，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中定义了如下设备：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">smdk2440_devices</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">	&amp;s3c_device_usb,</span><br><span class="line">	&amp;s3c_device_lcd,</span><br><span class="line">	&amp;s3c_device_wdt,</span><br><span class="line">	&amp;s3c_device_i2c,</span><br><span class="line">	&amp;s3c_device_iis,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在<code>arch/arm/plat-s3c24xx/common-smdk.c</code>中定义了如下设备：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> __<span class="title">initdata</span> *<span class="title">smdk_devs</span>[] =</span> &#123;</span><br><span class="line">	&amp;s3c_device_nand,</span><br><span class="line">	&amp;smdk_led4,</span><br><span class="line">	&amp;smdk_led5,</span><br><span class="line">	&amp;smdk_led6,</span><br><span class="line">	&amp;smdk_led7,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这些设备在<code>smdk2410_init</code>函数或<code>smdk2440_init</code>函数中，通过<code>platform_add_devices</code>函数注册进内核中。<br>NAND Flash设备s3c_device_nand在<code>arch/arm/plat-s3c24xx/devs.c</code>中的定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">s3c_device_nand</span> =</span> &#123;</span><br><span class="line">	.name		  = <span class="string">&quot;s3c2410-nand&quot;</span>,</span><br><span class="line">	.id		  = <span class="number">-1</span>,</span><br><span class="line">	.num_resources	  = ARRAY_SIZE(s3c_nand_resource),</span><br><span class="line">	.resource	  = s3c_nand_resource,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
对于S3C2440开发板，s3c_device_nand结构的名字会在s3c24xx_map_io函数中修改为“s3c2440-nand”，这个函数在<code>arch/arm/plat-s3c24xx/s3c244x.c</code>中的定义如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">s3c244x_map_io</span><span class="params">(<span class="keyword">struct</span> map_desc *mach_desc, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	s3c_device_i2c.name  = <span class="string">&quot;s3c2440-i2c&quot;</span>;</span><br><span class="line">	s3c_device_nand.name = <span class="string">&quot;s3c2440-nand&quot;</span>;</span><br><span class="line">	s3c_device_usbgadget.name = <span class="string">&quot;s3c2440-usbgadget&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有了NAND Flash设备，还要有NAND Flash驱动程序，内核针对S3C2410、S3C2412、S3C2440定义了3个驱动。它们在<code>drivers/mtd/s3c2410.c</code>中的<code>s3c2410_nand_init</code>函数中注册进内核，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3c2410_nand_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;S3C24XX NAND Driver, (c) 2004 Simtec Electronics\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	platform_driver_register(&amp;s3c2412_nand_driver);</span><br><span class="line">	platform_driver_register(&amp;s3c2440_nand_driver);</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;s3c2410_nand_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中的s3c2440_nand_driver结构也是在相同的文件中定义，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">s3c2440_nand_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= s3c2440_nand_probe,</span><br><span class="line">	.remove		= s3c2410_nand_remove,</span><br><span class="line">	.suspend	= s3c24xx_nand_suspend,</span><br><span class="line">	.resume		= s3c24xx_nand_resume,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;s3c2440-nand&quot;</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
可见，s3c_device_nand结构和s3c2440_nand_driver结构中的name成员相同，都是“s3c2440-nand”。<code>platform_driver_register</code>函数就是根据这点确定它们是匹配的，所以调用<code>s3c2440_nand_probe</code>函数来枚举NAND Flash设备s3c_device_nand。<br>从<code>s3c2440_nand_probe</code>函数开始，可以一直找到对NAND Flash分区的识别，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">s3c2440_nand_probe(&amp;s3c_device_nand) -&gt;								<span class="comment">//这个参数是为了便于理解加上的</span></span><br><span class="line">	s3c24xx_nand_probe(&amp;s3c_device_nand, TYPE_S3C2440) -&gt;			<span class="comment">//</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">s3c2410_platform_nand</span> *<span class="title">plat</span> =</span> to_nand_plat(pdev) -&gt;	<span class="comment">//plat = &amp;smdk_nand_info</span></span><br><span class="line">		s3c2410_nand_add_partition(info, nmtd, sets); -&gt;			<span class="comment">//sets就是smdk_nand_info</span></span><br><span class="line">		add_mtd_partitions											<span class="comment">//实际的参数为smdk_default_nand_part</span></span><br></pre></td></tr></table></figure>
这些函数都在<code>drivers/mtd/nand/s3c2410.c</code>中定义，最后的<code>add_mtd_partitions</code>函数根据smdk_default_nand_part结构来确定分区。这个结构在<code>arch/arm/plat-s3c24xx/common-smdk.c</code>中定义，要改变分区时修改它即可。</li>
</ol>
<h3 id="修改-MTD-分区-1"><a href="#修改-MTD-分区-1" class="headerlink" title="修改 MTD 分区"></a>修改 MTD 分区</h3><p>如上所述，要改变分区时，修改<code>arch/arm/plat-s3c24xx/common-smdk.c</code>文件中的smdk_default_nand_part结构即可。本章节将NAND Flash划分为3个分区，前2MB用于存放内核，接下来的8MB用于存放JFFS2文件系统，剩下的用来存放YAFFS文件系统。<br>smdk_default_nand_part结构修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">smdk_default_nand_part</span>[] =</span> &#123;</span><br><span class="line">	[<span class="number">0</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;Kernel&quot;</span>,</span><br><span class="line">		.size	= SZ_2M,</span><br><span class="line">		.offset	= <span class="number">0</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[<span class="number">1</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;jffs2&quot;</span>,</span><br><span class="line">		.offset = MTDPART_OFS_APPEND,</span><br><span class="line">		.size	= SZ_8M,</span><br><span class="line">	&#125;,</span><br><span class="line">	[<span class="number">2</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;yaffs&quot;</span>,</span><br><span class="line">		.offset = MTDPART_OFS_APPEND,</span><br><span class="line">		.size	= MTDPART_SIZ_FULL,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的MTDPART_OFS_APPEND表示当前分区紧接着上一个分区，MTDPART_SIZ_FULL表示当前分区的大小为剩余的Flash空间。<br>执行“make uImage”重新生成内核映像，重新启动后可以看到内核打印出如下分区信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Creating <span class="number">3</span> MTD partitions on <span class="string">&quot;NAND 64MiB 3,3V 8-bit&quot;</span></span><br><span class="line"><span class="number">0x00000000</span><span class="number">-0x00200000</span>: <span class="string">&quot;kernel&quot;</span></span><br><span class="line"><span class="number">0x00200000</span><span class="number">-0x00a00000</span>: <span class="string">&quot;jffs2&quot;</span></span><br><span class="line"><span class="number">0x00a00000</span><span class="number">-0x04000000</span>: <span class="string">&quot;yaffs&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于目标板没有写入文件系统映像，也没有设置命令行使用网络文件系统（nfs），内核启动后还是会出现panic信息。</p>
<h2 id="移植-YAFFS-文件系统"><a href="#移植-YAFFS-文件系统" class="headerlink" title="移植 YAFFS 文件系统"></a>移植 YAFFS 文件系统</h2><h3 id="YAFFS-文件系统介绍"><a href="#YAFFS-文件系统介绍" class="headerlink" title="YAFFS 文件系统介绍"></a>YAFFS 文件系统介绍</h3><p>YAFFS（yet another flash file system）是一种类似于JFFS&#x2F;JFFS2、专门为NAND Flash 设计的嵌入式文件系统，适用于大容量的存储设备。它是日志结构的文件系统，提供了损耗平衡和掉电保护，可以有效避免意外掉电对文件系统一致性和完整性的影响。与JFFS相比，它减少了一些功能，因此速度更快，占用内存更少。<br>YAFFS充分考虑了NAND Flash的特点，根据NAND Flash以页面为单位存取的特点，将文件组织成固定大小的数据段。利用NAND Flash提供的每个页面16字节的OOB空间来存储ECC（Error Correction Code）和文件系统的组织信息，不仅能实现错误检测和坏块处理，也能够提高文件系统的加载速度。YAFFS采用了一种多策略混合的垃圾回收算法，结合了贪心策略的高效性和随机选择的平均性，达到了兼顾系统开销和损耗平衡的目的。<br>YAFFS文件系统具有很好的移植性，可以在Linux、WindowsCE、pSOS、ThreadX、DSP-BIOS等多种操作系统上工作。为NAND Flash提供了一种可靠的操作系统，并且适合于对能耗要求高的嵌入式系统。<br>YAFFS文件系统目前已经发展到第二版本：YAFFS2，它向前兼容YAFFS1，主要特点是支持每页容量大于512字节的NAND Flash。</p>
<table>
<thead>
<tr>
<th></th>
<th>比较</th>
<th>YAFFS2</th>
<th>YAFFS1</th>
</tr>
</thead>
<tbody><tr>
<td>写操作</td>
<td>快1-3倍</td>
<td>1.5MB&#x2F;s-4.5MB&#x2F;s</td>
<td>1.5MB&#x2F;s</td>
</tr>
<tr>
<td>读操作</td>
<td>快1-2倍</td>
<td>7.6MB&#x2F;s-16.7MB&#x2F;s</td>
<td>7.6MB&#x2F;s</td>
</tr>
<tr>
<td>删除操作</td>
<td>快4-34倍</td>
<td>7.8MB&#x2F;s-62.5MB&#x2F;s</td>
<td>1.8MB&#x2F;s</td>
</tr>
<tr>
<td>垃圾回收</td>
<td>快2-7倍</td>
<td>2.1MB&#x2F;s-7.7MB&#x2F;s</td>
<td>1.1MB&#x2F;s</td>
</tr>
<tr>
<td>内存消耗</td>
<td>减少25%-50%</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>一般而言，在NOR Flash上使用JFFS2文件系统，在NAND Flash上使用YAFFS文件系统。JFFS2与YAFFS的性能比较如下。<br>| 性能 | JFFS2 | YAFFS |<br>| 内存消耗 | 每个节点（node）占用16字节<br>128MB的Flash将占用4MB内存 | 每页占用2字节<br>128MB的Flash将占用512KB内存 |<br>| 第一次启动时的扫描时间 | 128MB的Flash上时间为25S | 只需要读取OOB，时间为3S |<br>| 是否压缩 | 压缩 | 不压缩 |<br>| 代码复杂度 | 复杂 | 简单 |<br>| 使用的操作系统 | Linux、eCos | 很多，容易移植 |<br>| 启动时间 | Flash容量为4MB（or 8MB）时为4S | Flash容量为30MB时为7S |</p>
<h3 id="YAFFS-文件系统移植"><a href="#YAFFS-文件系统移植" class="headerlink" title="YAFFS 文件系统移植"></a>YAFFS 文件系统移植</h3><p>从<code>http://www.aleph1.co.uk/cgi-bin/viewcvs.cgi/</code>获取源代码文件root.tar.gz。解压得到Development目录，里面有两个子目录：yaffs和yaffs2。yaffs目录不在维护，yaffs2兼容yaffs。</p>
<h4 id="将yaffs2代码加入内核"><a href="#将yaffs2代码加入内核" class="headerlink" title="将yaffs2代码加入内核"></a>将yaffs2代码加入内核</h4><p>可以通过yaffs2目录下的脚本文件patch.ker.sh来给内核打补丁，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">usage: ./patch-ker.sh c/l kernelpath</span><br><span class="line">if c/l is c,then copy. if 1 then link</span><br></pre></td></tr></table></figure>
<p>这表明，如果“c&#x2F;l”为“c”，则yaffs2的代码会被复制到内核目录下；如果是“1”，则仅仅是在内核目录下创建一些连接文件。<br>假设下载解压后的yaffs2源码目录为<code>/work/system/Development/yaffs2</code>，内核源码目录为<code>/work/system/linux-2.6.22.6</code>，执行以下命令打补丁：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd /work/system/Development/yaffs2</span><br><span class="line">./patch-ker.sh c /work/system/linux-2.6.22.6</span><br></pre></td></tr></table></figure>
<p>上述命令完成以下3件事情。</p>
<ol>
<li>修改内核fs&#x2F;Kconfig文件，增加以下两行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Patched by YAFFS</span><br><span class="line">source &quot;fs/yaffs/Kconfig&quot;</span><br></pre></td></tr></table></figure></li>
<li>修改内核fs&#x2F;Makefile文件，增加以下两行<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"># Patched by YAFFS</span><br><span class="line">obj-$(CONFIG_YAFFS_FS)	+= yaffs2/</span><br></pre></td></tr></table></figure></li>
<li>在内核<code>fs/</code>目录下创建yaffs2子目录，然后复制如下文件。<br>将yaffs2源码目录下得Makefile.kernel文件复制为内核<code>fs/yaffs2/Makefile</code>文件。<br>将yaffs2源码目录下的Kconfig文件复制到内核<code>fs/yaffs2</code>目录下。<br>将yaffs2源码目录下的*.c、*.h（不包括子目录下的文件）复制到内核<code>fs/yaffs2</code>目录下。</li>
</ol>
<h4 id="配置、编译内核"><a href="#配置、编译内核" class="headerlink" title="配置、编译内核"></a>配置、编译内核</h4><p>阅读<code>fs/yaffs2/Kconfig</code>文件可以了解各个配置选项的作用。</p>
<ol>
<li>CONFIG_YAFFS_FS：支持YAFFS文件系统</li>
<li>CONFIG_YAFFS_YAFFS1：支持YAFFS1文件系统<br>对于每页大小为512字节的NAND Flash，要选上这个配置项</li>
<li>CONFIG_YAFFS_YAFFS1：支持YAFFS2文件系统<br>对于每页大小为2048字节的NAND Flash，要选上这个配置项。本书所用的NAND Flash每页为512字节，这个配置项可以不选。</li>
<li>CONFIG_YAFFS_AUTO_YAFFS2：自动选择YAFFS2格式。<br>如果不设置这个配置项，必须使用“yaffs2”字样来表示YAFFS2文件系统格式；如果设置了这个配置项，则可以使用“yaffs”字样来统一表示YAFFS、YAFFS2文件系统格式，驱动程序会根据NAND Flash页的大小自动分辨是YAFFS还是YAFFS2。</li>
<li>CONFIG_YAFFS_9BYTE_TAGS<br>老的YAFFS1文件系统中，使用oob区中9个字节作为文件系统的标记（tag），比新的YAFFS1多了1个字节—“pageStatus”，它用来表示页的状态。<br>如果要使用老的YAFFS1，这个配置项要选上，另外要修改MTD设备层以使用老的oob layout结构。oob layout就是内核文件<code>drivers/mtd/nand/nand_base.c</code>中的nand_oob_16结构。<br>Linux-2.6.22.6内核使用新的oob layout，格式如下。它表示ECC码存放的位置是oob区中0、1、…、7这8个字节；剩下的空间就称为可用空间，供文件系统使用，代码中将这些数据称为标记（tag）：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_ecclayout</span> <span class="title">nand_oob_16</span> =</span> &#123;</span><br><span class="line">	.eccbytes = <span class="number">6</span>,</span><br><span class="line">	.eccpos	= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	.oobfree = &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			.offset = <span class="number">8</span>,</span><br><span class="line">			.length = <span class="number">8</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
以前的内核使用老的oob layout，格式如下，ECC码的位置不一样，标记的位置也不一样。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_ecclayout</span> <span class="title">nand_oob_16</span> =</span> &#123;</span><br><span class="line">	.eccbytes = <span class="number">6</span>,</span><br><span class="line">	.eccpos	= &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,</span><br><span class="line">	.oobavail = <span class="number">9</span>,</span><br><span class="line">	.oobfree = &#123;&#123;<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>&#125;,&#123;<span class="number">11</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如果要使用老格式的YAFFS1映像文件，定义CONFIG_YAFFS_9BYTE_TAGS配置项，并且修改nand_oob_16结构为老的格式。</li>
<li>CONFIG_YAFFS_DOES_ECC：使用YAFFS本身的ECC校验参数。<br>一般使用MTD设备层的ECC校验函数，这个配置项不用设置。<br>了解各配置项的意义后，就可以配置内核，选上对YAFFS的支持了。在内核配置界面选中“YAFFS2 file system support”即可，其他配置选项使用默认值。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File systems	---&gt;</span><br><span class="line">	Miscellaneous filesystems	---&gt;</span><br><span class="line">		&lt;*&gt;	YAFFS2 file system support </span><br></pre></td></tr></table></figure>
最后执行“make uImage”编译内核。</li>
</ol>
<h2 id="编译、烧写、启动内核"><a href="#编译、烧写、启动内核" class="headerlink" title="编译、烧写、启动内核"></a>编译、烧写、启动内核</h2><p>到目前为止，内核已经同时支持了S3C2410和S3C2440，修改了NAND Flash的分区，增加了对YAFFS文件系统的支持。另外，内核原来已经支持JFFS2文件系统。现在的内核。已经基本可用，可以将它烧入NAND Flash中。</p>
<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make uImage</span><br></pre></td></tr></table></figure>
<h3 id="烧写内核"><a href="#烧写内核" class="headerlink" title="烧写内核"></a>烧写内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tftp 0x32000000 uImage 或 nfs 0x30000000 192.168.1.57:/work/nfs_root/uImage</span><br><span class="line">nand erase 0 0x200000							//擦除NAND Flash 前2MB</span><br><span class="line">nand write.jffs2 0x32000000 0 $(filesize)		//烧写uImage</span><br></pre></td></tr></table></figure>

<h3 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nboot 0x32000000 0 0</span><br><span class="line">bootm 0x32000000</span><br></pre></td></tr></table></figure>
<p>要想开发板上电自动启动内核，可以设置bootcmd环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">set bootcmd &#x27;nboot 0x32000000 0 0; bootm 0x32000000&#x27;</span><br><span class="line">setenv</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第3篇第16章 移植Linux内核</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>Linux移植</tag>
      </tags>
  </entry>
  <entry>
    <title>移植UBoot</title>
    <url>/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/</url>
    <content><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>嵌入式Linux系统移植之移植U-Boot</p>
<p>《嵌入式Linux应用完全开发手册》第3篇第15章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解BootLoader的作用及工作流程</li>
<li>了解U-Boot的代码结构、编译过程</li>
<li>移植U-Boot</li>
<li>掌握常用的U-Boot命令</li>
</ol>
<h1 id="BootLoader简介"><a href="#BootLoader简介" class="headerlink" title="BootLoader简介"></a>BootLoader简介</h1><h2 id="BootLoader的概念"><a href="#BootLoader的概念" class="headerlink" title="BootLoader的概念"></a>BootLoader的概念</h2><h3 id="BootLoader的引入"><a href="#BootLoader的引入" class="headerlink" title="BootLoader的引入"></a>BootLoader的引入</h3><p>从前面的篇章可以知道，系统上电之后，需要一段程序来进行初始化：关闭WATCHDOG、改变系统时钟、初始化存储控制器、将更多的代码复制到内存中等。如果它能将操作系统内核复制到内存中运行，无论是从本地（Flash）还是远端（网络），那么就称这段程序为BootLoader。<br>简单来说，BootLoader就是这么一段程序，它在系统上电时运行，初始化硬件设备，准备好软件环境，最后调用操作系统内核。<br>可以增强BootLoader的功能，比如增加网络功能、从PC上通过串口或网络下载文件、烧写文件、将Flash上压缩的文件解压后再运行等，这就是一个功能更为强大的BootLoader，也称为Monitor。实际上，最终产品并不需要这些功能，它们只是为了方便开发。<br>BootLoader的实现非常依赖于具体硬件，在嵌入式系统中硬件的配置千差万别，即使CPU相同，它们的外设也可能不同，所以不可能有一个BootLoader支持所有的CPU、所有的电路板卡。即使支持CPU架构较多的U-Boot，也不是拿来就可以使用的，需要进行一些移植。</p>
<h3 id="BootLoader的启动方式"><a href="#BootLoader的启动方式" class="headerlink" title="BootLoader的启动方式"></a>BootLoader的启动方式</h3><p>CPU上电后，会从某个地址开始执行。比如MIPS架构的CPU会从0xBFC00000取第一条指令，而ARM架构的CPU则会从地址0x00000000开始。嵌入式开发板中，需要把存储器件ROM或Flash等映射到这个地址，BootLoader就存放在这个地址开始处，这样一上电就可以执行。<br>在开发时，通常需要使用各种命令操作BootLoader，一般通过串口来连接PC和开发板，可以在串口上输入各种命令、观察运行结果等。这也只是对开发人员才有意义，用户使用产品时是不需要通过串口来控制BootLoader的。BootLoader可以分为以下两种操作模式。</p>
<ol>
<li>启动加载模式（Boot loading）<br>上电后，BootLoader从板子上的某个固态存储设备上将操作相同加载到RAM中运行，整个过程没有用户的介入。产品发布时，BootLoader工作在这种模式下。</li>
<li>下载模式（Downloading）<br>在这种模式下，开发人员可以使用各种命令，通过串口连接或网络连接等通信手段从主机（Host）下载文件（内核映像、文件系统映像），将它们直接放在内存运行或是烧入Flash。<br>板子与主机间传输文件时，可以使用串口的xmodem、ymodem、zmodem协议，它们使用简单，只是速度较慢；可以使用nfs、tftp协议传输，主机需要开启nfs、tftp服务；也可以使用USB。<br>像Blob或U-Boot等这样功能强大的BootLoader通常支持者两种工作模式，而且运行用户在这两种模式之间切换。比如，U-Boot在启动时处于正常的启动加载模式，但是它会延时若干秒（可设置），等待终端用户按下任意键，而将U-Boot切换到下载模式。如果指定时间内没有用户按键，则U-Boot继续启动Linux内核。</li>
</ol>
<h2 id="BootLoader的结构和启动过程"><a href="#BootLoader的结构和启动过程" class="headerlink" title="BootLoader的结构和启动过程"></a>BootLoader的结构和启动过程</h2><h3 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h3><p>在移植之前先了解BootLoader的一些通用概念，对理解它的代码会有所帮助。<br>嵌入式Linux系统从软件的角度通常可以分为以下4个层次。</p>
<ol>
<li>引导加载程序，包括固化在固件中的boot代码和BootLoader两大部分。<br>有些CPU在运行BootLoader之前先运行一段固化的程序，比如x86结构的CPU就是先运行BIOS中的固件，然后才运行硬盘的第一个分区（MBR）中的BootLoader。在大多数嵌入式系统中并没有固件，BootLoader是上电后执行的第一个程序。</li>
<li>Linux内核<br>特定于嵌入式板子的定制内核以及内核的启动参数。内核的启动参数可以是内核默认的，或是由BootLoader传递给它的。</li>
<li>文件系统<br>包括根文件系统和建立于Flash内存设备之上的文件系统。里面包含了Linux系统能够运行所必需的应用程序、库等，比如可以给用户提供操作Linux的控制界面Shell程序、动态连接的程序运行时需要的glibc或uClibc库等。</li>
<li>用户应用程序<br>特定于用户的应用程序，它们也存储在文件系统中。有时在用户应用程序和内核层之间可能还会包括一个嵌入式图形用户界面。</li>
</ol>
<p>显然，在嵌入式系统的固态存储设备上有相应的分区来存储它们，下图是一个典型的分区结构：<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/1.jpeg" alt="img not found"><br>“Boot parameter”分区中存放一些可设置的参数，比如IP地址，串口波特率、要传递给内核的命令行参数等。正常启动过程中，BootLoader首先运行，然后它将内核复制到内存中（也有些内核可以在固态存储设备上直接运行），并且在内存某个固定的地址设置好要传递给内核的参数，最后运行内核。内核启动之后，它会mount根文件系统（root filesystem），启动根文件系统中的应用程序。</p>
<h3 id="BootLoader的两个阶段"><a href="#BootLoader的两个阶段" class="headerlink" title="BootLoader的两个阶段"></a>BootLoader的两个阶段</h3><p>BootLoader的启动过程可以分为单阶段（Single Stage）、多阶段（Multi-Stage）两种。通常多阶段的BootLoader能提供更为复杂的功能以及更好的移植性。从固态存储设备上启动的BootLoader大多都是两阶段的启动过程。第一阶段使用汇编来实现，它完成一些依赖于CPU体系结构的初始化，并调用第二阶段的代码；第二阶段则通常使用C语言来实现，这样可以实现更复杂的功能，而且代码会有更好的可读性和可移植性。<br>一般而言，这两个阶段完成的功能可以如下分类。<br>BootLoader第一阶段的功能。</p>
<ol>
<li>硬件设备初始化</li>
<li>为加载BootLoader的第二阶段代码准备到RAM空间</li>
<li>复制BootLoader的第二阶段代码到RAM空间中</li>
<li>设置好栈</li>
<li>跳转到第二阶段代码的C入口点</li>
</ol>
<p>在第一阶段进行的硬件初始化一般包括：关闭WATCHDOG、关中断、设置CPU的速度和时钟频率、RAM初始化等。这些其实不是必须的，比如S3C2410&#x2F;S3C2440的开发板所使用的U-Boot中，就将CPU的速度和时钟频率的设置放在第二阶段。<br>甚至，将第二阶段的代码复制到RAM空间中也不是必须的，对于NOR Flash等存储设备，完全可以在上面直接执行代码，只不过相比在RAM中执行效率大为降低。<br>BootLoader第二阶段的功能</p>
<ol>
<li>初始化本阶段要用到的硬件设备</li>
<li>检测系统内存映射（memory map）</li>
<li>将内核映像和根文件系统映像从Flash上读到RAM空间中</li>
<li>为内核设置启动参数</li>
<li>调用内核</li>
</ol>
<p>为了方便开发，至少要初始化一个串口以便程序员与BootLoader交互。<br>所谓检测内存映射，就是确定板上使用了多少内存、它们的地址空间是什么。由于嵌入式开发中BootLoader多是针对某类板子进行编写，所以可以根据板子的情况直接设置，不需要考虑可以适用于各类情况的复杂算法。<br>Flash上的内核映像有可能是经过压缩的，在读到RAM之后，还需要进行解压。当然，如果内核带有自解压功能，不需要BootLoader来进行解压。<br>将根文件系统映像映射到RAM中，这不是必须的。这取决于是什么类型的根文件系统，以及内核访问它的方法。<br>将内核存放在适当的位置之后，直接跳到它的入口点即可调用内核。调用内核之前，下列条件要满足：</p>
<ol>
<li>CPU寄存器的设置<ol>
<li>R0 &#x3D; 0</li>
<li>R1 &#x3D; 机器类型ID；对于ARM架构的CPU，其机器类型ID可以参见linux&#x2F;arch&#x2F;arm&#x2F;tools&#x2F;mach-types</li>
<li>R2 &#x3D; 启动参数标记列表在RAM中的起始基地址</li>
</ol>
</li>
<li>CPU工作模式<ol>
<li>必须禁止中断（IRQs和FIQs）</li>
<li>CPU必须为SVC模式</li>
</ol>
</li>
<li>Cache和MMU的设置<ol>
<li>MMU必须关闭</li>
<li>指令Cache可以打开也可关闭</li>
<li>数据Cache必须关闭<br>如果用C语言，可以像下列代码一样来调用内核：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> (*theKernel)(<span class="type">int</span> zero,<span class="type">int</span> arch,u32 params_addr) = (<span class="type">void</span> (*)(<span class="type">int</span>,<span class="type">int</span>,u32))KERNEL_RAM_BASE;</span><br><span class="line">...</span><br><span class="line">theKernel(<span class="number">0</span>,ARCH_NUMBER,(u32)kernel_params_start);</span><br></pre></td></tr></table></figure></li>
</ol>
</li>
</ol>
<h3 id="BootLoader与内核的交互"><a href="#BootLoader与内核的交互" class="headerlink" title="BootLoader与内核的交互"></a>BootLoader与内核的交互</h3><p>BootLoader与内核的交互是单向的，BootLoader将各类参数传给内核。由于它们不能同时运行，传递办法只有一个：BootLoader将参数放在某个约定的地方，再启动内核，内核启动后从这个地方获取参数。<br>除了约定好参数存放的地址外，还要规定参数的结构。Linux 2.4.x之后的内核都期望以标记列表（tagged list）的形式来传递启动参数。标记就是一种数据结构；标记列表，就是挨着存放的多个标记。标记列表以标记ATAG_CORE开始，以标记ATAG_NONE结束。<br>标记的数据结构为tag，它由一个tag_header结构和一个联合（union）组成。tag_header结构表示标记的类型和长度，比如是表示内存还是表示命令行参数等。对于不同类型的标记使用不同的联合（union），比如表示内存时使用tag_mem32，表示命令行时使用tag_cmdline。数据结构tag和tag_header定义在Linux内核源码的<code>include/asm/setup.h</code>头文件中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">tag_header</span>  &#123;</span></span><br><span class="line">    u32 size;</span><br><span class="line">    u32 tag;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span>  <span class="title">tag</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tag_header</span>   <span class="title">hdr</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_core</span> <span class="title">core</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_mem32</span>    <span class="title">mem</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_videotext</span>    <span class="title">videotext</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_ramdisk</span>  <span class="title">ramdisk</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_initrd</span>   <span class="title">initrd</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_serialnr</span>    <span class="title">serialnr</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_revision</span> <span class="title">revision</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_videolfb</span> <span class="title">videolfb</span>;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_cmdline</span>  <span class="title">cmdline</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        Acorn   specific</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_acorn</span>    <span class="title">acorn</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">/*</span></span><br><span class="line"><span class="comment">        DC21285 specific</span></span><br><span class="line"><span class="comment">        */</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">tag_memclk</span>   <span class="title">memclk</span>;</span></span><br><span class="line">    &#125;u;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面以设置内存标记、命令行标记为例说明参数的传递。</p>
<ol>
<li>设置标记ATAG_CORE<br>标记列表以标记ATAG_CORE开始，假设BootLoader与内核约定的参数存放地址为0x30000100，则可以以如下代码设置标记ATAG_CORE<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">params = (<span class="keyword">struct</span> tag *)<span class="number">0x30000100</span>;</span><br><span class="line"></span><br><span class="line">params-&gt;hdr.tag = ATAG_CORE;</span><br><span class="line">params-&gt;hdr.size = tag_size(tag_core);</span><br><span class="line">params-&gt;u.core.flags = <span class="number">0</span>;</span><br><span class="line">params-&gt;u.core.pagesize = <span class="number">0</span>;</span><br><span class="line">params-&gt;u.core.rootdev = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">params = tag_next(params);</span><br></pre></td></tr></table></figure>
其中，tag_next定义如下，它指向当前标记的末尾：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> tag_next(t) ((struct tag *) ((u32 *)(t) + (t)-&gt;hdr.size))</span></span><br></pre></td></tr></table></figure></li>
<li>设置内存标记<br>假设开发板使用的内存起始地址为0x30000000，大小为0x4000000，则内存标记可以加如下设置：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">params-&gt;hdr.tag = ATAG_MEM;</span><br><span class="line">params-&gt;hdr.size = tag_size(tag_mem32);</span><br><span class="line"></span><br><span class="line">params-&gt;u.mem.start = <span class="number">0x30000000</span>;</span><br><span class="line">params-&gt;u.size = <span class="number">0x4000000</span>;</span><br><span class="line"></span><br><span class="line">params = tag_next(params);</span><br></pre></td></tr></table></figure></li>
<li>设置命令行标记<br>命令行就是一个字符串，它被用来控制内核的一些行为。比如“root&#x3D;&#x2F;dev&#x2F;mtdblock 2 init&#x3D;&#x2F;linuxrc console&#x3D;ttySAC0”表示根文件系统在MTD2分区上，系统启动后执行的第一个程序为&#x2F;linuxrc，控制台为ttySAC0（即第一个串口）。<br>命令行可以在BootLoader中通过命令设置好，然后按如下构造标记传给内核。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">char</span> *p = <span class="string">&quot;root=/dev/mtdblock 2 init=/linuxrc console=ttySAC0&quot;</span>;</span><br><span class="line">params-&gt;hdr.tag = ATAG_CMDLINE;</span><br><span class="line">params-&gt;hdr.size = (<span class="keyword">sizeof</span>(<span class="keyword">struct</span> tag_header) + <span class="built_in">strlen</span>(p) + <span class="number">1</span> + <span class="number">4</span>) &gt;&gt; <span class="number">2</span>;</span><br><span class="line"><span class="built_in">strcpy</span>(params-&gt;u.cmdline.cmdline,p);</span><br><span class="line">params = tag_next(params);</span><br></pre></td></tr></table></figure></li>
<li>设置标记ATAG_NONE<br>标记列表以标记ATAG_NONE结束，如下设置：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">params-&gt;hdr.tag = ATAG_NONE;</span><br><span class="line">params-&gt;hdr.size = <span class="number">0</span>;</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="常用的BootLoader介绍"><a href="#常用的BootLoader介绍" class="headerlink" title="常用的BootLoader介绍"></a>常用的BootLoader介绍</h2><p>现在的BootLoader种类繁多，比如x86上有LILO、GRUB等。对于ARM架构的CPU，有U-Boot、ViVi等。它们各有特点。</p>
<table>
<thead>
<tr>
<th>BootLoader</th>
<th>Monitor</th>
<th>描述</th>
<th>X86</th>
<th>ARM</th>
<th>PowerPC</th>
</tr>
</thead>
<tbody><tr>
<td>LILO</td>
<td>否</td>
<td>Linux磁盘引导程序</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>GRUB</td>
<td>否</td>
<td>GNU的LILO替代程序</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>Loadlin</td>
<td>否</td>
<td>从DOS引导Linux</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>ROLO</td>
<td>否</td>
<td>从ROM引导Linux而不需要BIOS</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>Etherboot</td>
<td>否</td>
<td>通过以太网卡启动Linux系统的固件</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>LinuxBIOS</td>
<td>否</td>
<td>完全替代BUIS的Linux引导程序</td>
<td>是</td>
<td>否</td>
<td>否</td>
</tr>
<tr>
<td>BLOB</td>
<td>是</td>
<td>LART等硬件平台的引导程序</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
<tr>
<td>U-Boot</td>
<td>是</td>
<td>通用引导程序</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>RedBoot</td>
<td>是</td>
<td>基于eCos的引导程序</td>
<td>是</td>
<td>是</td>
<td>是</td>
</tr>
<tr>
<td>Vivi</td>
<td>是</td>
<td>Mizi公司针对SAMSUNG的ARM CPU设计的引导程序</td>
<td>否</td>
<td>是</td>
<td>否</td>
</tr>
</tbody></table>
<p>对于S3C2410&#x2F;S3C2440开发板，U-Boot和Vivi是两个好选择。<br>Vivi是Mizi针对SAMSUNG的ARM架构CPU专门设计的，基本上可以直接使用，命令简单方便。不过其初始版本只支持串口下载，速度较慢。在网上出现了各种改进版本：支持网络功能、USB功能、烧写YAFFS文件系统映像等。<br>U-Boot支持大多CPU，可以烧写EXT2、JFFS2文件系统映像，支持串口下载、网络下载，并提供大量的命令。相对于Vivi，它的使用更复杂，但是可以用来更方便的调试程序。</p>
<h1 id="U-Boot分析与移植"><a href="#U-Boot分析与移植" class="headerlink" title="U-Boot分析与移植"></a>U-Boot分析与移植</h1><h2 id="U-Boot工程简介"><a href="#U-Boot工程简介" class="headerlink" title="U-Boot工程简介"></a>U-Boot工程简介</h2><p>U-Boot，全称Universal Boot Loader，即通用BootLoader，是遵循GPL条款的开源代码项目。其前身是由德国DENX软件工程中心的Wolfgang Denk基于8xxROM的源码创建的PPCBOOT工程。后来整理代码结构使得非常容易增加其他类型的开发板、其他架构的CPU（之前只支持PowerPC）；增加更多的功能，比如启动Linux、下载S-Record格式的文件、通过网络启动、通过PCMCIA&#x2F;CompactFLash&#x2F;ATA disk&#x2F;SCSI等方式启动。增加ARM架构CPU及其他更多CPU的支持后，改名U-Boot。<br>它的名字“通用”有两层含义：可以引导多种操作系统、支持多种架构的CPU。它支持如下操作系统：Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS等，支持如下架构的CPU：PowerPC、MIPS、x86、ARM、NIOS、XScale等。<br>U-Boot有如下特性：</p>
<ol>
<li>开放源码</li>
<li>支持多种嵌入式操作系统内核，Linux、NetBSD、VxWorks、QNX、RTEMS、ARTOS、LynxOS等</li>
<li>支持多个处理器系列，PowerPC、MIPS、x86、ARM、NIOS、XScale等</li>
<li>较高的可靠性和稳定性</li>
<li>高度灵活的功能设置，适合U-Boot调试、操作系统不同引导要求、产品发布等。</li>
<li>丰富的设备驱动源码，如串口、以太网、SDRAM、Flash、LCD、NVRAM、EEPROM、RTC、键盘等</li>
<li>较为丰富的开发调试文档以及强大的网络技术支持</li>
<li>支持NFS挂载、RAMDISK（压缩或非压缩）形式的根文件系统</li>
<li>支持NFS挂载、从Flash中引导压缩或非压缩的操作系统内核</li>
<li>可灵活设置、传递多个关键参数给操作系统，适合系统在不同开发阶段的调试要求与产品发布，尤对Linux支持最为强劲</li>
<li>支持目标板环境变量多种存储方式，如Flash、NVRAM、EEPROM</li>
<li>CRC32校验，可校验Flash中内核、RAMDISK镜像文件是否完好</li>
<li>上电自检功能：SDRAM、Flash大小自动检测、SDRAM故障检测、CPU型号</li>
<li>特殊功能：XIP内核引导</li>
</ol>
<h2 id="U-Boot源码结构"><a href="#U-Boot源码结构" class="headerlink" title="U-Boot源码结构"></a>U-Boot源码结构</h2><p>在U-Boot-1.1.6的基础上进行分析和移植，从sourceforge网站下载U-Boot-1.1.6.tar.bz2后解压得到全部源码。U-Boot-1.1.6源码根目录下共有26个子目录，可以分为4类：</p>
<ol>
<li>平台相关的或开发板相关的</li>
<li>通用的函数</li>
<li>通用的设备驱动程序</li>
<li>U-Boot工具、示例程序、文档</li>
</ol>
<table>
<thead>
<tr>
<th>目录</th>
<th>特性</th>
<th>解释说明</th>
</tr>
</thead>
<tbody><tr>
<td>board</td>
<td>开发板相关</td>
<td>对于不同配置的电路板（即使CPU相同），比如smdk2410、sbc2410x</td>
</tr>
<tr>
<td>cpu</td>
<td>平台相关</td>
<td>对应不同的CPU，比如arm920t、arm925t、i386等；在它们的子目录下仍可以进一步细分，比如arm920t下就有at91rm9200、s3c24x0</td>
</tr>
<tr>
<td>lib_i386等</td>
<td>平台相关</td>
<td>某一架构下的通用文件</td>
</tr>
<tr>
<td>include</td>
<td>通用的函数</td>
<td>头文件和开发板配置文件，开发板的配置文件都放在include&#x2F;configs目录下，U-Boot没有make menuconfig类似的菜单来进行可视化设置，需要手动的修改配置文件中的宏定义</td>
</tr>
<tr>
<td>lib_generic</td>
<td>通用的函数</td>
<td>通用的库函数，例如printf等</td>
</tr>
<tr>
<td>common</td>
<td>通用的函数</td>
<td>通用的函数，多是对下一层驱动程序的进一步封装</td>
</tr>
<tr>
<td>disk</td>
<td>通用的设备驱动程序</td>
<td>硬盘接口程序</td>
</tr>
<tr>
<td>drivers</td>
<td>通用的设备驱动程序</td>
<td>各类具体设备的驱动程序，基本上可以通用，它们通过宏从外面引入平台&#x2F;开发板相关的函数</td>
</tr>
<tr>
<td>dtt</td>
<td>通用的设备驱动程序</td>
<td>数字温度测量器或者传感器的驱动</td>
</tr>
<tr>
<td>fs</td>
<td>通用的设备驱动程序</td>
<td>文件系统</td>
</tr>
<tr>
<td>nand_spl</td>
<td>通用的设备驱动程序</td>
<td>U-Boot一般从ROM、NOR Flash等设备启动，现在开始支持从NAND Flash启动，但是支持的CPU种类还不多</td>
</tr>
<tr>
<td>net</td>
<td>通用的设备驱动程序</td>
<td>各种网络协议</td>
</tr>
<tr>
<td>post</td>
<td>通用的设备驱动程序</td>
<td>上电自检程序</td>
</tr>
<tr>
<td>rtc</td>
<td>通用的设备驱动程序</td>
<td>实时时钟的驱动</td>
</tr>
<tr>
<td>doc</td>
<td>文档</td>
<td>开发、使用文档</td>
</tr>
<tr>
<td>examples</td>
<td>示例程序</td>
<td>一些测试程序，可以使用U-Boot下载后运行</td>
</tr>
<tr>
<td>tools</td>
<td>工具</td>
<td>制作S-Record、U-Boot格式映像的工具，比如mkimage</td>
</tr>
</tbody></table>
<p>U-Boot各目录间的层次结构如下图所示：<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/2.jpeg" alt="img not found"></p>
<p>比如common&#x2F;cmd_nand.c文件提供了操作NAND Flash的各种命令，这些命令通过调用drivers&#x2F;nand&#x2F;nand_base.c中的擦除、读写函数来实现。这些函数针对NAND Flash的共性作了一些封装，将平台&#x2F;开发板相关的代码用宏或外部函数替代。而这些宏与外部函数，如果与平台相关，就要在下一层次的cpu&#x2F;xxx（xxx表示某型号的CPU）中实现；如果与开发板相关，就要在下一层次的board&#x2F;xxx目录（xxx表示某款开发板）中实现。本书移植的U-Boot，就是在cpu&#x2F;arm920t&#x2F;s3c24x0目录下增加一个nand_flash.c文件来实现这些函数。<br>以增加烧写yaffs文件系统映像的功能为例，即在common目录下的cmd_nand.c中增加命令。比如nand write.yaffs，这个命令要调用drivers&#x2F;nand&#x2F;nand_util.c中的相应函数，针对yaffs文件系统的特点依次调用擦除、烧写函数。而这些函数依赖于drivers&#x2F;nand&#x2F;nand_base.c、cpu&#x2F;arm920t&#x2F;s3c24x0&#x2F;nand_flash.c文件中的相关函数。<br>目前U-Boot-1.1.6支持10种架构，根目录下有10个类似lib_i386的目录；31个型号（类型）的CPU，cpu目录下有31个子目录；214种开发板，board目录下有214个子目录，很容易从中找到与自己板子相似的配置，在上面稍作修改即可使用。</p>
<h2 id="U-Boot的配置、编译、连接过程"><a href="#U-Boot的配置、编译、连接过程" class="headerlink" title="U-Boot的配置、编译、连接过程"></a>U-Boot的配置、编译、连接过程</h2><h3 id="U-Boot初体验"><a href="#U-Boot初体验" class="headerlink" title="U-Boot初体验"></a>U-Boot初体验</h3><p>U-Boot-1.1.6中有几千个文件，要想了解对于某款开发板，使用哪些文件、哪个文件首先执行，可执行文件占用内存的情况，最好的方法就是阅读它的Makefile。<br>根据顶层Readme文件的说明，可以知道如果要使用开发板board&#x2F;<board_name>，就先执行“make <board_name>_config”命令进行配置，然后执行“make all”，就可以生成如下3个文件：</board_name></board_name></p>
<ol>
<li>U-Boot.bin：二进制可执行文件，它就是可以直接烧入ROM、NOR Flash的文件。</li>
<li>U-Boot：ELF格式的可执行文件。</li>
<li>U-Boot.srec：Motorola S-Record格式的可执行文件。</li>
</ol>
<p>对于S3C2410的开发板，执行“make smdk2410_config”、“make all”后生成的U-Boot.bin可以烧入NOR Flash中运行。启动后可以看到串口输出一些信息后进入控制界面，等待用户的输入。<br>对于S3C2440的开发板，烧入上面生成的U-Boot.bin，串口无输出，需要修改代码。<br>在修改代码之前，先看看上面两个命令“make smdk2410_config”、“make all”做了什么事情，以了解程序的流程，知道要修改哪些文件。<br>另外，编译U-Boot成功之后，还会在它的tools子目录下生成一些工具，比如mkimage等。将它们复制到&#x2F;usr&#x2F;local&#x2F;bin目录下，以后就可以直接使用它们了，比如编译内核时，会使用mkimage来生成U-Boot格式的内核映像文件uImage。</p>
<h3 id="U-Boot的配置过程"><a href="#U-Boot的配置过程" class="headerlink" title="U-Boot的配置过程"></a>U-Boot的配置过程</h3><p>在顶层Makefile中可以看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SRCTREE     :=  $(CURDIR)</span><br><span class="line">... ...</span><br><span class="line">MKCONFIG    :=  $(SRCTREE)/mkconfig</span><br><span class="line">... ...</span><br><span class="line">smdk2410_config : unconfig</span><br><span class="line">        @$(MKCONFIG)  $(@:_config=) arm arm920t smdk2410  <span class="literal">NULL</span>  s3c24x0</span><br></pre></td></tr></table></figure>
<p>假定在U-Boot-1.1.6的根目录下编译，则其中的MKCONFIG就是根目录下的mkconfig文件。$(@:_config&#x3D;)的结果就是将“smdk2410_config”中的“_config”去掉，结果为“smdk2410”。所以“make smdk2410_config”实际上就是执行如下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">./mkconfig smdk2410 arm arm920t smdk2410 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure>
<p>再来看看mkconfig的作用，在mkconfig文件开头第6行给出了它的用法：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#Paramters: Target Architecture CPU Board [VENDOR] [SOC]</span><br></pre></td></tr></table></figure>
<p><code>这里解释一下概念，对于S3C2410、S3C2440，它们被称为SOC（System on Chip），上面除了CPU外，还集成了UART、USB控制器、NAND Flash控制器等设备（称为片内外设）。S3C2410/S3C2440中的CPU为ARM920T</code>。<br>下面分步骤分析mkconfig的作用。</p>
<ol>
<li>确定开发板名称BOARD_NAME，相关代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">APPEND=no               <span class="meta">#default: Create new config file</span></span><br><span class="line">BOARD_NAME=<span class="string">&quot;&quot;</span>           #Name to print in make output</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> [ $# -gt <span class="number">0</span> ] ; <span class="keyword">do</span></span><br><span class="line">  <span class="keyword">case</span> <span class="string">&quot;$1&quot;</span> in</span><br><span class="line">  --) shift ; <span class="keyword">break</span> ;;</span><br><span class="line">  -a) shift ; APPEND=yes ;;</span><br><span class="line">  -n) shift ; BOARD_NAME=<span class="string">&quot;$&#123;1%%_config&#125;&quot;</span> ; shift ;;</span><br><span class="line">  *)  <span class="keyword">break</span> ;;</span><br><span class="line">  esac</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">[ <span class="string">&quot;$&#123;BOARD_NAME&#125;&quot;</span> ] || BOARD_NAME=<span class="string">&quot;$1&quot;</span></span><br></pre></td></tr></table></figure>
对于“.&#x2F;mkconfig smdk2410 arm arm920t smdk2410 NULL s3c24x0”命令。其中没有“–”、“-a”、“-n”等符号，所以第4-11行没做任何事情。第1、2行两个变量仍旧维持原来的值。<br>执行完第13行之后，BOARD_NAME的值等于第1个参数，即“smdk2410”。</li>
<li>创建到平台&#x2F;开发板相关的头文件的链接。<br>略过mkconfig文件中的一些没有起作用的行，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line"># Create link to architecture specific headers</span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> [ <span class="string">&quot;$SRCTREE&quot;</span> != <span class="string">&quot;$OBJTREE&quot;</span> ] ; then</span></span><br><span class="line">... ...</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    cd ./include</span><br><span class="line">    rm -f <span class="keyword">asm</span></span><br><span class="line">    ln -s <span class="keyword">asm</span>-$<span class="number">2</span> <span class="keyword">asm</span></span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
第4行判断源代码目录和目标文件目录是否一样，可以选择在其他目录下编译U-Boot，这可以令源代码目录保持干净，可以同时使用不同的配置进行编译。<br>第7-9行进入include目录，删除asm文件（这时上一次配置时建立的链接文件），然后再次建立asm文件，并令它链接向asm-$2目录，即asm-arm。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">rm -f <span class="keyword">asm</span>-$<span class="number">2</span>/arch</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ -z <span class="string">&quot;$6&quot;</span> -o <span class="string">&quot;$6&quot;</span> = <span class="string">&quot;NULL&quot;</span> ] ; then</span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;arch-$<span class="number">3</span> <span class="keyword">asm</span>-$<span class="number">2</span>/arch</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;arch-$<span class="number">6</span> <span class="keyword">asm</span>-$<span class="number">2</span>/arch</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> [ <span class="string">&quot;$2&quot;</span> = <span class="string">&quot;arm&quot;</span> ] ; then</span><br><span class="line">    rm -f <span class="keyword">asm</span>-$<span class="number">2</span>/proc</span><br><span class="line">    ln -s $&#123;LNPREFIX&#125;proc-armv <span class="keyword">asm</span>-$<span class="number">2</span>/proc</span><br><span class="line">fi</span><br></pre></td></tr></table></figure>
第1行删除asm-$2&#x2F;arch目录，即asm-arm&#x2F;arch。<br>对于“.&#x2F;mkconfig smdk2410 arm arm920t smdk2410 NULL s3c24x0”命令，$6为“s3c24x0”，不为空，也不是“NULL”，所以第3行的条件不满足，将执行else分支。<br>第6行中LNPREFIX为空，所以这个命令实际上就是“ln -s arch-$6 asm-$2&#x2F;arch”，即“ln -s arch-$6 asm-arm&#x2F;arch”。<br>第10、11行重新建立asm-arm&#x2F;arch文件，并让它链接向proc-armv目录。</li>
<li>创建顶层Makefile包含的文件include&#x2F;config.mk，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">#</span><br><span class="line"># Create include file <span class="keyword">for</span> Make</span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta">echo <span class="string">&quot;ARCH = $2&quot;</span> &gt; config.mk</span></span><br><span class="line">echo <span class="string">&quot;CPU = $3&quot;</span> &gt;&gt; config.mk</span><br><span class="line">echo <span class="string">&quot;BOARD = $4&quot;</span> &gt;&gt; config.mk</span><br><span class="line"></span><br><span class="line">[ <span class="string">&quot;$5&quot;</span> ] &amp;&amp; [ <span class="string">&quot;$5&quot;</span> != <span class="string">&quot;NULL&quot;</span> ] &amp;&amp; echo <span class="string">&quot;VENDOR = $5&quot;</span> &gt;&gt; config.mk</span><br><span class="line"></span><br><span class="line">[ <span class="string">&quot;$6&quot;</span> ] &amp;&amp; [ <span class="string">&quot;$6&quot;</span> != <span class="string">&quot;NULL&quot;</span> ] &amp;&amp; echo <span class="string">&quot;SOC = $6&quot;</span> &gt;&gt; config.mk</span><br></pre></td></tr></table></figure>
对于“.&#x2F;mkconfig smdk2410 arm arm920t smdk2410 NULL s3c24x0”命令，上面几行代码创建的config.mk文件内容如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARCH = arm</span><br><span class="line">CPU = arm920t</span><br><span class="line">BOARD = smdk2410</span><br><span class="line">SOC = s3c24x0</span><br></pre></td></tr></table></figure></li>
<li>创建开发板相关的头文件<code>include/config.h</code><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"># </span><br><span class="line"># Create board specific header file</span><br><span class="line"><span class="meta"># </span></span><br><span class="line"><span class="meta"><span class="keyword">if</span> [ <span class="string">&quot;$APPEND&quot;</span> = <span class="string">&quot;yes&quot;</span> ]              # Append to existing config file</span></span><br><span class="line">then</span><br><span class="line">    echo &gt;&gt; config.h</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    &gt; config.h                        # Create new config file</span><br><span class="line">fi</span><br><span class="line">echo <span class="string">&quot;/* Automatically generated - do not edit */&quot;</span> &gt;&gt; config.h</span><br><span class="line">echo <span class="string">&quot;#include &lt;configs/$1.h&gt;&quot;</span> &gt;&gt; config.h</span><br></pre></td></tr></table></figure>
APPEND维持原值“no”，所以config.h被重新建立，它的内容如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Automatically generated - do not edit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;configs/smdk2410.h&gt;</span></span></span><br></pre></td></tr></table></figure></li>
</ol>
<p>现在总结一下，配置命令“make smdk2410_config”，实际的作用就是执行“.&#x2F;mkconfig smdk2410 arm arm920t smdk2410 NULL s3c24x0”命令。假设执行“.&#x2F;mkconfig $1 $2 $3 $4 $5 $6”命令，则将产生如下结果。</p>
<ol>
<li>开发板名称BOARD_NAME等于$1。</li>
<li>创建到平台&#x2F;开发板相关的头文件的链接，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ln -s <span class="keyword">asm</span>-$<span class="number">2</span> <span class="keyword">asm</span></span><br><span class="line">ln -s arch-$<span class="number">6</span> <span class="keyword">asm</span>-$<span class="number">2</span>/arch</span><br><span class="line">ln -s proc-armv <span class="keyword">asm</span>-$<span class="number">2</span>/porc           # 如果$<span class="number">2</span>不是<span class="keyword">asm</span>的话，此行没有</span><br></pre></td></tr></table></figure></li>
<li>创建顶层Makefile包含的文件include&#x2F;config.mk，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">ARCH = $<span class="number">2</span></span><br><span class="line">CPU = $<span class="number">3</span></span><br><span class="line">BOARD = $<span class="number">4</span></span><br><span class="line">VENDOR = $<span class="number">5</span>       # $<span class="number">5</span>为空，或者是<span class="literal">NULL</span>的话，此行没有</span><br><span class="line">SOC = $<span class="number">6</span>          # $<span class="number">6</span>为空，或者是<span class="literal">NULL</span>的话，此行没有</span><br></pre></td></tr></table></figure></li>
<li>创建开发板相关的头文件include&#x2F;config.h，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* Automatically generated - do not edit */</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;configs/$1.h&gt;</span></span></span><br></pre></td></tr></table></figure>
从这4个结果可以知道，如果要在board目录下新建一个开发板<board_name>的目录，则在<code>include/config</code>目录下也要建立一个文件<board_name>.h，里面存放的就是开发板<board_name>的配置信息。<br>U-Boot还没有类似Linux一样的可视化配置界面（make menuconfig），需要手动修改配置文件<code>include/config/&lt;board_name&gt;.h</code>来裁剪、设置U-Boot。</board_name></board_name></board_name></li>
</ol>
<p>配置文件中有以下两类宏。</p>
<ol>
<li>一类是选项（Options），前缀为“CONFIG_”，它们用于选择CPU、SOC、开发板类型，设置系统时钟、选择设备驱动等。比如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ARM920T        1           <span class="comment">/*This is an ARM920T Core*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_S3C2410        1           <span class="comment">/*in a SAMSUNG S3C2410 SoC*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SMDK2410       1           <span class="comment">/*on a SAMSUNG SMDK2410 Board*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SYS_CLK_FREQ   12000000    <span class="comment">/*the SMDK2410 has 12MHz input clock*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_DRVER_CS8900   1           <span class="comment">/*we have a CS8900 on-board*/</span></span></span><br></pre></td></tr></table></figure></li>
<li>另一类参数（Setting），前缀为“CFG_”，它们用于设置malloc缓冲池的大小、U-Boot的提示符、U-Boot下载文件时的默认加载地址、Flash的起始地址等。比如：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_MALLOC_LEN  (CFG_ENV_SIZE + 128*1024)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_PROMPT      <span class="string">&quot;Nibil&gt;&quot;</span>                        <span class="comment">/*控制台命令行前缀*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_LOAD_ADDR   0x33000000                      <span class="comment">/*default load address*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PHYS_FLASH_l    0x00000000                      <span class="comment">/*Flash Bank #1*/</span></span></span><br></pre></td></tr></table></figure>
从下面的编译、链接过程可知，U-Boot中几乎每个文件都被编译和连接，但是这些文件是否包含有效代码，则由宏开关来控制。比如对于网卡驱动cs8900.c，它的格式为：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span>                     <span class="comment">/*将包含配置文件include/config/&lt;board_name&gt;.h*/</span></span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DRIVER_CS8900</span></span><br><span class="line"><span class="comment">/*实际的代码*/</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span>  <span class="comment">/*CONFIG_DRIVER_CS8900*/</span></span></span><br></pre></td></tr></table></figure>
如果定义了宏CONFIG_DRIVER_CS8900，则文件中包含有效的代码；否则，文件被注释为空。<br>可以这样认为，“CONFIG_”除了设置一些参数外，主要用来设置U-Boot的功能、选择使用文件中的哪一部分；而“CFG_”用来设置更细节的参数。</li>
</ol>
<h3 id="U-Boot的编译、连接过程"><a href="#U-Boot的编译、连接过程" class="headerlink" title="U-Boot的编译、连接过程"></a>U-Boot的编译、连接过程</h3><p>配置完后，执行“make all”即可编译，从Makefile中可以了解U-Boot使用了哪些文件、哪个文件首先执行、可执行文件占用内存的情况。<br>先确定用到哪些文件，下面所示为Makefile中与ARM相关的部分。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include $(OBJTREE)/include/config.mk</span><br><span class="line">export ARCH CPU BOARD VENDOR SOC</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line">ifeq ($(ARCH),arm)</span><br><span class="line">CROSS_COMPILE = arm-linux-</span><br><span class="line">endif</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"><span class="meta"># load other configuration</span></span><br><span class="line">include $(TOPDIR)/config.mk</span><br></pre></td></tr></table></figure>
<p>第1行、第11行用于包含其他的config.mk文件，第1行所要包含文件的就是在上面的配置过程中制作出来的<code>include/config.mk</code>，其中定义了ARCH、CPU、BOARD、SOC等4个变量的值为arm、arm920t、smdk2410、s3c24x0。<br>第11行包含顶层目录的<code>config.mk</code>文件，它根据上面的4个变量得值确定了编译器、编译选项等。其中对我们理解编译过程有帮助的是BOARDDIR、LDFLAGS的值，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">BOADRDIR = $(BOARD)</span><br><span class="line">...</span><br><span class="line">include $(TOPDIR)/board/$(BOARDDIR)/config.mk         <span class="meta"># <span class="keyword">include</span> board specific rules</span></span><br><span class="line">...</span><br><span class="line">LDSCRIPT  :=  $(TOPDI)/board/$(BOADRDIR)/U-Boot.lds</span><br><span class="line">...</span><br><span class="line">LDFLAGS += -Bstatic -T $(LDSCRIPT) -Ttext $(TEXT_BASE) $(PALTFORM_LDFALGS)</span><br></pre></td></tr></table></figure>
<p>在board&#x2F;smdk2410&#x2F;config.mk中，定义了“TEXT_BASE &#x3D; 0x33F80000”。所以，最终结果如下：BOARDDIR为smdk2410；LDFLAGS中有“-T board&#x2F;smdk2410&#x2F;U-Boot.lds -Ttext 0x33F80000”字样。<br>继续往下看Makefile</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">OBJS = cpu/$(CPU)/start.o</span><br><span class="line">...</span><br><span class="line">LIBS = lib_generic/libgeneric.a</span><br><span class="line">LIBS += board/$(BOARDDIR)/lib$(BOARD).a</span><br><span class="line">LIBS += cpu/$(CPU)/lib$(CPU).a</span><br><span class="line">...</span><br><span class="line">LIBS += lib_$ARCH/lib$(ARCH).a</span><br><span class="line">LIBS += fs/cramfs/libcramfs.a fs/fat/libfat.a fs/fdos/libfdos.a fs/jffs2/libjffs2.a \</span><br><span class="line">fs/reiserfs/libreiserfs.a fs/ext2/libext2fs.a</span><br><span class="line">LIBS += net/libnet.a</span><br><span class="line">...</span><br><span class="line">LIB += $(BOARDLIBS)</span><br><span class="line">......</span><br></pre></td></tr></table></figure>
<p>从第1行可知，OBJS的第一个值为“cpu&#x2F;$(CPU)&#x2F;start.o”，即“cpu&#x2F;arm920t&#x2F;start.o”。<br>第3-13行指定了LIBS变量就是平台&#x2F;开发板相关的各个目录、通用目录下相应的库，比如：lib_generic&#x2F;libgeneric.a、board&#x2F;smdk2410&#x2F;libsmdk2410.a、cpu&#x2F;arm920t&#x2F;libarm920t.a、lib_arm&#x2F;libarm.a、fs&#x2F;cramfs&#x2F;libcramfs.a、fs&#x2F;fat&#x2F;libfat.a等。<br>OBJS、LIBS所代表的.a、.o文件就是U-Boot的构成，它们通过如下命令有相应的源文件编译得到。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$(OBJS):</span><br><span class="line">          $(MAKE) -C cpu/$(CPU)/ $(<span class="keyword">if</span> $(REMOTE_BUILD),$@,$(notdir $@))</span><br><span class="line"></span><br><span class="line">$(LIBS):</span><br><span class="line">          $(MAKE) -C $(dir $(subset $(obj),,$@))</span><br><span class="line"></span><br><span class="line">$(SUBDIRS):</span><br><span class="line">          $(MAKE) -C $@ all</span><br></pre></td></tr></table></figure>
<p>第1、2行的规则表示，对于OBJS中的每个成员，都将进入cpu&#x2F;$(CPU)目录（即cpu&#x2F;arm920t）编译它们。现在OBJS为cpu&#x2F;arm920t&#x2F;start.o，它将由cpu&#x2F;arm920t&#x2F;start.S编译得到。<br>第4、5行的规则表示，对于LIBS中的每个成员，都将进入相应的子目录执行“make”命令。这些子目录中的Makefile，结构相似，它们将Makefile中指定的文件编译、连接成一个库文件。<br>当所有的OBJS、LIBS表示的.o、.a文件都生成之后，就剩最后的连接了，这对应Makefile中如下几行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">$(obj)U-Boot.srec:        $(obj)U-Boot</span><br><span class="line">              $(OBJCOPY)  $(OBJCFLAGS)  -O  srec  $&lt;  $@</span><br><span class="line"></span><br><span class="line">$(obj)U-Boot.bin:        $(obj)U-Boot</span><br><span class="line">              $(OBJCOPY)  $(OBJCFLAGS)  -O  binary  $&lt;  $@</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">$(obj)U-Boot：    depend version $(SUBDIRS) $(OBJS) $(LIBS) $(LDSCRIPT)</span><br><span class="line">              UNDEF_SYM=`$(OBJDUMP) -x $(LIBS) | sed -n -e <span class="string">&#x27;s/.*\(_u_boot_cmd_.*\)/-u\1/p&#x27;</span>|sort | uniq`;\</span><br><span class="line">              cd $(LNDIR) &amp;&amp; $(LD) $(LDFLAGS) $$UNDEF_SYM $(__OBJS) \</span><br><span class="line">              --start-group $(__LIBS) --end-group $(PLATFORM_LIBS)  \</span><br><span class="line">              -Map U-Boot.<span class="built_in">map</span> -o U-Boot</span><br></pre></td></tr></table></figure>
<p>先使用第8-12行的规则连接得到ELF格式的U-Boot，最后转换为二进制格式U-Boot.bin、S-Record格式U-Boot.srec。LDFLAGS确定了连接方式，其中的“-T board&#x2F;smdk2410&#x2F;U-Boot.lds -Ttext 0x33F80000”这样指定了程序的布局、地址。board&#x2F;smdk2410&#x2F;U-Boot.lds文件如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">    . = <span class="number">0x00000000</span>;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>);</span><br><span class="line">    .text       :</span><br><span class="line">    &#123;</span><br><span class="line">      cpu/arm920t/start.o   (.text)</span><br><span class="line">      *(.text)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>)</span><br><span class="line">    .rodata : &#123; *(.rodata) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>)</span><br><span class="line">    .data : &#123; *(.data) &#125;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>)</span><br><span class="line">    .got : &#123; *(.got) &#125;</span><br><span class="line"></span><br><span class="line">    . = .;</span><br><span class="line">    __u_boot_cmd_start = .;</span><br><span class="line">    .u_boot_cmd : &#123; *(.u_boot_cmd) &#125;</span><br><span class="line">    __u_boot_cmd_end = .;</span><br><span class="line"></span><br><span class="line">    . = ALIGN(<span class="number">4</span>)</span><br><span class="line">    __bss_satrt = .;</span><br><span class="line">    .bss : &#123; *(.bss) &#125;</span><br><span class="line">    _end = .;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>从第7行可知，cpu&#x2F;arm920t&#x2F;start.o被放在程序的最前面，所以U-Boot的入口点在cpu&#x2F;arm920t&#x2F;start.S中。<br>现在来总结一下U-Boot的编译流程。</p>
<ol>
<li>首先编译cpu&#x2F;$(CPU)&#x2F;start.S，对于不同的CPU，还可能编译cpu&#x2F;$(CPU)下其他的文件。</li>
<li>然后，对于平台&#x2F;开发板相关的每个目录、每个通用目录都使用它们各自的Makefile生成相应的库。</li>
<li>将1、2步骤生成的.o、.a文件按照board&#x2F;$(BOARDDIR)&#x2F;config.mk文件中指定的代码段起始地址、board&#x2F;$(BOARDDIR)&#x2F;U-Boot.lds连接脚本进行连接。</li>
<li>第3步得到的ELF格式的U-Boot，后面Makefile还会将它转换为二进制格式、S-Record格式。</li>
</ol>
<h2 id="U-Boot的启动过程源码分析"><a href="#U-Boot的启动过程源码分析" class="headerlink" title="U-Boot的启动过程源码分析"></a>U-Boot的启动过程源码分析</h2><p>本书使用的U-Boot从NOR Flash 启动，下面以开发板smdk2410的U-Boot为例、<br>U-Boot属于两阶段的Bootloader，第一阶段的文件为cpu&#x2F;arm920t&#x2F;start.S和board&#x2F;smdk2410&#x2F;lowlevel_init.S，前者是平台相关的，后者是开发板相关的。</p>
<h3 id="U-Boot第一阶段代码分析"><a href="#U-Boot第一阶段代码分析" class="headerlink" title="U-Boot第一阶段代码分析"></a>U-Boot第一阶段代码分析</h3><ol>
<li><p>硬件设备初始化<br>依次完成如下设置：将CPU的工作模式设为管理模式（SVC），关闭WATCHDOG，设置FCLK、HCLK、PCLK的比例（即设置CLKDIVN寄存器），关闭MMU、CACHE。<br>代码都在cpu&#x2F;arm920t&#x2F;start.S中，注释也比较完善。</p>
</li>
<li><p>为加载Bootloader的第二阶段代码准备RAM空间。<br>所谓准备RAM空间，就是初始化内存芯片，使它可用。对于S3C2410&#x2F;S3C2440，通过在start.S中调用lowlevel_init函数来设置存储控制器，使得外接的SDRAM可用。代码在board&#x2F;smdk2410&#x2F;lowlevel_init.S中。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">注：lowlevel_init.S文件是开发板相关的，这表示如果外接的设备不一样，可以修改lowlevel_init.S文件中的宏。</span><br></pre></td></tr></table></figure>
<p>lowlevel_init函数并不复杂，只要注意这时的代码、数据都只存放在NOR Flash中，内存中还没有，所以读取数据时要变换地址。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">_TEXT_BASE:</span><br><span class="line">.word   TEXT_BASE</span><br><span class="line"></span><br><span class="line">.global   lowlevel_init</span><br><span class="line">lowlevel_init:</span><br><span class="line">  <span class="comment">/* memory control configuration */</span></span><br><span class="line">  <span class="comment">/* make r0 relative the current location so that it */</span></span><br><span class="line">  <span class="comment">/* reads SMRDATA out of FLASH rather than memory! */</span></span><br><span class="line">  ldr r0,=SMRDATA</span><br><span class="line">  ldr r1,_TEXT_BASE</span><br><span class="line">  sub r0,r0,r1</span><br><span class="line">  ldr r1,=BWSCON<span class="comment">/*Bus Width Status Controller*/</span></span><br><span class="line">  add r2,r0,#<span class="number">13</span>*<span class="number">4</span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>:</span><br><span class="line">  ldr r3,[r0],#<span class="number">4</span></span><br><span class="line">  str r3,[r1],#<span class="number">4</span></span><br><span class="line">  cmp r2,r0</span><br><span class="line">  bne <span class="number">0b</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">/* everything is fine now */</span></span><br><span class="line">  mov pc,lr</span><br><span class="line"></span><br><span class="line">  .ltorg</span><br><span class="line">  <span class="comment">/* the literal pools origin */</span></span><br><span class="line"></span><br><span class="line">SMRDATA:</span><br><span class="line">  .word ... ...</span><br><span class="line">  .word ... ... </span><br></pre></td></tr></table></figure>
<p>第9-11行进行地址变换，因为这时候内存中没有数据，不能使用连接程序时确定的地址来读取数据。<br>第9行中SMRDATA表示这13个寄存器的值存放的开始地址（连接地址），值为0x33F8xxxx，处于内存中。<br>第10行获得代码段的起始地址，它就是第1行中的“TEXT_BASE”，其值在<code>board/smdk2410/config.mk</code>中定义为“TEXT_BASE &#x3D; 0x33F80000”。<br>第11行将0x33F8xxxx与0x33F80000相减，这就是13个寄存器值在NOR Flash上存放的开始地址。</p>
</li>
<li><p>复制Bootloader的第二阶段代码到RAM空间中<br>这里将整个U-Boot的代码（包括第一、第二阶段）都复制到SDARM中，这在<code>cpu/arm920t/start.S</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">relocate:                               <span class="comment">/*将U-Boot复制到RAM中*/</span></span><br><span class="line">  adr r0,_start                         <span class="comment">/*r0:当前代码的开始地址*/</span></span><br><span class="line">  ldr r1,_TEXT_BASE                     <span class="comment">/*r1:代码段的连接地址*/</span></span><br><span class="line">  cmp r0,r1                             <span class="comment">/*测试现在是在Flash中还是RAM中*/</span></span><br><span class="line">  beq stack_setup                       <span class="comment">/*如果已经在RAM中（通常是调试时直接下载到RAM中），则不需要复制*/</span></span><br><span class="line"></span><br><span class="line">  ldr r2,_armboot_start                 <span class="comment">/*_armboot_start在前面定义，是第一条指令的运行地址*/</span></span><br><span class="line">  ldr r3,_bss_start                     <span class="comment">/*在连接脚本U-Boot.lds中定义，是代码段的结束地址*/</span></span><br><span class="line">  sub r2,r3,r2                          <span class="comment">/*r2 = 代码段长度*/</span></span><br><span class="line">  add r2,r0,r2                          <span class="comment">/*r2 = NOR Flash 上代码段的结束地址*/</span></span><br><span class="line"></span><br><span class="line">copy_loop:</span><br><span class="line">  ldmia r0!,&#123;r3-r10&#125;                    <span class="comment">/*从地址[r0]处获得数据*/</span></span><br><span class="line">  stmia r1!,&#123;r3-r10&#125;                    <span class="comment">/*复制到地址[r1]处*/</span></span><br><span class="line">  cmp r0,r2                             <span class="comment">/*判断是否复制完毕*/</span></span><br><span class="line">  ble copy_loop                         <span class="comment">/*没复制完，则继续*/</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>设置好栈<br>栈的设置灵活性很大，只要让sp寄存器指向一段没有使用的内存即可。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* set up the stack */</span></span><br><span class="line">stack_setup:</span><br><span class="line">  ldr r0,_TEXT_BASE                     <span class="comment">/*_TEXT_BASE为代码段的开始地址，值为0x33F80000*/</span></span><br><span class="line">  sub r0,r0,#CFG_MALLOC_LEN             <span class="comment">/*代码段下面，留出一段内存以实现malloc*/</span></span><br><span class="line">  sub r0,r0,#CFG_GBL_DATA_SIZE          <span class="comment">/*再留出一段内存，存一些全局参数*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_USE_IRQ</span></span><br><span class="line">  sub r0,r0,#(CONFIG_STACKSIZE_IRQ + CONFIG_STACKSIZE_FIQ)          <span class="comment">/*IRQ、FIQ模式的栈*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">  sub sp,r0,#<span class="number">12</span>                         <span class="comment">/*最后，留出12字节的内存给abort异常，往下的内存就是栈了*/</span></span><br></pre></td></tr></table></figure>
<p>到了这一步，读者就可以知道内存的使用情况了，如下图所示，图中与上面代码的划分稍有不同，这时因为在<code>cpu/arm920t/cpu.c</code>中的cpu_init函数中才真正为IRQ、FIQ模式划分了栈。<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/3.jpeg" alt="img not found"></p>
</li>
<li><p>跳转到第二阶段代码的C入口点<br>在跳转之前，还要清除BSS段（初始值为0、无初始值的全局变量、静态变量放在BSS段），代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">clear_bss:</span><br><span class="line">  ldr r0,_bss_start                      <span class="comment">/*BSS段的开始地址，它的值在连接脚本U-Boot.lds中确定*/</span></span><br><span class="line">  ldr r1,_bss_end                        <span class="comment">/*BSS段的结束地址，它的值在连接脚本U-Boot.lds中确定*/</span></span><br><span class="line">  mov r2,#<span class="number">0x00000000</span></span><br><span class="line"></span><br><span class="line">clbss_l:</span><br><span class="line">  str r2,[r0]                            <span class="comment">/*往BSS段中写入0值*/</span></span><br><span class="line">  add r0,r0,#<span class="number">4</span></span><br><span class="line">  cmp r0,r1</span><br><span class="line">  ble clbss_l</span><br></pre></td></tr></table></figure>
<p>现在，C函数的环境已经完全准备好，通过如下命令直接跳转（这之后，程序才在内存中执行），它将调用<code>lib_arm/board.c</code>中的start_arm_boot函数，这是第二阶段的入口点。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">  ldr pc,_start_armboot</span><br><span class="line"></span><br><span class="line">_start_armboot: .word start_armboot</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="U-Boot第二阶段代码分析"><a href="#U-Boot第二阶段代码分析" class="headerlink" title="U-Boot第二阶段代码分析"></a>U-Boot第二阶段代码分析</h3><p>U-Boot在启动内核之前可以让用户选择是否进入下载模式，即进入U-Boot的控制界面。<br>第二阶段从<code>lib_arm/board.c</code>中的start_armboot函数开始，程序流程图如下所示：<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/4.jpeg" alt="img not found"><br>移植U-Boot的主要工作在于对硬件的初始化、驱动，所以下面讲解时将重点放在硬件的操作上。</p>
<ol>
<li>初始化本阶段要使用到的硬件设备<br>最主要的的是系统时钟、初始化串口，只要设置好这两个，就可以从串口看到打印信息。<br>board_init函数设置MPLL、改变系统时钟，它是开发板相关的函数，在<code>board/smdk2410/smdk2410.c</code>中实现。值得注意的是，board_init函数中保存了机器类型ID，这将在调用内核时传给内核。代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*arch number of SMDK2410-Board*/</span></span><br><span class="line">gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410;      <span class="comment">//值为193</span></span><br></pre></td></tr></table></figure>
串口的初始化函数主要是serial_init，它设置UART控制器，是CPU相关的函数，在<code>cpu/arm920t/s3c24x0/serail.c</code>中实现。</li>
<li>检测系统内存映射（memory map）<br>对于特定的开发板，其内存的分布是明确的，所以可以直接设置。<code>board/smdk2410/smdk2410.c</code>中的dram_init函数指定了本开发板的内存起始地址为0x30000000，大小为0x4000000。代码如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">dram_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  gd-&gt;bd-&gt;bi_dram[<span class="number">0</span>].start = PHYS_SDRAM_1;          <span class="comment">//即0x30000000；</span></span><br><span class="line">  gd-&gt;bd-&gt;bi_dram[<span class="number">0</span>].size = PHYS_SDRAM_1_SIZE;          <span class="comment">//即0x4000000；</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>；</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
这些参数的设置，将在后面向内核传递参数时用到。</li>
<li>U-Boot命令的格式<br>即使是内核的启动，也是通过U-Boot命令来实现的。U-Boot中每个命令都通过U_BOOT_CMD宏来定义，格式如下：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(name,maxargs,repeatable,command,<span class="string">&quot;usage&quot;</span>,<span class="string">&quot;help&quot;</span>)</span><br></pre></td></tr></table></figure>
各项参数意义如下：<br>①name：命令的名字，它不是一个字符串，不要用双引号括起来。<br>②maxargs：最大的参数个数<br>③repeatable：命令是否可以重复，可重复是指运行一个命令后，下次再敲回车即可再次运行<br>④command：对应的函数指针，类型为<code>(*cmd)(struct cmd_tbl_s *,int,int,char *[])</code>。<br>⑤usage：简短的使用说明，字符串。<br>⑥help：详细的使用说明，字符串。</li>
</ol>
<p>宏U_BOOT_CMD在<code>include/command.h</code>中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> U_BOOT_CMD(name,maxargs,rep,cmd,usage,help) \</span></span><br><span class="line"><span class="meta">cmd_tbl_t __u_boot_cmd_##name Struct_Section = &#123;#name,maxargs,rep,cmd,usage,help&#125;</span></span><br></pre></td></tr></table></figure>
<p>Struct_Section也是在<code>include/command.h</code>中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> Struct_Section __attribute__ ((unused,section (<span class="string">&quot;.u_boot_cmd&quot;</span>)))</span></span><br></pre></td></tr></table></figure>
<p>比如对与bootm命令，它如下定义：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(</span><br><span class="line">  bootm,CFG_MAXARGS,<span class="number">1</span>,do_bootm,</span><br><span class="line">  <span class="string">&quot;string1&quot;</span>,</span><br><span class="line">  <span class="string">&quot;string2&quot;</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>宏U_BOOT_CMD扩展开后如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">cmd_tbl_t</span> __u_boot_cmd_bootm __attribute__ ((unused,section (<span class="string">&quot;.u_boot_cmd&quot;</span>))) = &#123;<span class="string">&quot;bootm&quot;</span>,CFG_MAXARGS,<span class="number">1</span>,do_bootm,<span class="string">&quot;string1&quot;</span>,<span class="string">&quot;string2&quot;</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>对于每个使用U_BOOT_CMD宏来定义的命令，其实都是在“.u_boot_cmd”段中定义一个cmd_tbl_t结构。连接脚本U-Boot.lds中有如下代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">__u_boot_cmd_start = .;</span><br><span class="line">.u_boot_cmd : &#123; *(.u_boot_cmd) &#125;</span><br><span class="line">__u_boot_cmd_end = .;</span><br></pre></td></tr></table></figure>
<p>程序中就是根据命令的名字在内存段__u_boot_cmd_start~__u_boot_cmd_end找到它的cmd_tbl_t结构，然后调用它的函数。<br>内核的复制与启动，可以通过如下命令来完成：bootm从内存、ROM、NOR Flash中启动内核，bootp则通过网络来启动，而nboot从NAND Flash启动内核。它们都是先将内核映像从各种媒介中读出，存放在指定的位置；然后设置标记列表以给内核传递参数；最后跳到内核的入口点去执行。<br>4. 为内核设置启动参数<br>U-Boot也是通过标记列表向内核传递参数。并且，在之前的小节中内存标记、命令行标记的示例代码就是取自U-Boot中的setup_memory_tags、setup_commandline_tag函数，它们都是在<code>lib_arm/armlinux.c</code>中定义。一般而言，设置这两个标记就可以了，在配置文件<code>include/configs/smdk2410.h</code>中增加如下两个配置项即可：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SETUP_MEMORY_TAGS  1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CMDLINE_TAG  1</span></span><br></pre></td></tr></table></figure>
<p>对于ARM架构的CPU，都是通过<code>lib_arm/armlinux.c</code>中的do_bootm_linux函数来启动内核。这个函数中，设置标记列表，最后通过<code>theKernel(0,bd-&gt;bi_arch_number,bd-&gt;bi_boot_params)</code>调用内核。其中。theKernel指向内核存放的地址（对于ARM架构的CPU，通常是0x30008000），bd-&gt;bi_arch_number就是前面board_init函数设置的机器类型ID，而bd-&gt;bi_boot_params就是标记列表的开始地址。</p>
<h2 id="U-Boot的移植"><a href="#U-Boot的移植" class="headerlink" title="U-Boot的移植"></a>U-Boot的移植</h2><p>开发板smdk2410的配置适用于大多数S342410开发板，或者只需要极少的修改即可使用。但是目前的U-Boot中没有对S3C2410的支持，需要我们自己移植。<br>本书基于S342410、S342440两款开发板，它们的外接硬件相同。</p>
<ol>
<li>BANK0外界容量为1MB，位宽为8的NOR Flash芯片AM29LV800。</li>
<li>BANK3外接10M网卡芯片CS8900，位宽为16。</li>
<li>BANK6外接两片容量为32MB、位宽为16的SDRAM芯片K4S561632，组成容量为64MB、位宽为32的内存。</li>
<li>听过NAND Flash控制器外接容量为64MB，位宽为8的NAND Flash芯片K9S1208。</li>
</ol>
<p>对于NOR Flash和NAND Flash，下图划分了它们的使用区域。<br><img src="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/5.jpeg" alt="img not found"><br>由于NAND Flash的“位反转”现象比较常见，为保证数据的正确，在读写数据时需要使用ECC校验。另外，NAND Flash在使用过程中、运输过程中还有可能出现坏块。所以下面使用NOR Flash保存U-Boot，NAND Flash保存内核和文件系统，并使用U-Boot烧写内核、文件系统时进行坏块检查、ECC校验。这样，即使NAND Flash出现坏块导致内核或文件系统不能使用，也可以通过NOR Flash中的U-Boot来重新烧写。<br>smdk2410开发板已经支持NOR Flash芯片AM29LV800，U-Boot本身也已经支持JFFS2文件系统映像的烧写。下面一步一步移植U-Boot，增加以下新功能。</p>
<ol>
<li>同时支持本书使用的S3C2410和S3C2440开发板。</li>
<li>支持串口xmodem协议。</li>
<li>支持网卡芯片CS8900。</li>
<li>支持NAND Flash读写。</li>
<li>支持烧写yaffs文件系统映像。</li>
</ol>
<h3 id="同时支持S3C2410和S3C2440"><a href="#同时支持S3C2410和S3C2440" class="headerlink" title="同时支持S3C2410和S3C2440"></a>同时支持S3C2410和S3C2440</h3><p>我们将在开发板smdk2410的基础上进行移植。</p>
<h4 id="新建一个开发板的相应目录和文件"><a href="#新建一个开发板的相应目录和文件" class="headerlink" title="新建一个开发板的相应目录和文件"></a>新建一个开发板的相应目录和文件</h4><p>为了不破坏原来的代码，在board目录下将smdk2410复制为<code>100ask24x0</code>目录，并将<code>board/100ask24x0/smdk2410.c</code>改名为<code>100ask2410.c</code>。<br>根据前面描述的配置过程可知，还要在<code>include/configs</code>目录下建立一个配置文件<code>100ask24x0.h</code>，可以将<code>include/configs/smdk2410.h</code>直接复制为<code>100ask24x0.h</code>。<br>还要修改两个Makefile，首先在顶层Makefile中增加两行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="number">100</span>ask24x0_config : unconfig</span><br><span class="line">                    @$(MKCONFIG) $(@:_config=) arm arm920t <span class="number">100</span>ask24x0 <span class="literal">NULL</span> s3c24x0</span><br></pre></td></tr></table></figure>
<p>在<code>board/100ask24x0/Makefile</code>中进行如下修改：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COBJS := smdk2410.o flash.o</span><br><span class="line">改为</span><br><span class="line">COBJS := <span class="number">100</span>ask24x0.o flash.o</span><br></pre></td></tr></table></figure>

<h4 id="修改SDRAM的设置"><a href="#修改SDRAM的设置" class="headerlink" title="修改SDRAM的设置"></a>修改SDRAM的设置</h4><p>SDRAM的初始化在U-Boot的第一阶段完成，就是在<code>board/100ask24x0/lowlevel_init.S</code>文件中设置存储寄存器。<br>检查BANK6的设置：位宽为32，宏B6_BWSON刚好为DW32（32位），无需改变；另外还需要根据HCLK设置SDRAM的刷新参数，主要是REFCNT寄存器。<br>本书所用开发板的HCLK都设为100MHz，需要根据SDRAM芯片的具体参数重新计算REFCNT寄存器的值。代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> REFCNT 1113         <span class="comment">//period=15.6μs,HCLK=60MHz,(2048+1-15.6*60)</span></span></span><br><span class="line">改为</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> REFCNT 0x4f4         <span class="comment">//period=7.8125μs,HCLK=100MHz,(2048+1-7.8125*100)</span></span></span><br></pre></td></tr></table></figure>
<p>对于其他BANK，比如网卡芯片CS8900所在的BANK2，原来的设置刚好匹配，无需更改；而对于BANK1、BANK2、BANK4、BANK5、BANK7，在U-Boot中并没有使用到它们外接的设备，也不需要理会。</p>
<h4 id="增加对S3C2440的支持"><a href="#增加对S3C2440的支持" class="headerlink" title="增加对S3C2440的支持"></a>增加对S3C2440的支持</h4><p>S3C2440是S3C2410的改进版，它们的操作基本相似。不过在系统时间的设置、NAND Flash控制器的操作方面有一些小差别。它们的MPLL、UPLL计算公式不一样，FCLK、HCLK和PCLK的分频化设置也不一样。<br>我们的目标是令同一个二进制映像文件既能在S3C2410上运行，也可以在S3C2440上运行。首先需要在代码中自动识别芯片是S3C2440还是S3C2410，这可以通过读取GSTATUS1寄存器来分辨：0x32410000表示S3C2410，0x32410002表示S3C2410A，0x32440000表示S3C2440，0x32440001表示S3C2440A。<br>对于S3C2410开发板，将FCLK设为200MHz，分频比为FCLK：HCLK：PCLK&#x3D;1：2：4；对于S3C2440，将FCLK设为400MHz，分频比为FCLK：HCLK：PCLK&#x3D;1：4：8。还将UPLL设为48MHz，即UCLK为48MHz，以在内核中支持USB控制器。<br>首先修改<code>board/100ask24x0/100ask24x0.c</code>中的<code>board_init</code>函数，下面是修改后的代码：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* S3C2440:</span></span><br><span class="line"><span class="comment">          MPLL = (2 * m * Fin) / (p * 2^s)</span></span><br><span class="line"><span class="comment">          UPLL = (m * Fin) / (p * 2^s)  </span></span><br><span class="line"><span class="comment">          m = M(the value for divider M) + 8</span></span><br><span class="line"><span class="comment">          p = P(the value for divider P) + 2 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_MPLL_400MHz                 ((0x5c &lt;&lt; 12) | (0x01 &lt;&lt; 4) | 0x01)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_UPLL_48MHz                  ((0x38 &lt;&lt; 12) | (0x02 &lt;&lt; 4) | 0x02)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIV                      (0x05)  <span class="comment">//FCLK:HCLK:PLCK = 1:4:8  UCLK = UPLL</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* S3C2410:</span></span><br><span class="line"><span class="comment">          MPLL = (m * Fin) / (p * 2^s)  </span></span><br><span class="line"><span class="comment">          UPLL = (m * Fin) / (p * 2^s)  </span></span><br><span class="line"><span class="comment">          m = M(the value for divider M) + 8</span></span><br><span class="line"><span class="comment">          p = P(the value for divider P) + 2 </span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_MPLL_200MHz                 ((0x5c &lt;&lt; 12) | (0x04 &lt;&lt; 4) | 0x00)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_UPLL_48MHz                  ((0x28 &lt;&lt; 12) | (0x01 &lt;&lt; 4) | 0x02)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_CLKDIV                      (0x05)  <span class="comment">//FCLK:HCLK:PLCK = 1:2:8</span></span></span><br></pre></td></tr></table></figure>
<p>针对S3C2410、S3C2440分别定义了MPLL、UPLL寄存器的值。开发板输入时钟为12MHz（<code>include/configs/100ask24x0.h中的宏CONFIG_SYS_CLK_FREQ中定义</code>）。<br>下面针对S3C2410、S3C2440分别使用不同的宏设置系统时钟。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">board_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C24X0_CLOCK_POWER * <span class="type">const</span> clk_power = S3C24X0_GetBase_CLOCK_POWER();</span><br><span class="line">  S3C24X0_GPIO * <span class="type">const</span> gpio = S3C24X0_GetBase_GPIO();</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*设置GPIO*/</span></span><br><span class="line">  gpio-&gt;GPACON = <span class="number">0x007FFFFF</span>;</span><br><span class="line">  gpio-&gt;GPBCON = <span class="number">0x00044555</span>;</span><br><span class="line">  gpio-&gt;GPBUP  = <span class="number">0x000007FF</span>;</span><br><span class="line">  gpio-&gt;GPCCON = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  gpio-&gt;GPCUP  = <span class="number">0x0000FFFF</span>;</span><br><span class="line">  gpio-&gt;GPDCON = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  gpio-&gt;GPDUP  = <span class="number">0x0000FFFF</span>;</span><br><span class="line">  gpio-&gt;GPECON = <span class="number">0xAAAAAAAA</span>;</span><br><span class="line">  gpio-&gt;GPEUP  = <span class="number">0x0000FFFF</span>;</span><br><span class="line">  gpio-&gt;GPFCON = <span class="number">0x000055AA</span>;</span><br><span class="line">  gpio-&gt;GPFUP  = <span class="number">0x000000FF</span>;</span><br><span class="line">  gpio-&gt;GPGCON = <span class="number">0xFF95FFBA</span>;</span><br><span class="line">  gpio-&gt;GPGUP  = <span class="number">0x0000FFFF</span>;</span><br><span class="line">  gpio-&gt;GPHCON = <span class="number">0x002AFAAA</span>;</span><br><span class="line">  gpio-&gt;GPHUP  = <span class="number">0x000007FF</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*同时支持S3C2410和S3C2440*/</span></span><br><span class="line">  <span class="keyword">if</span>((gpio-&gt;GSTATUS1 == <span class="number">0x32410000</span>) || (gpio-&gt;GSTATUS1 == <span class="number">0x32410002</span>))</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*FCLK:HCLK:PCLK=1:2:4*/</span></span><br><span class="line">    clk_power-&gt;CLKDIVN = S3C2410_CLKDIV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*修改为异步总线模式*/</span></span><br><span class="line">    __asm__(<span class="string">&quot;mrc p15,0,r1,c1,c0,0 \n&quot;</span>     <span class="comment">/*read ctrl register*/</span></span><br><span class="line">            <span class="string">&quot;orr r1,r1, #0xc0000000 \n&quot;</span>   <span class="comment">/*Asynchronous*/</span></span><br><span class="line">            <span class="string">&quot;mcr p15,0,r1,c1,c0,0 \n&quot;</span>     <span class="comment">/*write ctrl register*/</span></span><br><span class="line">            :::<span class="string">&quot;r1&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置PLL锁定时间*/</span></span><br><span class="line">    clk_power-&gt;LOCKTIME = <span class="number">0xFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置MPLL*/</span></span><br><span class="line">    clk_power-&gt;MPLLCON = S3C2410_MPLL_200MHZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置MPLL后，要延时一段时间再配置UPLL*/</span></span><br><span class="line">    delay(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置UPLL*/</span></span><br><span class="line">    clk_power_UPLLCON = S3C2410_UPLL_48MHZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*再延时一会*/</span></span><br><span class="line">    delay(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*机器类型ID，这在调用Linux内核时用到*/</span></span><br><span class="line">    gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2410;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">/*FCLK:HCLK:PCLK=1:4:8*/</span></span><br><span class="line">    clk_power-&gt;CLKDIVN = S3C2440_CLKDIV;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*修改为异步总线模式*/</span></span><br><span class="line">    __asm__(<span class="string">&quot;mrc p15,0,r1,c1,c0,0 \n&quot;</span>     <span class="comment">/*read ctrl register*/</span></span><br><span class="line">            <span class="string">&quot;orr r1,r1, #0xc0000000 \n&quot;</span>   <span class="comment">/*Asynchronous*/</span></span><br><span class="line">            <span class="string">&quot;mcr p15,0,r1,c1,c0,0 \n&quot;</span>     <span class="comment">/*write ctrl register*/</span></span><br><span class="line">            :::<span class="string">&quot;r1&quot;</span></span><br><span class="line">    );</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*设置PLL锁定时间*/</span></span><br><span class="line">    clk_power-&gt;LOCKTIME = <span class="number">0xFFFFFF</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置MPLL*/</span></span><br><span class="line">    clk_power-&gt;MPLLCON = S3C2440_MPLL_400MHZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置MPLL后，要延时一段时间再配置UPLL*/</span></span><br><span class="line">    delay(<span class="number">4000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*配置UPLL*/</span></span><br><span class="line">    clk_power_UPLLCON = S3C2440_UPLL_48MHZ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*再延时一会*/</span></span><br><span class="line">    delay(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*机器类型ID，这在调用Linux内核时用到*/</span></span><br><span class="line">    gd-&gt;bd-&gt;bi_arch_number = MACH_TYPE_SMDK2440;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*启动内核时，参数存放位置。这个值在构造标记列表时用到*/</span></span><br><span class="line">  gd-&gt;bd-&gt;bi_boot_params = <span class="number">0x30000100</span>;</span><br><span class="line"></span><br><span class="line">  icache_enable();</span><br><span class="line">  dcache_enable();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>最后一步：获取系统时钟的函数需要针对S3C2410、S3C2440的不同进行修改。<br>在后面设置串口波特率时需要获得系统时钟，就是在U-Boot第二阶段，<code>lib_arm/board.c</code>中<code>start_armboot</code>函数调用<code>serial_init</code>函数初始化串口时，会调用<code>get_PCLK</code>函数。它在<code>cpu/arm920t/s3c24x0/speed.c</code>中定义，与它相关的还有<code>get_HCLK</code>、<code>get_PLLCLK</code>等函数。<br>前面的<code>board_init</code>函数在识别出S3C2410或S3C2440后，设置了机器类型ID：<code>gd-&gt;bd-&gt;bi_arch_number</code>，后面的函数可以通过它分辨是S3C2410还是S3C2440。首先要在程序的开头增加如下代码，这样才可以使用<code>gd</code>变量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br></pre></td></tr></table></figure>
<p>S3C2410和S3C2440的MPLL、UPLL计算公式不一样，所以<code>get_PLLCLK</code>也需要修改，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">static</span> ulong <span class="title function_">get_PLLCLK</span><span class="params">(<span class="type">int</span> pllreg)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C24X0_CLOCK_POWER * <span class="type">const</span> clk_power = S3C24X0_GetBase_CLOCK_POWER();</span><br><span class="line">  ulong r,m,p,s;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(pllreg == MPLL)</span><br><span class="line">    r = clk_power-&gt;MPLLCON;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span>(pllreg == UPLL)</span><br><span class="line">    r = clk_power-&gt;UPLLCON;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    hang();</span><br><span class="line"></span><br><span class="line">  m = ((r &amp; <span class="number">0xFF000</span>) &gt;&gt; <span class="number">12</span>) + <span class="number">8</span>;</span><br><span class="line">  p = ((r &amp; <span class="number">0x003F0</span>) &gt;&gt; <span class="number">4</span> ) + <span class="number">2</span>;</span><br><span class="line">  s = r &amp; <span class="number">0x3</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*同时支持S3C2410和S3C2440*/</span></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)</span><br><span class="line">    <span class="keyword">return</span> ((CONFIG_SYS_CLK_FREQ * m) / (p &lt;&lt; s));</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">    <span class="keyword">return</span> ((CONFIG_SYS_CLK_FREQ * m * <span class="number">2</span>) / (p &lt;&lt; s));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于分频系数的设置方法也不一样，<code>get_HCLK</code>，<code>getPCLK</code>也需要修改。对于S3C2410，沿用原来的计算方法，else分支中是S3C2440的代码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* for s3c2440 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_PDIVN                     (1 &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_MASK                (3 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_1                   (0 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_2                   (1 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_4_8                 (2 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_HDIVN_3_6                 (3 &lt;&lt; 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CLKDIVN_UCLK                      (1 &lt;&lt; 3)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_CAMCLK_MASK               (0xf &lt;&lt; 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_CAMCLK_SEL                (1 &lt;&lt; 4)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_HCLK3_HALF                (1 &lt;&lt; 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_HCLK4_HALF                (1 &lt;&lt; 9)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_CAMDIVN_DVSEN                     (1 &lt;&lt; 12)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*return HCLK frequency*/</span></span><br><span class="line">ulong <span class="title function_">get_HCLK</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C24X0_CLOCK_POWER * <span class="type">const</span> clk_power = S3C24X0_GetBase_CLOCK_POWER();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> clkdiv;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> camdiv;</span><br><span class="line">  <span class="type">int</span> hdiv = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*同时支持S3C2410和S3C2440*/</span></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)</span><br><span class="line">    <span class="keyword">return</span> ((clk_power-&gt;CLKDIVN &amp; <span class="number">0x2</span>) ? get_FCLK() / <span class="number">2</span> : getFCLK());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    clkdiv = clk_power-&gt;CLKDIVN;</span><br><span class="line">    camdiv = clk_power-&gt;CAMDIVN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算分频比*/</span></span><br><span class="line">    <span class="keyword">switch</span>(clkdiv &amp; S3C2440_CLKDIVN_HDIVN_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_1:</span><br><span class="line">        hdiv = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_2:</span><br><span class="line">        hdiv = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_4_8:</span><br><span class="line">        hdiv = (camdiv &amp; S3C2440_CAMDIVN_HCLK4_HALF) ? <span class="number">8</span> : <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_3_6:</span><br><span class="line">        hdiv = (camdiv &amp; S3C2440_CAMDIVN_HCLK3_HALF) ? <span class="number">6</span> : <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_FCLK() / hdiv;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*return PCLK frequence*/</span></span><br><span class="line">ulong <span class="title function_">getPCLK</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C24X0_CLOCK_POWER * <span class="type">const</span> clk_power = S3C24X0_GetBase_CLOCK_POWER();</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> clkdiv;</span><br><span class="line">  <span class="type">unsigned</span> <span class="type">long</span> camdiv;</span><br><span class="line">  <span class="type">int</span> hdiv = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/*同时支持S3C2410和S3C2440*/</span></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)</span><br><span class="line">    <span class="keyword">return</span> ((clk_power-&gt;CLKDIVN &amp; <span class="number">0x1</span>) ? get_HCLK() / <span class="number">2</span> : getHCLK());</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    clkdiv = clk_power-&gt;CLKDIVN;</span><br><span class="line">    camdiv = clk_power-&gt;CAMDIVN;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*计算分频比*/</span></span><br><span class="line">    <span class="keyword">switch</span>(clkdiv &amp; S3C2440_CLKDIVN_HDIVN_MASK)</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_1:</span><br><span class="line">        hdiv = <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_2:</span><br><span class="line">        hdiv = <span class="number">2</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_4_8:</span><br><span class="line">        hdiv = (camdiv &amp; S3C2440_CAMDIVN_HCLK4_HALF) ? <span class="number">8</span> : <span class="number">4</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">case</span> S3C2440_CLKDIVN_HDIVN_3_6:</span><br><span class="line">        hdiv = (camdiv &amp; S3C2440_CAMDIVN_HCLK3_HALF) ? <span class="number">6</span> : <span class="number">3</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> get_FCLK() / hdiv / ((clkdiv &amp; S3C2440_CLKDIVN_PDIVN)?<span class="number">2</span>:<span class="number">1</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在重新执行“make 100ask24x0_config”和“make all”生成的U-Boot.bin文件既可以运行于S3C2410开发板，也可以运行于S3C2440开发板。将它烧录进入NOR Flash后启动，就可以在串口工具中看到提示信息，可以输入各种命令操作U-Boot了。</p>
<h4 id="选择NOR-Flash的型号"><a href="#选择NOR-Flash的型号" class="headerlink" title="选择NOR Flash的型号"></a>选择NOR Flash的型号</h4><p>但是，现在还无法通过U-Boot命令烧写NOR Flash。本书所用开发板中的NOR Flash型号为AM29LV800，而配置文件<code>include/configs/a00ask24x0.h</code>中的默认型号为AM29LV400。修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_AMD_LV400 1  <span class="comment">//uncomment this if you have a LV400 flash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_AMD_LV800 1  <span class="comment">//uncomment this if you have a LV800 flash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">改为</span><br><span class="line"><span class="meta">#<span class="keyword">if</span> 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_AMD_LV400 1  <span class="comment">//uncomment this if you have a LV400 flash</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_AMD_LV800 1  <span class="comment">//uncomment this if you have a LV800 flash</span></span></span><br></pre></td></tr></table></figure>
<p>本例子中NOR Flash的操作函数在<code>board/100ask24x0/flash.c</code>中实现，它支持AM29LV400y和AM29LV800。对于其他型号的NOR Flash，如果符合CFI接口标准，则可以在使用<code>drivers/cfi_flash.c</code>中的接口函数；否则，只好自己编写了。如果要使用<code>cfi_flash.c</code>，如下修改两个文件：<br>在<code>include/configs/100ask24x0.h</code>中增加以下一行：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_FLASH_CFI_DRIVER 1</span></span><br></pre></td></tr></table></figure>
<p>在<code>board/100ask24x0/Makefile</code>去掉flash.o:</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COBJS :=  <span class="number">100</span>ask24x0.o flash.o</span><br><span class="line">改为</span><br><span class="line">COBJS :=  <span class="number">100</span>ask24x0.o </span><br></pre></td></tr></table></figure>
<p>修改好对NOR Flash的支持后，重新编译U-Boot：make clean、make all。运行后可以在串口中看到如下字样：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Flash: <span class="number">1</span>MB</span><br></pre></td></tr></table></figure>
<p>现在可以使用loadb、loady等命令通过串口下载文件，然后使用erase、cp命令分别擦除、烧写NOR Flash了，它们的效率比JTAG高好几倍。</p>
<h3 id="支持串口xmodem协议"><a href="#支持串口xmodem协议" class="headerlink" title="支持串口xmodem协议"></a>支持串口xmodem协议</h3><p>上面的loadb命令需要配合Linux下的kermit工具来使用，loady命令通过串口ymodem协议来传输文件。Windows工具SecureCRT只支持xmodem和zmodem。现在修改代码对xmodem的支持，即增加一个命令loadx。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* 支持xmodem */</span></span><br><span class="line">U_BOOT_CMD(</span><br><span class="line">    loadx,<span class="number">3</span>,<span class="number">0</span> do_load_serial_bin,</span><br><span class="line">    <span class="string">&quot;loadx - load binary file over serial line (xmodem mode)\n&quot;</span>,</span><br><span class="line">    <span class="string">&quot;[ off ] [ baud ]\n&quot;</span></span><br><span class="line">    <span class="string">&quot; -load binary file over serial line&quot;</span></span><br><span class="line">    <span class="string">&quot;with offset &#x27;off&#x27; and baudrate &#x27;baud&#x27;\n&quot;</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<p>其次，在<code>do_load_serial_bin</code>函数中增加对loadx命令的处理分支。也是依照loady来实现：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*支持xmodem*/</span></span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;loadx&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;## Ready for binary (xmodem) download to 0x%081X at %d bps...\n&quot;</span>,offset,load_baudrate);</span><br><span class="line">  addr = load_serial_xmodem(offset);</span><br><span class="line">&#125;<span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">strcmp</span>(argv[<span class="number">0</span>],<span class="string">&quot;loady&quot;</span>) == <span class="number">0</span>)&#123;</span><br><span class="line">  <span class="built_in">printf</span>(<span class="string">&quot;## Ready for binary (ymodem) download to 0x%081X at %d bps...\n&quot;</span>,offset,load_baudrate);</span><br><span class="line">  addr = load_serial_ymodem(offset);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第2-5行就是为loadx命令增加的代码。<br>第4行调用<code>load_serial_xmodem</code>函数，它是依照<code>load_serial_ymodem</code>实现的一个新函数：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">if</span> (CONFIG_COMMANDS &amp; CFG_CMD_LOADB)</span></span><br><span class="line"><span class="comment">/*支持xmodem*/</span></span><br><span class="line"><span class="type">static</span> ulong <span class="title function_">load_serial_xmodem</span><span class="params">(ulong offset)</span>;</span><br><span class="line"><span class="type">static</span> ulong <span class="title function_">load_serial_ymodem</span><span class="params">(ulong offset)</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*支持xmodem*/</span></span><br><span class="line"><span class="type">static</span> ulong <span class="title function_">load_serial_xmodem</span><span class="params">(ulong offset)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">char</span> xmodemBuf[<span class="number">1024</span>];               <span class="comment">//原来是ymodemBuf，这只是为了与函数名称一致</span></span><br><span class="line"></span><br><span class="line">  info.mode = xyzmodem_xmodem;        <span class="comment">//原来是xyzmodem_ymodem，对应ymodem</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先在开头增加<code>load_serail_xmodem</code>函数的声明，然后复制<code>load_serial_ymodem</code>函数为<code>load_serial_xmodem</code>。稍作修改：</p>
<ol>
<li>将局部数组ymodemBuf改名为xmodemBuf，并在后面使用到的地方统一修改。这只是为了与函数名称一致。</li>
<li>info.mode的值从<code>xyzModem_ymodem</code>改为<code>xyzModem_xmodem</code>。<br>重新编译、烧写U-Boot.bin后，就可以使用laodx命令下载文件了。</li>
</ol>
<h3 id="支持网卡芯片CS8900"><a href="#支持网卡芯片CS8900" class="headerlink" title="支持网卡芯片CS8900"></a>支持网卡芯片CS8900</h3><p>使用串口来传输文件的速率太低，现在增加对网卡芯片CS8900的支持。<br>本书使用开发板的网卡芯片CS8900的连接方式与smdk2410完全一样，所以现在的U-Boot中已经支持CS8900了，它的驱动程序为<code>drivers/cs8900.c</code>。只要在U-Boot控制界面中稍加配置就可以使用网络功能。使用网络之前，先设置开发板IP地址、MAC地址，服务器IP地址，比如可以在U-Boot中执行以下命令：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">setenv ipdaar <span class="number">192.168</span><span class="number">.1</span><span class="number">.17</span></span><br><span class="line">setenv ethaddr <span class="number">08</span>:<span class="number">00</span>:<span class="number">3</span>e:<span class="number">26</span>:<span class="number">0</span>a:<span class="number">5b</span></span><br><span class="line">setenv serverip <span class="number">192.168</span><span class="number">.1</span><span class="number">.11</span></span><br><span class="line">saveenv</span><br></pre></td></tr></table></figure>
<p>然后就可以使用tftp或nfs命令下载文件了，注意：服务器上要开启tftp或nfs服务。比如可以使用如下命令将U-Boot.bin命令下载到内存0x30000000中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x30000000</span> U-Boot.bin</span><br><span class="line">或</span><br><span class="line">tftp <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/U-Boot.bin</span><br></pre></td></tr></table></figure>
<p>可以修改配置文件，让网卡的各个默认值就是上面设置的值。在此之前，先了解网卡的相关文件，这有助于移植代码以支持其他连接方式的CS8900。<br>首先，CS8900接在S3C2410、S3C2440的BANK3，位宽16，使用WAIT、nBE信号。在设置存储控制器时要设置好BANK3，代码在<code>board/100ask24x0/lowlevel_init.S</code>中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> B3_BWSCON           (DW16 + WAIT + UBLB)</span></span><br><span class="line">... ...</span><br><span class="line"><span class="comment">/* 时序参数 */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tacs             (0x0) <span class="comment">/*0clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tcos             (0x3) <span class="comment">/*4clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tacc             (0x7) <span class="comment">/*14clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tcoh             (0x1) <span class="comment">/*1clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tah              (0x0) <span class="comment">/*0clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_Tacp             (0x3) <span class="comment">/*6clk*/</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> B3_PMC              (0x0) <span class="comment">/*normal*/</span></span></span><br></pre></td></tr></table></figure>
<p>接下来，还要确定CS8900的基地址。这在配置文件<code>include/configs/100ask24x0.h</code>中定义，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_DRIVER_CS8900            1           <span class="comment">/* 使用CS8900 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CS8900_BASE                     0x19000300  <span class="comment">/* 基地址 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CS8900_BUS16                    1           <span class="comment">/* 位宽为16 */</span></span></span><br></pre></td></tr></table></figure>
<p>网卡CS8900的访问基址为0x1900000，之所以再偏移0x300是由它的特性决定的。<br>最后，还是在配置文件<code>include/config/100ask24x0.h</code>中定义CS8900的各个默认地址，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ETHADDR        08:00:3e:26:0a:5b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_NETMASK        255.255.255.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_IPADDR         192.168.1.17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SERVERIP       192.168.1.11 </span></span><br></pre></td></tr></table></figure>
<p>如果要增加ping命令，还可以在配置文件<code>include/configs/100ask24x0.h</code>的宏CONFIG_COMMANDS中增加CFG_CMD_PING，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_COMMANDS (CONFIG_CMD_DFL | CFG_CMD_CACHE | CFG_CMD_PING \</span></span><br><span class="line"><span class="meta">                        | ... ... \</span></span><br><span class="line"><span class="meta">                        )</span></span><br></pre></td></tr></table></figure>
<h3 id="支持NAND-Flash"><a href="#支持NAND-Flash" class="headerlink" title="支持NAND Flash"></a>支持NAND Flash</h3><p>U-Boot 1.1.6中对NAND Flash的支持有新旧两套代码，新代码在<code>drivers/nand</code>目录下，旧代码在<code>drivers/nand_legacy</code>目录下。文档<code>doc/README.md</code>对这两套代码有所说明：使用旧代码需要定义更多的宏，而新代码移植自Linux内核2.6.12，它更加智能，可以自动识别更多型号的NAND Flash。目前之所以还保留旧的代码，是因为两个目标板NETTA、NETTA_ISDN使用JFFS文件系统，它们还依赖于旧代码。当相关的功能移植到新代码之后，旧代码将从U-Boot中移除。<br>要让U-Boot支持NAND Flash，首先在配置文件<code>include/configs/100ask24x0.h</code>的宏CONFIG_COMMANDS中增加CFG_CMD_NAND，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_COMMANDS                     \</span></span><br><span class="line"><span class="meta">                        (CONFIG_CMD_DEL   | \</span></span><br><span class="line"><span class="meta">                        CFG_CMD_CACHE     | \</span></span><br><span class="line"><span class="meta">                        CFG_CMD_PING      | \</span></span><br><span class="line"><span class="meta">                        CFG_CMD_NAND      | \</span></span><br><span class="line"><span class="meta">                        ... ... )</span></span><br></pre></td></tr></table></figure>
<p>然后选择使用哪套代码：在配置文件中定义宏CFG_NAND_LEGACY则使用旧代码，否则使用新代码。<br>使用旧代码时，需要实现<code>drivers/nand_legacy/nand_legacy.c</code>中使用到的各种宏，比如：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> NAND_WAIT_READY(nand)       <span class="comment">/* 等待Nand Flash的状态为“就绪”，代码依赖于具体的开发板 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> WRITE_NAND_COMMAN(d,adr)    <span class="comment">/* 写NAND Flash命令，代码依赖于具体的开发板 */</span></span></span><br></pre></td></tr></table></figure>
<p>本书使用新代码，下面讲述移植过程。<br>代码的移植没有现成的文档，可以在配置文件<code>include/configs/100ask24x0.h</code>的宏CONFIG_COMMANDS中增加CFG_CMD_NAND后就编译代码，然后一个一个的解决出现的的错误。编译结果中出现的错误和警告如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand.h: <span class="number">412</span>: error: <span class="string">&#x27;NAND_MAX_CHIPS&#x27;</span> undeclared <span class="title function_">here</span> <span class="params">(not in a function)</span></span><br><span class="line">nand.h: 35: error: &#x27;CFG_MAX_NAND_DEVICE&#x27; undeclared <span class="title function_">here</span> <span class="params">(not in a function)</span></span><br><span class="line">nand.h: 38: error: &#x27;CFG_NAND_BASE&#x27; undeclared <span class="title function_">here</span> <span class="params">(not in a function)</span></span><br><span class="line">nand.h: 35: error: storage size of &#x27;nand_info&#x27; isn&#x27;t known</span><br><span class="line">nand.h: 37: error: storage size of &#x27;nand_chip&#x27; isn&#x27;t known</span><br><span class="line">nand.h: 38: error: storage size of &#x27;base_address&#x27; isn&#x27;t known</span><br><span class="line">nand.h: 37: warning: &#x27;nand_chip&#x27; defined but not used</span><br><span class="line">nand.h: 38: warning: &#x27;base_address&#x27; defined but not used</span><br></pre></td></tr></table></figure>
<p>在配置文件<code>include/configs/100ask24x0.h</code>中增加如下3个宏就可以解决上述错误。在Flash的驱动程序中，设备是逻辑上的概念，表示一组相同结构、访问函数相同的Flash芯片。在本书所用的开发板中，只有一个NAND Flash芯片，所以设备数为1，芯片数也为1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_NAND_BASE           0 <span class="comment">/* 无实际意义：基地址，这在board_nand_init中重新指定 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CFG_MAX_NAND_DEVICE     1 <span class="comment">/* NAND Flash “设备”的数目为1 */</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NAND_MAX_CHIPS          1 <span class="comment">/* 每个NAND Flash “设备”由1个NAND Flash“芯片”组成 */</span></span></span><br></pre></td></tr></table></figure>
<p>修改配置文件后再次编译，现在只有一个错误了，“<code>board_nand_init</code>函数未定义”，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">nand.c:<span class="number">50</span>: undefined reference to <span class="string">&#x27;board_nand_init&#x27;</span></span><br></pre></td></tr></table></figure>
<p>调用<code>board_nand_init</code>函数的过程为：NAND Flash的初始化入口函数是<code>nand_init</code>，它在<code>lib_arm/board.c</code>的<code>start_armboot</code>函数中被调用；<code>nand_init</code>函数在<code>drivers/nand/nand.c</code>中实现，它调用相同文件中的<code>nand_init_chip</code>函数；<code>nand_init_chip</code>函数首先调用<code>board_nand_init</code>函数来初始化NAND Flash设备，最后才是统一的识别过程。<br>从<code>board_nand_init</code>函数的名称就可以知道它是平台&#x2F;开发板相关的函数，需要自己编写。本书在<code>cpu/arm920t/s3c24x0</code>目录下新建一个文件nand_flash.c，在里面针对S3C2410、S3C2440实现了统一的<code>board_nand_init</code>函数。<br>在编写<code>board_nand_init</code>函数之前，需要针对S3C2410、S3C2440 Nand Flash控制器的不同来定义一些数据结构和函数：</p>
<ol>
<li>在<code>include/s3c24x0.h</code>文件中增加S3C2440_NAND数据结构。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">typdef <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    S3C24X0_REG32   NFCONF;</span><br><span class="line">    S3C24X0_REG32   NFCONT;</span><br><span class="line">    S3C24X0_REG32   NFCMD;</span><br><span class="line">    S3C24X0_REG32   NFADDR;</span><br><span class="line">    S3C24X0_REG32   NFDATA;</span><br><span class="line">    S3C24X0_REG32   NFMECCD0;</span><br><span class="line">    S3C24X0_REG32   NFMECCD1;</span><br><span class="line">    S3C24X0_REG32   NFSECCD;</span><br><span class="line">    S3C24X0_REG32   NFSTAT;</span><br><span class="line">    S3C24X0_REG32   NFESTAT0;</span><br><span class="line">    S3C24X0_REG32   NFESTAT1;</span><br><span class="line">    S3C24X0_REG32   NFMECC0;</span><br><span class="line">    S3C24X0_REG32   NFMECC1;</span><br><span class="line">    S3C24X0_REG32   NFSECC;</span><br><span class="line">    S3C24X0_REG32   NFSBLK;</span><br><span class="line">    S3C24X0_REG32   NFEBLK;</span><br><span class="line">&#125;<span class="comment">/* __attribute__((__packed__)) */</span>S3C2440_NAND;</span><br></pre></td></tr></table></figure></li>
<li>在<code>include/s3c2410.h</code>文件中仿照<code>S3C2410_GetBase_NAND</code>函数定义<code>S3C2440_GetBase_NAND</code>函数。<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/* for s3c2440 */</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> S3C2440_NAND * <span class="type">const</span> <span class="title function_">S3C2440_GetBase_NAND</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">return</span> (S3C2440_NAND * <span class="type">const</span>)S3C2410_NAND_BASE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
既然新的NAND Flash代码是从Linux 内核2.6.12中移植来的，那么<code>cpu/arm920t/s3c24x0/nand_flash.c</code>文件也可以仿照内核中对S3C2410、S3C2440的NAND Flash进行初始化的<code>drivers/mtd/nand/s3c2410.c</code>文件来编写。为了方便阅读，先把<code>cpu/arm920t/s3c24x0/nand_flash.c</code>文件的代码全部列出来，如下所示：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">s3c2410/s3c2440的NAND Flash控制器接口，</span></span><br><span class="line"><span class="comment">修改自Linux内核2.6.13文件 drivers/mtd/nand/s3c2410.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;common.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">if</span> (CONFIG_COMMANDS &amp; CFG_CMD_NAND) &amp;&amp; !defined(CFG_NAND_LEGACY)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;s3c2410.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;nand.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">DECLARE_GLOBAL_DATA_PTR;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_NFSTAT_READY          (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2410_NFCONF_nFCE           (1&lt;&lt;11)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_NFSTAT_READY          (1&lt;&lt;0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> S3C2440_NFCONF_nFCE           (1&lt;&lt;1)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* S3C2410: NAND Flash 的片选函数 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2410_nand_select_chip</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd,<span class="type">int</span> chip)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(chip == <span class="number">-1</span>)&#123;</span><br><span class="line">    s3c2410nand-&gt;NFCONF |= S3C2410_NFCONF_nFCE;           <span class="comment">//禁止片选信号</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    s3c2410nand-&gt;NFCONF |= ~S3C2410_NFCONF_nFCE;          <span class="comment">//使能片选信号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S3C2410: 命令和控制函数</span></span><br><span class="line"><span class="comment">注意，这个函数仅仅是根据各种命令来修改“写地址”IO_ADDR_W的值（这称为tglx方法），这种方法使得平台/开发板相关的代码很简单。</span></span><br><span class="line"><span class="comment">真正发出命令是在上一层NAND Flash的统一的驱动中实现，它首先调用这个函数修改“写地址”，然后才分别发出控制、地址、数据序列。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2410_nand_hwcontrol</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd,<span class="type">int</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">chip</span> =</span> mtd-&gt;priv;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETNCE:</span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_CLRNCE:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: called for NCE\n&quot;</span>,__FUNCTION__);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETCLE:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFCMD;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETALE:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFADDR;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NAND_CTL_CLRCLE */</span></span><br><span class="line">    <span class="comment">/* NAND_CTL_CLRALE */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFDATA;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S3C2410: 查询NAND Flash状态</span></span><br><span class="line"><span class="comment">返回值：0表示忙，1表示就绪</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c2410_nand_devread</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (s3c2410nand-&gt;NFSTAT &amp; S3C2410_NFSTAT_READY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* S3C2440: NAND Flash的片选函数  */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2440_nand_select_chip</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd,<span class="type">int</span> chip)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(chip == <span class="number">-1</span>)&#123;</span><br><span class="line">    s3c2440nand-&gt;NFCONT |= S3C2440_NFCONT_nFCE;       <span class="comment">//禁止片选信号</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    s3c2440nand-&gt;NFCONT &amp;= ~S3C2440_NFCONT_nFCE;      <span class="comment">//使能片选信号</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* S3C2440: 命令和控制函数，与s3c2440_nand_hwcontrol函数类似 */</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2440_nand_hwcontrol</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd,<span class="type">int</span> cmd)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">nand_chip</span> *<span class="title">chip</span> =</span> mtd-&gt;priv;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span>(cmd)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETNCE:</span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_CLRNCE:</span><br><span class="line">      <span class="built_in">printf</span>(<span class="string">&quot;%s: called for NCE\n&quot;</span>,__FUNCTION__);</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETCLE:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFCMD;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">case</span> NAND_CTL_SETALE:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFADDR;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* NAND_CTL_CLRCLE */</span></span><br><span class="line">    <span class="comment">/* NAND_CTL_CLRALE */</span></span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFDATA;</span><br><span class="line">    <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">S3C2440: 查询NAND Flash状态</span></span><br><span class="line"><span class="comment">返回值：0表示忙，1表示就绪</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c2440_nand_devready</span><span class="params">(<span class="keyword">struct</span> mtd_info *mtd)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (s3c2440nand-&gt;NFSTAT &amp; S3C2440_NFSTAT_READY);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">NAND Flash 硬件初始化：</span></span><br><span class="line"><span class="comment">设置NAND Flash 的时序，使能NAND Flash控制器</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">s3c2440_nand_inithw</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TACLS   0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH0  4</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TWRPH1  2</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//使能NAND Flash控制器，初始化ECC，使能片选信号，设置时序</span></span><br><span class="line">    s3c2410nand-&gt;NFCONF = (<span class="number">1</span> &lt;&lt; <span class="number">15</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">12</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">11</span>) | (TACLS &lt;&lt; <span class="number">8</span>) | (TWRPH0 &lt;&lt; <span class="number">4</span>) | (TWRPH1 &lt;&lt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span></span><br><span class="line">  &#123;</span><br><span class="line">    <span class="comment">//设置时序</span></span><br><span class="line">    s3c2440nand-&gt;NFCONF = (TACLS &lt;&lt; <span class="number">12</span>) | (TWRPH0 &lt;&lt; <span class="number">8</span>) | (TWRPH1 &lt;&lt; <span class="number">4</span>);</span><br><span class="line">    <span class="comment">//初始化ECC，使能NAND Flash控制器，使能片选信号</span></span><br><span class="line">    s3c2440nand-&gt;NFCONT = (<span class="number">1</span> &lt;&lt; <span class="number">4</span>) | (<span class="number">0</span> &lt;&lt; <span class="number">1</span>) | (<span class="number">1</span> &lt;&lt; <span class="number">0</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">被drivers/nand/nand.c调用，初始化NAND Flash硬件，初始化访问接口函数</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">board_nand_init</span><span class="params">(<span class="keyword">struct</span> nand_chip *chip)</span></span><br><span class="line">&#123;</span><br><span class="line">  S3C2410_NAND * <span class="type">const</span> s3c2410nand = S3C2410_GetBase_NAND();</span><br><span class="line">  S3C2440_NAND * <span class="type">const</span> s3c2440nand = S3C2440_GetBase_NAND();</span><br><span class="line"></span><br><span class="line">  s3c24x0_nand_inithw();                                   <span class="comment">//NAND Flash  硬件初始化</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span>(gd-&gt;bd-&gt;bi_arch_number == MACH_TYPE_SMDK2410)&#123;</span><br><span class="line">    chip-&gt;IO_ADDR_R = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFDATA;</span><br><span class="line">    chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2410nand-&gt;NFDATA;</span><br><span class="line">    chip-&gt;hwconrol  = s3c2410_nand_hwcontrol;</span><br><span class="line">    chip-&gt;dev_ready = s3c2410_nand_devready;</span><br><span class="line">    chip-&gt;select_chip = s3c2410_nand_select_chip;</span><br><span class="line">    chip-&gt;options = <span class="number">0</span>;<span class="comment">//设置位宽等，位宽为8</span></span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    chip-&gt;IO_ADDR_R = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFDATA;</span><br><span class="line">    chip-&gt;IO_ADDR_W = (<span class="type">void</span> *)&amp;s3c2440nand-&gt;NFDATA;</span><br><span class="line">    chip-&gt;hwconrol  = s3c2440_nand_hwcontrol;</span><br><span class="line">    chip-&gt;dev_ready = s3c2440_nand_devready;</span><br><span class="line">    chip-&gt;select_chip = s3c2440_nand_select_chip;</span><br><span class="line">    chip-&gt;options = <span class="number">0</span>;<span class="comment">//设置位宽等，位宽为8</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  chip-&gt;eccmode =  NAND_ECC_SOFT;                           <span class="comment">//ECC校验方式：软件ECC</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
文件中分别针对S3C2410、S3C2440实现了NAND Flash最底层访问函数，并进行了一些硬件的设置（比如时序、使能NAND Flash控制器等）。新的代码对NAND Flash的封装做的很好，只要向上提供底层初始化函数<code>board_nand_init</code>来设置好平台&#x2F;开发板的相关的初始化、提供底层接口即可。<br>最后，只要将新建的nand_flash.c文件编入U-Boot中就可以擦除、读写NAND Flash了。如下修改<code>cpu/arm920t/s3c24x0/Makefile</code>文件即可。<br>修改前：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COBJS = i2c.o interrupts.o serial.o speed.o \</span><br><span class="line">        usb_ohci.o</span><br></pre></td></tr></table></figure>
修改后：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">COBJS = i2c.o interrupts.o serial.o speed.o \</span><br><span class="line">        usb_ohci.o  nand_flash.o</span><br></pre></td></tr></table></figure>
现在，可以使用新编译的U-Boot.bin烧写内核映像到NAND Flash中去了。</li>
</ol>
<h3 id="支持烧写yaffs文件系统映像"><a href="#支持烧写yaffs文件系统映像" class="headerlink" title="支持烧写yaffs文件系统映像"></a>支持烧写yaffs文件系统映像</h3><p>在实际生产中，可以通过烧片器等手段将内核、文件系统映像烧入固态存储设备中，Bootloader不需要具备烧写功能。但为了方便开发，通常在Bootloader中增加烧写内核、文件系统映像文件的功能。<br>增加了NAND Flash功能的U-Boot 1.1.6已经可以通过“nand write …”、“nand write.jffs2…”等命令来烧写内核，烧写cramfs、jffs2文件系统映像文件。但是在NAND Flash上，yaffs文件系统的性能更佳，下面增加“nand write.yaffs…”命令以烧写yaffs文件系统映像文件。<br>“nand write.yaffs…”字样的命令中，“nand”是具体命令，“write.yaffs…”是参数。nand命令在<code>common/cmd_nand.c</code>中实现。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(nand,<span class="number">5</span>,<span class="number">1</span>,do_nand,</span><br><span class="line">          <span class="string">&quot;nand - NAND sub-system\n&quot;</span>,</span><br><span class="line">          <span class="string">&quot;info                 -show available NAND devices\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand device [dev]    -show or set current device\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand read[.jffs2]    -addr off|partition size \n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand write[.jffs2]   -addr off|partition size - read/write &#x27;size&#x27; bytes starting\n&quot;</span></span><br><span class="line">          <span class="string">&quot;at offset &#x27;off&#x27; to/from memory address &#x27;addr&#x27;\n&quot;</span></span><br><span class="line">          ...</span><br><span class="line">          )</span><br></pre></td></tr></table></figure>
<p>先在其中增加“nand write.yaffs…”的使用说明，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">U_BOOT_CMD(nand,<span class="number">5</span>,<span class="number">1</span>,do_nand,</span><br><span class="line">          <span class="string">&quot;nand - NAND sub-system\n&quot;</span>,</span><br><span class="line">          <span class="string">&quot;info                 -show available NAND devices\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand device [dev]    -show or set current device\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand read[.jffs2]    -addr off|partition size \n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand write[.jffs2]   -addr off|partition size - read/write &#x27;size&#x27; bytes starting\n&quot;</span></span><br><span class="line">          <span class="string">&quot;at offset &#x27;off&#x27; to/from memory address &#x27;addr&#x27;\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand read.yaffs addr off size - read the &#x27;size&#x27; byte yaffs image starting\n&quot;</span></span><br><span class="line">          <span class="string">&quot;at offset &#x27;off&#x27; to memory address &#x27;addr&#x27;\n&quot;</span></span><br><span class="line">          <span class="string">&quot;nand write.yaffs addr off size - write the &#x27;size&#x27; byte yaffs image starting\n&quot;</span></span><br><span class="line">          <span class="string">&quot;at offset &#x27;off&#x27; from memory address &#x27;addr&#x27;\n&quot;</span></span><br><span class="line">          ...</span><br><span class="line">          )</span><br></pre></td></tr></table></figure>
<p>然后，在nand命令的处理函数<code>do_nand</code>中增加对“write.yaffs…”的支持。<code>do_nand</code>函数仍在<code>common/cmd_nand.c</code>中实现，代码修改如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s != <span class="literal">NULL</span> &amp;&amp; !<span class="built_in">strcmp</span>(s,<span class="string">&quot;.yaffs&quot;</span>))&#123;</span><br><span class="line">  <span class="keyword">if</span>(read)&#123;</span><br><span class="line">    <span class="comment">/*read*/</span></span><br><span class="line">    <span class="type">nand_read_options_t</span> opts;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;opts,<span class="number">0</span>,<span class="keyword">sizeof</span>(opts));</span><br><span class="line">    opts.buffer = (u_char *)addr;</span><br><span class="line">    opts.length = size;</span><br><span class="line">    opts.offset = off;</span><br><span class="line">    opts.readoob = <span class="number">1</span>;</span><br><span class="line">    opts.quiet = quiet;</span><br><span class="line">    ret = nand_read_opts(nand,&amp;opts);</span><br><span class="line">  &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">    <span class="comment">/*write*/</span></span><br><span class="line">    <span class="type">nand_write_options_t</span> opts;</span><br><span class="line">    <span class="built_in">memset</span>(&amp;opts,<span class="number">0</span>,<span class="keyword">sizeof</span>(opts));</span><br><span class="line">    opts.buffer = (u_char *)addr; <span class="comment">//yaffs 文件系统映像存放的地址</span></span><br><span class="line">    opts.length = size;           <span class="comment">//长度</span></span><br><span class="line">    opts.offset = off;            <span class="comment">//要烧写到的NAND Flash的偏移地址</span></span><br><span class="line">    <span class="comment">/* opts.foreceyaffs = 1 */</span>    <span class="comment">//计算ECC码的方法，没有使用</span></span><br><span class="line">    opts.noecc = <span class="number">1</span>;               <span class="comment">//不需要计算ECC，yaffs映像中有OOB数据</span></span><br><span class="line">    opts.writeoob = <span class="number">1</span>;            <span class="comment">//写OOB区</span></span><br><span class="line">    opts.blockalign = <span class="number">1</span>;          <span class="comment">//每个“逻辑块”大小为1个“物理块”</span></span><br><span class="line">    opts.quiet = quiet;           <span class="comment">//是否打印提示信息</span></span><br><span class="line">    opts.skipfirstblk = <span class="number">1</span>;        <span class="comment">//跳过第一个可用块</span></span><br><span class="line">    ret = nand_write_opts(nand,&amp;opts);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>下面开始分析这段代码，即“nand write.yaffs…”命令的实现。<br>NAND Flash 每一页大小为（512 + 16）字节（还有其他格式的NAND Flash，比如每页大小为（256 + 8）、（2048 + 64）等），其中的512字节就是一般存储数据的区域，16字节称为OOB（Out Of Band）区。通常在OOB区存放坏块标记、前面512字节的ECC校验码等。<br>cramfs、jffs2文件系统映像文件中没有OOB区的内容，如果将它们烧入NOR Flash中，则是简单的“平铺”关系；如果将它们烧入NAND Flash中，则NAND Flash的驱动程序首先根据OOB的标记略过坏块，然后将一页数据（512字节）写入后，还会计算这512字节的ECC校验码，最会将它写入OOB区，如此循环。cramfs、jffs2文件系统映像文件的大小通常是512的整数倍。<br>而yaffs文件系统映像文件的格式则跟它们不同，文件本身就包含了OOB区的数据（里面有坏块标记、ECC校验码、其他yaffs相关的信息）。所以烧写时，不需要再计算ECC值，首先检查是否坏块（是则跳过），然后写入512字节的数据，最后写入16字节的OOB数据，如此循环。yaffs文件系统映像文件的大小是（512 + 16）的整数倍。<br>第16-18行设置源地址、目的地址、长度。烧写yaffs文件系统映像之前，一般通过网络将它下载到内存的某个地址处，比如0x30000000，然后通过类似“nand write.yaffs 0x30000000 0x00A00000 $(filesize)”的命令烧到NAND Flash的偏移地址0x00A00000处。对于这个命令，第16行中的“opts.buffer &#x3D; 0x30000000”，第17行中的“opts.length &#x3D; $(filesize)”，就是前面下载文件的大小，第18行中的“opts.offset &#x3D; 0x00A00000”。<br>这里列出不使用的第19行，是因为“opts.forceyaffs”这个名字，很有欺骗性，它其实是指计算ECC校验码的一种方法。烧写yaffsw文件系统映像时，不需要计算ECC校验码。<br>第20-21行指定烧写数据时不计算ECC校验码，而是烧入文件中的OOB数据。<br>第22行指定“逻辑块”的大小，“逻辑块”可以由多个“物理块”组成，在yaffs文件系统映像中，它们是1：1的关系。<br>第24行的“opts.skipfirstblk”是新加的项，<code>nand_write_options_t</code>结构中没有<code>skipfirstblk</code>成员。它表示烧写时跳过第一个可以的逻辑块，这是由yaffs系统的特性决定的。<br>既然<code>skipfirstblk</code>是在<code>nand_write_options_t</code>结构中新加的项，那么就要重新定义<code>nand_write_options_t</code>结构，并在下面调用的<code>nand_write_opts</code>函数中对它进行处理。<br>首先在<code>include/nand.h</code>中进行如下修改，增加<code>skipfirstblk</code>成员。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">nand_write_options</span> &#123;</span></span><br><span class="line">       u_char *buffer;              <span class="comment">//memory block containing image to write</span></span><br><span class="line">       ulong length;                <span class="comment">//number of bytes to write</span></span><br><span class="line">       ulong offset;                <span class="comment">//start address in NAND</span></span><br><span class="line">       <span class="type">int</span> quiet;                   <span class="comment">//dont display progress message</span></span><br><span class="line">       <span class="type">int</span> autopalce;               <span class="comment">//if true use auto oob layout</span></span><br><span class="line">       <span class="type">int</span> forcejffs2;              <span class="comment">//force jffs2 oob layout</span></span><br><span class="line">       <span class="type">int</span> forceyaffs;              <span class="comment">//force yaffs oob layout</span></span><br><span class="line">       <span class="type">int</span> noecc;                   <span class="comment">//write without ecc</span></span><br><span class="line">       <span class="type">int</span> writeoob;                <span class="comment">//image contain oob data</span></span><br><span class="line">       <span class="type">int</span> pad;                     <span class="comment">//pad to page size</span></span><br><span class="line">       <span class="type">int</span> blockalign;              <span class="comment">//1 | 2 | 4 set multiple of eraseblocks to align to </span></span><br><span class="line">       <span class="type">int</span> skipfirstblk;            <span class="comment">//新加，烧写时跳过第一个可用的逻辑块</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_write_options</span> <span class="title">nand_write_options_t</span>;</span></span><br></pre></td></tr></table></figure>
<p>然后，修改<code>nand_write_opts</code>函数，增加对skipfirstblk成员的支持。它在<code>drivers/nand/nand_utils.c</code>文件中。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">nand_write_opts</span><span class="params">(<span class="type">nand_info_t</span> *meminfo,<span class="type">const</span> <span class="type">nand_write_options_t</span> *opts)</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="type">int</span> result;</span><br><span class="line">  <span class="type">int</span> skipfirstblk = opts-&gt;skipfirstblk;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span>(blockstart != (mtdoffset &amp; (~erasesize_blockalign + <span class="number">1</span>)))&#123;</span><br><span class="line">    ... ...</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(baderaseblcok)&#123;</span><br><span class="line">      mtdoffset = blockstart + erasesize_blockalign;</span><br><span class="line">    &#125;</span><br><span class="line">    ... ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>进行上面的移植之后，U-Boot已经支持烧写yaffs文件系统映像了。由于前面设置“opts.noecc &#x3D; 1”不使用ECC校验码，在烧写过程中会出现很多的提示信息。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Writing data without ECC to NAND-FLASH is not recommended</span><br></pre></td></tr></table></figure>
<p>修改前：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> NAND_ECC_NONE:</span><br><span class="line">printk(KERNEL_WARING<span class="string">&quot;Writing data without ECC to NAND-FLASH is not recommended\n&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">case</span> NAND_ECC_NONE:</span><br><span class="line"><span class="comment">// printk(KERNEL_WARING&quot;Writing data without ECC to NAND-FLASH is not recommended\n&quot;);</span></span><br></pre></td></tr></table></figure>
<h3 id="修改默认配置参数以方便使用"><a href="#修改默认配置参数以方便使用" class="headerlink" title="修改默认配置参数以方便使用"></a>修改默认配置参数以方便使用</h3><p>前面移植网卡芯片CS8900时，已经设置过默认IP地址等。为了使用U-Boot时减少一些设置，现在修改配置文件<code>include/configs/100ask24x0.h</code>，增加默认配置参数，其中一些在移植过程中已经增加的选项这里也再次说明。</p>
<ol>
<li>Linux启动参数<br>增加如下3个宏：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SETUP_MEMORY_TAGS        1       <span class="comment">//向内核传递内存分布信息</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_CMDLINE_TAG              1       <span class="comment">//向内核传递命令行参数</span></span></span><br><span class="line"><span class="comment">//默认命令行参数</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTTAGS                 <span class="string">&quot;noinited root=/dev/mtdblack 2 init=/linuxrc console=ttySAC0&quot;</span></span></span><br></pre></td></tr></table></figure></li>
<li>自动启动命令<br>增加如下2个宏：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">//自动启动前延时3s</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTDELAY        3</span></span><br><span class="line"><span class="comment">//自动启动的命令</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_BOOTCOMMAND      <span class="string">&quot;nboot 0x32000000 0 0; bootm 0x32000000&quot;</span></span></span><br></pre></td></tr></table></figure>
自动启动时（开机3s内无输入），首先执行“nboot 0x32000000 0 0”命令将第0个NAND Flash的偏移地址0上的映像文件复制到内存0x32000000中；然后执行“bootm 0x32000000”命令启动内存中的映像。</li>
<li>默认网络设置<br>根据具体网络环境增加、修改下面4个宏<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_ETHADDR  08:00:3e:26:0a:5b</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_NETMASK  255.255.255.0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_IPADDR   192.168.1.17</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CONFIG_SERVERIP 192.168.1.11</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="U-Boot的常用命令"><a href="#U-Boot的常用命令" class="headerlink" title="U-Boot的常用命令"></a>U-Boot的常用命令</h2><h3 id="U-Boot的常用命令的用法"><a href="#U-Boot的常用命令的用法" class="headerlink" title="U-Boot的常用命令的用法"></a>U-Boot的常用命令的用法</h3><p>进入U-Boot的控制界面之后，可以运行各种命令，比如下载文件到内存，擦除、读写Flash，运行内存、NOR Flash、NAND Flash中的程序，查看、修改、比较内存中的数据等。<br>使用各种命令时，可以使用其开头的若干字母代替它。比如tftpboot命令，可以使用t、tf、tft、tftp等代替，只要其他命令不以这些字母开头即可。<br>当运行一个命令之后，如果它是可重复执行的（代码中使用U_BOOT_CMD定义这个命令时，第3个参数是1），若想再次运行可以直接输入回车。<br>U-Boot接受的数据都是十六进制，输入时可以省略前缀0x、0X。<br>下面介绍常用的命令：</p>
<ol>
<li><p>帮助命令help<br>运行help命令可以看到U-Boot中所有命令的作用，如果要查看某个命令的使用方法，运行“help 命令名”，比如“help bootm”。<br>可以使用“?”来代替help，比如直接输入“?”、“?bootm”。</p>
</li>
<li><p>下载命令<br>U-Boot支持串口下载、网络下载，相关命令有：loadb、loads、loadx、loady和tftpboot、nfs。<br>前几个串口下载命令使用方法相似，以loadx命令为例，它的用法为“loadx [off] [baud]”。“[]”表示里面的参数可以省略，off表示文件下载后存放的内存地址，baud表示使用的波特率。如果baud参数省略，则使用当前的波特率；如果off参数省略，存放的地址为配置文件中定义的宏CFG_LOAD_ADDR。<br>tftpboot命令使用TFTP协议从服务器下载文件，服务器的IP地址为环境变量serverip。用法为“tftpboot [loadAddress] [bootfilename]”，loadAddress表示文件下载后存放的内存地址，bootfilename表示要下载的文件的名称。如果loadAddress省略，存放的地址为配置文件中定义的宏CFG_LOAD_ADDR；如果bootfilename省略，则使用开发板的IP地址构造一个文件名，比如开发板IP为192.168.1.17，则默认的文件名为C0A80711.img。<br>nfs命令使用NFS协议下载文件，用法为“nfs [loadAddress] [host ip addr:bootfilename]”。“loadAddress、bootfilename”的意义与tftpboot命令一样，“host ip addr”表示服务器的IP地址，默认为环境变量serverip。<br>下载文件成功后，U-Boot会自动创建或更新环境变量filesize，它表示下载的文件的长度，可以在后续命令中使用”$(filesize)“来引用它。</p>
</li>
<li><p>内存操作命令<br>常用的命令有：查看内存命令md、修改内存命令mm、填充内存命令mw、复制命令cp。这些命令都可以带上后缀“.b”、“.w”或“.l”，表示以字节、字（2个字节）、双字（4个字节）为单位进行操作。比如“cp.l 30000000 31000000 2”将从开始地址0x3000000处，复制2个双字到开始地址为0x31000000的地方。<br>md命令用法为“md[.b,.w,.l] address [count]”，表示以字节、字或双字（默认为双字）为单位，显示地址address开始的内存数据，显示的数据个数为count。<br>mm命令用法为“mm[.b,.w,.l] address ”，表示以字节、字或双字（默认为双字）为单位，从地址address处开始修改内存数据。执行命令mm后，输入新数据后回车，地址会自动增加，按“Ctrl + C”键退出。<br>mw命令用法为“mw[.b,.w,.l] address value [count]”，表示以字节、字或双字（默认为双字）为单位，往开始地址为address的内存中填充count个数据，数据值为value。<br>cp命令用法为“cp[.b,.w,.l] source target count”，表示以字节、字或双字（默认为双字）为单位，往源地址source的内存复制count个数据到目的地址的内存。</p>
</li>
<li><p>NOR Flash操作命令<br>常用的命令有查看Flash信息的info命令、加&#x2F;解写保护命令protect、擦除命令erase。由于NOR Flash的接口与一般内存相似，所以一些内存命令可以在NOR Flash上使用，比如读NOR Flash时可以使用md、cp命令，写NOR Flash时可以使用cp命令（cp根据地址分辨出是NOR Flash，从而调用NOR Flash驱动完成写操作）。<br>直接运行“flinfo”即可看到NOR Flash的信息，有NOR Flash的型号、容量、各扇区的开始地址、是否只读等信息。比如对于本书基于的开发板，flinfo命令的结果如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">Bank # <span class="number">1</span>: AMD: <span class="number">1</span>x <span class="title function_">Amd29LV800BB</span><span class="params">(<span class="number">8</span>Mbit)</span></span><br><span class="line">Size: 1 MB in 19 Sectors</span><br><span class="line">Sector Start Address:</span><br><span class="line">00000000 <span class="params">(RO)</span> 00004000 <span class="params">(RO)</span> 00006000 <span class="params">(RO)</span> 00008000 <span class="params">(RO)</span> 00010000 <span class="params">(RO)</span></span><br><span class="line">00020000 <span class="params">(RO)</span> 00030000      00040000      00050000      00060000</span><br><span class="line">00070000      00080000      00090000      000A0000      000B0000</span><br><span class="line">000C0000      000D0000      000E0000      000<span class="title function_">F0000</span> <span class="params">(RO)</span></span><br></pre></td></tr></table></figure>
<p>其中的RO表示该扇区处于写保护状态，只读。<br>对于只读的扇区，在擦除、烧写它之前，要先接触写保护。最简单的命令为“protect off all”，解除所有的NOR Flash的写保护。<br>erase命令常用的格式为“erase start end”，擦除的地址范围为start<del>end；“erase start + len”，擦除的地址范围为start</del>（start + len - 1）；“erase all”，表示擦除所有NOR Flash。</p>
</li>
<li><p>NAND Flash操作命令<br>NAND Flash操作命令只有一个：nand，它根据不同的参数进行不同操作，比如擦除、读取、烧写等。<br>“nand info”查看NAND Flash信息。<br>“nand erase [clean] [off size]”擦除NAND Flash。加上“clean”时，表示在每个块的第一个扇区的OOB区写入清除标记；off、size表示要擦除的开始偏移地址的长度，如果省略off和size，表示要擦除整个NAND Flash。<br>“nand read [.jffs2] addr off size”从NAND Flash偏移地址off处读出size个字节的数据存放到开始地址为addr的内存中。是否加后缀“.jffs”的差别只是读操作时的ECC校验方法不同。<br>“nand write [.jffs2] addr off size”把开始地址为addr的内存中的size个字节数据写到NAND Flash的偏移地址off处。是否加后缀“.jffs”的差别只是写操作时的ECC校验方法不同。<br>“nand read.yaffs addr off size”从NAND Flash偏移地址off处读出size个字节的数据（包括OOB区域），存放到开始地址为addr的内存中。<br>“nand write.yaffs addr off size”把开始地址为addr的内存中的size个字节数据（其中有要写入OOB区域的数据）写到NAND Flash的偏移地址off处。<br>“nand dump off”将NAND Flash偏移地址off的一个扇区的数据打印出来，包括OOB数据。</p>
</li>
<li><p>环境变量命令<br>“printenv”命令打印全部环境变量，“printenv name1 name2……”打印名字为name1、name2、…的环境变量。<br>“setenv name value”设置名字为name的环境变量的值为value。<br>“setenv name”删除名字为name的环境变量。<br>上面的设置、删除操作只是在内存中进行，“saveenv”将更改后的所有环境变量写入NOR Flash中。</p>
</li>
<li><p>启动命令<br>不带参数的“boot”、“bootm”命令都是执行环境变量bootcmd所指定的命令。<br>“bootm [addr [arg…]]”命令启动存放在地址addr处的U-Boot格式的映像文件（使用U-Boot目录tools下的mkimage制作工具得到），[arg…]表示参数。如果addr参数省略，映像文件所在地址为配置文件中定义的宏CFG_LOAD_ADDR。<br>“go addr [arg…]”与bootm命令类似，启动存放在地址addr处的二进制文件，[arg…]表示参数。<br>“nboot [[[loadAddr]dev]offset]”命令将NAND Flash设备dev上偏移地址off处的映像文件复制到内存loadAddr处，然后，如果环境变量autostart的值为“yes”，就启动这个映像。如果loadAddr参数省略，存放地址为配置文件中定义的宏CFG_LOAD_ADDR；如果dev参数省略，则它的取值为环境变量bootdevice的值；如果offset参数省略，则默认为0。</p>
</li>
</ol>
<h3 id="U-Boot命令使用实例"><a href="#U-Boot命令使用实例" class="headerlink" title="U-Boot命令使用实例"></a>U-Boot命令使用实例</h3><p>下面通过一个例子来演示如何使用各种命令烧写内核映像文件，yaffs映像文件，并启动系统。</p>
<ol>
<li><p>制作内核映像文件<br>对于本书使用的Linux2.6.22.6版本，编译内核时可以直接生成U-Boot格式的映像文件uImage。<br>对于不能直接生成uImage的内核，制作方法在U-Boot根目录下的README文件中有说明，假设已经编译好的内核文件为vmlimux，它是ELF格式的。mkimage是U-Boot命令tools下的工具，它在编译U-Boot是自动生成。执行以下3个命令将内核文件vmlinux制作为U-Boot格式的映像文件uImage，它们首先将vmlinux转换为二进制格式，然后压缩，最后构造头部信息（里面包含文件名称、大小、类型、CRC校验码等），如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">arm-linux-objcopy -O binary -R .note -R .comment -S vmlinux linux.bin</span><br><span class="line">gzip <span class="number">-9</span> linux.bin</span><br><span class="line">mkimage -A arm -O linux -T kernel -C gzip -a <span class="number">0x30008000</span> -e <span class="number">0x30008000</span> -n <span class="string">&quot;Linux Kernel Image&quot;</span> -d linux.bin.gz uImage</span><br></pre></td></tr></table></figure></li>
<li><p>烧写内核映像文件uImage<br>首先将uImage放在主机上的tftp或nfs目录下，确保已经开启tftp或nfs服务。<br>然后运行如下命令下载文件，擦除、烧写NAND Flash，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x30000000</span> uImage 或nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/uImage</span><br><span class="line">nand erase <span class="number">0x0</span> <span class="number">0x00200000</span></span><br><span class="line">nand write.jffs2 <span class="number">0x30000000</span> <span class="number">0x0</span> $(filesize)</span><br></pre></td></tr></table></figure>
<p>第3条命令之所以使用“nand write.jffs2”而不是“nand write”，是因为前者不要求文件的长度是页对齐的（512字节对齐）。也可以使用“nand write”，但是需要将命令中的长度参数改为$(filesize)向上进行512取整（513向上取整得1024）。比如uImage的大小为1540883，向上进行取整为1541120（0x178400），可以使用命令“nand write 0x30000000 0x0 0x178400”进行烧写。</p>
</li>
<li><p>烧写yaffs文件系统映像<br>假设yaffs文件系统映像的文件名为yaffs.img，首先将它放在主机上的tftp或nfs目录下，确保已经开启或nfs服务；然后执行如下命令下载、擦除、烧写，如下所示：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x30000000</span> yaffs.img 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/yaffs.img</span><br><span class="line">nand erase <span class="number">0xA00000</span> <span class="number">0x3600000</span></span><br><span class="line">nand write.yaffs <span class="number">0x30000000</span> <span class="number">0xA00000</span> $(filesize)</span><br></pre></td></tr></table></figure>
<p>这时，重启系统，在U-Boot倒数3s之后，就会自动启动Linux系统。</p>
</li>
<li><p>烧写jffs2文件系统映像<br>假设jffs2文件系统映像的文件名为jffs2.img，首先将它放在主机上的tftp或nfs目录下，确保已经开启tftp或nfs服务；然后执行如下命令下载、擦除、烧写，如下所示。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x30000000</span> jffs2.img 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>/work/nfs_root/jffs2.img</span><br><span class="line">nand erase <span class="number">0x200000</span> <span class="number">0x800000</span></span><br><span class="line">nand write.jffs2 <span class="number">0x30000000</span> <span class="number">0x200000</span> $(filesize)</span><br></pre></td></tr></table></figure>
<p>系统启动后，就可以使用“mount -t jffs2 &#x2F;dev&#x2F;mtdblock1 &#x2F;mnt”挂载jffs2文件系统。</p>
</li>
</ol>
<h2 id="使用U-Boot来执行程序"><a href="#使用U-Boot来执行程序" class="headerlink" title="使用U-Boot来执行程序"></a>使用U-Boot来执行程序</h2><p>之前章节的实例使用JTAG烧写程序到NAND Flash，烧写过程十分缓慢。如果使用U-Boot来烧写NAND Flash，效率会高很多。烧写二进制文件到NAND Flash中所使用的命令与上面烧写内核映像文件uImage的过程类似，只是不需要将二进制文件制作成U-Boot格式。<br>另外，可以将程序下载到内存中，然后使用go命令执行它。假设有一个程序的二进制可执行文件test.bin，连接地址为0x30000000。首先将它放在主机上的tftp和nfs目录下，确保已经开启tftp或nfs服务；然后将它下载到内存0x30000000处，最后使用go命令执行它。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">tftp <span class="number">0x3000000</span> test.bin 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/test.bin</span><br><span class="line">go <span class="number">0x30000000</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第3篇第15章 移植U-Boot</category>
      </categories>
      <tags>
        <tag>嵌入式Linux</tag>
        <tag>U-Boot移植</tag>
      </tags>
  </entry>
</search>
