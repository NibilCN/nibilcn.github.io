<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>第一篇博客</title>
    <url>/2022/07/30/%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    <content><![CDATA[<p>这里是Nibil建立博客后的第一篇文章。</p>
<span id="more"></span>
<p>历时两个工作日，我采用了<a href="https://hexo.io/">Hexo博客框架</a>和Github Pages网页部署工具。在广大网友的帮助下，踩过一些坑，终于成功搭建并部署Nibil的博客。博客采用了<a href="https://github.com/next-theme/hexo-theme-next">Next</a>主题模板,在仿照<a href="https://carlyleliu.github.io/">CarlyleLiu</a>的博客模板的基础上，附带了我本人的一些个性化设置。于是，Nibil的私人博客诞生了，希望不要马上去世~~~<br>我建立博客的初衷是为了督促自己能抽出时间来学习，复习自己从事的嵌入式行业的专业知识，并分享在博客上，以此来达到温故而知新的目的，从而提高自己的行业竞争力。我暂时将博客大纲定性为四块，工作，学习，生活，杂项。工作包含自己在公司做项目过程中遇到的问题以及解决的问题，避免自己重复踩坑。学习包含自己主动去提升尚未掌握但是以后工作中会用到的领域的知识，避免一问三不知。生活属于是自己日常生活中的一些分享，毕竟这是一个博客。杂项就是我个人的一些感想，领悟啥的，属于是发牢骚。<br>暂时就写这么多，希望我的这第一篇文章不会成为我的最后一篇文章！</p>
]]></content>
      <categories>
        <category>杂</category>
        <category>感想</category>
      </categories>
      <tags>
        <tag>感想</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式Linux开发概述</title>
    <url>/2022/08/04/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BC%80%E5%8F%91%E6%A6%82%E8%BF%B0/</url>
    <content><![CDATA[<p>《嵌入式Linux应用完全开发手册》第1篇第1章总结归纳</p>
<span id="more"></span>
<h1 id="嵌入式系统介绍"><a href="#嵌入式系统介绍" class="headerlink" title="嵌入式系统介绍"></a>嵌入式系统介绍</h1><h2 id="嵌入式系统的定义和特点"><a href="#嵌入式系统的定义和特点" class="headerlink" title="嵌入式系统的定义和特点"></a>嵌入式系统的定义和特点</h2><h3 id="嵌入式系统的定义"><a href="#嵌入式系统的定义" class="headerlink" title="嵌入式系统的定义"></a>嵌入式系统的定义</h3><p>嵌入式系统的定义为：以应用为中心，以计算机技术为基础、软硬件可裁剪、适用于应用系统，对功能、可靠性、成本、体积、功耗严格要求的专用计算机系统。它的主要特点是嵌入，专用。<br>含有嵌入式系统的设备成为嵌入式设备，这在生活中随处可见：电子表、手机、MP3播放器、遥控器等。涵盖了生产、工业控制、通信、网络、消费电子、汽车电子、军工等领域。从通俗，广义的角度来说，除电脑，超级计算机等具备比较强大计算能力及系统资源（比如内存，存储器等）的电子系统之外，凡具备计算能力的设备都可称为嵌入式设备。</p>
<h3 id="嵌入式设备的特点"><a href="#嵌入式设备的特点" class="headerlink" title="嵌入式设备的特点"></a>嵌入式设备的特点</h3><ol>
<li>软硬件可裁剪</li>
<li>对功能、可靠性、成本、体积、功耗严格要求</li>
</ol>
<h2 id="嵌入式技术的发展史"><a href="#嵌入式技术的发展史" class="headerlink" title="嵌入式技术的发展史"></a>嵌入式技术的发展史</h2><p>通用计算机和嵌入式计算机是两条不同的道路。通用计算机系统的技术要求是高速海量的数值计算；技术发展方向是总线速度的无限提升，存储容量的无限扩大。而嵌入式计算机系统的技术要求是对象的智能化控制能力；技术发展方向则是与对象系统密切相关的嵌入性能、控制能力与控制的可靠性。<br>嵌入式技术发展日新月异，经历了单片机（SCM）、微控制器（MCU）、系统级芯片（SOC）3个阶段。</p>
<h3 id="SCM（Single-Chip-Microcomputer）"><a href="#SCM（Single-Chip-Microcomputer）" class="headerlink" title="SCM（Single Chip Microcomputer）"></a>SCM（Single Chip Microcomputer）</h3><p>又称单片微型计算机，简称单片机，随着大规模集成电路的出现以及发展，计算机的CPU、RAM、ROM、定时计数器和多种I&#x2F;O接口集成在一片芯片上，形成芯片级计算机。<br>这个阶段主要寻求单片形态嵌入式系统的最佳体系结构。</p>
<h3 id="MCU（Micro-Controller-Unit）"><a href="#MCU（Micro-Controller-Unit）" class="headerlink" title="MCU（Micro Controller Unit）"></a>MCU（Micro Controller Unit）</h3><p>MCU即微型控制器的特征是：满足各类嵌入式应用，根据对象系统扩展各类外围电路和接口电路，突显其对象的智能化控制能力。它所涉及的领域都与对象系统有关。<br>实际上，SCM和MCU在日常工作中并不严格区分，很多时候一概以单片机称呼。随着能够运行更复杂软件（操作系统）的SOC的出现，单片机通常是指不允许操作系统，功能相对单一的嵌入式系统。但这也不是绝对的，比如8051上就可以运行RTX51实时操作系统，它的大小只有6KB，相比于嵌入式Linux，Windows CE等操作系统而言比较简单。</p>
<h3 id="SoC（System-on-a-Chip）"><a href="#SoC（System-on-a-Chip）" class="headerlink" title="SoC（System on a Chip）"></a>SoC（System on a Chip）</h3><p>随着设计与制造技术的发展，集成电路设计从晶体管的集成发展到逻辑门的集成，现在又发展到IP的集成，即SOC设计技术。Soc可以有效降低电子&#x2F;信息系统产品的开发成本，缩短开发周期，提高产品的竞争力，是未来工业界将采用的最主要的产品开发方式。<br>Soc的特征：</p>
<ol>
<li>实现复杂系统功能的VLSI；</li>
<li>采用超深亚微米工艺技术；</li>
<li>使用一个以上嵌入式CPU&#x2F;数字信号处理器DSP；</li>
<li>外部可以对芯片进行编程；</li>
<li>主要采用第三方IP进行设计。<br>从上述SoC特征来看，SoC中包含了微处理器、微控制器、存储器以及其他专用功能逻辑，但是并不包含微处理器、微控制器、存储器以及其他专用功能的芯片就是SoC。8051就集成了微处理器、存储器等部件，它不属于SoC。SoC的主要价值在于—缩短了产品的上市周期。<br>因此SoC更合理的定义：SoC是在一个芯片上由于广泛使用预定制模块IP（Intellectual Property）而得以快速开发的集成电路。<br>本书介绍的S3C2410&#x2F;S3C2440就属于SoC，它们集成了处理器、MMU、NAND Flash控制器等部件，而处理器的IP是基于ARM公司的。<br>以前写的单片机软件，通常是在main函数当中定义一个无限循环，然后在里面查询各类输入事件，并做相应处理，它直接操作硬件；而基于SoC的软件多是在操作系统上面运行，通过驱动程序操作硬件。</li>
</ol>
<h1 id="基于ARM处理器的嵌入式Linux系统"><a href="#基于ARM处理器的嵌入式Linux系统" class="headerlink" title="基于ARM处理器的嵌入式Linux系统"></a>基于ARM处理器的嵌入式Linux系统</h1><h2 id="ARM处理器介绍"><a href="#ARM处理器介绍" class="headerlink" title="ARM处理器介绍"></a>ARM处理器介绍</h2><h3 id="ARM处理器的概念"><a href="#ARM处理器的概念" class="headerlink" title="ARM处理器的概念"></a>ARM处理器的概念</h3><p>嵌入式处理器的种类繁多，又ARM、MIPS、PPC等多种架构。ARM的文档丰富，各类嵌入式软件大多选择ARM。在掌握ARM架构之后，上手其他处理器架构也会很快。<br>ARM(Advanced RISC Machine),既是一家公司的名字，也可以是一类处理器的统称，还可以认为是一种技术的名字。<br>ARM公司并不生产芯片，而是出售芯片授权。基于ARM的处理器以其高速度、低功耗、价格低等优点得到非常广泛的应用，它可以应用于以下领域：</p>
<ol>
<li>为无线通信、消费电子、成像设备等产品提供可运行复杂操作系统的开放应用平台；</li>
<li>在海量存储、汽车电子、工业控制和网络应用等领域提供实时嵌入式应用；</li>
<li>安全系统，比如SIM卡、信用卡等。</li>
</ol>
<h3 id="ARM体系架构的版本"><a href="#ARM体系架构的版本" class="headerlink" title="ARM体系架构的版本"></a>ARM体系架构的版本</h3><p>ARM体系架构的版本就是它所使用的指令集的版本。ARM公司支持32位的ARM指令集和16位的Thumb指令集，后者使得代码的存储空间大大减小。<br>还在使用的ARM指令集（ISA，Instruction Set Architecture）有以下版本：</p>
<ol>
<li>ARMv4<br>这是当前市场上最老的版本，ARMv4只支持32位的指令集，支持32位的地址空间。一些ARM7系列的处理器和Intel公司的StrongARM处理器采用ARMv4指令集。</li>
<li>ARMv4T<br>增加了16位的Thumb指令集，它可以产生更紧凑的代码，与相同功能的ARM代码相比，可以节省超过35%的存储空间，同时具备32位代码的所有优点。</li>
<li>ARMv5TE<br>1999年，ARMv5TE版本改进了Thumb指令集，增加了一些“增强型DSP指令”，简称E指令集。<br>这些指令用于增强处理器对于一些典型的DSP算法的处理性能，是的音频DSP应用可以提升70%的性能。许多系统在使用微控制器来进行各类控制的时候，还要具备数据处理能力，传统的做法要么是使用更高级的处理器，这会使得成本增加，要么是使用多个处理器，这会使得系统复杂度增高。通过E指令集可以在一个普通CPU中增加DSP的功能，这在成本、性能、简化设计等方面都有优势。</li>
<li>ARMv5TEJ<br>增加Jazelle技术用于提供Java加速功能。</li>
<li>ARMv6<br>2001年，ARMv6问世。它在很多方面都有改进：存储系统、异常处理，最重要的是增加了对多媒体功能的支持。ARMv6包含了一些媒体指令以支持SIMD媒体功能扩展。SIMD媒体功能扩展为音视频的处理提供了优化功能，可以使得音视频的处理性能提高4倍。<br>ARMv6中还引入了Thumb-2和TrustZone技术，这是两个可选的技术。之前的版本中，ARM指令和Thumb分别运行于不同的处理器状态下，执行不同的指令集的指令前需要进行切换。Thumb-2技术增加了混合模式的功能，定义了新的32位指令集，可以运行32位指令和16位指令的混合代码。这能够提供”ARM指令级别的性能“和”Thumb指令级别的代码密度“。TrustZone技术在硬件上提供了两个隔离的地址空间：安全域和非安全域，给系统提供了一个安全机制。</li>
<li>ARMv7<br>ARMv7架构使用Thumb-2技术，还使用了NEON技术，将DSP和媒体处理能力提高了近4倍，并支持改良的浮点运算，满足下一代3D图形、游戏物理应用以及传统嵌入式控制应用的需求。</li>
</ol>
<h3 id="ARM处理器系列"><a href="#ARM处理器系列" class="headerlink" title="ARM处理器系列"></a>ARM处理器系列</h3><p>在相同的指令集下，搭配不同的部件就可以组装出具有不同功能的处理器，比如有无内存管理单元，有无调试功能等。它们可以分为8个系列，系列名有7个后缀，这些后缀可以组合：<br>T：表示支持Thumb指令集。<br>D：表示支持片上调试（Debug）。<br>M：表示内嵌乘法器（Multiplier）。<br>I：支持片上断点和调试点。<br>E：表示支持增强型DSP功能。<br>J：表示支持Jazelle技术，即Java加速器。<br>S：表示全合成式（full synthesizable）。</p>
<ol>
<li>ARM7<br>ARM7系列处理器是低功耗32位RISC微处理器，它主要用于对成本、功耗特别敏感的产品。最高可达到130MIPS（Million Instructions Percent Second），支持Thumb16位指令集和ARM32位指令集。ARM7系列微处理器包括如下几种类型的核：ARM7TDMI、ARM7TDMI-S、ARM720T、ARM7EJ-S。其中。ARM7TMDI是目前使用最广泛的32位嵌入式RISC处理器，属于低端ARM处理器核。ARM7不带MMU。</li>
<li>ARM9<br>与ARM7相比，ARM9最大的差别在于：有MMU和Cach。它的指令执行效率较ARM7有较大提高，最高可达300MIPS。ARM9系列微处理器有ARM920T和ARM922T两种类型。</li>
<li>ARM9E<br>ARM9E系列微处理器在单一的处理器内核上提供了微控制器、DSP、Java应用系统的解决方案，极大的减少了芯片的面积和系统的复杂度。ARM9E系列微处理器提供了增强的DSP处理能力，适合于那些需要同时使用DSP和微控制器的应用场合。<br>ARM9E系列微处理器有ARM926EJ-S、ARM946E-S、ARM966E-S、ARM968E-S和ARM996HS共五种类型。</li>
<li>ARM10E<br>ARM10E微处理器具有更加杰出的高性能、低功耗特点，由于使用了新的体系结构，它拥有ARM系列中最高的主频。ARM10E系列微处理器采用了一种新的省电模式，支持”64 bit load-store micro-architecture“，含浮点运算协处理器。<br>ARM10E系列微处理器有ARM1020E、ARM1022E和ARM1026EJ-S三种类型。</li>
<li>ARM11<br>ARM11系列微处理器是ARM公司近年来推出的新一代RISC处理器，它是ARM新指令架构—ARMv6的第一代设计实现。ARM11的媒体处理能力和低功耗特点特别适用于无线和消费类电子产品，其高数据吞吐量和高性能的结合非常适合网络处理应用。另外在实时性能和浮点处理等方面ARM11可以满足汽车电子的应用需求。<br>ARM11系列微处理器有这4种类型：ARM11 MPCore、ARM1136J(F)-S、ARM1156T2(F)-S和ARM1176JZ(F)-S。</li>
<li>Cortex<br>Cortex基于ARMv7架构，分为Cortex-A、Cortex-R、Cortex-M三类。Cortex-A为传统的、基于虚拟内存的操作系统和应用程序而设计，支持ARM、Thumb、和Thumb-2指令集；Cortex-R针对实时系统设计，支持ARM、Thumb、和Thumb-2指令集；Cortex-M为对价格敏感的产品设计，只支持Thumb-2指令集。</li>
<li>SecureCore<br>SecureCore系列微处理器专为安全需要设计，提供了完善的32位RISC技术的安全解决方案，因此，SecureCore系列微处理器除了具有ARM体系结构的低功耗、高性能特点外，还具有其独特的优势，即提供了对安全解决方案的支持。<br>SecureCore系列微处理器有如下类型：SecureCoreSC100、SecureCoreSC200。</li>
<li>OptimoDE Data Engines<br>这是一个新的IP核，针对高性能的嵌入式信号处理应用而设计。<br>另外，Intel公司的StrongARM、Xscale系列处理器也属于ARM架构。Intel StrongARM处理器是便携式通信产品和消费电子产品的理想选择，已成功应用于多家公司的掌上电脑系列产品。Xscale处理器是基于ARMv5TE体系结构的解决方案，是一款全性能、高性价比、低功耗的处理器。它支持16位的Thumb指令和DSP指令集。</li>
</ol>
<h2 id="选择嵌入式Linux的理由"><a href="#选择嵌入式Linux的理由" class="headerlink" title="选择嵌入式Linux的理由"></a>选择嵌入式Linux的理由</h2><p>在嵌入式领域可以选择的操作系统有很多，比如：嵌入式Linux、VxWorks、Windows CE、μC&#x2F;OS-Ⅱ等。<br>VxWorks是美国WindRiver公司开发的嵌入式实时操作系统。但就性能而言，它是非常优秀的操作系统，具有可裁剪的微内核结构、高效的任务管理、灵活的任务间通信、微秒级的中断处理，支持POSIX 1003.1b实时扩展标准，支持多种物理介质及标准、完整的TCP&#x2F;IP网络协议等。缺点是它支持的硬件相对较少，源代码不开放，需要专门的技术人员进行维护，授权费用高。<br>Windows CE是微软公司针对嵌入式设备开发的32位、多任务、多线程的操作系统。它支持x86、ARM、MIPS、SH等架构的CPU，硬件驱动丰富，支持WiFi、USB2.0等新型设备，并且具有强大的多媒体功能；可以灵活裁剪以减少系统体积；与PC上的Windows操作系统相通，开发、调试工具使用方便。应用程序的开发流程与PC上的Windows程序开发流程类似。就开发的便利性而言，Windows CE是最好的。但是，它的源代码没有开放，开发人员难以进行更细致的定制，占用内存较多，整个相同相对庞大，版权许可费也比较高。<br>μC&#x2F;OS-Ⅱ是Micrium公司开发的操作系统，可用于8位、16位、32位处理器。可裁剪，对硬件要求低；可运行最多64个任务；任务调度方式位抢占式调度，总是运行最高优先级的就绪任务。用户可以获取μC&#x2F;OS-Ⅱ的全部代码，但是它不是完全免费的。用于商业目的，需要购买商业授权。μC&#x2F;OS-Ⅱ采用一次性收费的方式，价格低廉。μC&#x2F;OS-Ⅱ仅是一个实时内核，用户需要完成其他更多的工作，比如编写硬件驱动程序，实现文件操作等。<br>Linux是遵循GPL协议的开放源代码的操作系统，使用时无需缴纳许可费。内核可以任意裁剪，几乎支持所有的32位、62位CPU；内核中支持的硬件种类繁多，几乎可以从网络上找到所有的硬件驱动程序；支持几乎所有的网络协议；有大量的应用程序可以使用，从编译工具，调试工具到GUI程序，几乎都遵循GPL协议的相关版本；有庞大的开发人员群体，有数量众多的技术论坛，大多数问题可以得到快速而且免费的解答。<br>Linux的缺点在于实时性，虽然在2.6版本的Linux在实时性上有了较大的改进，但是仍然无法称作实时操作系统。不过正是因为Linux开放源代码、易于移植、资源丰富、免费等优点，使得它在嵌入式领域越来越流行。更重要的一点，由于嵌入式Linux与PC Linux基于同样的内核代码，只是裁剪的程度不一样，这使得很多为PC开发的软件再次编译后，可以直接在嵌入式设备上面运行，这使得软件资源极大丰富，比如各类使用的函数库等。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第1章 嵌入式Linux开发概述</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>何谓硬解码和软解码</title>
    <url>/2022/08/05/%E4%BD%95%E8%B0%93%E7%A1%AC%E8%A7%A3%E7%A0%81%E5%92%8C%E8%BD%AF%E8%A7%A3%E7%A0%81/</url>
    <content><![CDATA[<p>关于“硬解码”与“软解码”。</p>
<span id="more"></span>
<p>软解码和硬解码的区别：</p>
<ol>
<li>软解码使用CPU进行解码。</li>
<li>硬解码使用非CPU进行解码，如GPU、专用的DSP、FPGA、ASIC等芯片。</li>
</ol>
]]></content>
      <categories>
        <category>学习</category>
        <category>何谓硬解码和软解码</category>
      </categories>
      <tags>
        <tag>多媒体编解码</tag>
      </tags>
  </entry>
  <entry>
    <title>GPIO接口</title>
    <url>/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>《嵌入式Linux应用完全开发手册》第1篇第5章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>掌握嵌入式开发的步骤：编程、编译、烧写程序、运行</li>
<li>通过GPIO口的操作了解软件如何控制硬件</li>
</ol>
<h1 id="GPIO硬件介绍"><a href="#GPIO硬件介绍" class="headerlink" title="GPIO硬件介绍"></a>GPIO硬件介绍</h1><p>GPIO（Genaral Purpose I&#x2F;O Ports）意思是通过通用输入&#x2F;输出端口，通俗的说，就是一些引脚，可以通过它们输出高低电平或者通过它们读入引脚的状态—是高电平还是低电平。<br>S3C2410有117个I&#x2F;O端口，共分为A-H 8组，GPA、GPB、……、GPH。S3C2440有130个I&#x2F;O端口，共分为A-H 9组，GPA、GPB、……、GPJ。可以通过设置寄存器来确定某个引脚用于输入、输出还是其他特殊功能。比如可以设置GPH6作为一般的输入、输出引脚，或者用于串口。<br>GPIO的操作是所有硬件操作的基础，由此扩展开来可以了解所有硬件的操作，这是底层开发人员必须掌握的。</p>
<h2 id="通过寄存器来操作GPIO引脚"><a href="#通过寄存器来操作GPIO引脚" class="headerlink" title="通过寄存器来操作GPIO引脚"></a>通过寄存器来操作GPIO引脚</h2><p>既然一个引脚可以用于输入、输出或其他功能，那么一定有寄存器用来选择这些功能；对于输入，一定可以通过读取某个寄存器来确定引脚的电平是高还是低；对于输出，一定可以通过写入某个寄存器来让这个引脚输出高电平还是低电平；对于其他特殊功能，则有另外的寄存器来控制它。<br>对于这几组GPIO引脚，它们的寄存器是相似的；GPxCON用于选择引脚功能。GPxDAT用于读写引脚数据。GPxUP用于确定是否使用内部上拉电阻。</p>
<h3 id="GPxCON寄存器"><a href="#GPxCON寄存器" class="headerlink" title="GPxCON寄存器"></a>GPxCON寄存器</h3><p>从寄存器的名字可以看出，它用于配置（Configure）—选择引脚的功能。<br>PORT A与PORT B-PORT H&#x2F;J在功能选择方面有所不同，GPACON中每一位对应一根引脚（共23根引脚）。当某位被设置为0时，相应引脚为输出引脚，此时我们可以在GPADAT中的相应位写入0或1让此引脚输出高电平或者低电平。当某位被设置为1时，相应的引脚为地址线，或用于地址控制。此时的GPADAT无用。通常而言GPACON全被设置为1，以便访问外部存储器件。<br>PORT B-PORT H&#x2F;J 在寄存器操作方面完全相同。GPxCON中每两位控制一根引脚，00表示输入、01表示输出、10表示特殊功能、11保留。</p>
<h3 id="GPxDAT寄存器"><a href="#GPxDAT寄存器" class="headerlink" title="GPxDAT寄存器"></a>GPxDAT寄存器</h3><p>GPxDAT用于读&#x2F;写引脚；当引脚被设置为输入时，读此寄存器可知相应引脚的电平状态是高还是低；当引脚被设置为输出时，写此寄存器相应位可令此引脚输出高电平或者低电平。</p>
<h3 id="GPxUP"><a href="#GPxUP" class="headerlink" title="GPxUP"></a>GPxUP</h3><p>某位为1时，相应引脚无内部上拉电阻；为0时，相应引脚使用内部上拉电阻。<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/1.jpeg" alt="img not found"><br>上拉、下拉电阻的作用在于，当GPIO引脚处于第三态（既不是输出高电平，也不是输出低电平，而是呈高阻态）时，它的电平状态由上拉、下拉电阻决定。</p>
<h2 id="怎样使用软件来访问硬件"><a href="#怎样使用软件来访问硬件" class="headerlink" title="怎样使用软件来访问硬件"></a>怎样使用软件来访问硬件</h2><h3 id="访问单个引脚"><a href="#访问单个引脚" class="headerlink" title="访问单个引脚"></a>访问单个引脚</h3><p>单个引脚的操作无外乎3种：输出高低电平、检测引脚状态、中断。对某个引脚的操作一般通过读写寄存器来完成。<br>比如对于图5.2所示的电路，可以设置GPBCON寄存器将GPB5、GPB6、GPB7和GPB8设为输出功能，然会写GPBDAT的寄存器使得这四个引脚输出高电平或低电平。输出高电平时，相应的LED灯熄灭，输出低电平时，相应的LED灯点亮。<br>还可以设置GPFCON寄存器将GPF0、GPF2、GPF3和GPF11设为输入功能，然后通过读出GPFDAT&#x2F;GPGDAT寄存器并判断相应位是0还是1来确定各个按键是否被按下。某个按键按下时，相应引脚电平为低，GPFDAT&#x2F;GPGDAT寄存器相应位为0，否则为1。<br>那么怎么访问这些寄存器呢，通过软件，读写它们的地址。比如，GPBCON和GPBDAT寄存器的地址都是0x56000010、0x56000014，可以通过如下的指令让GPB5输出低电平，点亮LED1。<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/2.jpeg" alt="img not found"></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (*(volatile unsigned long *)0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (*(volatile unsigned long *)0x56000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line">GPBCON = GPB5_out;<span class="comment">//GPB5引脚设置为输出</span></span><br><span class="line">GPBDAT &amp;= ~(<span class="number">1</span>&lt;&lt;<span class="number">5</span>);<span class="comment">//GPB5输出低电平</span></span><br></pre></td></tr></table></figure>
<h3 id="以总线方式访问硬件"><a href="#以总线方式访问硬件" class="headerlink" title="以总线方式访问硬件"></a>以总线方式访问硬件</h3><p>并非只能通过寄存器才能发出硬件信号，实际上，通过访问总线的方式控制硬件更常见。以NOR Flash的访问为例：<br><img src="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/3.jpeg" alt="img not found"><br>图中，缓冲器的作用是为了提高驱动力、隔离前后级信号。NOR Flash AM29LV800BB的片选信号使用S3C2410&#x2F;S3C2440的nGCS0信号，当CPU发出的地址信号处于0x00000000-0x07FFFFFF之间时，nGCS0信号有效，于是NOR Flash被选中。这时，CPU发出的地址信号传到NOR Flash；进行写操作时，nWE信号为低，数据信号从CPU发出给NOR Flash；进行读操作时，nWE信号为高，数据信号从NOR Flash发给CPU。上图所示的硬件连线决定了读写操作都是以16位为单位的。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址对齐的16位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x2</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> wVal;</span><br><span class="line">wVal = *pwAddr;</span><br></pre></td></tr></table></figure>
<p>上述代码就会向NOR Flash发起读操作：CPU发出的读地址为0x2，则地址总线ADDR1-ADDR20、A0-A19的信号都是1、0、…、0（CPU的ADDR0为0，不过ADDR0没有接到NOR Flash上）。NOR Flash接收到的地址就是0x1，NOR Flash在稍后的时间里将此址上的16位数据取出，并通过数据总线D0-D15发给CPU。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*地址不对齐的16位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x1</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> wVal;</span><br><span class="line">wVal = *pwAddr;</span><br></pre></td></tr></table></figure>
<p>由于地址位0x1；不是2对齐的，但是BANK0的位宽被设为16，这将导致异常。我们可以设置异常处理函数来处理这种情况。在异常处理函数中，使用0x0、0x2发起两次读操作，然后将两个结果组合起来。使用地址0x0读到两字节数据D0、D1，再使用地址0x2读到D2、D3。最后D1、D2组合成一个16位的数返回给wVal。如果没有设置地址不对齐异常处理函数，那么上述代码将出错。如果某个BANK位宽被设置为n，访问此BANK时，在总线上永远只会看到地址对齐的n位操作。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*8位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> *pucAddr = (<span class="type">unsigned</span> <span class="type">char</span> *)<span class="number">0x6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">char</span> ucVal;</span><br><span class="line">ucVal = *pucAddr;</span><br></pre></td></tr></table></figure>
<p>CPU首先使用地址0x6对NOR Flash发起16位的读操作，得到两字节的数据，假设位D1、D0，然后将D0取出赋值给uvVal。在读操作期间，地址总线ADDR1-ADDR20、A0-A19的信号都是1、1、1、…、0。CPU会自动丢弃D1。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*32位读操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> *pdwAddr = (<span class="type">unsigned</span> <span class="type">int</span> *)<span class="number">0x6</span>;</span><br><span class="line"><span class="type">unsigned</span> <span class="type">int</span> dwVal;</span><br><span class="line">dwVal = *pdwAddr;</span><br></pre></td></tr></table></figure>
<p>CPU首先使用地址0x6对NOR Flash发起16位的读操作，得到两字节的数据，假设为D0，D1；再使用地址0x8发起读操作，得到两字节的数据D2，D3，最后将这4个字节的数据组合后再赋值给变量dwVal。<br>由于NOR Flash的特性，使得对NOR Flash的写操作比较复杂—比如要先发出特定的地址信号通知NOR Flash准备接受数据，然后才发出数据。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*16位写操作*/</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">short</span> *pwAddr = (<span class="type">unsigned</span> <span class="type">short</span> *)<span class="number">0x6</span>;</span><br><span class="line">*pwAddr = <span class="number">0x1234</span>;</span><br></pre></td></tr></table></figure>
<p>CPU发起一次对NOR Flash的写操作，地址总线ADDR1-ADDR20、A0-A19的信号都时1、1、…、0；数据线DATA0-DATA15、D0-D15的信号为0、0、1、0、1、1、0、0、0、1、0、0、1、0、0、0。<br>由此可见，CPU使用某个地址进行访问时，这个32位的地址值和ADDR0-ADDR31一一对应，外接的设备可以以8位、16位、32位进行操作—取决于硬件设计。如果以8位进行操作，那么数据出现在数据信号DATA0-DATA7上，如果以16位进行操作，则数值出现在数据线DATA0-DATA15上；如果以32位进行操作，则数值出现在DATA0-DATA31上。</p>
<h1 id="GPIO操作实例"><a href="#GPIO操作实例" class="headerlink" title="GPIO操作实例"></a>GPIO操作实例</h1><p>LED和按键与处理器的电路连接基于图5.2。程序基于裸机开发，不带操作系统。</p>
<h2 id="纯汇编实现点亮一个LED"><a href="#纯汇编实现点亮一个LED" class="headerlink" title="纯汇编实现点亮一个LED"></a>纯汇编实现点亮一个LED</h2><p>汇编程序实现。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    ldr r0,=0x56000010      @r0设置为GPBCON寄存器，用于配置GPIOB系列引脚。</span><br><span class="line">    mov r1,#0x00000400      @r1赋值立即数0x00000400</span><br><span class="line">    str r1,[r0]             @GPBCON写入0x00000400，设置GPB5为输出口，位[10:9]=0b01</span><br><span class="line">    ldr r0,=0x56000014      @r0设置为GPBDAT寄存器，用于读写GPIOB系列引脚的数据。</span><br><span class="line">    mov r1,#0x00000020      @r1赋值立即数0x00000020</span><br><span class="line">    str r1,[r0]             @点亮LED1</span><br><span class="line">main_loop:</span><br><span class="line">    b main_lopp             @死循环</span><br></pre></td></tr></table></figure>
<p>编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o led_on.o led_on.S                        @编译</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf        @链接</span><br><span class="line">arm-linux-objcopy -O binary -S led_on_elf led_on.bin            @将elf格式的可执行文件转换位二进制格式</span><br></pre></td></tr></table></figure>

<h2 id="C代码实现点亮一个LED"><a href="#C代码实现点亮一个LED" class="headerlink" title="C代码实现点亮一个LED"></a>C代码实现点亮一个LED</h2><p>C语言执行的第一条指令并不在main函数中。生成一个C程序的可执行文件时，编译器通常会在我们的代码中加上几个被称为启动文件的代码—crtl.o、crti.o、crtend.o、crtn.o等，它们是标准库文件。这些代码设置C程序的堆栈等，然后调用main函数。它们依赖于操作系统，在裸板上这些代码无法执行，所以需要自己写一个。<br>这段代码很简单，只有6条指令，自己编写的crt0.S文件内容如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:crt0.S</span></span><br><span class="line"><span class="comment">通过它转入C程序</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    ldr r0,=<span class="number">0x56000010</span>      @watchdog地址寄存器</span><br><span class="line">    mov r1,#<span class="number">0x0</span>             @</span><br><span class="line">    str r1,[r0]             @写入<span class="number">0</span>，禁止watchdog，否则CPU会不断重启</span><br><span class="line">    ldr sp,=<span class="number">1024</span>*<span class="number">4</span>          @设置堆栈，注意不能大于<span class="number">4</span>KB，因为当前可以内存只有<span class="number">4</span>KB</span><br><span class="line">                            @NAND Flash中的代码会在复位后移到内部RAM（只有<span class="number">4</span>KB）</span><br><span class="line">    bl main                 @调用C程序中的main函数</span><br><span class="line"></span><br><span class="line">halt_loop:</span><br><span class="line">    b halt_loop</span><br></pre></td></tr></table></figure>
<p>设置好堆栈指针后，就可以调用C函数main了。C函数执行前，必须设置栈。<br>所以现在可以写出控制LED的C程序了。main函数在led_on_c.c中，代码如下：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (*(volatile unsigned long *)0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (*(volatile unsigned long *)0x56000014)</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    GPBCON = <span class="number">0x00000040</span>;    <span class="comment">//设置GPB5为输出端口，位[10:9]=0b01</span></span><br><span class="line">    GPBDAT = <span class="number">0x00000000</span>;    <span class="comment">//GPB5输出0，LED1点亮</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>编译如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o crt0.o crt0.S</span><br><span class="line">arm-linux-gcc -g -c -o led_on_c.0 led_on_c.c</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 -g crt0.o led_on_c.o -o led_on_c_elf</span><br><span class="line">arm-linux-objcopy -O binary -S led_on_c_elf led_on_c.bin</span><br><span class="line">arm-linux-objdump -D -m arm led_on_c_elf &gt; led_on_c.dis</span><br></pre></td></tr></table></figure>
<p>先分别编译crt0.S和led_on_c.c(不连接)。然后将编译的结果连接起来。然后把得到的ELF格式的文件led_on_c_elf转换成二进制的bin文件。最后将结果转换为汇编代码以供查看。</p>
<h2 id="按键来控制LED"><a href="#按键来控制LED" class="headerlink" title="按键来控制LED"></a>按键来控制LED</h2><p>当K1-K4某个按键按下时，点亮LED1-LED4中相应的代码。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:key_led.c</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBCON (* (unsigned long *) 0x56000010)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPBDAT (* (unsigned long *) 0x56000014)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFCON (* (unsigned long *) 0x56000050)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPFDAT (* (unsigned long *) 0x56000054)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPGCON (* (unsigned long *) 0x56000060)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPGDAT (* (unsigned long *) 0x56000064)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">LED1-LED4对应GPB5、GPB6、GPB7、GPB8</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB5_out (1&lt;&lt;(5*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB6_out (1&lt;&lt;(6*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB7_out (1&lt;&lt;(7*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPB8_out (1&lt;&lt;(8*2))</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">K1-K4对应GPG11、GPG3、GPF2、GPF0</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPG11_in ~(3&lt;&lt;(11*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPG3_in ~(3&lt;&lt;(3*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPF2_in ~(3&lt;&lt;(2*2))</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GPF0_in ~(3&lt;&lt;(0*2))</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> dwDat;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//LED1-LED4对应的4根引脚设置为输出</span></span><br><span class="line">    GPBCON = GPB5_out | GPB6_out | GPB7_out | GPB8_out ;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//K1-K2对应的两根引脚设为输入</span></span><br><span class="line">    GPGCON = GPG11_in &amp; GPG3_in;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        dwDat = GPGDAT;             <span class="comment">//读取GPG管脚电平状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">11</span>))       <span class="comment">//K1没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">5</span>);    <span class="comment">//LED1熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">5</span>);   <span class="comment">//LED1点亮</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">3</span>))        <span class="comment">//K2没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">6</span>);    <span class="comment">//LED2熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">6</span>);   <span class="comment">//LED2点亮</span></span><br><span class="line"></span><br><span class="line">        dwDat = GPFDAT;             <span class="comment">//读取GPF管脚电平状态</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">2</span>))        <span class="comment">//K3没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">7</span>);    <span class="comment">//LED3熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">7</span>);   <span class="comment">//LED3点亮</span></span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(dwDat &amp; (<span class="number">1</span> &lt;&lt; <span class="number">0</span>))        <span class="comment">//K4没有按下</span></span><br><span class="line">            GPBDAT  |= (<span class="number">1</span> &lt;&lt; <span class="number">8</span>);    <span class="comment">//LED4熄灭</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            GPBDAT  &amp;= ~(<span class="number">1</span> &lt;&lt; <span class="number">8</span>);   <span class="comment">//LED4点亮</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>代码先将LED1-LED4对应的引脚GPB5-GPB8设为输出引脚。<br>然后将K1、K2对应的引脚GPG11、GPG3设为输入引脚，K3、K4对应的引脚GPF2、GPF0设为输入引脚。<br>然后就是一个无穷循环，读取GPGDAT、GPFDAT寄存器，从中判断K1、K2、K3、K4是否按下。若按下则点亮相应的LED，否则熄灭相应的LED。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第5章 GPIO接口</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>设备与模块</title>
    <url>/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/</url>
    <content><![CDATA[<p>《Linux内核设计与实现》第17章总结归纳</p>
<span id="more"></span>
<h1 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h1><ol>
<li>设备类型：在所有Unix系统中为了统一普通设备的操作所采用的分类</li>
<li>模块：Linux内核中用于按需加载和卸载目标码的机制</li>
<li>内核对象：内核数据结构支持面向对象的简单操作，还支持维护父子对象之间的关系</li>
<li>sysfs：表示系统中设备树的一个文件系统</li>
</ol>
<h1 id="设备类型"><a href="#设备类型" class="headerlink" title="设备类型"></a>设备类型</h1><p>在Linux以及所有的Unix中，设备被分为三种类型；</p>
<ol>
<li>块设备<br> 通常缩写为blkdev，块设备是可寻址的，寻址以块为单位。块设备通常支持重定位操作，即对数据的随机访问。常见的块设备有硬盘，光碟，Flash。块设备通常会被挂载为文件系统。</li>
<li>字符设备<br> 通常缩写为cdev，字符设备是不可寻址的，仅提供数据的流式访问（即一个一个字符或者一个一个字节）。常见的字符设备有键盘，鼠标，打印机等，还有大部分伪设备。应用程序可以直接访问字符设备节点与字符设备交互。</li>
<li>网络设备<br> 一般以Ethernet Device来称呼，它提供了对网络的访问，通过一种物理适配器（如网卡）和一种特定的协议（如IP）进行的。它不是通过文件节点来访问的，而是通过套接字来这样的特殊接口来访问。</li>
<li>伪设备<br> 并不是所有设备驱动都表示物理设备。有些设备驱动时虚拟的，仅仅提供访问访问内核功能而已，称之为伪设备。例如内核随机数发生器（&#x2F;dev&#x2F;null）,空设备（&#x2F;dev&#x2F;zero）,零设备（&#x2F;dev&#x2F;urandom），满设备（&#x2F;dev&#x2F;full），内存设备（&#x2F;dev&#x2F;mem）。</li>
</ol>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><p>Linux是单块内核的操作系统，即整个系统都运行与一个单独的保护域中，但是Linux内核却是模块化的。它允许内核在运行期间动态的向其中插入或删除代码。这些代码（相关的子例程，数据，函数出口，函数入口）被存放在一个单独的二进制镜像中，称之为模块。支持模块的好处就是基本的内核镜像能尽可能的小，因为可选的功能和驱动程序都可以以模块的形式再提供。当热插拔新设备时，可以重新载入新的驱动程序。</p>
<h2 id="一个最简单模块"><a href="#一个最简单模块" class="headerlink" title="一个最简单模块"></a>一个最简单模块</h2><p>虽然编写“Hello World”程序属于陈词滥调，但是它就是那么合适，下面就是属于内核模块的“Hello World”。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello.c Hello World 我们的第一个内核模块</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/kernel.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello_init--初始化函数，模块装载时被调用，如果成功装载，返回0，否则返回非零值。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;hello init.\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">hello_exit--退出函数，模块卸载时被调用。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;hello exit.\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_LISENCE(<span class="string">&quot;GPL&quot;</span>);</span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Nibil&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A Hello World Module&quot;</span>);</span><br></pre></td></tr></table></figure>
<p><code>hello_init()</code>函数是模块的入口点，它通过<code>module_init()</code>例程注册到系统中，在内核装载时被调用。<code>module_init()</code>是一个宏。<br>模块的所有初始化函数必须符合下面的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">my_init</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>因为它不会被外部调用，所以可以加上static修饰。在实际的模块初始化函数中，往往会注册资源，初始化硬件，分配数据结构等。如果这个文件被静态编译进入内核镜像，那么这个模块将会在内核启动时运行。<br><code>hello_exit()</code>函数是模块的出口函数，他由<code>module_exit()</code>例程注册到系统。在模块从内核中卸载时，便会调用<code>hello_exit()</code>。简单来说，该函数负责对模块生命周期内所做的一切事情的撤销工作，在<code>hello_exit()</code>返回后，模块就被卸载了。<br>退出函数必须符合下面的形式。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">my_exit</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure>
<p>与init函数一样，你也可以用static修饰它。<br><code>MODULE_LISENCE()</code>用于指定模块的版权；<code>MODULE_AUTHOR()</code>和<code>MODULE_DESCRIPTION()</code>用于指定作者和模块的简要描述，他们完全是用作信息记录目的。</p>
<h2 id="构建模块"><a href="#构建模块" class="headerlink" title="构建模块"></a>构建模块</h2><p>在2.6的内核中采用了“KBuild”构建系统，现在构建模块相比从前更加容易。构建过程的第一步是决定在哪里管理模块代码。你可以把模块源码加入到内核源代码树上，或者是作为一个补丁，最终把你的代码合并到正式的内核代码树上；另一种可行的方法就是在内核源代码树之外维护和构建你的模块代码。</p>
<h3 id="放在内核源代码树上"><a href="#放在内核源代码树上" class="headerlink" title="放在内核源代码树上"></a>放在内核源代码树上</h3><p>当你决定了把你的模块放在内核源代码树上，下一步就要清楚放在内核源代码树的何处。设备驱动程序位于&#x2F;drivers的子目录下，在其内部，设备驱动程序被进一步按照类别，类型或者特殊驱动程序等更有序的组织起来。如字符设备存放于&#x2F;drivers&#x2F;char目录下，块设备存放于&#x2F;drivers&#x2F;block目录下，USB设备存放于&#x2F;drivers&#x2F;usb目录下。文件的具体组织规则并不是墨守成规，不容打破，很多USB设备也属于字符设备。不管怎样，这些组织关系对我们来说相当容易理解，而且也很准确。<br>假定你有一个字符设备，而且你希望将它存放于&#x2F;drivers&#x2F;char目录下，建议建立你自己代码的子目录。你的驱动程序是一个钓鱼竿和计算机的接口，那么你需要在&#x2F;drivers&#x2F;char下面建立一个fishing的子目录。接下来需要向&#x2F;drivers&#x2F;char下的Makefile文件添加一行</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-m += fishing/</span><br></pre></td></tr></table></figure>
<p>这行代码告诉模块构建系统，在模块编译时需要进入fishing&#x2F;子目录中。更有可能发生的是，你的驱动程序的编译取决于一个特殊配置选项；比如，可能的CONFIG_FISHING_POLE。那么，你可能需要用下面的指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing/</span><br></pre></td></tr></table></figure>
<p>最后，在&#x2F;drivers&#x2F;char&#x2F;fishing&#x2F;下，添加一个新的Makefile文件，其中需要有下面这行指令</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing.o</span><br></pre></td></tr></table></figure>
<p>以后，假如你的钓鱼竿程序需要更加智能化–它需要可以增加自动检测钓鱼线的功能。那么你的源程序就不止一个C文件了</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">obj-$(CONFIG_FISHING_POLE) += fishing.o</span><br><span class="line">fishing-objs := fish-main.o fish-line.o</span><br></pre></td></tr></table></figure>
<p>每当设置了CONFIG_FISHING_POLE，fishing-main.c和fishing-line.c就会被一起编译链接到fishin.ko中去。最后需要注意的是，构建文件时你可能需要额外的编译标记，你只需要在Makefile中添加如下命令，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">EXTRA_CFLAGS += -DTITANIUM_POLE</span><br></pre></td></tr></table></figure>
<p>然后就开始编译吧！</p>
<h3 id="放在内核代码外"><a href="#放在内核代码外" class="headerlink" title="放在内核代码外"></a>放在内核代码外</h3><p>模块在内核内和在内核外的构建的区别在于构建过程。当模块在内核源码树外时，你必须告诉make如何找到内核源代码文件和Makefile文件，</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">make -C /kernel/source/location SUBDIRS=$PWD modules</span><br></pre></td></tr></table></figure>
<p>在这个例子中，&#x2F;kernel&#x2F;source&#x2F;location是你自己配置的内核源码树。</p>
<h2 id="安装模块"><a href="#安装模块" class="headerlink" title="安装模块"></a>安装模块</h2><p>编译后的模块将被装入到目录&#x2F;lib&#x2F;modules&#x2F;version&#x2F;kernel下，在将kernel&#x2F;目录下的每一个目录都对应着内核源码树中的模块位置。如果使用的是2.6.34的内核，而且将你的模块源代码直接放在&#x2F;drivers&#x2F;char下，那么编译后的钓鱼杆驱动程序的存放路径将是:&#x2F;lib&#x2F;modules&#x2F;2.6.34&#x2F;kernel&#x2F;drivers&#x2F;char&#x2F;fishing.ko。<br>下面的构建命令用来安装编译的模块到合适的目录下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make modules_install</span><br></pre></td></tr></table></figure>
<h2 id="产生模块依赖性"><a href="#产生模块依赖性" class="headerlink" title="产生模块依赖性"></a>产生模块依赖性</h2><p>Linux模块之间存在依赖性，也就是说钓鱼模块依赖于鱼饵模块，那么当你载入钓鱼模块时，鱼饵模块会自动被载入。你可以使用如下命令获取内核模块之间的依赖信息：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depmod</span><br><span class="line">depmod -A #模块依赖关系存放于/lib/modules/version/modules.dep中。</span><br></pre></td></tr></table></figure>

<h2 id="载入模块"><a href="#载入模块" class="headerlink" title="载入模块"></a>载入模块</h2><p>载入模块最简单的方法就是通过insmod命令，它的功能就是请求内核载入指定的模块：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">insmod module.ko</span><br><span class="line">rmmod module #卸载一个模块</span><br></pre></td></tr></table></figure>
<h2 id="管理配置选项"><a href="#管理配置选项" class="headerlink" title="管理配置选项"></a>管理配置选项</h2><p>这里我们继续以钓鱼竿驱动程序为例，看看一个新的配置选项如何加入。<br>由于2.6内核新引入了“Kbuild”系统，你所需要做的就是想Kconfig文件中添加一项，用以对应内核源码树。对驱动程序而言，kconfig通常和源代码处于同一目录。如果钓鱼杆驱动程序位于&#x2F;drivers&#x2F;char下，那么&#x2F;drivers&#x2F;char&#x2F;kconfig也会存在。<br>如果你新引入了一个子目录fishing&#x2F;，那么你必须在一个已经存在的kconfig文件中将它引入：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source &quot;drivers/char/fishing/kconfig&quot;</span><br></pre></td></tr></table></figure>
<p>请看kconfig中钓鱼竿模块的选项，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">config FISHING_POLE</span><br><span class="line">    tristate &quot;Fish Mater 3000 support&quot;</span><br><span class="line">    default n</span><br><span class="line">    help </span><br><span class="line">        you can say N(no),M(Module),Y(yes) here,if unsure say N</span><br></pre></td></tr></table></figure>
<p>第一行定义了该选项所代表的配置目标，注意CONFIG_前缀并不需要带上。<br>第二行声明类型为tristate，也就是说可以编译进内核（Y），也可以作为模块编译（M），或者干脆不编译它（N）。如果配置选项代表的是一个系统功能，而不是一个模块，那么编译选项将用bool代替tristate，说明它不允许被编译成模块。<br>第三行指定默认编译选项，驱动程序一般默认不编译进入内核（N）。<br>help指令为该选项提供帮助文档。<br>除了上述选项外，还存在其他选项。比如depends指令指定了在该选项设置前，首先需要设置的选项。假设你加入</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depends on FISH_TANK</span><br></pre></td></tr></table></figure>
<p>到配置选项中，那么就意味着在CONFIG_FISH_TANK被选择前，我们的钓鱼竿模块是不能被使用的（Y或者M）。<br>select指令和depends类似，它们只有一点不同之处—那就是select指定了谁，它就会将被指定的选项强制打开，所以要慎重使用select</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select BAIT</span><br></pre></td></tr></table></figure>
<p>意味着当CONFIG_FISHING_POLE被激活时，配置选项CONFIG_BAIT必然被一起激活。<br>如果select和depends同时指定多个选项，那就需要通过&amp;&amp;指令来进行多选。使用的depends时，你还可以利用叹号前缀来指明禁止某个选项。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">depends on EXAMPLE_DIRVERS &amp;&amp; !NO_FISHING_ALLOWED</span><br></pre></td></tr></table></figure>
<p>这行指令就指定驱动程序安装要求打开CONFIG_EXAMPLE_DIRVERS选项，同时禁止CONFIG_NO_FISHING_ALLOWED选项。<br>tristate和bool选项往往会结合if指令一起使用，这表示某个选项取决于另一个配置选项。如果条件不满足，配置选项不但会被禁止，甚至不会显示在配置工具中。比如，要求配置系统只有在CONFIG_x86配置选项时才显示某选项。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">bool &quot;x86 only&quot; if x86</span><br></pre></td></tr></table></figure>
<h2 id="导出符号表"><a href="#导出符号表" class="headerlink" title="导出符号表"></a>导出符号表</h2><p>模块被载入后，就会被动态的连接到内核。注意，它与用户空间的动态链接库类似，只有被显式导出后的外部函数，才可以被动态库调用。在内核中，导出内核函数需要使用特殊的指令<code>EXPORT_SYMBOL()</code>和<code>EXPORT_SYMBOL_GPL()</code>。<br>导出的内核函数可以被模块调用，而未导出的函数模块则无法被调用。函数代码的链接和调用规则相比核心内核镜像的的代码而言，要更加严格。核心代码在内核中可以调用任意非静态接口，因为所有的核心源代码文件被链接成了同一个镜像。当然，被导出的符号表所含的函数必然也要是非静态的。<br>导出的内核符号被看作导出的内核接口，甚至被称为内核API。导出符号相当简单，在声明函数后，紧跟上<code>EXPORT_SYMBOL()</code>指令就搞定了。比如：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    返回当前priate胡须的颜色</span><br><span class="line">*/</span><br><span class="line">int get_priate_beard_color(struct priate *p)</span><br><span class="line">&#123;</span><br><span class="line">    return p-&gt;beard.color;</span><br><span class="line">&#125;</span><br><span class="line">EXPROT_SYMBOL(get_priate_beard_color)</span><br></pre></td></tr></table></figure>
<p>如果你希望先前的函数仅对标记为GPL协议的模块可见，那么你就需要用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">EXPROT_SYMBOL_GPL(get_priate_beard_color)</span><br></pre></td></tr></table></figure>
<p>如果你的代码被配置为模块，那么你就必须确保它被编译为模块时，它所用的全部接口都已经被导出，否则就会出现连接错误（而且模块不能编译成功）。</p>
<h1 id="设备模型"><a href="#设备模型" class="headerlink" title="设备模型"></a>设备模型</h1><p>2.6的内核增加了一个引人注目的新特性—-统一设备模型（device model）。设备模型提供了一个独立的机制专门来表示设备，并描述其在系统中的拓扑结构，从而使得系统具有以下优点：</p>
<ol>
<li>代码重复最小化；</li>
<li>提供诸如引用计数这样的统一机制；</li>
<li>可以列举系统中的所有设备，观察他们的形态，并且查看他们连接的总线；</li>
<li>可以将系统中的全部设备结构以树的形式完整，有效的展示出来—-包括总线和所有的内部连接；</li>
<li>可以将设备和其对应的驱动联系起来，反之亦然；</li>
<li>可以将设备按照类型分类，比如分为输入设备，而无需理解物理设备的拓扑结构；</li>
<li>可以沿这设备树的叶子向其根节点的方向遍历，以保证能以正确的顺序关闭各个设备的电源。<br>内核无疑需要一棵设备树。</li>
</ol>
<h2 id="kobject"><a href="#kobject" class="headerlink" title="kobject"></a>kobject</h2><p>设备模型的核心部分就是kobject（kernel object），它由struct kobject结构体表示，定义域头文件<code>&lt;linux/kobject.h&gt;</code>中。它提供了诸如引用计数，名称，父指针等字段，可以创建对象的层次结构。具体结构如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject&#123;</span><br><span class="line">    const char          *name;</span><br><span class="line">    struct list_head    entry;</span><br><span class="line">    struct kobject      *parent;</span><br><span class="line">    struct kset         *kset;</span><br><span class="line">    struct kobi_type    *ktype;</span><br><span class="line">    struct sysfs_dirent *sd;</span><br><span class="line">    struct kref         kref;</span><br><span class="line">    unsigned int        state_initialized:1;</span><br><span class="line">    unsigned int        state_in_sysfs:1;</span><br><span class="line">    unsigned int        state_add_uevent_sent:1;</span><br><span class="line">    unsigned int        state_remove_uevent_sent:1;</span><br><span class="line">    unsigned int        uevent_suppress:1;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>name 指针指向该kobject的名称。<br>parent 指针指向kobject的父对象，这样一来，kobject就会在内核中构造一个对象层次结构，并且可以将多个对象间的关系表现出来。这便是sysfs的真面目：一个用户空间的文件系统，用来表示内核中kobject对象的层次结构。<br>sd 指针指向sysfs_dirent结构体，它在sysfs中表示的就是这个kobject。<br>kref 提供引用计数。ktype和kset对kobject进行描述和分类。<br>kobject通常是嵌入到其他结构中，其单独存在的意义不大。比如定义在<code>&lt;linux/cdev.h&gt;</code>下的struct cdev中才真正用到了kobj结构：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">    该对象代表一个字符设备</span><br><span class="line">*/</span><br><span class="line">struct cdev&#123;</span><br><span class="line">    struct kobject          kobj;</span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当konject被嵌入到其他结构中时，该结构便拥有了kobject提供的标准功能。更重要的一点是，嵌入kobject的结构体可以成为对象层次架构中的一部分。比如cdev就可以通过其父指针cdev-&gt;kobj.parent 和链表 cdev-&gt;kobj.entry 插入到对象层次结构中。</p>
<h2 id="ktype"><a href="#ktype" class="headerlink" title="ktype"></a>ktype</h2><p>kobject对象被关联到一种特殊的类型，即ktype（kernel object type）。ktype由kobj_type结构体表示，定义于头文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">strcut kobj_type&#123;</span><br><span class="line">    void (*release)(struct kobject *);</span><br><span class="line">    const struct sysfs_ops *sysfs_ops;</span><br><span class="line">    struct attribute       **defalut_attrs;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>ktype的存在就是为了描述一族kobject的普遍特性。如此一来，不需要每一个kobject都分别定义自己的特性，而是将这些普遍的特性在ktype中一次定义，然后所有的同类“kobject”都能共享一样的特性。<br>release函数指针指向kobject引用计数为零时要被调用的析构函数。该函数负责释放所有kobject使用的内存和其他相关清理工作。<br>sysyfs_ops变量指向sysfs_ops结构体。该结构体描述了sysfs文件读写时的特性。<br>default_attrs指向了一个attribute结构体数组。这些结构体定义了该kobject相关的默认属性。属性描述了给定对象的特征，如果该kobject导出到sysyfs，那么这些属性都将相应的作为文件而导出，数组的最后一项必须为NULL。</p>
<h2 id="kset"><a href="#kset" class="headerlink" title="kset"></a>kset</h2><p>kset是kobject对象的集合体。可以把它看作是一个容器，可将所有相关的kobject对象，比如”全部的块设备“置于同一位置。kset和ktype最大的区别就是：具有相同ktype的kobject可以被分组到不同的kset。也就是说，在Linux内核中，只有少数一些的ktype，却有多个kset。<br>kobject的kset指针指向相应的kset集合。kset集合由kset结构体表示，定义于头文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kset&#123;</span><br><span class="line">    struct list_head        list;</span><br><span class="line">    spinlock_t              list_lock;</span><br><span class="line">    struct kobject          kobj;</span><br><span class="line">    struct kset_uevent_ops  *uevenet_ops;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在这个结构中，其中list连接该集合中所有的kobject对象，list_lock是保护这个链表对象的自旋锁，kobj指向的konject对象代表了该集合的基类。uevent_ops指向了一个结构体—用于处理集合中kobject对象的热插拔操作。<code>uevent就是用户事件（user event）的缩写</code>，提供了与用户空间热插拔信息进行通信的机制。</p>
<h2 id="kobject、ktype、kset的相互关系"><a href="#kobject、ktype、kset的相互关系" class="headerlink" title="kobject、ktype、kset的相互关系"></a>kobject、ktype、kset的相互关系</h2><p><img src="/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/1.jpeg" alt="img not found"></p>
<h2 id="管理和操作kobject"><a href="#管理和操作kobject" class="headerlink" title="管理和操作kobject"></a>管理和操作kobject</h2><p>当了解了kobject的内部基本细节后，我们来看管理和操作他的外部接口了。<br>使用kobject的第一步需要先进行声明和初始化。kobject通过函数<code>kobject_init()</code>进行初始化，该函数定义在文件<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_init(struct kobject *kobj,struct kobj_type *ktype);</span><br></pre></td></tr></table></figure>
<p>该函数第一个参数就是需要初始化kobject对象，在调用初始化之前，kobject必须清空：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">memset(kobj,0,sizeof(*kobj));</span><br></pre></td></tr></table></figure>
<p>只有在初始化之后就可以安全的初始化parent和kset字段：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">kobj = kmalloc(sizeof(*kobj),GFP_KERNEL);</span><br><span class="line">if(!kobj)</span><br><span class="line">    return -ENOMEM;</span><br><span class="line">memset(kobj,0,sizeof(*kobj));</span><br><span class="line">kobj-&gt;kset = my_kset;</span><br><span class="line">kobject_init(kobj,my_ktype);</span><br></pre></td></tr></table></figure>
<p>or</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobj;</span><br><span class="line"></span><br><span class="line">kobj = kobject_create();</span><br><span class="line">if(!kobj)</span><br><span class="line">    return -ENOMEM;</span><br></pre></td></tr></table></figure>
<p>大多数情况下，应该调用<code>kobject_create()</code>而不是直接操作这个结构体。</p>
<h2 id="引用计数"><a href="#引用计数" class="headerlink" title="引用计数"></a>引用计数</h2><p>kobject的主要功能之一就是为我们提供了一个统一的引用计数系统。初始化后，koject的引用计数设置为1。只要引用计数不为零，那么该对象就会继续保留在内存中。任何包含对象引用的代码首先要增加该对象的引用计数，当代码结束后就减少它的引用计数。当引用计数跌为零时，对象便可以撤销，相关内存也都被释放。</p>
<h3 id="增加和递减引用计数"><a href="#增加和递减引用计数" class="headerlink" title="增加和递减引用计数"></a>增加和递减引用计数</h3><p>增加一个引用计数可通过<code>kobject_get()</code>函数完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_get(struct kobject *kobj);</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>该函数正常情况下将返回一个指向kobject的指针，如果失败则返回NULL。<br>减少引用计数通过<code>kobject_put()</code>完成，这个函数也声明在<code>&lt;linux/kobject.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_put(struct kobject *kobj);</span><br></pre></td></tr></table></figure>
<p>如果对应的kobject的引用计数减少到零，那么与该kobject关联的ktype中的析构函数将会被调用。</p>
<h3 id="kref"><a href="#kref" class="headerlink" title="kref"></a>kref</h3><p>kobject的引用计数是通过kref结构体实现的。该结构体定义在<code>&lt;linux/kref.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kref&#123;</span><br><span class="line">    atomic_t refcount;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中唯一的字段是用来存放引用计数的原子变量。那么为什么采用结构体，这是为了便于进行类型检测。在使用kref前，你必须通过<code>kref_init()</code>来初始化它：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_init(strcut kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">    atomic_set(&amp;kref-&gt;refcount,1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个函数简单的将原子变量置1，所以fref一旦被初始化，它所表示的引用计数便固定为1。<br>要获得对kref的引用，需要调用<code>kref_get()</code>函数，该函数增加引用计数值，没有返回值，这个函数在<code>&lt;linux/kref.h&gt;</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_get(strcut kref *kref)</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(!atomic_read(&amp;kref-&gt;refcount));</span><br><span class="line">    atomic_inc(&amp;kref-&gt;refcount);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>减少对kref的引用，这个函数在<code>&lt;linux/kref.h&gt;</code>中声明：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kref_put(strcut kref *kref,void (*release) (strcut kref *kref))</span><br><span class="line">&#123;</span><br><span class="line">    WARN_ON(release == NULL);</span><br><span class="line">    WARN_ON(release == (void (*release) (strcut kref *)) kfree);</span><br><span class="line"></span><br><span class="line">    if(atomic_dec_and_test(&amp;kref-&gt;refcount))&#123;</span><br><span class="line">        release(kref);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述所有函数定义和声明分别在<code>lib/kref.c</code>和<code>&lt;linux/kref.h&gt;</code>中。</p>
<h1 id="sysfs"><a href="#sysfs" class="headerlink" title="sysfs"></a>sysfs</h1><p>sysfs文件系统是一个处于内存中的虚拟文件系统，它为我们提供了kobject对象层次结构的视图。帮助用户能以一个简单文件系统的方式来视察系统中各种设备的拓扑结构。借助属性对象，kobject可以用导出文件的方式，将内核变量提供给用户读取或者写入。<br>虽然设备模型的初衷是为了方便电源管理而提出的一种设备拓扑结构，但是sysfs是颇为意外的收获。为了方便调试，设备模型的开发者决定将设备结构树导出为一个文件系统。今天所有的2.6内核的系统都拥有sysfs文件系统，而且几乎都将其挂载在<code>sys/</code>下。<br>sysfs的诀窍就是吧kobject对象和目录项（directory entries）紧密联系在一起，这点是通过kobject对象中的dentry字段实现的。dentry结构体表示目录项，通过连接kobject到指定的目录项上，无疑方便的将kobject映射到该目录上。从此，把kobject导出形成文件系统就变得跟在内存中构建目录项一样简单。kobject其实已经形成了一棵树—就是我们心爱的对象体系模型。由于kobject映射到目录项，同时对象层次结构也已经在内存中形成了一棵树，因此sysfs的生成便水到渠成般的简单了。<br><img src="/2022/08/02/%E8%AE%BE%E5%A4%87%E4%B8%8E%E6%A8%A1%E5%9D%97/2.jpeg" alt="img not found"><br>sysfs的根目录下至少包含了十个目录：block、bus、class、dev、devices、firmware、fs、kernel、module和power。</p>
<ol>
<li>block下每个子目录都对应着系统中已注册的块设备。反过来，每个目录下又都包含了该块设备的所有分区。</li>
<li>bus目录提供了一个系统总线试图。</li>
<li>class目录包含了以高层功能逻辑组织起来的系统设备视图。</li>
<li>dev目录是已注册的设备节点的视图。</li>
<li>devices目录是系统中的设备拓扑结构视图，它直接映射了内核中设备结构体的组织层次。</li>
<li>firmware目录包含了一些诸如ACPI、EDD、EFI等低层子系统的特殊树。</li>
<li>fs目录是已注册的文件系统的视图。</li>
<li>kernel目录包含内核配置项和状态信息。</li>
<li>module目录则包含系统已加载模块的信息。</li>
<li>power目录包含系统范围的电源去管理数据。<br>其中最重要的目录是devices，该目录将设备模型导出到用户空间。目录结构就是系统中的实际的设备拓扑。其他目录中的很多数据都是将devices目录下的数据加以转换加工得来的。比如，<code>/sys/class/net/</code>目录是以注册网络接口这一高层概念来组织设备关系的，在这个目录中可能会有目录<code>eth0</code>，它里面包含的devices文件其实就是一个指回到devices下实际设备目录的符号链接。<br>随便看看你可以访问到的任何Linux系统的sys目录，这种系统设备视图相当准确和漂亮，而且可以看到class中高层概念与devices中的低层物理设备，以及bus中的实际驱动程序之间互相联络是非常广泛的。当你认识到这种数据是开放的，换句话说，这种内核中维持系统的很好表示方式时，整个经历都是弥足珍贵的。</li>
</ol>
<h2 id="sysfs中添加和删除kobject"><a href="#sysfs中添加和删除kobject" class="headerlink" title="sysfs中添加和删除kobject"></a>sysfs中添加和删除kobject</h2><p>仅仅初始化kobject是不能将其导入到sysfs中去的，想要将kobject导入sysfs，你需要用到<code>kobject_add()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kobject_add(struct kobject *kobj,struct kobject *parent,const char *fmt,...);</span><br></pre></td></tr></table></figure>
<p>kobject在sysfs的位置取决于kobject在对象层次结构中的位置。如果kobject的父指针被设置，那么在sysfs中kobject将被映射为其父目录下的子目录；如果parent没有被设置，那么kobject将被映射为kset-&gt;kobj中的子目录。如果给定的kobject中parent或kset字段都没有被设置，那么就认为kobject没有父对象，所以就会被映射成sysfs下的根级目录。这往往不是你所需要的，所以在调用<code>kobject_add()</code>之前，parent或者kset应该被适当的设置。sysfs中代表kobject的目录名字是由fmt指定的，它也接受<code>printf()</code>样式的格式化字符串。<br>辅助函数<code>kobject_create_and_add()</code>把<code>koject_create()</code>和<code>kobject_add()</code>所做的工作放在一个函数中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct kobject *kobject_create_and_add(const char *name,struct kobject *parent);</span><br></pre></td></tr></table></figure>
<p>从sysfs中删除一个kobject对应文件目录，需要使用函数<code>kobject_del()</code>:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void kobject_del(struct kobject *kobj);</span><br></pre></td></tr></table></figure>
<p>上述函数都定义于文件<code>lib/kobject.c</code>中，声明位于头文件<code>&lt;linux/kobject.h&gt;</code>中。</p>
<h2 id="向sysfs中添加文件"><a href="#向sysfs中添加文件" class="headerlink" title="向sysfs中添加文件"></a>向sysfs中添加文件</h2><p>我们已经看到kobject被映射为文件目录了，而且所有的对象层次结构都优雅的，一个不少的映射成sys下的目录结构。但是里面的文件是什么，sysfs仅仅是一个漂亮的树，但是没有提供实际数据的文件。</p>
<h3 id="默认属性"><a href="#默认属性" class="headerlink" title="默认属性"></a>默认属性</h3><p>默认的文件集合是通过kobject和kset中的ktype提供的。因此所有具有相同类型的kobject在它们对应的sysfs目录下都拥有相同默认文件集合。kobject_type字段含有一个字段—default_attrs，它是一个attribute结构体数组。这些属性负责将内核数据映射成sysfs中的文件。<br>attribute结构体定义在文件<code>&lt;linux/sysfs.h&gt;</code>中：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*</span><br><span class="line">attribute 结构体 - 内核数据映射成sysfs中的文件</span><br><span class="line">*/</span><br><span class="line">struct attribute&#123;</span><br><span class="line">    const char      *name;      /*属性名称*/</span><br><span class="line">    struct module   *owner;     /*所属模块，如果存在*/</span><br><span class="line">    mode_t          mode;       /*权限*/</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中名称字段提供了该属性的名称，最终出现在sysfs中的文件名就是它。owner字段在存在所属模块的情况下指向其所属的module结构体。如果一个模块没有该属性，那么该字段为NULL。mode 字段类型为mode_t，它表示了sysfs中该文件的权限。对于只读属性而言，如果是所有人都可以读它，则该字段设置为S_IRUGO;如果只限于所有者可读，则该字段被设置为S_IRUSR。同样对于可写属性，可能会设置该字段为S_IRUGO | S_IWUSR。sysfs中的所有文件和目录的uid与gid标志均为0。<br>虽然default_attr列出了默认的属性，sysfs_ops字段则描述了如何使用他们。sysfs_ops字段指向了一个定义于文件<code>&lt;linux/sysfs.h&gt;</code>的同名的结构体：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">struct sysfs_ops&#123;</span><br><span class="line">    /*在读sysfs时被调用*/</span><br><span class="line">    ssize_t (*show) (struct kobject *kobj,struct attribute *attr,char *buffer);</span><br><span class="line">    /*在写sysfs时被调用*/</span><br><span class="line">    ssize_t (*store) (struct kobject *kobj,struct attribute *attr,char *buffer,size_t size);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>当从用户空间读取sysfs的项时调用<code>show()</code>方法。它会拷贝由attr提供的属性值到buffer指定的缓冲区中，缓冲区大小为PAGE_SIZE字节；<br><code>store()</code>方法在写操作时调用，它会从buffer中读取size大小的字节，并将其存放入attr表示的属性结构体变量中。</p>
<h3 id="创建新属性"><a href="#创建新属性" class="headerlink" title="创建新属性"></a>创建新属性</h3><p>内核为能在默认集合上，再添加新属性而提供了<code>sysfs_create_file()</code>接口:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sysfs_create_file(struct kobject *kobj,const struct attribute *attr);</span><br></pre></td></tr></table></figure>
<p>注意，kobject中的ktype所对应的sysfs_ops操作将负责处理新属性。现有的<code>show()</code>和<code>store()</code>方法必须能够处理新属性。<br>除了添加文件外，还有可能需要创建符号链接。再sysf中创建一个符号链接很简单：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int sysyfs_create_link(struct kobject *kobj,struct kobject *target,char *name);</span><br></pre></td></tr></table></figure>
<p>该函数创建的符号链接名由name决定，连接则由kobj对应的目录映射到target指定的目录。如果成功该函数返回零，如果失败返回负的错误码。</p>
<h3 id="删除新属性"><a href="#删除新属性" class="headerlink" title="删除新属性"></a>删除新属性</h3><p>删除一个属性需要通过函数<code>sysfs_remove_file()</code>完成：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sysfs_remove_file(struct kobject *kobj,const struct attribute *attr);</span><br></pre></td></tr></table></figure>
<p>一但调用返回，给定的属性将不再存在于给定的kobject目录中。另外由<code>sysfs_create_link()</code>创建的符号链接可通过函数<code>sysfs_remove_link()</code>删除：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">void sysfs_remove_link(struct kobject *kobj,char *name);</span><br></pre></td></tr></table></figure>
<p>调用一旦返回，在kobj对应目录中的名为name的符号链接将不复存在。<br>上述四个函数在文件<code>&lt;linux/kobject.h&gt;</code>中声明；<code>sysfs_create_file()</code>和<code>sysfs_remove_file()</code>定义于文件<code>fs/sysfs/file.c</code>。<code>sysyfs_create_link()</code>和<code>sysfs_remove_link()</code>定义于文件<code>fs/sysfs/symlink.c</code>中。</p>
<h2 id="内核事件层"><a href="#内核事件层" class="headerlink" title="内核事件层"></a>内核事件层</h2><p>内核事件层实现了内核到用户的消息通知系统，就是建立在上文一直讨论的kobject基础之上。在2.6.0版本之后，显而易见，系统确实需要一种机制来帮助事件传出内核输入到用户空间，特别是对于桌面系统来说吗，因为他需要更完整和异步的系统。为此就要让内核将其事件压倒堆栈：硬盘满了，CPU过热了，分区挂载了。<br>早期的事件层没有采用kobject和sysfs，他们如过眼云烟，没有存在多久。现在的事件层借助kobject和sysfs实现以证明相当理想。内核事件层把事件模拟册成信号—从明确的kobject对象发出，所以每个事件源都是一个sysfs路径。如果请求的事件与你的第一个硬盘相关，那么<code>sys/block/had</code>便是源树。实质上，在内核中我们认为事件都是从幕后的kobject对象产生的。<br>每个事件都被赋予了一个动词或者动作字符串表示信号。该字符串会以“被修改过”或者“未挂载”等词语来描述事件。<br>最后。每个事件都有一个可选的负载（payload）。相比传递任意一个标识负载的字符串到用户空间而言，内核事件层使用sysfs属性代表负载。<br>从内部实现来讲，内核事件由内核空间传递到用户空间需要经过netlink。netlink是一个用于传送网络信息的多点传送套接字。使用netlink就意味着从用户空间获取内核事件就如同在套接字上堵塞一样易如反掌。方法就是用户空间实现一个系统后台服务用于监听套接字，处理任何读到的信息，并将事件传送到系统栈里面。对于这种用户后台服务来说，一个潜在的目的就是将事件融入D-BUS系统。D-BUS系统已经实现了一套系统范围的消息总线，这种总线可帮助内核如同系统中其他组件一样地发出信号。<br>在内核代码中向用户空间发送信号使用函数<code>kobject_uevent()</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">int kobject_uevent(struct kobject* kobj,enum kobject_action action);</span><br></pre></td></tr></table></figure>
<p>第一个参数指定发送该信号的对象。实际的内核事件将包含该kobject映射到sysfs的路径。<br>第二个参数指定了该信号的“动作”或者“动词”。实际的内核事件将包含一个映射成枚举类型kobject_action的字符串。该函数不是直接提供一个字符串，而是利用一个枚举变量来提高可重用性和保证类型安全，而且也消除了打字错误或者其他错误。该枚举变量定义于文件<code>&lt;linux/kobject_uevent.c&gt;</code>中，其形式为kOBJ_foo。当前值包含kOBJ_MOUNT、kOBJ_UNMOUNT、kOBJ_ADD、kOBJ_REOMOVE、kOBJ_CHNAGE等。这些值分别映射为字符串“mount”、“unmount”、“add”、“remove”、“change”等。当现有的这些值不够用时，允许添加新动作。</p>
<h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>本章中涉及到的内核功能有设备驱动的实现、设备树的管理、包括模块、kobject、kset、ktype和sysfs。这些功能对于设备驱动程序的开发者来说是至关重要的。因为它能让我们写出更加模块化、更为高级的驱动程序。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>Linux内核设计与实现</category>
        <category>第17章 设备与模块</category>
      </categories>
      <tags>
        <tag>Linux Kernel</tag>
      </tags>
  </entry>
  <entry>
    <title>存储控制器</title>
    <url>/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/</url>
    <content><![CDATA[<p>《嵌入式Linux应用完全开发手册》第1篇第6章总结归纳<br>总线的使用是嵌入式底层开发的基础，了解它之后，再根据外设的具体特性，就可以驱动该外设了。</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解S3C2410&#x2F;S3C2440地址空间的布局</li>
<li>掌握如何通过总线形式访问扩展的外设，比如内存、NOR Flash、网卡等。</li>
</ol>
<h1 id="使用存储控制器访问外设的原理"><a href="#使用存储控制器访问外设的原理" class="headerlink" title="使用存储控制器访问外设的原理"></a>使用存储控制器访问外设的原理</h1><h2 id="S3C2410-x2F-S3C2440的地址空间"><a href="#S3C2410-x2F-S3C2440的地址空间" class="headerlink" title="S3C2410&#x2F;S3C2440的地址空间"></a>S3C2410&#x2F;S3C2440的地址空间</h2><p>S3C2410&#x2F;S3C2440的”存储控制器“提供了访问外部设备所需的信号，它有如下特性：</p>
<ol>
<li>支持小字节序、大字节序（通过软件选择）；</li>
<li>每个BANK的地址空间为128MB，共1GB（8BANKs）；</li>
<li>可编程控制的范围总线位宽（8&#x2F;16&#x2F;32bit），不过BANK0只能选择两种位宽（16&#x2F;32bit）；</li>
<li>总共8个BANK，BANK0-BANK5可以支持外接ROM、SRAM等。BANK6-BANK7除了可以支持ROM、SRAM外，还支持SDRAM等；</li>
<li>BANK0-BANK7共7个BANK的起始地址是固定的；</li>
<li>BANK7的起始地址可编程选择；</li>
<li>BANK6、BANK7的地址空间大小是可编程控制的；</li>
<li>每个BANK的访问周期均可编程控制；</li>
<li>可以通过外部的”wait“信号延长总线的访问周期；</li>
<li>在外接SDRAM时，支持自刷新（self-refresh）和省电模式（power down mode）<br>S3C2410&#x2F;S3C2440对外引出的27根地址线ADDR0-ADDR26的访问范围只有128MB，那么如何达到上面所说的1GB的访问空间呢？CPU对外引出了8根片选信号nGCS0-nGCS7，对应于BANK0-BANK7，当访问BANKx的地址空间时，nGCSx的引脚输出低电平，用来选中外接的设备。这样，每个nGCSx对应的128MB空间，8个nGCSx信号总共就对应了1GB的地址空间。这8个BANK的地址空间如图所示：<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/1.jpeg" alt="img not found"><br>如图所示，左边对应不使用NAND Flash作为启动设备（单板上不接NAND BOOT跳线）时的地址空间布局，右边对应使用NAND Flash作为启动设备（单板上接NAND BOOT跳线）时的地址空间布局。<br>S3C2410&#x2F;S3C2440作为32位的CPU，可以使用的地址范围理论上达到4GB。除去上述用于连接外设的1GB地址空间外，还有一部分是CPU内部寄存器的地址，剩下的地址空间没有使用。<br>S3C2410&#x2F;S3C2440的寄存器地址范围都处于0x4800000-0x5fffffff，各功能部件的寄存器大体相同。（”-表示相同。”无“表示不含该功能部件。）<table>
<thead>
<tr>
<th>功能部件</th>
<th>S3C2410起始地址</th>
<th>S3C2410结束地址</th>
<th>S3C2440起始地址</th>
<th>S3C2440结束地址</th>
</tr>
</thead>
<tbody><tr>
<td>存储控制器</td>
<td>0x48000000</td>
<td>0x48000030</td>
<td>0x48000000</td>
<td>0x48000030</td>
</tr>
<tr>
<td>USB Host控制器</td>
<td>0x49000000</td>
<td>0x49000058</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>中断控制器</td>
<td>0x4A000000</td>
<td>0x4A00001C</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>DMA</td>
<td>0x4B000000</td>
<td>0x4B0000E0</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>时钟和电源管理</td>
<td>0x4C000000</td>
<td>0x4C000014</td>
<td>-</td>
<td>0x4C000018</td>
</tr>
<tr>
<td>LCD控制器</td>
<td>0x4D000000</td>
<td>0x4D000060</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>NAND Flash控制器</td>
<td>0x4E000000</td>
<td>0x4E000014</td>
<td>-</td>
<td>0x4E00003C</td>
</tr>
<tr>
<td>摄像头接口</td>
<td>无</td>
<td>无</td>
<td>0x4F000000</td>
<td>0x4F0000A0</td>
</tr>
<tr>
<td>UART</td>
<td>0x50000000</td>
<td>0x50008028</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>脉宽调制计时器</td>
<td>0x51000000</td>
<td>0x51000040</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>USB设备</td>
<td>0x52000140</td>
<td>0x5200026F</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>看门狗计时器</td>
<td>0x53000000</td>
<td>0x53000008</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>IIC控制器</td>
<td>0x54000000</td>
<td>0x5400000C</td>
<td>-</td>
<td>0x54000010</td>
</tr>
<tr>
<td>IIS控制器</td>
<td>0x55000000</td>
<td>0x55000012</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>I&#x2F;O端口</td>
<td>0x56000000</td>
<td>0x560000B0</td>
<td>-</td>
<td>0x560000CC</td>
</tr>
<tr>
<td>RTC</td>
<td>0x57000000</td>
<td>0x5700008B</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>A&#x2F;D转换器</td>
<td>0x58000000</td>
<td>0x58000010</td>
<td>-</td>
<td>0x58000014</td>
</tr>
<tr>
<td>SPI</td>
<td>0x59000000</td>
<td>0x59000034</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>SD接口</td>
<td>0x5A000000</td>
<td>0x5A000040</td>
<td>-</td>
<td>0x5A000043</td>
</tr>
<tr>
<td>AC97音频编码接口</td>
<td>无</td>
<td>无</td>
<td>0x5B000000</td>
<td>0x5B00001C</td>
</tr>
</tbody></table>
</li>
</ol>
<h2 id="存储控制器与外设的关系"><a href="#存储控制器与外设的关系" class="headerlink" title="存储控制器与外设的关系"></a>存储控制器与外设的关系</h2><p>本书所用的开发板使用了存储控制器的BANK0-BANK6，分别接如下设备：NOR Flash、IDE接口、10M网卡 CS8900A、100M网卡DM9000、扩展串口芯片16C2550、SDRAM。连线方式如下图所示：<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/2.jpeg" alt="img not found"><br>根据图6.1可以知道各个BANK的起始地址，但是还需要结合图6.2中用到的地址线才能确定相关外设的访问地址。这些地址线所确定的地址值，再加上这个BANK的起始地址，就是这个外设的访问地址。<br>选择一个复杂的BANK—扩展串口作为例子。</p>
<ol>
<li>它使用nGCS5，起始地址作为0x28000000；</li>
<li>nCSA&#x3D;ADDR24 || nGCS5，nCSB&#x3D;!ADDR24 || nGCS5。当ADDR24和nGCS5均为低电平时选中扩展串口A；当ADDR24为高电平、nGCS5为低电平时选中扩展串口B。</li>
<li>CPU的ADDR0-ADDR2连接到扩展串口的A0-A2。所以访问空间有8字节。<br>综上所述，扩展串口A的访问空间为：0x28000000-0x28000007；扩展串口B的访问空间为：0x29000000-0x29000007。</li>
</ol>
<p>BANK0-BANK5的连接方式都是相似的，BANK6连接SDRAM时复杂一点，CPU提供了一组用于SDRAM的信号。</p>
<ol>
<li>SDRAM时钟有效信号SCKE；</li>
<li>SDRAM时钟信号SCLK0&#x2F;SCLK1；</li>
<li>数据掩码信号DQM0、DQM1、DQM2、DQM3；</li>
<li>SDRAM片选信号nSCS0（它与nGCS6是同一个引脚的两个功能）；</li>
<li>SDRAM行地址选通脉冲信号nSRAS；</li>
<li>SDRAM列地址选通脉冲信号nSCAS；</li>
<li>写允许信号mWE（它不是专用于SDRAM的）。<br>SDRAM的内部是一个存储阵列，阵列就如同表格一样，把数据填进去，和表格的检索原理一样，先指定一个行（Row），再指定一个列（Column），就可以找到所需的单元格，这就是SDRAM的寻址的基本原理。这个单元格称为存储单元，这个表格就是逻辑BANK（L-BANK），SDRAM一般含有4个L-BANK。<br>对SDRAM的访问可以分为如下4个步骤：</li>
<li>CPU发出片选信号，nSCS0有效，它选中SDRAM芯片。</li>
<li>SDRAM中有4个L-BANK,需要两个地址线来选择其中一个，从图6.2可知使用ADDR24、ADDR25作为L-BANK的选择信号。</li>
<li>对被选中的芯片进行统一的行&#x2F;列（存储单元）寻址。<br>根据SDRAM芯片的列地址线数目选择CPU的相关寄存器后，CPU就会从32位的地址中自动分出L-BANK选择信号，行地址信号，列地址信号，然后发出行地址信号、列地址信号。L-BANK选择信号在发出行地址信号的同时发出，并维持到列地址信号结束。<br>在图6.2中，行地址、列地址公用地址线ADDR2-ADDR14（BANK6位宽位32，ADDR0&#x2F;1没有使用），使用nSRAS、nSCAS两个信号来区分它们。比如本开发板中，使用两根地址线ADDR24、ADDR25作为L-BANK的选择信号；SDRAM芯片K4S561632的行地址数位13，列地址数为9，所以当nSRAS信号有效时，ADDR2-ADDR14上发出的是行地址信号，它对应32位地址空间的bit[23::11]；当nSCAs信号有效时，ADDR2-ADDR10上发出的是列地址信号，它对应32位地址空间的bit[10:2]；由于图6.2中BANK6以32位的宽度外接SDRAM，ADDR0、ADDR1恒为0，不参与译码。</li>
<li>找到存储单元后，被选中的芯片就要进行统一的数据传输了。<br>开发板中使用两片16位的SDRAM芯片并联组成32位的位宽，与CPU的32根数据线（DATA0-DATA31）相连。<br>BANK6的起始地址为0x30000000，所以SDRAM的访问地址为0x30000000-0x33ffffff，共64M。<br>对6.2图中连接的外设，它们的访问地址（物理地址）如下表所示：<table>
<thead>
<tr>
<th>BANKx</th>
<th>外设名称</th>
<th>起始地址</th>
<th>结束地址</th>
<th>大小（字节）</th>
<th>位宽</th>
</tr>
</thead>
<tbody><tr>
<td>BANK0</td>
<td>NOR Flash</td>
<td>0x00000000</td>
<td>0x001FFFFF</td>
<td>2M</td>
<td>16</td>
</tr>
<tr>
<td>BANK1</td>
<td>IDE 接口命令块寄存器</td>
<td>0x08000000</td>
<td>0x0800000F</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>BANK2</td>
<td>IDE 接口控制块寄存器</td>
<td>0x10000000</td>
<td>0x1000000F</td>
<td>16</td>
<td>16</td>
</tr>
<tr>
<td>BANK3</td>
<td>10M网卡CS8900A</td>
<td>0x19000000</td>
<td>0x190FFFFF</td>
<td>1M</td>
<td>16</td>
</tr>
<tr>
<td>BANK4</td>
<td>10&#x2F;100M网卡DM9000</td>
<td>只有两个地址 0x20000000 和 0x20000004</td>
<td></td>
<td>2M</td>
<td>16</td>
</tr>
<tr>
<td>BANK5</td>
<td>扩展串口A</td>
<td>0x28000000</td>
<td>0x28000007</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>BANK6</td>
<td>扩展串口B</td>
<td>0x29000000</td>
<td>0x29000007</td>
<td>8</td>
<td>8</td>
</tr>
<tr>
<td>BANK7</td>
<td>SDRAM</td>
<td>0x30000000</td>
<td>0x33FFFFFF</td>
<td>64M</td>
<td>32</td>
</tr>
</tbody></table>
</li>
</ol>
<p>注：10M网卡CS8900A使用nIOR、nIOW作为读&#x2F;写使能信号时，ADDR24必须为1。</p>
<h2 id="存储控制器的寄存器使用方法"><a href="#存储控制器的寄存器使用方法" class="headerlink" title="存储控制器的寄存器使用方法"></a>存储控制器的寄存器使用方法</h2><p>存储控制器共有13个寄存器，BANK0-BANK5只需要设置BWSCON和BANKCONx（x为0-5）两个寄存器，BANK6、BANK7外接SDRAM时，除BWSCON和BANKCONx（x为6、7）外，还要设置REFRESH、BANKSIZE、MRSRB6、MRSRB7等4个寄存器。</p>
<ol>
<li>位宽和等待控制寄存器BWSCON（BUS WIDTH &amp; WAIT CONTROL REGISTER）<br>BWSCON中每4位控制一个BANK。最高4位对应BANK7、接下来4位对应BANK6、依此类推。<br>STx：启动&#x2F;禁止SDRAM的数据掩码引脚，对于SDRAM，此位为0；对于SRAM此位为1。<br>DWx：使用两位来设置相应BANK的位宽。0b00对应8位，0b01对应16位，0b10对应32位，0b11保留。<br>WSx：是否使用存储器的WAIT信号，通常设为0。<br>比较特殊的是BANK0，他没有ST0和WS0，DW0（[2:1]）只读，0b01表示16位，0b10表示32位，BANK0只支持16、32两种位宽。</li>
<li>BANK控制寄存器BANKCONx（BANK CONTROL REGISTER x为0-5）<br>这几个寄存器控制BANK0-BANK5外接设备的访问时序。</li>
<li>BANK控制寄存器BANKCONx（BANK CONTROL REGISTER x为6-7）<br>在8个BANK中，只有BANK6和BANK7可以外接SRAM或者SDRAM，所以BANKCON6-BANKCON7与BANKCON0-BANKCON5有点不同。<br>MT[16:15]：用于设置本BANK外接的是ROM&#x2F;SRAM还是SDRAM。SRAM-0b00，SDRAM-0b11。当MT&#x3D;0b00时，此寄存器与BANKCON0-BANKCON5类似，当MT&#x3D;0b11时，此寄存器其他值如下设置：<br>Trcd[3:2]：RAS to CAS delay，设为推荐值，0b01。<br>SCAN[1:0]：SDRAM的列地址位数，对于本开发板使用的SDRAM K4S561632，列地址位数为9，所以SCAN&#x3D;0b01。如果使用其他型号的SDRAM，需要查看其数据手册来决定SCAN的取值。0b00表示8位，0b01表示9位，0b10表示10位。</li>
<li>刷新控制寄存器REFRESH（REFRESH CONTROL RFEGISTER）：设为0x008C0000 + R_CNT<br>REFEN[23]：0&#x3D;禁止SDRAM的刷新功能，1&#x3D;开启SDRAM的刷新功能。<br>TREFMD[22]：SDRAM的刷新模式，0&#x3D;CBR&#x2F;ATUO Refresh，1&#x3D;Self Refresh（一般在系统休眠时使用）。<br>Trp[21:20]设为0即可。<br>Tsrc[19:18]：设为默认值0b11即可。<br>Refresh Counter[10:0]：即上述的R_CNT。可如下计算（SDRFAM的时钟频率就是HCLK）：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R_CNT = 2^11 + 1 - SDRAM时钟频率(MHZ) + SDRAM刷新周期（uS）</span><br></pre></td></tr></table></figure>
SDRAM的刷新周期在SDRAM的数据手册上有标明，在本开发板上使用的SDRAM K4S561632的数据手册上，可以看见这么一行”64ms refresh period （8K Cycle）“。所以，刷新周期&#x3D;64ms&#x2F;8192 &#x3D; 7.8125 us。<br>在未使用PLL时，SDRAM的时钟频率等于晶振频率，12MHz。现在可以计算：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">R_CNT = 2^11 + 1 - 12 * 7.8125 = 1955</span><br></pre></td></tr></table></figure>
所以在未使用PLL时，REFRESH &#x3D; 0x008C0000 + 1955 &#x3D; 0x008C07A3。</li>
<li>BANKSIZE寄存器REFRESH （BANKSIZE REGISTER）<br>BURST_EN[7]：0&#x3D; ARM核禁止突发传输，1&#x3D;ARM核支持突发传输。<br>SCKE_EN[5]：0&#x3D;不使用SCKE信号令SDRAM进入省电模式，1&#x3D;使用SCKE信号令SDRAM进入省电模式。<br>SCLK_EN[4]：0&#x3D;时刻发出SCLK信号，1&#x3D;仅在访问SDRAM期间发出SCLK信号（推荐）。<br>BK76MAP[2:0]：设置BANK6&#x2F;7的大小。<br>BANK6&#x2F;7对应的地址空间与BANK0-5不同，BANK0-5的地址空间大小都是固定的128MB，地址范围是（x * 128M）到（x + 1）* 128M-1，x表示0到5。BANK6&#x2F;7的大小是可变的，以保持这两个空间的地址连续，即BANK7的起始地址会随他们的大小而变化。  BK76MAP的取值意义如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">0b010 = 128MB/128MB,0b001 = 64MB/64MB,0b000 = 32MB/32MB,</span><br><span class="line">0b111 = 16MB/16MB,0b110 = 8MB/8MB,0b101 = 4M/4M,0b100 = 2M/2M</span><br></pre></td></tr></table></figure>
本开发板BANK6外接64MB的SDRAM，令[2:0]&#x3D;0b001，表示BANK6&#x2F;7的容量都是64MB，虽然BANK7未使用。</li>
<li>SDRAM模式设置寄存器MRSRBx（SDRAM MODE REGISTER SET REGISTER，x为6-7）<br>能修改的只有为CL[6:4]，这是SDRAM时序的一个时间参数：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">[work]0b000 = 1 clock,0b010  = 2 clocks,0b011 = 3 clocks</span><br></pre></td></tr></table></figure>
SDRAM K4S561632不支持CL&#x3D;1的情况，所以位[6:4]取值为0b010(CL &#x3D; 2)或0b011(CL &#x3D; 3)。</li>
</ol>
<h1 id="存储控制器操作实例：使用SDRAM"><a href="#存储控制器操作实例：使用SDRAM" class="headerlink" title="存储控制器操作实例：使用SDRAM"></a>存储控制器操作实例：使用SDRAM</h1><h2 id="代码详解及程序的复制、跳转过程"><a href="#代码详解及程序的复制、跳转过程" class="headerlink" title="代码详解及程序的复制、跳转过程"></a>代码详解及程序的复制、跳转过程</h2><p>从NAND Flash启动CPU时，CPU会通过内部的硬件将NAND Flash开始的4KB数据复制到称为”Steppingstone“的4KB的内部RAM中（起始地址为0），然后跳到地址0开始执行。<br>本实例先使用汇编语言设置好存储控制器，使外接的SDRAM可用：然后把程序本身从Steppingstone复制到SDRAM处，最后跳到SDRAM中执行。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">File:head.S</span></span><br><span class="line"><span class="comment">功能：设置SDRAM，将程序复制到SDRAM，然后跳到SDARM执行</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">.equ    MEM_CTL_BASE,       <span class="number">0x48000000</span></span><br><span class="line">.equ    SDRAM_BASE,         <span class="number">0x30000000</span></span><br><span class="line"></span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">    bl  disable_watch_dog                       @关闭看门狗，否则CPU会一直重启</span><br><span class="line">    bl  memsetup                                @设置存储控制器</span><br><span class="line">    bl  copy_steppingstone_to_sdram             @复制代码到SDRAM中</span><br><span class="line">    ldr pc,=on_sdram                            @跳到SDRAM中执行</span><br><span class="line">on_sdram:</span><br><span class="line">    ldr sp,=<span class="number">0x34000000</span>                          @设置栈</span><br><span class="line">    bl  main</span><br><span class="line">    </span><br><span class="line">halt_loop:</span><br><span class="line">    b   halt_loop</span><br><span class="line"></span><br><span class="line">disable_watch_dog:</span><br><span class="line">    mov r1,#<span class="number">0x53000000</span>                          @看门狗寄存器</span><br><span class="line">    mov r2,#<span class="number">0x0</span>                                 @往里写<span class="number">0</span></span><br><span class="line">    str r2,[r1]</span><br><span class="line">    mov pc,lr                                   @返回</span><br><span class="line"></span><br><span class="line">copy_steppingstone_to_sdram:</span><br><span class="line">                                                @将Steppingstone的<span class="number">4</span>KB数据全部复制到SDRAM中去。</span><br><span class="line">                                                @Steppingstone起始地址为<span class="number">0x00000000</span>，SDRAM中起始地址为<span class="number">0x30000000</span></span><br><span class="line">    mov r1,#<span class="number">0</span>                                   </span><br><span class="line">    ldr r2,=SDARM_BASE</span><br><span class="line">    mov r3,#<span class="number">4</span>*<span class="number">1024</span></span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    ldr r4,[r1],#<span class="number">4</span>                              @从Steppingstone读取<span class="number">4</span>字节的数据，并让源地址加<span class="number">4</span></span><br><span class="line">    str r4,[r2],#<span class="number">4</span>                              @将此<span class="number">4</span>字节的数据复制到SDRAM中，并让目的地址加<span class="number">4</span></span><br><span class="line">    cmp r1,r3                                   @判断是否完成：源地址等于Steppingstone的末地址</span><br><span class="line">    bne lb                                      @若没有复制完，继续</span><br><span class="line">    mov pc, lr                                  @返回</span><br><span class="line"></span><br><span class="line">memsetup:</span><br><span class="line">                                                @设置存储控制器以便使用SDRAM外设</span><br><span class="line">    mov r1,#MEM_CTL_BASE                        @存储控制器的<span class="number">13</span>个寄存器的开始地址</span><br><span class="line">    adrl    r2,mem_cfg_val                      @这<span class="number">13</span>个值的起始存储地址</span><br><span class="line">    add r3,r1,#<span class="number">52</span>                               @<span class="number">13</span>*<span class="number">4</span> = <span class="number">52</span></span><br><span class="line"></span><br><span class="line">l:</span><br><span class="line">    ldr r4,[r2],#<span class="number">4</span>                              @读取设置值，并让r2加<span class="number">4</span></span><br><span class="line">    str r4,[r1],#<span class="number">4</span>                              @将此值写入寄存器，并让r1加<span class="number">4</span></span><br><span class="line">    cmp r1,r3                                   @判断是否设置完所有<span class="number">13</span>个寄存器</span><br><span class="line">    bne lb                                      @若没有完成，继续</span><br><span class="line">    mov pc,lr                                   @返回</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">.align <span class="number">4</span></span><br><span class="line">mem_cfg_val:</span><br><span class="line">                                                @存储控制器<span class="number">13</span>个寄存器的设置值</span><br><span class="line">    .<span class="type">long</span> <span class="number">0x22011110</span>    </span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000700</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00018005</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00018005</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x008C07A3</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x000000B1</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000030</span></span><br><span class="line">    .<span class="type">long</span> <span class="number">0x00000030</span></span><br></pre></td></tr></table></figure>
<p>12-18行是程序的主题，为了使得程序结构明了，主要使用了函数调用的方式。<br>第12行禁止看门狗，否则看门狗会不断重启系统，往看门狗寄存器（0x53000000）里写0即可禁止看门狗。<br>第13行设置存储控制器的13个寄存器，以便使用SDRAM。<br>第14行将Steppingstone中的代码复制到SDRAM中（起始地址为0x30000000）。<br>第15行向pc寄存器直接赋值跳到SDRAM中执行下一条指令”ldr sp，&#x3D;0x34000000“。、<br>第17行设置栈，调用c函数之前必须设置好栈。<br>第18行调用C函数main。<br>程序是如何从Steppingstone跳到SDRAM中去执行的呢？<br>这是通过第15行的”ldr pc,&#x3D;on_sdram“指令完成的。程序标号”on_stream“这个地址值在连接程序时被确定为0x30000010（这是SDRAM的地址），执行”ldr pc,&#x3D;on_sdram“后，程序一下子就跳到SDRAM中去了。<br>”on_sdram“这个地址值为什么等于0x30000010？<br>Makefile中连接程序的命令为”arm-linux-ld -Ttext 0x30000000 head.o sdram.o -o sdram_elf“，意思就是代码段的起始地址为0x30000000，即程序的第一条指令（第12行）的连接地址为0x30000000，第二条指令（第13行）的连接地址是0x30000004，…,第五条指令（第17行）的连接地址为0x300000010，其程序标号”on_sdram“的值即为0x300000010。<br>虽然第12-14行指令的连接地址都在SDRAM中，但是由于它们都是位置无关的相对跳转指令，所以可以在Steppingstone里执行。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -g -c -o head.o head.S</span><br><span class="line">arm-linux-gcc -g -c -o leds.o leds.c</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 -g head.o leds.o -o sdram_elf</span><br><span class="line">arm-linux-objcopy -O binary -S sdram_elf sdram_elf.bin</span><br><span class="line">arm-linux-objdump -D -m arm sdram_elf &gt; sdram_elf.dis</span><br></pre></td></tr></table></figure>
<p>下图所示程序从Steppingstone 到SDRAM 的执行过程。<br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/3.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/4.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/5.png" alt="img not found"><br><img src="/2022/08/11/%E5%AD%98%E5%82%A8%E6%8E%A7%E5%88%B6%E5%99%A8/6.png" alt="img not found"></p>
<h2 id="实例测试"><a href="#实例测试" class="headerlink" title="实例测试"></a>实例测试</h2><p>生成的sdram.bin下载到板子上运行之后，可以发现与leds程序相比，LED灯闪烁的更慢，原因是外部的SDRAM的性能比内部SRAM差一些。<br>把程序从性能更好的内部SRAM移到外部SDRAM中去，是否多此一举？内部的SRAM只有4KB大小，如果程序大于4KB，那么就不指望完全利用内部SRAM来运行了，就得想办法把存储在NAND Flash中的代码复制到SDRAM中去。对于NAND Flash的前4KB，芯片自动把它复制到内部SRAM中，可以很轻松的再把它复制到SDRAM中（实验代码中的函数copy_steppingstone_to_sdram就有此功能），要复制4KB后面的代码需要使用NAND Flash控制器来读取NAND Flash。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第6章 存储控制器</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
  <entry>
    <title>嵌入式编程基础知识</title>
    <url>/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<p>《嵌入式Linux应用完全开发手册》第1篇第3章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解交叉编译工具链的各种选项</li>
<li>掌握连接脚本的编译方法</li>
<li>了解Makefile文件中常用的函数</li>
<li>了解几个常用的ARM汇编指令</li>
<li>了解汇编程序调用C函数所遵循的ATPCS规则</li>
</ol>
<h1 id="交叉编译工具选项说明"><a href="#交叉编译工具选项说明" class="headerlink" title="交叉编译工具选项说明"></a>交叉编译工具选项说明</h1><p>源文件需要经过编译才能生成可执行文件。在Windows上进行开发时，只需要单击几个按钮即可编译，集成开发环境已经将各种编译工具的使用封装好了。Linux下也有很多优秀的集成开发工具，但是更多的是时候是直接使用编译工具；即使使用集成开发工具，也需要掌握一些编译选项。<br>PC上的编译工具链为gcc、ld、objcopy、objdump等，它们编译出来的程序在x86平台上运行。要编译出在ARM平台上运行的程序，必须要使用交叉编译工具arm-linux-gcc、arm-linux-ld。</p>
<h2 id="arm-linux-gcc选项"><a href="#arm-linux-gcc选项" class="headerlink" title="arm-linux-gcc选项"></a>arm-linux-gcc选项</h2><p>一个c&#x2F;c++文件需要经过预处理，编译，汇编，链接等4步才能变成可执行文件。</p>
<ol>
<li>预处理<br>c&#x2F;c++源文件中，以”#“开头的命令被称为预处理命令。如包含命令”#include“，宏定义命令”#define“，条件编译命令”#if“，”#ifdef“等。预处理就是将要包含的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些代码输入到一个”.i“文件中等待进一步处理。预处理将要用到arm-linux-cpp工具。</li>
<li>编译<br>编译就是把c&#x2F;c++代码”翻译“汇编代码，所用到的工具为ccl（它的名字就是ccl，而不是arm-linux-ccl）。</li>
<li>汇编<br>汇编就是将第二步输出的汇编代码翻译成一定格式的机器代码，在Linux系统上一般表现为ELF（OBJ文件），用到的工具为arm-linux-as。”反汇编“是指将机器代码转换为汇编代码，这在调试程序时常常用到。</li>
<li>连接<br>连接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件连接起来，最终生成可以在特定平台运行的可执行文件，用到的工具是arm-linux-ld。<br>编译器利用这4个步骤中的一个或者多个来处理输入文件，源文件的后缀名表示源文件所用的语言，后缀名控制着编译器的默认动作。</li>
</ol>
<table>
<thead>
<tr>
<th>后缀名</th>
<th>语言种类</th>
<th>后期操作</th>
</tr>
</thead>
<tbody><tr>
<td>.c</td>
<td>c源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.C</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cc</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cxx</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.m</td>
<td>Object-C 源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.i</td>
<td>预处理后的c文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.ii</td>
<td>预处理后的c++文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.s</td>
<td>汇编语言源程序</td>
<td>汇编</td>
</tr>
<tr>
<td>.S</td>
<td>汇编语言源程序</td>
<td>预处理、汇编</td>
</tr>
<tr>
<td>.h</td>
<td>预处理器文件</td>
<td>通常不出现在命令行上</td>
</tr>
</tbody></table>
<p>其他后缀名的文件被传递给连接器（linker），通常包括一下两种：<br>.o：目标文件（Object file，OBJ文件）。<br>.a：归档库文件（Archive file）。<br>在编译过程中，除非使用了”-c“，”-S“,或者”-E“选项，或者编译错误组织了完整的编译过程，否则最后的步骤总是连接。在连接阶段中，所有对应于源程序的.o文件、”-l“选项指定的库文件、无法识别的文件名（包括指定的”.o“目标文件和”.a“库文件）按命令行中的顺序传递给连接器。<br>以一个简单的”Hello World“C程序为例：</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="comment">/*File : hello.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用arm-linux-gcc，只需要一个命令就可以生成可执行文件hello，它包含了4个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>加上”-v“选项，可以查看编译的细节：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ccl hello.c -o /tmp/cctETob7.s</span><br><span class="line">as -o /tmp/ccvv2KbL.o /tmp/cctETob7.s</span><br><span class="line">collect2 -o hello   crtl.o  crti.o  crtbegin.o /tmp/ccvv2KbL.o crtend.o crtn.o</span><br></pre></td></tr></table></figure>
<p>以上三个命令分别对应于编译步骤中的预处理+编译、汇编和连接，ld被collect2调用来连接程序。预处理和编译被放在了一个命令中（ccl）进行，可以把它再次拆分为一下两步：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cpp -o hello.i hello.c</span><br><span class="line">ccl hello.i -o /tmp/cctETob7.s</span><br></pre></td></tr></table></figure>
<p>可以通过各种选项来控制arm-linux-gcc的动作，下面介绍一些常用的选项。</p>
<h3 id="总体选项"><a href="#总体选项" class="headerlink" title="总体选项"></a>总体选项</h3><ol>
<li>-c<br>预处理、编译和汇编源文件，但是不作连接，编译器根据源文件生成OBJ文件。默认情况下，GCC通过用”.o“替换文件名的后缀”.c“，”.i“，”.s“等，产生OBJ文件名。可以使用”-o“选项选择其他名字。GCC忽略”-c“选项后面任何无法识别的输入文件。</li>
<li>-S<br>编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。默认情况下，GCC通过用”.s“替换源文件名后缀”.c“，”.i“等，产生汇编文件名。可以使用”-o“选项选择其他名字。GCC忽略任何不需要汇编的输入文件。</li>
<li>-E<br>预处理后即停止，不进行编译。预处理后的代码送往标准输出。GCC忽略任何不需要预处理的输入文件。</li>
<li>-o file<br>指定输出文件为file。无论下是预处理、编译、汇编还是连接，这个选项都可以使用，</li>
<li>-v<br>显示制作GCC工具自身时的配置命令；同时显示编译器驱动程序、预处理器、编译器的版本号。<br>以一个程序为例，它包含三个文件：<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">File:main.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main fun\n&quot;</span>);</span><br><span class="line">    sub_fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File:sub.h</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">File:sub.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pintf(<span class="string">&quot;Sub fun\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用上述命令进行编译：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
其中，main.o、sub.o是经过了预处理、编译、汇编后生成的OBJ文件，它们还没有被连接成可执行文件；最后一步将它们连接成可执行文件test，可以直接运行以下命令：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Main fun</span><br><span class="line">Sub fun</span><br></pre></td></tr></table></figure>
现在试试其他选项，以下命令生成的main.s是main.c的汇编语言文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -S -o main.s  main.c</span><br></pre></td></tr></table></figure>
以下命令对main.c进行预处理，并将得到的结果打印出来，里面包含了所有包含的文件、所有定义的宏。在编写程序时，有时候查找某个宏定义是非常繁琐的事情，可以使用”-dM-E“选项来查看。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -E main.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="警告选项"><a href="#警告选项" class="headerlink" title="警告选项"></a>警告选项</h3><p>”-Wall“选项基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明前就使用的函数、局部变量除了声明就没有再使用等。<br>编译上面的main.c文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -Wall -c main.c</span><br></pre></td></tr></table></figure>
<p>得到的警告信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.c:In function &quot;main&quot;</span><br><span class="line">main.c:6 warning: unused variable &quot;i&quot;</span><br></pre></td></tr></table></figure>
<p>这个警告虽然对程序没有坏的影响，但是有些警告需要加以关注，比如匹配类型的警告等。</p>
<h3 id="调试选项"><a href="#调试选项" class="headerlink" title="调试选项"></a>调试选项</h3><p>-g: 加入只有GDB才使用的额外调试信息。</p>
<h3 id="优化选项"><a href="#优化选项" class="headerlink" title="优化选项"></a>优化选项</h3><ol>
<li>-O或者-O1<br>优化：对于大多数函数，优化编译的过程将占用较长的时间和相当大的内存。不使用”-O“选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的。如果在两条语句之间用断点中止程序，可以对任何变量进行赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确获取所期待的结果。<br>不使用”-O“或者”-O1“选项时，只有声明了register的变量才分配使用寄存器。<br>使用了”-O“或者”-O1“选项时，编译器会试图减少目标码的大小和执行时间。如果指定了”-O“或者”-O1“选项，”-fthread-jumps“和”-fdefer-pop“选项被打开。在有delay slot的机器上，”-fdelayed-branch“选项将被打开。在既没有帧指针又支持调试的机器上，”-fomit-frame-pointer“选项将被打开。某些机器上还可能打开其他选项。</li>
<li>-O2<br>多优化一些。除了涉及空间和速度的优化选项，执行几乎所有的优化工作。例如不进行循环展开和函数内嵌。和”-O“选项相比，这个选项既增加了编译时间，也提高了生成代码的运行效果。</li>
<li>-O3<br>优化的更多，除了打开”-O2“所做的一切，它还打开了”-finline-functions“选项。</li>
<li>-O0<br>不优化。<br>如果指定了多个”-O0“选项，不管带不带数字，生效的是最后一个选项。</li>
</ol>
<h3 id="链接器选项"><a href="#链接器选项" class="headerlink" title="链接器选项"></a>链接器选项</h3><p>下面的选项用于连接OBJ文件，输出可执行文件或者库文件。</p>
<ol>
<li>object-file-name<br>如果某些文件没有特别明确的后缀。GCC就认为它是OBJ文件或者库文件。如果GCC执行连接操作，这些OBJ文件就会成为连接器的输入文件。例如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
main.o和sub.o就是输入的文件。</li>
<li>-llibrary<br>连接名为library的库文件。<br>连接器在搜索标准目录中寻找这个库文件，库文件的真正名字”liblibrary.a“。搜索目录除了一些系统标准目录外，还包括用户以”-L“选项指定的路径。一般来说用这个方法找到的文件就是<code>库文件---即由OBJ文件组成的归档文件</code>。连接器处理归档文件的方法是：扫面归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义。但是，如果连接器普通的OBJ文件，而不是库文件，就把这个OBJ文件按照平常方式连接进来。指定”-l“选项和指定文件名的唯一区别是，”-l“选项用”lib“和”.a“把library包裹起来，而且搜索一些目录。<br>即使不明显的使用”-llibrary“选项，一些默认的库也被连接进去，可以使用”-v“选项看到这点。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker /lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtl.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../ctri.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtbegin.o</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o</span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtend.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtn.o</span><br></pre></td></tr></table></figure>
可以看见，除了main.o、sub.o两个文件外，还连接了启动文件crtl.o、crti.o、crtend.o、crtn.o，还有一些库文件（-lgcc、-lgcc_eh、-lc、-lgcc、-lgcc_eh）。</li>
<li>-nostartfiles<br>不连接系统标准启动文件，而标准库文件依然正常使用：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -nostartfiles -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/ld:warning:cannot find entry symbol _start;defaulting to 08048184</span><br></pre></td></tr></table></figure>
可以看见启动文件ctll.o、ctri.o、crtend.o、crtn.o没有被连接进去。需要说明的是，对于一般应用程序，这些启动文件是必须的，这里仅是作为例子（这样编译出来的test文件无法执行）。在编译bootloader、内核时，将用到这个选项。</li>
<li>-nostdlib<br>不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器，这个选项常用于编译内核，bootloader等程序，它们不需要启动文件，标准库文件。仍以options程序作为例子：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">/usr/bin/ld:warning:cannot find entry symbol _start;defaulting to 08048074</span><br><span class="line">main.o(.text + 0x19):In function &quot;main&quot;:</span><br><span class="line">:undefined referendce to &quot;printf&quot;</span><br><span class="line">sub.o(.text + 0xf):In function &quot;sub_fun&quot;:</span><br><span class="line">:undefined reference to &quot;printf&quot;</span><br><span class="line">collect2:ld returned 1 exit status</span><br></pre></td></tr></table></figure>
出现了一大堆错误，因为printf等函数是在库文件中实现的。在编译bootloader、内核时，用到这个选项，它们用的很多函数都是自包含的。</li>
<li>-static<br>在支持动态连接的的系统上阻止连接共享库。<br>仍以options程序作为例子,使用和不使用”-static“选项编译出来的可执行程序大小相差巨大：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.c</span><br><span class="line">$ gcc -c -o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br><span class="line">$ gcc -o test_static mian.o sub.o -static </span><br><span class="line">$ ls -l test test_static</span><br><span class="line">6591 test</span><br><span class="line">546479 test_static</span><br></pre></td></tr></table></figure>
其中test文件为6591字节，test_static为546479字节。当不使用”-static“编译文件时，程序执行前要连接共享库文件，所以还需要将共享库文件放入文件系统中。</li>
<li>-shared<br>生成一个共享OBJ文件，它可以和其他OBJ文件连接产生可执行文件。只有部分系统支持该选项。<br>当不想以源代码发布程序时，可以使用”-shared“选项生成库文件，比如对于options程序，可以如下制作库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure>
以后要使用sub.c中的sub_fun时，在连接程序时，将sub.a加入即可。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure>
可以将多个文件制作为一个库文件，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub.o sub2.o sub3.o</span><br></pre></td></tr></table></figure></li>
<li>-Xlinker option<br>把选项option传递给连接器。可以用来传递系统特定的连接选项，GCC无法识别这些选项。如果需要传递携带参数的选项，必须使用两次”-Xlinker“，一次传递选项，另一次传递其参数。例如，如果传递”-arsset-definitions“，要写成”-Xlinker -assert -Xlinker definitions“，而不能写成”-Xlinker -assert definitions“。因为这样会把整个字符串当作一个参数传递，显然不是连接器期待的。</li>
<li>-Wl，option<br>把选项option传递给连接器 。如果option中含有逗号，就在逗号处分割成多个选项。连接器通常都是通过gcc，arm-linux-gcc等命令间接启动的，要向他传入参数时，参数前面加上”-Wl,“。</li>
<li>-u symbol<br>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义。可以使用多个”-u“选项，各自跟上不同的符号，使得连接器调入附加的模块。</li>
</ol>
<h3 id="目录选项"><a href="#目录选项" class="headerlink" title="目录选项"></a>目录选项</h3><p>下列选项指定搜索路径，用于查找头文件，库文件或者编译器的某些成员。</p>
<ol>
<li>-Idir<br>在头文件的搜索路径列表添加dir目录。头文件的搜索方法为：如果以”#include &lt;&gt;“包含文件，则只会在标准库目录开始搜索（包括使用-Idir选项定义的目录）；如果以”#include “包含文件，则先从用户的工作目录开始搜索，再搜索标准库目录。</li>
<li>-I-<br>任何在”-I-“前面用”-I“选项指定的搜索路径只适用于”#include ’file‘“这种情况；它们不能用来搜索”#include&lt;&gt;“包含的头文件。如果用”-I“选项指定的搜索路径位于”-I-“选项后面，就可以在这些路径中搜索所有的”#include“指令。”-I-“选项能够阻止当前目录成为搜索”#include ’file‘“的第一选择。</li>
<li>-Ldir<br>在”-L“选项的搜索路径中添加dir目录，仍然使用options程序进行说明，先制作库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o libsub.a sub.o</span><br></pre></td></tr></table></figure>
编译main.c：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br></pre></td></tr></table></figure>
连接程序，下面的指令将会出错，提示找不到库文件：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -o test main.o -lsub</span><br><span class="line">/usr/bin/ld: cannot find lsub</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
可以使用”-Ldir“选项将当前目录加入搜索路径，如下则连接成功：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ gcc -L. -o test main.o -lsub</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-ld选项"><a href="#arm-linux-ld选项" class="headerlink" title="arm-linux-ld选项"></a>arm-linux-ld选项</h2><p>arm-linux-ld将用于多个目标文件、库文件连接成可执行文件。</p>
<h3 id="直接指定代码段、数据段、bss段的起始地址"><a href="#直接指定代码段、数据段、bss段的起始地址" class="headerlink" title="直接指定代码段、数据段、bss段的起始地址"></a>直接指定代码段、数据段、bss段的起始地址</h3><p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure>
<p>其中的”startaddr“分别代表代码段、数据段和bss段的起始地址，它是一个十六进制数。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure>
<p>它代表的代码段的运行地址为0x00000000，<code>由于没有定义数据段、bss段的起始地址，它们被依次放在代码段的后面</code>。<br>以一个例子来说明”-Ttext“选项的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.text </span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">  b step1</span><br><span class="line">step1:</span><br><span class="line">  ldr pc, =step2</span><br><span class="line">step2:</span><br><span class="line">  b step2 </span><br></pre></td></tr></table></figure>
<p>使用下面的命令编译、连接、反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-gcc -c -o link.o link.s</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 link.o -o  link_elf_0x00000000</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 link.o -o  link_elf_0x30000000</span><br><span class="line">arm-lihux-objdump -D link_elf_0x00000000 &gt; link_0x00000000.dis</span><br><span class="line">arm-lihux-objdump -D link_elf_0x30000000 &gt; link_0x30000000.dis</span><br></pre></td></tr></table></figure>
<p>例子中用到了两种跳转方法：b跳转指令、直接向pc寄存器赋值。先列出不同“-Ttext”选项下生成的反汇编文件，在详细分析由于不同运行地址带来的差异及影响。两个反汇编文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">link_0x00000000.dis                       link_0x30000000.dis</span><br><span class="line">0: eaffffff b 0x4                         0: eaffffff b 0x4</span><br><span class="line">4: e59ff000 ldr pc, [pc, #0]              4: e59ff000 ldr pc, [pc, #0]</span><br><span class="line">8: eafffffe b 0x8                         8: eafffffe b 0x8</span><br><span class="line">c: 00000008 andeq r0, r0, r8              c: 30000008 tsteq r0, #8 ; 0x8</span><br></pre></td></tr></table></figure>
<p>“b step1”是个相对跳转指令，其机器码的格式如下：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpeg" alt="img not found"></p>
<ol>
<li>[31:28]位是条件码。</li>
<li>[27:24]位为“1010”时，表示b跳转指令；为“1011”时，表示b1跳转指令。</li>
<li>[23::0]表示偏移地址。<br>使用“b”或者“b1”跳转时，下一条指令的地址是这样计算的：将指令中24位带符号的补码扩展为32位（扩展其符号位），将此32位数左移两位，将得到的值加到pc寄存器中，将得到跳转的目标地址。</li>
</ol>
<p>“b step1”的机器码为eaffffff。</p>
<ol>
<li>24位带符号的补码为0xffffff，将它扩展为32位得到0xffffffff。</li>
<li>将此32位数左移两位得到0xfffffffc，其值就是-4.</li>
<li>pc的值是当前指令下的下两条指令的地址，加上步骤2得到的-4，这恰好是第二条指令step1的地址。<br>请不要被反汇编代码的“b 0x4”迷惑。它不是指跳转到0x4处执行，绝对地址需要按照上述3个步骤计算。可以发现，b跳转指令依赖于当前PC寄存器的值，这个特性使得使用b指令的程序不依赖于代码存储的位置—即不管这条代码放在什么位置，b指令都可以跳到正确的位置。这类指令称为位置无关码。使用不同的“-Ttext”选项，生成的代码仍旧是一样的。<br>“ldr pc, &#x3D;step2”，从汇编码“ldr pc, [pc, #0]”可以看出，这条指令从内存中的某个位置读出数据，并赋值给PC寄存器。这个位置的地址是当前pc寄存器的值加上偏移量0。其中存放的值依赖于连接命令的“-Ttext”选项。执行这条指令之后，对于link_0x00000000.dis，pc &#x3D; 0x0000000；对于link_0x30000000.dis，pc &#x3D; 0x30000008。执行第三条指令“b step2”后，程序的运行地址就不同了：分别是0x00000008、0x30000008。<br>Bootloader、内核程序刚开始执行时，它们所处的地址通常不等于运行地址。在程序的开头，先使用b、bl、mov等“位置无关”的指令将代码从Flash等设备复制到内存的“运行地址”处，然后再跳转到“运行地址”去执行。</li>
</ol>
<h3 id="使用连接脚本设置地址"><a href="#使用连接脚本设置地址" class="headerlink" title="使用连接脚本设置地址"></a>使用连接脚本设置地址</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">arm-linux-ld -Ttimer.lds -o timer_elf head.o init.o interrupt.o main.o</span><br></pre></td></tr></table></figure>
<p>它使用连接脚本timer.lds来设置可执行文件timer_elf的地址信息，timer.lds文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  . = 0x30000000;</span><br><span class="line">  .text             : &#123;   *(.text)    &#125;</span><br><span class="line">  .rodata ALIGN(4)  : &#123;   *(rodata)   &#125;</span><br><span class="line">  .data   ALIGN(4)  : &#123;   *(data)     &#125;</span><br><span class="line">  .bss    ALIGN(4)  : &#123;   *(bss)  *(COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析timer.lds文件之前，先讲解连接脚本的格式。连接脚本的基本命令是SECTIONS命令，它描述了输出文件的映射图：输出文件中各段、各文件怎么怎么放置。一个SECTIONS命令内部包含一个或者多个段。段（Section）是连接脚本的基本单元，它表示输入文件中的某部分怎么放置。<br>完整的连接脚本格式如下，它的核心部分是段（Section）：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">···</span><br><span class="line">secname start ALIGN(align)  (NOLOAD)  : AT(ldadr)</span><br><span class="line">  &#123; contents  &#125; &gt; region :phdr =fill</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>secname 和 contents是必需的，前者用来命名这个段。后者用来确定代码中的什么部分放在这个段中。<br>start是这个段重定位地址，也称为运行地址。如果代码中有位置无关的指令，程序在运行时，这个段必须放在这个地址上。<br>ALIGN(align)：虽然start指定了运行地址，但是仍然可以使用BLOCK（align）来指定对齐的要求—这个对齐的地址才是真正的运行地址。<br>（NOLOAD）：用来告诉加载器，在运行时不用加载这个段。显然，这个选项只有在操作系统的情况下才有意义。<br>AT（ldadr）：指定这个段在编译出来的映像文件中的地址—加载地址。如果不使用这个选项，则加载地址等于运行地址。通过这个选项，可以控制各段分别保存输出文件中不同的位置，便于把文件保存到单板上：A段放在A处，B段放在B处，运行前再把A、B段分别读出来组装成一个完整的执行程序。<br>现在开始分析下timer.lds文件：</p>
<ol>
<li>第2行表示设置“当前运行地址”为0x30000000。</li>
<li>第3行定义了一个名为“.text”的段，它的内容为“* （.text）”，表示所有输入文件的代码段。这些代码段被集合在一起，起始运行地址为0x30000000。</li>
<li>第4行定义了一个名为“.rodata”的段，在输出文件timer_elf中，它紧挨着“.text”段存放。其中“ALIGN（4）”表示起始运行地址为4字节对齐。假设前面“.text”段的地址范围是0x30000000-0x300003f1，则“.rodata”段的地址为4字节对齐后的0x300003f4。</li>
<li>第5、6行的含义与第4行类似。</li>
</ol>
<h2 id="arm-linux-objcopy选项"><a href="#arm-linux-objcopy选项" class="headerlink" title="arm-linux-objcopy选项"></a>arm-linux-objcopy选项</h2><p>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可以使用不同于源文件的格式来输出目的文件，即可以进行格式转换。<br>这本书中，常用arm-linux-objcopy来将ELF格式的可执行文件转换为二进制文件。下面讲解常用的选项：</p>
<ol>
<li>input-file、outfile<br>参数input-file和outfile分别表示输入目标文件和输出目标文件。</li>
<li>-I bfdname 或 –input-target&#x3D;bfdname<br>用来指明源文件的格式，bfdname是BFD库中描述的标准格式名。如果不指明源文件格式，arm-linux-objcopy会自己去分析源文件的格式，然后去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</li>
<li>-O bfdname 或 –output-target&#x3D;bfdname<br>使用指定的格式来输出文件，bfdname是BFD库中描述的的标准格式名。</li>
<li>-F bfdname 或 –target&#x3D;bfdname<br>同时指明源文件和目的文件的格式。将源文件的内容复制到目的文件的过程中，只进行复制而不做格式转换，源文件是什么格式，目的目标文件就是什么格式。</li>
<li>-R sectionname 或 –remove-section&#x3D;sectionname<br>从输出文件中删除掉所有名为sectionname的段。这个选项可以多次使用。</li>
<li>-S 或 –strip-all<br>不从源文件复制重定位信息和符号信息到目标文件中去。</li>
<li>-g 或 –strip-debug<br>不从源文件中复制调试符号到目标文件中去。<br>在编译bootloader、内核时，常用arm-linux-objcopy命令将ELF格式的生成结果转换为二进制文件，比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ arm-linux-objcopy -O binary -S elf_file bin_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-objdump选项"><a href="#arm-linux-objdump选项" class="headerlink" title="arm-linux-objdump选项"></a>arm-linux-objdump选项</h2><p>arm-linux-objdump用于显示二进制文件信息，本书中常用来查看反汇编代码。下面讲解常用的选项：</p>
<ol>
<li>-b bfdname 或 –target&#x3D;bfdname<br>指定目标码格式。这不是必须的，arm-linux-objdump能自动识别许多格式。可以使用“arm-linux-objdump -i”命令查看支持的目标码格式。</li>
<li>–disassemble 或 -d<br>反汇编可执行段。</li>
<li>–disassemble 或 -D<br>反汇编所有段。</li>
<li>-EB或-EL或–endian&#x3D;{big|little}<br>指定字节序。</li>
<li>–file-headers或-f<br>显示文件的整体头部摘要信息。</li>
<li>–section-headers、–header或-h<br>显示目标文件各个段的头部摘要信息。</li>
<li>–info或-i<br>显示支持的目标文件格式和CPU架构，它们在“-b”、“-m”选项中用到。</li>
<li>–section&#x3D;name或-j name<br>仅显示指定section的信息。</li>
<li>–architecture&#x3D;machine或-m machine<br>指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候，这个选项很有用。可以用“-i”选项列出这里能够指定的架构。<br>在调试程序时，常用arm-linux-objdump命令来得到汇编代码。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将ELF格式的文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D elf_file &gt; dis_file</span><br><span class="line">/*将二进制文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D -b binary -m arm bin_file &gt; dis_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="汇编代码、机器码和存储器的关系以及数据的表示"><a href="#汇编代码、机器码和存储器的关系以及数据的表示" class="headerlink" title="汇编代码、机器码和存储器的关系以及数据的表示"></a>汇编代码、机器码和存储器的关系以及数据的表示</h2><p>即使使用C&#x2F;C++或者其他高级语言编程，最后也会被编译工具转换为汇编代码，并最终作为机器码存储在内存、硬盘或者其他存储器上。在调试程序时，经常需要阅读它的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">4bc:        e3a0244e: mov r2, #1308622848;</span><br><span class="line">4c0:        e3a0344e: mov r3, #1308622848;</span><br><span class="line">4c4:        e5933000: ldr r3, [r3];</span><br></pre></td></tr></table></figure>
<p>4bc、4c0、4c4是这些代码的运行地址，就是说运行前，这些指令必须位于内存中的这些地址上；e3a0244e、e3a0344e、e5933000是机器码。运行地址、机器码都是十六进制表示。CPU用到的、内存中保存的都是机器码示意如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*内存中的示意图*/</span><br><span class="line">/*地址:机器码*/</span><br><span class="line">···</span><br><span class="line">0x4bc:0xe3a0244e</span><br><span class="line">0x4c0:0xe3a0344e</span><br><span class="line">0x4c4:0xe5933000</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>“mov r2, #1308622848”、“mov r3, #1308622848”、“ldr r3, [r3]”是上述几个机器码的汇编代码。所谓汇编代码仅仅是为了方便读写而引入的，机器码和汇编代码之间也仅仅是简单的转换关系。参考CPU的数据手册，ARM的数据处指令格式为：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.jpeg" alt="img not found"><br>以机器码0xe3a0244e为例：</p>
<ol>
<li>[31:28] &#x3D; 0b1110，表示这条指令无条件执行。</li>
<li>[25] &#x3D; 0b1，表示Operand2是一个立即数。</li>
<li>[24:21] &#x3D; 0b1101，表示这是MOV指令。</li>
<li>[20] &#x3D; 0b0，表示这条指令执行时不影响状态位。</li>
<li>[15:12] &#x3D; 0b0010，表示Rd就是r2寄存器。</li>
<li>[11:0] &#x3D; 0x44e，这是一个立即数。<br>立即数占据机器码的低12位表示：最低8位的值称为immed_8，高4位称为rotate_imm。立即数的数值计算方法为：<value> &#x3D; immed_8 循环右移 （2 * rotate_imm）。对于”[11:0] &#x3D; 0x44e“，其中immed_8 &#x3D; 0x4e、rotate_imm&#x3D;0x4，所以此立即数为0x4e000000。</value></li>
</ol>
<h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>在Linux中使用Make命令来编译程序，特别是大程序；而make命令所执行的动作依赖与Makefile文件。最简单的Makefile文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">hello：hello.c</span><br><span class="line">  gcc -o hello hello.c</span><br><span class="line">clean:</span><br><span class="line">  rm -rf hello</span><br></pre></td></tr></table></figure>
<p>将上述4行存为Makefile文件（注意必须以Tab键来进行缩进第2、4行，不能以空格来进行缩进），执行make即可编译程序，执行make clean即可清除编译出来的结果。<br>make命令根据文件更新的时间戳来决定哪些文件需要重新编译，这使得可以避免编译已经编译过的、没有变化的程序，大大提高编译效率。</p>
<h2 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h2><p>一个简单的Makefile文件包含一系列”规则“，其样式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">目标（target）...：依赖（prerequiries）...</span><br><span class="line">&lt;Tab&gt;命令（command）</span><br></pre></td></tr></table></figure>
<p>目标（target）通常是要生成的文件的名称，可以是可执行文件或者OBJ文件，也可以是一个执行的动作名称，诸如”clean“。<br>依赖是用来产生目标的材料（比如源文件），一个目标通常有几个依赖。<br>命令是生成目标时的动作，一个规则可以含有几个命令，每个命令占一行。<br>通常，如果一个依赖发生了变化，就需要规则调整命令以更新或者创建目标。但是并非所有的目标都有依赖，例如，目标”clean“的作用就是清除文件，它没有依赖。<br>规则一般是用于解释怎样和何时重建目标。make首先调用命令处理依赖，进而才能创建或者更新目标。当然，一个规则也可以是用于解释怎样和何时执行一个动作，即打印提示信息。<br>一个Makefile文件可以包含规则以外的其他文本，但一个简单的Makefile文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但是格式是完全一样的。<br>对于上述Makefile，执行”make“命令时，仅当hello.c文件比hello文件新，才会执行命令”arm-linux-gcc -o hello hello.c“生成可执行文件hello；如果还没有hello文件，这个命令也会执行。<br>运行”make clean“，由于目标没有依赖项，它的命令“rm -f hello”将被强制执行。</p>
<h2 id="Makefile文件里的赋值方法"><a href="#Makefile文件里的赋值方法" class="headerlink" title="Makefile文件里的赋值方法"></a>Makefile文件里的赋值方法</h2><p>变量的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">immediate = deferred</span><br><span class="line">immediate ?= deferred</span><br><span class="line">immediate := immediate</span><br><span class="line">immediate += deferred or immediate</span><br><span class="line">define immediate</span><br><span class="line">deferred</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>在GNU make中对变量的赋值有两种方式：延时变量、立即变量。区别在于它们的定义方式和扩展时的方式不同，前者在这个变量使用时才会扩展开，意思就是当真正使用这个变量时才会确定；后者在定义时它的值就已经确定了。使用“&#x3D;”、“?&#x3D;”定义或者使用define指定定义的变量是延时变量；使用“：&#x3D;”定义的变量是立即变量。需要注意一点的的是“?&#x3D;”仅仅在变量没有定义的情况下有效，即“?&#x3D;”用来定义第一次出现的延时变量。对于附加操作符“+&#x3D;”，右边变量如果在前面使用（：&#x3D;）定义为立即变量则它也是立即变量，否则均为延时变量。</p>
<h2 id="Makefile常用函数"><a href="#Makefile常用函数" class="headerlink" title="Makefile常用函数"></a>Makefile常用函数</h2><p>函数调用的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(function arguments)</span><br></pre></td></tr></table></figure>
<p>这里“function”是函数名，“arguments”是该函数的参数。参数与函数名之间用空格或者Tab隔开，如果有多个参数，它们之间用逗号隔开。这些空格和逗号不是参数值的一部分。下面介绍一些常用的Makefile函数。</p>
<h3 id="字符串替换和分析函数"><a href="#字符串替换和分析函数" class="headerlink" title="字符串替换和分析函数"></a>字符串替换和分析函数</h3><ol>
<li>$ (subst from,to,text)<br>在文本“text”中使用“to”替换每一处“from”。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (subst ee,EE,feet on the street)</span><br><span class="line">==&gt;fEEt on the strEEt</span><br></pre></td></tr></table></figure></li>
<li>$ (patsubst pattern,replacement,text)<br>寻找“text”中符合格式“pattern”的字，用“replacement”替换它们。“pattern”和“replacement”中可以使用通配符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (patsubst %.c,%.o,x.c.c bar.c)</span><br><span class="line">==&gt;x.c.o bar.o</span><br></pre></td></tr></table></figure></li>
<li>$ (strip string)<br>去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$ (strip a   b c )</span><br><span class="line">==&gt;a b c</span><br></pre></td></tr></table></figure></li>
<li>$ (findstring find,in)<br>在字符串“in”中查找“find”，如果找到，则返回值是“find“，否则返回值为空。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(findstring a,a b c)</span><br><span class="line">==&gt;a</span><br><span class="line">$(findstring a,b c)</span><br><span class="line">==&gt;</span><br></pre></td></tr></table></figure></li>
<li>$(filter pattern…,text)<br>返回在”text“中由空格隔开且匹配格式”pattern…“的字，去除不符合格式”pattern…“的字。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;foo.c bar.c baz.s</span><br></pre></td></tr></table></figure></li>
<li>$(filter-out pattern…,text)<br>返回在”text“中由空格隔开并且不匹配格式”pattern…“的字，去除符合格式”pattern…“的字。它是函数filter的反函数。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;ugh.h</span><br></pre></td></tr></table></figure></li>
<li>$(sort list)<br>将”list“中的字按照字母顺序排列，并去掉重复的字。输出由单个空格隔开的字的列表。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(sort foo bar lose)</span><br><span class="line">==&gt;bar foo lose</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文件名函数"><a href="#文件名函数" class="headerlink" title="文件名函数"></a>文件名函数</h3><ol>
<li>$(dir names…)<br>抽取”names…“中每一个文件名的路径部分，文件名的路径部分包括从文件名的首字符到最后一个斜杠之前的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/ ./</span><br></pre></td></tr></table></figure></li>
<li>$(notdir names…)<br>抽取”names…“中每一个文件名的除路径之外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;foo.c hacks</span><br></pre></td></tr></table></figure></li>
<li>$(suffix names…)<br>抽取”names…“中每一个文件名的后缀。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;.c</span><br></pre></td></tr></table></figure></li>
<li>$(basename names…)<br>抽取”names…“中每一个文件名除后缀以外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/foo hacks</span><br></pre></td></tr></table></figure></li>
<li>$(addsuffix suffix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；suffix是一个后缀名。将suffix（后缀）的值附加在每一个独立文件的后面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(addsuffix .c,foo bar)</span><br><span class="line">==&gt;foo.c bar.c</span><br></pre></td></tr></table></figure></li>
<li>$(addprefix prefix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；prefix是一个前缀名。将prefix（前缀）的值附加在每一个独立文件的前面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line">==&gt;src/foo  src/bar</span><br></pre></td></tr></table></figure></li>
<li>$(wildcard pattern)<br>参数”pattern“是一个文件名格式，包含有通配符（通配符和shell的用法一样）。函数wildcard的结果是一列和格式匹配且真实存在的文件的名称，文件名之间用一个空格隔开。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_src := $(wildcard *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ol>
<li>$(foreach var,list,text)<br>前两个参数，”var“和”list“将首先扩展，最后一个参数”text“此时不扩展；接着，”list“扩展得到的每个字都赋值给”var“变量；然后，”text“引用该变量进行扩展，因此”text“每次扩展都不相同。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">dirs := a b c d</span><br><span class="line">files := $(foreach dir,$(dir),$(wildcard $(dir)/*))</span><br><span class="line">==&gt;</span><br><span class="line">$(wildcard a/*)</span><br><span class="line">$(wildcard b/*)</span><br><span class="line">$(wildcard c/*)</span><br><span class="line">$(wildcard d/*)</span><br></pre></td></tr></table></figure></li>
<li>$(if condition,then-part[,else-part])<br>首先把第一个参数”condition“的前导空格、结尾空格去掉，然后扩展。如果扩展为非空字符产，则条件”condition“为真，那么计算第二个参数”then-part“的值，并将之作为函数的返回值。如果condition为假，并且第三个参数存在，则计算第三个参数”else-part“的值，并将该值作为函数得返回值。如果第三个参数不存在，则返回空。</li>
<li>$(origin variable)<br>变量”variable“是一个查询变量的名称，不是对改变量的引用。所以不能采用”$“和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。函数的返回值如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">undefined                     :变量”variable“从未被定义；</span><br><span class="line">default                       :变量”variable“是默认定义；</span><br><span class="line">environment                   :变量”variable“作为环境变量定义，选项”-e“没有打开；</span><br><span class="line">environment override          :变量”variable“作为环境变量定义，选项”-e“已打开；</span><br><span class="line">file                          :变量”variable“在Makefile中定义；</span><br><span class="line">command line                  :变量”variable“在命令行中定义；</span><br><span class="line">override                      :变量”variable“在Makefile中用override指令定义；</span><br><span class="line">automatic                     :变量”variable“是自动变量。</span><br></pre></td></tr></table></figure></li>
<li>$(shell command arguments)<br>函数shell是Makefile与外部环境通信的工具。函数shell的执行结果和在控制台上执行”command arguments“的结果相似。不过如果”command arguments“的结果含有换行符，则在函数shell的返回结果中将它们处理为单个空格，若返回结果最后是换行符或者回车符则被去掉。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">c_src := $(shell ls *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure>
下面以一个Makefile为例进行演示：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">File:Makefiel</span><br><span class="line">src :=  $(shell ls *.c)</span><br><span class="line">objs := $(patsubst  %.c,%.o,$(src))</span><br><span class="line"></span><br><span class="line">test: $(objs)</span><br><span class="line">  gcc -o  $@  $^</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">  gcc -c -o $@  $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -rf test *.o</span><br></pre></td></tr></table></figure>
上述Makefile中”$@“、”$^“、”$&lt;“称为自动变量。”$@“表示规则的目标文件名；”$^“表示所有依赖的名字，名字中间用空格隔开；”$&lt;“表示第一个依赖的文件名。<br>已知当前目录下的所有文件为Makefile、main.c、sub.c、sub.h。<br>第一行src变量的值为”main.c sub.c“。<br>第二行objs变量的值为”main.o sub.o“。<br>第四行实际上就是：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">test  : main.o sub.o</span><br></pre></td></tr></table></figure>
目标test的依赖项是main.o sub.o。开始时这两个文件还没有生成，在执行文件生成test的命令前先将main.o、sub.o作为目标查找合适的规则，以生成main.o、sub.o。<br>第七八行就是用来生成main.o、sub.o的规则：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">main.o : main.c</span><br><span class="line">  gcc -c -o main.o main.c</span><br><span class="line"></span><br><span class="line">sub.o : sub.c</span><br><span class="line">  gcc -c -o sub.o sub.c</span><br></pre></td></tr></table></figure>
这样，test的依赖main.o和sub.o就生成了。</li>
</ol>
<h1 id="常用ARM汇编指令及ATPCS规则"><a href="#常用ARM汇编指令及ATPCS规则" class="headerlink" title="常用ARM汇编指令及ATPCS规则"></a>常用ARM汇编指令及ATPCS规则</h1><p>在嵌入式开发中，汇编程序常常用于非常关键的地方，比如系统启动时的初始化，进出中断时的环境保存、恢复，对性能要求非常苛刻的函数等。</p>
<ol>
<li>相对跳转指令b、bl<br>这两条指令的不同之处在于bl指令除了跳转之外，还将返回地址（bl的下一条指令的地址）保存在lr寄存器中。<br>这两条指令的可跳转范围是当前指令的前后32M。<br>它们是位置无关的指令。<br>使用示例：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  b fun1</span><br><span class="line">  ...</span><br><span class="line">fun1:</span><br><span class="line">  bl fun2</span><br><span class="line">  ...</span><br><span class="line">fun2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>数据传送指令mov，地址读取伪指令ldr<br>mov指令可以把一个寄存器的值赋值给另一个寄存器赋给另一个寄存器，或者把一个常数赋值给寄存器。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*r1 = r2*/</span><br><span class="line">mov r1,r2</span><br><span class="line"></span><br><span class="line">/*r1 = 4096*/</span><br><span class="line">mov r1,#4096</span><br></pre></td></tr></table></figure>
mov传送的常数必须能用立即数来表示。<br>当不知道一个数能否用”立即数“来表示时，可以使用ldr命令来赋值。ldr是伪指令，它不是真实存在的指令，编译器会把它扩展成真正的指令：如果该常数能用”立即数“来表示，则使用mov指令；否则编译时将该常数保存在某个位置，使用内存读取指令把它读出来。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*r1 = 4097*/</span><br><span class="line">ldr r1, =4097</span><br><span class="line"></span><br><span class="line">/*r1 = label的绝对地址*/</span><br><span class="line">ldr r1, =label</span><br><span class="line">label:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>内存访问指令:ldr,str,ldm,stm<br>ldr指令从内存中读取数据到寄存器，str指令把寄存器的值存储到内存，它们操作的数据都是32位的。示例如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">/*将地址为r2+4的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2,#4]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1,然后r2 = r2 + 4*/</span><br><span class="line">ldr r1,[r2],#4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*将r1的数据保存到地址为r2 + 4的内存单元*/</span><br><span class="line">str r1,[r2,#4]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元*/</span><br><span class="line">str r1,[r2]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元，然后r2 = r2 + 4*/</span><br><span class="line">str r1,[r2],#4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ldm和stm属于批量内存访问指令，只用一条指令就可以读写多个数据。它们的格式如下：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br><span class="line">stm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br></pre></td></tr></table></figure>
其中{cond}表示地址变化模式，有以下4种模式：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ia (Increment After):事后递增模式</span><br><span class="line">ib (Increment Before):事先递增模式</span><br><span class="line">da (Decrement After):事后递减模式</span><br><span class="line">db (Decrement Before):事先递减模式</span><br></pre></td></tr></table></figure>
<rn>中保存内存的地址，如果在后面加上了感叹号，指令执行后，rn的值会更新，等于下一个内存单元的地址。<br><register list>表示寄存器列表，对于ldm指令，从<rn>所对应的内存块取出数据。写入这些寄存器；对于stm指令，把这些寄存器的值写入<rn>所对应的内存块中。<br>{^}有两种含义：如果<register list>中有PC寄存器，它表示指令执行后，spsr寄存器的值将自动复制到cpsr寄存器中—这常用于从中断处理函数返回；如果<register list>中没有pc寄存器，它表示操作的是用户模式下的寄存器，而不是当前特权模式的寄存器。<br>指令中寄存器列表和内存单元的对应关系为：编号低的寄存器对应内存中的低地址单元，编号高的寄存器对应内存中的高地址单元。</register></register></rn></rn></register></rn></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">HandleIRQ:                @中断入口函数</span><br><span class="line">  sub lr,lr,#4            @计算返回地址</span><br><span class="line">  stmdb sp!,&#123;r0-r12,lr&#125;   @保存使用到的寄存器，r0-r12,lr被保存在sp表示的内存中，”!“使得指令执行后sp=sp-14*4</span><br><span class="line">  ldr lr, =int_return     @设置调用Handle_IRQ函数后的返回地址</span><br><span class="line">  ldr pc, =IRQ_Handle     @调用中断返回函数</span><br><span class="line"></span><br><span class="line">int_return:</span><br><span class="line">  ldmia sp!,&#123;r0-r12,pc&#125;^  @中断返回，”^“表示将spsr的值复制到cpsr，于是从irq模式返回被中断的工作模式。”!“使得指令执行后sp = sp + 14*4</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加减指令：add、sub<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">add r1,r2,#1 /*表示r1 = r2 + 1,即寄存器r1的值等于r2的值加上1*/</span><br><span class="line">sub r1,r2,#1 /*表示r1 = r2 - 1*/</span><br></pre></td></tr></table></figure></li>
<li>程序状态字寄存器的访问指令：msr、mrs<br>ARM处理器有一个程序状态字寄存器cpsr，它用来控制处理器的工作模式、设置中断的总开关。<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">msr cpsr,r0 /*复制r0到cpsr中*/</span><br><span class="line">mrs r0,cpsr /*复制cpsr到r0中*/</span><br></pre></td></tr></table></figure></li>
<li>其他伪指令<br>在本书的汇编程序中，常常见到如下语句：<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">.extern main</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure>
”.extern“定义一个外部符号（可以是变量也可以是函数），上面的代码表示本文件中引用的main是一个外部函数。<br>”.text“表示下面的语句都属于代码段。<br>”.global“将本文件的某个程序标号定义为全局的，比如下面的代码表示_start是个全局函数。</li>
<li>汇编指令的执行条件<br>大多数ARM指令都可以条件执行，即根据cpsr寄存器中的条件标志决定执行该指令：如果条件不满足，该指令相当于一条nop指令。<br>每条ARM指令包含4位的条件域码，这表明可以定义16个执行条件。可以将这些执行条件的助记符附加在汇编指令后，如moveq，movgt等。</li>
</ol>
<table>
<thead>
<tr>
<th>条件码</th>
<th>助记符</th>
<th>含义</th>
<th>cpsr中条件标志位</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>eq</td>
<td>相等</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>0001</td>
<td>ne</td>
<td>不相等</td>
<td>Z&#x3D;0</td>
</tr>
<tr>
<td>0010</td>
<td>cs&#x2F;hs</td>
<td>无符号数大于&#x2F;等于</td>
<td>C&#x3D;1</td>
</tr>
<tr>
<td>0100</td>
<td>mi</td>
<td>负数</td>
<td>N&#x3D;1</td>
</tr>
<tr>
<td>0101</td>
<td>pl</td>
<td>非负数</td>
<td>N&#x3D;0</td>
</tr>
<tr>
<td>0110</td>
<td>vs</td>
<td>上溢出</td>
<td>V&#x3D;1</td>
</tr>
<tr>
<td>0111</td>
<td>vc</td>
<td>没有上溢出</td>
<td>V&#x3D;0</td>
</tr>
<tr>
<td>1000</td>
<td>hi</td>
<td>无符号数大于</td>
<td>C&#x3D;1 &amp;&amp; Z&#x3D;0</td>
</tr>
<tr>
<td>1001</td>
<td>ls</td>
<td>无符号数小于等于</td>
<td>C&#x3D;0</td>
</tr>
<tr>
<td>1010</td>
<td>ge</td>
<td>带符号数大于等于</td>
<td>N&#x3D;1,V&#x3D;1</td>
</tr>
<tr>
<td>1011</td>
<td>lt</td>
<td>带符号数小于</td>
<td>N&#x3D;1,V&#x3D;0</td>
</tr>
<tr>
<td>1100</td>
<td>gt</td>
<td>带符号数大于</td>
<td>Z&#x3D;0 &amp;&amp; N&#x3D;V</td>
</tr>
<tr>
<td>1101</td>
<td>le</td>
<td>带符号数小于&#x2F;等于</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>1110</td>
<td>al</td>
<td>无条件执行</td>
<td>-</td>
</tr>
<tr>
<td>1111</td>
<td>nv</td>
<td>从不执行</td>
<td>-</td>
</tr>
</tbody></table>
<p>表中的cpsr条件标志位N、Z、C、V分别表示Negative、Zero、Cary、Overflow。影响条件标志位的因素比较多，比如比较指令cmp、cnm、teq及tst等。</p>
<h2 id="ARM-THUMB子程序调用规则ATPCS"><a href="#ARM-THUMB子程序调用规则ATPCS" class="headerlink" title="ARM-THUMB子程序调用规则ATPCS"></a>ARM-THUMB子程序调用规则ATPCS</h2><p>为了使C语言程序和汇编程序之间能够相互调用，必须为子程序之间的调用制定规则，在ARM处理器中，这个规则被称为ATPCS：ARM程序和Thumb程序中子程序的调用的规则。<br>基本的ATPCS规则包括寄存器使用规则、数据栈使用规则、参数传递规则等。</p>
<h3 id="寄存器使用规则"><a href="#寄存器使用规则" class="headerlink" title="寄存器使用规则"></a>寄存器使用规则</h3><p>ARM处理器中有r0-r15共16个寄存器，它们的用途有一些约定的习惯，并依据这些这些用途定义了别名。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>别名</th>
<th>使用规则</th>
</tr>
</thead>
<tbody><tr>
<td>r15</td>
<td>pc</td>
<td>程序计数器</td>
</tr>
<tr>
<td>r14</td>
<td>lr</td>
<td>连接寄存器</td>
</tr>
<tr>
<td>r13</td>
<td>sp</td>
<td>数据栈指针</td>
</tr>
<tr>
<td>r12</td>
<td>ip</td>
<td>子程序内部调用的scratch寄存器</td>
</tr>
<tr>
<td>r11</td>
<td>v8</td>
<td>ARM状态局部变量寄存器8</td>
</tr>
<tr>
<td>r10</td>
<td>v7、sl</td>
<td>ARM状态局部变量寄存器7、在支持数据栈检查的ATPCS中为数据栈限定指针</td>
</tr>
<tr>
<td>r9</td>
<td>v6、sb</td>
<td>ARM状态局部变量寄存器6、在支持RWPI的ATPCS中为静态基址寄存器</td>
</tr>
<tr>
<td>r8</td>
<td>v5</td>
<td>ARM状态局部变量寄存器5</td>
</tr>
<tr>
<td>r7</td>
<td>v4、wr</td>
<td>ARM状态局部变量寄存器4、Thumb状态工作寄存器</td>
</tr>
<tr>
<td>r6</td>
<td>v3</td>
<td>ARM状态局部变量寄存器3</td>
</tr>
<tr>
<td>r5</td>
<td>v2</td>
<td>ARM状态局部变量寄存器2</td>
</tr>
<tr>
<td>r4</td>
<td>v1</td>
<td>ARM状态局部变量寄存器1</td>
</tr>
<tr>
<td>r3</td>
<td>a4</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器4</td>
</tr>
<tr>
<td>r2</td>
<td>a3</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器3</td>
</tr>
<tr>
<td>r1</td>
<td>a2</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器2</td>
</tr>
<tr>
<td>r0</td>
<td>a1</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器1</td>
</tr>
</tbody></table>
<p>寄存器的使用规则总结如下：</p>
<ol>
<li>子程序间通过寄存器r0-r3来传递参数，这时可以使用它们的别名a0-a3。被调用的子程序返回前无须恢复r0-r3的内容。</li>
<li>在子程序中，使用r4-r11来保存局部变量，这时可以使用它们的别名v1-v8。如果在子程序中使用了它们的某些寄存器，子程序进入时需要保存这些寄存器的值，在返回时需要恢复它们；对于子程序没有使用到的寄存器，则不必进行这些操作。在Thumb程序中，通常只能使用寄存器r4-r7来保存局部变量。</li>
<li>寄存器r12用作子程序间scratch寄存器，别名ip。</li>
<li>寄存器r13用作数据栈指针，别名sp。在子程序中寄存器r13不能用作其他用途。它的值在进入、退出子程序时必须相等。</li>
<li>寄存器r14称为连接寄存器，别名lr。它用于保存子程序的返回地址。如果在子程序中保存了返回地址（比如将lr的值保存到数据栈中），r14可以用作其他用途。</li>
<li>寄存器r15是程序计数器，别名pc。它不能用作其他用途。</li>
</ol>
<h3 id="数据栈使用规则"><a href="#数据栈使用规则" class="headerlink" title="数据栈使用规则"></a>数据栈使用规则</h3><p>数据栈有两个增长方向：向内存地址减小的方向增长时，称为DESCENDING栈；向内存增加的方向增长时，称为ASCENDING栈。<br>所谓数据栈的增长就是移动栈指针。当栈指针指向栈顶元素时，称为FULL栈；当栈指针指向栈顶元素相邻的一个空的数据单元时，称为EMPTY栈。<br>使用stmdb命令往数据栈保存内容时，先递减sp指针，再保存数据，使用ldmia命令从数据栈恢复数据时，先获得数据，再递增sp指针，sp指针总是指向栈顶元素。</p>
<h3 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h3><p>一般来说，当参数个数不超过4个时，使用r0-r3这4个寄存器来传递参数；如果参数超过4个，剩余的参数通过数据栈来传递。<br>对于一般的返回结果，通常使用a0-a3来传递。示例：<br>假设CopyCode2SDRAM函数是用C语言实现的，它的数据原型如下：<br>int CopyCode2SDRAM(unsigned char *buf,unsigned long start_addr,int size);<br>在汇编代码中，使用下面的代码调用它，并判断返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">ldr r0,=0x30000000</span><br><span class="line">mov r1,#0</span><br><span class="line">mov r2,#16*1024</span><br><span class="line">bl CopyCode2SDRAM</span><br><span class="line">cmp a0,#0</span><br></pre></td></tr></table></figure>
<p>第一行将r0设为0x30000000，则CopyCode2SDRAM函数执行时，它的第一个参数buf的指向的内存地址是0x30000000。<br>第二行将r1设为0，CopyCode2SDRAM函数的第二个参数start_addr等于0。<br>第三行将r2设为16x1024，CopyCode2SDRAM函数的第三个参数size等于16x1024。<br>第五行判断返回值。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>书籍</category>
        <category>嵌入式Linux应用完全开发手册</category>
        <category>第1篇第3章 嵌入式编程基础知识</category>
      </categories>
      <tags>
        <tag>Linux 应用开发</tag>
      </tags>
  </entry>
</search>
