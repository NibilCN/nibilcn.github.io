<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="Linux设备驱动会以内核模块的形式出现，因此，学会编写Linux内核模块编程是学习Linux设备驱动的先决条件。4.1-4.2节讲解了Linux内核模块的概念和结构，4.3-4.8节对Linux内核模块的各个组成部分进行详细讲解，4.1-4.2节与4.3-4.8节是整体与部分的关系。4.9节讲解了独立存在的Linux内核模块的Makefile文件编写方法和模块的编译方法。">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux内核模块">
<meta property="og:url" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/index.html">
<meta property="og:site_name" content="Laugh Tale">
<meta property="og:description" content="Linux设备驱动会以内核模块的形式出现，因此，学会编写Linux内核模块编程是学习Linux设备驱动的先决条件。4.1-4.2节讲解了Linux内核模块的概念和结构，4.3-4.8节对Linux内核模块的各个组成部分进行详细讲解，4.1-4.2节与4.3-4.8节是整体与部分的关系。4.9节讲解了独立存在的Linux内核模块的Makefile文件编写方法和模块的编译方法。">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/1.jpeg">
<meta property="og:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/2.jpeg">
<meta property="og:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/3.jpeg">
<meta property="og:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/4.jpeg">
<meta property="og:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/5.jpeg">
<meta property="og:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/6.jpeg">
<meta property="og:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/7.jpeg">
<meta property="og:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/8.jpeg">
<meta property="article:published_time" content="2023-01-09T02:46:06.000Z">
<meta property="article:modified_time" content="2023-01-09T02:46:06.000Z">
<meta property="article:author" content="Nibil">
<meta property="article:tag" content="Linux Kernel">
<meta property="article:tag" content="Linux 设备驱动">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/1.jpeg">


<link rel="canonical" href="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/","path":"2023/01/09/Linux内核模块/","title":"Linux内核模块"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>Linux内核模块 | Laugh Tale</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <!--pjax：防止跳转页面音乐暂停-->
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Laugh Tale</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A Nibil's Sharing Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#4-1-Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%AE%80%E4%BB%8B"><span class="nav-number">1.</span> <span class="nav-text">4.1 Linux内核模块简介</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-2-Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97%E7%9A%84%E7%A8%8B%E5%BA%8F%E7%BB%93%E6%9E%84"><span class="nav-number">2.</span> <span class="nav-text">4.2 Linux内核模块的程序结构</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-3-%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">4.3 模块加载函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-4-%E6%A8%A1%E5%9D%97%E5%8D%B8%E8%BD%BD%E5%87%BD%E6%95%B0"><span class="nav-number">4.</span> <span class="nav-text">4.4 模块卸载函数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-5-%E6%A8%A1%E5%9D%97%E5%8F%82%E6%95%B0"><span class="nav-number">5.</span> <span class="nav-text">4.5 模块参数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-6-%E5%AF%BC%E5%87%BA%E7%AC%A6%E5%8F%B7"><span class="nav-number">6.</span> <span class="nav-text">4.6 导出符号</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-7-%E6%A8%A1%E5%9D%97%E5%A3%B0%E6%98%8E%E4%B8%8E%E6%8F%8F%E8%BF%B0"><span class="nav-number">7.</span> <span class="nav-text">4.7 模块声明与描述</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-8-%E6%A8%A1%E5%9D%97%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AE%A1%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">4.8 模块的使用计数</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-9-%E6%A8%A1%E5%9D%97%E7%9A%84%E7%BC%96%E8%AF%91"><span class="nav-number">9.</span> <span class="nav-text">4.9 模块的编译</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-10-%E6%A8%A1%E5%9D%97%E4%B8%8EGPL"><span class="nav-number">10.</span> <span class="nav-text">4.10 模块与GPL</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#4-11-%E6%80%BB%E7%BB%93"><span class="nav-number">11.</span> <span class="nav-text">4.11 总结</span></a></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Nibil</p>
  <div class="site-description" itemprop="description">A Nibil's Sharing Blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">58</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">74</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">42</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NibilCN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NibilCN" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
    <div class="sidebar-inner">
      <!-- require APlayer -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
      <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
      <!-- require MetingJS -->
      <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
      <!--网易云-->   
      <meting-js
        server="netease"
        id="7593069088"
        type="playlist" 
        mini="false"
        fixed="false"
        list-folded="true"
        autoplay="true"
        volume="0.4"
        theme="#FADFA3"
        order="random"
        loop="all"
        preload="auto"
        mutex="true">
      </meting-js>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/NibilCN" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nibil">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laugh Tale">
      <meta itemprop="description" content="A Nibil's Sharing Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="Linux内核模块 | Laugh Tale">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          Linux内核模块
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2023-01-09 10:46:06" itemprop="dateCreated datePublished" datetime="2023-01-09T10:46:06+08:00">2023-01-09</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/" itemprop="url" rel="index"><span itemprop="name">书籍</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/LINUX%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/" itemprop="url" rel="index"><span itemprop="name">LINUX设备驱动开发详解</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/LINUX%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E5%BC%80%E5%8F%91%E8%AF%A6%E8%A7%A3/%E7%AC%AC4%E7%AB%A0-Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/" itemprop="url" rel="index"><span itemprop="name">第4章 Linux内核模块</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>10k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>9 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>Linux设备驱动会以内核模块的形式出现，因此，学会编写Linux内核模块编程是学习Linux设备驱动的先决条件。<br>4.1-4.2节讲解了Linux内核模块的概念和结构，4.3-4.8节对Linux内核模块的各个组成部分进行详细讲解，4.1-4.2节与4.3-4.8节是整体与部分的关系。<br>4.9节讲解了独立存在的Linux内核模块的Makefile文件编写方法和模块的编译方法。</p>
<span id="more"></span>

<h1 id="4-1-Linux内核模块简介"><a href="#4-1-Linux内核模块简介" class="headerlink" title="4.1 Linux内核模块简介"></a>4.1 Linux内核模块简介</h1><p>Linux内核的整体结构非常庞大，其包含的组件也非常多。我们怎样把需要的部分都包含在内核中呢？<br>一种方法是把所有需要的功能都编译到Linux内核。这会导致两个问题，一是生成的内核会很大，二是如果我们要在现有的内核中新增或删除发功能，将不得不重新编译内核。<br>有没有一种机制使得编译出的内核本身并不需要包含所有功能，而在这些功能需要被使用的时候，其对应的代码可被动态地加载到内核中呢？<br>Linux提供了这样的一种机制，这种机制被称为模块（Module），可以实现以上效果。模块具有以下特点。</p>
<ol>
<li>模块本身不被编译入内核映像，从而控制了内核的大小。</li>
<li>模块一旦被加载，它就和内核中的其他部分完全一样。</li>
</ol>
<p>为了使读者对模块建立初步的感性认识，我们先来看一个最简单的内核模块“Hello World”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"></span><br><span class="line">MODULE_LICENSE(<span class="string">&quot;Dual BSD/GPL&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">hello_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Hello World enter\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">hello_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Hello World exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(hello_init);</span><br><span class="line">module_exit(hello_exit);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Song Baohua&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple Hello World Module&quot;</span>);</span><br><span class="line">MODULE_ALIAS(<span class="string">&quot;a simplest module&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>这个最简单的内核模块只包含内核模块加载函数、卸载函数和对Dual BSD&#x2F;GPL许可权限的声明以及一些描述信息。编译它会产生hello.ko目标文件，通过“insmod .&#x2F;hello.ko”命令可以加载它，通过“rmmod hello”命令可以卸载它，加载时输出“Hello World enter”，卸载时输出“Hello World exit”。<br>内核模块中用于输出的函数是内核空间的printk()而非用户空间的printf()，printk()的用法和printf()相似，但前者可定义输出级别。printk()可作为一种最基本的内核调试手段。<br>在Linux系统中，使用lsmod命令可以获得系统中加载了的所有模块以及模块间的依赖关系，例如：<br><img src="/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/1.jpeg" alt="img not found"><br>lsmod命令实际上读取并分析&#x2F;proc&#x2F;modules文件，与上述lsmod命令结果对应的&#x2F;proc&#x2F;modules文件如下：<br><img src="/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/2.jpeg" alt="img not found"><br>内核中已加载模块的信息也存在于&#x2F;sys&#x2F;module目录下，加载hello.ko后，内核中将包含&#x2F;sys&#x2F;module&#x2F;hello目录，该目录下又包含了一个refcnt文件和一个sections目录，在&#x2F;sys&#x2F;module&#x2F;hello目录下运行“tree -a”得到如下目录树：<br><img src="/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/3.jpeg" alt="img not found"><br>modprobe命令比insmod命令要强大，它在加载某模块时会同时加载该模块所依赖的其他模块。使用modprobe命令加载的模块若以“modprobe -r filename”的方式卸载将同时卸载其依赖的模块。<br>使用modinfo&lt;模块名&gt;命令可以获得模块的信息，包括模块的作者、模块的说明、模块所支持的参数以及vermagic，如下所示：<br><img src="/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/4.jpeg" alt="img not found"></p>
<h1 id="4-2-Linux内核模块的程序结构"><a href="#4-2-Linux内核模块的程序结构" class="headerlink" title="4.2 Linux内核模块的程序结构"></a>4.2 Linux内核模块的程序结构</h1><p>一个内核模块主要由以下几个部分组成。</p>
<ol>
<li>模块加载函数（必须）。<br>当通过insmod或modprobe命令加载内核模块时，模块的加载函数会自动被执行，完成本模块的相关初始化工作。</li>
<li>模块卸载函数（必须）。<br>当通过rmmod命令卸载某模块时，模块的卸载函数会自动被执行，完成与模块加载函数相反的功能。</li>
<li>模块许可证声明（必须）。<br>模块许可证（LISENCE）声明描述内核模块的许可权限，如果不声明LICENSE，模块被加载时，将收到内核被污染的警告。<br>在Linux2.6内核中，可接受的LISENCE包括“GPL”、“GPL v2”、“GPL and additional rights”、“Dual BSD&#x2F;GPL”、“Dual MPL&#x2F;GPL”和“Proprietary”。<br>大多数情况下，内核模块应遵循GPL兼容许可权。Linux2.6内核模块最常见的是以MODULE_LISENCE(“Dual BSD&#x2F;GPL”)语句声明模块采用BSD&#x2F;GPL双LISENCE。</li>
<li>模块参数（可选）。<br>模块参数是模块被加载的时候可以传递给它的值，它本身对应模块内部的全局变量。</li>
<li>模块导出符号（可选）。<br>内核模块可以导出符号（symbol，对应于函数或变量），这样其他模块可以使用本模块中的变量或函数。</li>
<li>模块作者等信息声明（可选）。</li>
</ol>
<h1 id="4-3-模块加载函数"><a href="#4-3-模块加载函数" class="headerlink" title="4.3 模块加载函数"></a>4.3 模块加载函数</h1><p>Linux内核模块加载函数一般以__init标识声明，典型的模块加载函数的形式如代码所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">initialization_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//初始化代码</span></span><br><span class="line">&#125;</span><br><span class="line">module_init(initialization_function);</span><br></pre></td></tr></table></figure>
<p>模块加载函数必须以“module_init(函数名)”的形式被指定。它返回整型值，若初始化成功，应返回0。而在初始化失败时，应该返回错误编码。在Linux内核里面，错误编码是一个负值，在&lt;linux&#x2F;error.h&gt;中定义，包含-ENODEV、-ENOMEM之类的符号值。返回相应的错误编码是种非常好的习惯，因为只有这样，用户程序才可以利用perror等方法把它们转换成有意义的错误信息字符串。<br>在Linux2.6内核中，可以使用request_module(const char *fmt,…)函数加载内核模块，驱动开发人员可以通过调用</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_module(module_name);</span><br></pre></td></tr></table></figure>
<p>或</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">request_module(<span class="string">&quot;char-major-%d-%d&quot;</span>,MAJOR(dev),MINOR(dev));</span><br></pre></td></tr></table></figure>
<p>来加载其他内核模块。<br>在Linux内核中，所有标识为__init的函数在连接的时候都放在.init.text这个区段内，此外，所有的__init函数在区段.initcall.init中还保存了一份函数指针，在初始化时内核会通过这些函数指针调用这些__init函数，并在初始化完成后释放init区段（包括.init.text，.initcall.init等）。</p>
<h1 id="4-4-模块卸载函数"><a href="#4-4-模块卸载函数" class="headerlink" title="4.4 模块卸载函数"></a>4.4 模块卸载函数</h1><p>Linux内核模块函数一般以__exit标识声明，典型的模块卸载函数的形式如下所示:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __exit <span class="title function_">cleanup_function</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//释放代码</span></span><br><span class="line">&#125;</span><br><span class="line">module_exit(cleanup_function);</span><br></pre></td></tr></table></figure>
<p>模块卸载函数在模块卸载的时候执行，不返回任何值，必须以“module_exit(函数名)”的形式来指定。<br>通常来说，模块卸载函数要完成与模块加载函数相反的功能，如下所示。</p>
<ol>
<li>若模块加载函数注册了XXX，则模块卸载函数应该注销XXX。</li>
<li>若模块加载函数动态申请了内存，则模块卸载函数应释放该内存。</li>
<li>若模块加载函数申请了硬件资源（中断、DMA通道、I&#x2F;O端口和I&#x2F;O内存等）的占用，则模块卸载函数应释放这些硬件资源。</li>
<li>若模块加载函数开启了硬件，则模块卸载函数中一般要关闭硬件。</li>
</ol>
<p>和__init一样，__exit也可以使对应函数在运行完成后自动回收内存。实际上，__init和__exit都是宏，其定义分别为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __init__attribute__((__section__(<span class="string">&quot;.init.text&quot;</span>)))</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MODULE</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __exit__attribute__((__section__(<span class="string">&quot;.exit.text&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __exit__attribute_used____attribute__((__section__(<span class="string">&quot;.exit.text&quot;</span>)))</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p>数据也可以被定义为_initdata和_exitdata，这两个宏分别为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __initdata__attribute__((__section__(<span class="string">&quot;.init.text&quot;</span>)))</span></span><br></pre></td></tr></table></figure>
<p>和</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> __exitdata__attribute__((__section__(<span class="string">&quot;.exit.text&quot;</span>)))</span></span><br></pre></td></tr></table></figure>

<h1 id="4-5-模块参数"><a href="#4-5-模块参数" class="headerlink" title="4.5 模块参数"></a>4.5 模块参数</h1><p>我们可以用“module_param(参数名，参数类型，参数读&#x2F;写权限)”为模块定义一个参数，例如下列代码定义了一个整型参数和一个字符指针参数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">char</span> *book_name = <span class="string">&quot;深入浅出Linux设备驱动&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">4000</span>;</span><br><span class="line">module_param(num,<span class="type">int</span>,S_IRUGO);</span><br><span class="line">module_param(book_name,charp,S_IRUGO);</span><br></pre></td></tr></table></figure>
<p>在装载内核模块时，用户可以向模块传递参数，形式为“insmod（或modprobe）模块名 参数名&#x3D;参数数值”，如果不传递，参数将使用模块内定义的默认值。<br>参数类型可以是byte、short、ushort、int、uint、long、ulong、charp（字符指针）、bool或invbool（布尔的反），在模块被编译时会将module_param中声明的类型与变量定义的类型进行比较，判断是否一致。<br>模块被加载后，在&#x2F;sys&#x2F;module&#x2F;目录下将出现以此模块名命名的目录。当“参数读&#x2F;写权限”为0时，表示此参数不存在sysfs文件系统下对应的文件节点，如果此模块存在“参数读&#x2F;写权限”不为0的命令行参数，在此模块的目录下还将出现parameters目录，包含一系列以参数名命名的文件节点，这些文件的权限值就是传入module_param()的“参数读&#x2F;写权限”，而文件的内容为参数的值。<br>除此之外，模块也可以拥有参数数组，形式为“module_param_array(数组名，数组类型，数组长，参数读&#x2F;写权限)”。从2.6.0-2.6.10版本，需将数组长变量名赋给“数组长”，从2.6.10版本开始，需将数组长变量的指针赋给“数组长”，当不需要保存实际输入的数组元素个数时，可以设置“数组长”为NULL。<br>运行inmod或modprobe命令时，应使用逗号分隔输入的数组元素。<br>现在我们定义一个包含两个参数的模块，并观察模块加载时被传递参数和不传递参数时的输出。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line">MODULE_LISENCE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">char</span> *book_name = <span class="string">&quot;dissecting Linux Device Driver&quot;</span>;</span><br><span class="line"><span class="type">static</span> <span class="type">int</span> num = <span class="number">4000</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">book_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;book name:%s\n&quot;</span>,book_name);</span><br><span class="line">    printk(KERN_INFO<span class="string">&quot;book num:%d\n&quot;</span>,num);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">void</span> <span class="title function_">book_exit</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    printk(KERN_ALERT<span class="string">&quot;Book module exit\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module_init(book_init);</span><br><span class="line">module_exit(book_exit);</span><br><span class="line">module_param(num,<span class="type">int</span>,S_IRUGO);</span><br><span class="line">module_param(book_name,charp,S_IRUGO);</span><br><span class="line"></span><br><span class="line">MODULE_AUTHOR(<span class="string">&quot;Song Baohua,author@linuxdriver.cn&quot;</span>);</span><br><span class="line">MODULE_DESCRIPTION(<span class="string">&quot;A simple Module for testing module params&quot;</span>);</span><br><span class="line">MODULE_VERSION(<span class="string">&quot;V1.0&quot;</span>);</span><br></pre></td></tr></table></figure>
<p>对上述模块运行“insmod book.ko”命令加载，相应输出都为模块内的默认值，通过查看“var&#x2F;log&#x2F;messages”日志文件可以看到内核的输出，如下所示：<br><img src="/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/5.jpeg" alt="img not found"><br>当用户运行“insmod book.ko book_name&#x3D;’GoodBook’num&#x3D;5000”命令时，输出的是用户传递的参数，如下所示：<br><img src="/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/6.jpeg" alt="img not found"></p>
<h1 id="4-6-导出符号"><a href="#4-6-导出符号" class="headerlink" title="4.6 导出符号"></a>4.6 导出符号</h1><p><code>Linux2.6的“/proc/kallsyms”文件对应着内核符号表，它记录了符号以及符号所在的内存地址</code>。<br>模块可以使用如下宏导出符号到内核符号表：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">EXPORT_SYMBOL(符号名);</span><br><span class="line">EXPORT_SYMBOL_GPL(符号名);</span><br></pre></td></tr></table></figure>
<p><code>导出的符号将可以被其他模块使用，使用前声明一下即可</code>。EXPORT_SYMBOL_GPL()只适合于包含GPL许可权的模块。下列代码给出了一个导出整数加、减运算符号的内核模块的例子（这些导出符号没有实际意义，只是为了演示）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/init.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line">MODULE_LISENCE(<span class="string">&quot;Dual BSD/GPL&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">add_integar</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a+b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">sub_integar</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> a-b;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">EXPORT_SYMBOL(add_integar);</span><br><span class="line">EXPORT_SYMBOL(sub_integar);</span><br></pre></td></tr></table></figure>
<p>从“&#x2F;proc&#x2F;kallsyms”文件中找出add_integar、sub_integar相关信息：<br><img src="/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/7.jpeg" alt="img not found"></p>
<h1 id="4-7-模块声明与描述"><a href="#4-7-模块声明与描述" class="headerlink" title="4.7 模块声明与描述"></a>4.7 模块声明与描述</h1><p>在Linux内核模块中，我们可以用MODULE_AUTHOR、MODULE_DESCROIPTION、MODULE_VERSION、MODULE_DEVICE_TABLE、MODULE_ALIAS分别声明模块的作者、描述、版本、设备表和别名，例如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">MODULE_AUTHOR(author);</span><br><span class="line">MODULE_DESCROIPTION(description);</span><br><span class="line">MODULE_VERSION(version_string);</span><br><span class="line">MODULE_DEVICE_TABLE(table_info);</span><br><span class="line">MODULE_ALIAS(alternate_name);</span><br></pre></td></tr></table></figure>
<p>对于USB、PCI等设备驱动，通常会创建一个MODULE_DEVICE_TABLE，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对应此驱动的设备表</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">usb_device_id</span> <span class="title">skel_table</span>[] =</span> &#123;</span><br><span class="line">    &#123;USB_DEVICE(USB_SKEL_VENDOR_ID,USB_SKEL_PRODUCT_ID)&#125;,</span><br><span class="line">    &#123;&#125;<span class="comment">//表结束</span></span><br><span class="line">&#125;;</span><br><span class="line">MODULE_DEVICE_TABLE(usb,skel_table);</span><br></pre></td></tr></table></figure>
<p>此时，并不需要读者理解MODULE_DEVICE_TABLE的作用。</p>
<h1 id="4-8-模块的使用计数"><a href="#4-8-模块的使用计数" class="headerlink" title="4.8 模块的使用计数"></a>4.8 模块的使用计数</h1><p>Linux2.4内核中，模块自身通过MOD_INC_USE_COUNT、MOD_DEC_USE_COUNT宏来管理自己被使用的计数。<br>Linux2.6内核提供了模块计数管理接口try_module_get(&amp;module)和module_put(&amp;module)。从而取代Linux2.4内核中的模块使用计数管理宏。模块的实用计数一般不必由模块自身管理，而且模块计数管理还考虑了SMP与PREEMPT机制的影响。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">try_module_get</span><span class="params">(<span class="keyword">struct</span> module *module)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数用于增加模块使用计数；若返回0，表示调用失败，希望使用的模块没有被加载或正在被卸载中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">module_put</span><span class="params">(<span class="keyword">struct</span> module *module)</span>;</span><br></pre></td></tr></table></figure>
<p>该函数用于减少模块使用计数。<br>try_module_get()与module_put()的引入与使用与Linux2.6内核下的设备模型密切相关。Linux2.6内核为不同类型的设备定义了struct module *owner域，用来指向管理此设备的模块。当开始使用某个设备时，内核使用try_module_get(dev-&gt;owner)去增加管理此设备的owner模块的使用计数；当不再使用此设备时，内核使用module_put(dev-&gt;owner)减少对管理此设备的owner模块的使用计数。这样，当设备在使用时，管理此设备的模块将不再被使用时，模块才允许被卸载。<br>在Linux2.6内核下，对于设备驱动工程师来说，很少需要亲自调用try_module_get()与module_put()，因此此时开发人员所写的驱动通常为支持某具体设备的owner模块，对此设备owner模块的计数管理由内核更底层的代码（如总线驱动或是此类设备公用的核心模块）来实现，从而简化了设备驱动的开发。</p>
<h1 id="4-9-模块的编译"><a href="#4-9-模块的编译" class="headerlink" title="4.9 模块的编译"></a>4.9 模块的编译</h1><p>我们可以为之前的一份代码编写一份简单的Makefile，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-m := hello.o</span><br></pre></td></tr></table></figure>
<p>并使用如下命令编译Hello World模块，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make -C /usr/src/linux<span class="number">-2.6</span><span class="number">.15</span><span class="number">.5</span>/ M=/driver_study/ modules</span><br></pre></td></tr></table></figure>
<p>如果当前处于模块所在的目录，则以下命令与上述命令相等：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost driver_study]<span class="meta">#make -C /usr/src/linux-2.6.15.5/ M=/driver_study/ modules</span></span><br><span class="line">make: Entering directory <span class="string">&#x27;/usr/src/linux-2.6.15.5&#x27;</span></span><br><span class="line">CC [M] /driver_study/hello.o</span><br><span class="line">Building modules, stage <span class="number">2.</span></span><br><span class="line">MODPOST</span><br><span class="line">CC     /driver_study/hello.mod.o</span><br><span class="line">LD [M] /driver_study/hello.ko</span><br><span class="line">make: Leaving directory <span class="string">&#x27;/usr/src/linux-2.6.15.5&#x27;</span></span><br></pre></td></tr></table></figure>
<p>从中可以看出，编译过程中经历了这样的步骤：先进入Linux内核所在的目录，并编译出hello.o文件，运行MODPOST会生成临时的hello.mod.c文件，而后根据此文件编译出hello.mod.o，之后连接hello.o和hello.mod.o文件得到模块目标文件hello.ko，最后离开Linux内核所在的目录。<br>中间生成的hello.mod.c文件的源代码如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/module.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/vermagic.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/compiler.h&gt;</span></span></span><br><span class="line">MODULE_INFO(vermagic,VERMAGIC_STRIGN)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">module__this_module</span></span></span><br><span class="line"><span class="class">__<span class="title">attribute__</span>((<span class="title">section</span>(&quot;.<span class="title">gnu</span>.<span class="title">linkonce</span>.<span class="title">this_module</span>&quot;))) =</span> &#123;</span><br><span class="line">    .name = KBUILD_MODNAME,</span><br><span class="line">    .init = init_module,</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MODULE_UNLOAD</span></span><br><span class="line">    .<span class="built_in">exit</span> = cleanup_module</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> __module_depends[]</span><br><span class="line">__attribute_used__</span><br><span class="line">__attribute__((section(<span class="string">&quot;.modinfo&quot;</span>))) = </span><br><span class="line"><span class="string">&quot;depends=&quot;</span>;</span><br></pre></td></tr></table></figure>
<p>hello.mod.o产生ELF（Linux所采用的可执行&#x2F;可连接的文件格式）的两个节，即modinfo和.gnu.linkonce.this_module。<br>如果一个模块包括多个.c文件（如file1.c、file2.c），则应该以如下方式编写Makefile：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-m := modulename.o</span><br><span class="line">module-objs := file1.o file2.o</span><br></pre></td></tr></table></figure>

<h1 id="4-10-模块与GPL"><a href="#4-10-模块与GPL" class="headerlink" title="4.10 模块与GPL"></a>4.10 模块与GPL</h1><p>对于自己编写的驱动等内核代码，如果不编译为模块则无法绕开GPL，编译为模块后企业在产品中使用模块，则公司对外不再需要提供对应的源代码，为了使公司产品所使用的Linux操作系统支持模块，需要完成如下工作。</p>
<ol>
<li>在内核编译时应该选上“Enable loadable module support”，嵌入式产品一般不需要动态卸载模块，所以“可以卸载模块不用选”，当然选了也没有关系，如下图所示。<br><img src="/2023/01/09/Linux%E5%86%85%E6%A0%B8%E6%A8%A1%E5%9D%97/8.jpeg" alt="img not found"><br>如果有项目被选择“M”，则编译时除了make bzImage以外，也要make modules。</li>
<li>将我们编译的内核模块.ko文件放置在目标文件系统的相关目录中。</li>
<li>产品的文件系统中应该包含了支持新内核的insmod、lsmod、rmmod等工具，由于嵌入式产品中一般不需要建立模块间依赖关系，所以modprobe可以不要，一般也不需要卸载模块，所以rmmod也可以不要。</li>
<li>在使用中用户可使用insmod命令手动记载模块，如insmod xxx.ko。</li>
<li>但是一般而言，产品在启动过程中应该加载模块，在嵌入式Linux的启动过程中，加载企业自己的模块的最简单的方法是修改启动过程中的rc脚本，增加inmod &#x2F;…&#x2F;xxx.ko这样的命令。如某设备正在使用的Linux系统中包含如下rc脚本：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">mount /proc</span><br><span class="line">mount /var</span><br><span class="line">mount /dev/pts</span><br><span class="line">mkdir /var/<span class="built_in">log</span></span><br><span class="line">mkdir /var/run</span><br><span class="line">mkdir /var/ftp</span><br><span class="line">mkdir -p /var/spool/cron</span><br><span class="line">mkdir /var/config</span><br><span class="line">...</span><br><span class="line">insmod /usr/lib/company_driver.ko <span class="number">2</span>&gt; /dev/null</span><br><span class="line">/usr/bin/userprocess</span><br><span class="line">/var/config/rc</span><br></pre></td></tr></table></figure></li>
</ol>
<h1 id="4-11-总结"><a href="#4-11-总结" class="headerlink" title="4.11 总结"></a>4.11 总结</h1><p>本章主要讲解了Linux内核模块的概念和基本的编程方法。内核模块由加载&#x2F;卸载函数、功能函数以及一些列声明组成，它可以被传入参数，也可以导出符号供其他模块使用。<br>由于Linux设备驱动以内核模块的形式而存在，因此，掌握这一章的内容是编写任何设备驱动所必须的。在具体的设备驱动开发中，将驱动编译为模块也有很强的工程意义，因为如果将正在开发中的驱动直接编译入内核，而开发过程中会不断修改驱动的代码，则需要不断地编译内核并重启Linux，但是如果编译为模块，则只需要rmmod并insmod即可，开发效率大为提高。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux-Kernel/" rel="tag"># Linux Kernel</a>
              <a href="/tags/Linux-%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8/" rel="tag"># Linux 设备驱动</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2023/01/05/Linux%E5%86%85%E6%A0%B8%E5%8F%8A%E5%86%85%E6%A0%B8%E7%BC%96%E7%A8%8B/" rel="prev" title="Linux内核及内核编程">
                  <i class="fa fa-chevron-left"></i> Linux内核及内核编程
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2023/01/10/Linux%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%92%8C%E8%AE%BE%E5%A4%87%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="next" title="Linux文件系统和设备文件系统">
                  Linux文件系统和设备文件系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 2022 – 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nibil</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">863k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">13:05</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
