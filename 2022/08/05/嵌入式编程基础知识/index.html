<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="《嵌入式Linux应用完全开发手册》第1篇第3章总结归纳">
<meta property="og:type" content="article">
<meta property="og:title" content="嵌入式编程基础知识">
<meta property="og:url" content="http://example.com/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/index.html">
<meta property="og:site_name" content="Laugh Tale">
<meta property="og:description" content="《嵌入式Linux应用完全开发手册》第1篇第3章总结归纳">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpeg">
<meta property="og:image" content="http://example.com/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.jpeg">
<meta property="article:published_time" content="2022-08-05T07:06:39.000Z">
<meta property="article:modified_time" content="2022-08-05T07:06:39.000Z">
<meta property="article:author" content="Nibil">
<meta property="article:tag" content="嵌入式Linux">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpeg">


<link rel="canonical" href="http://example.com/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"http://example.com/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/","path":"2022/08/05/嵌入式编程基础知识/","title":"嵌入式编程基础知识"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>嵌入式编程基础知识 | Laugh Tale</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <!--pjax：防止跳转页面音乐暂停-->
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Laugh Tale</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A Nibil's Sharing Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E7%9B%AE%E6%A0%87"><span class="nav-number">1.</span> <span class="nav-text">本章目标</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%BA%A4%E5%8F%89%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7%E9%80%89%E9%A1%B9%E8%AF%B4%E6%98%8E"><span class="nav-number">2.</span> <span class="nav-text">交叉编译工具选项说明</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#arm-linux-gcc%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.</span> <span class="nav-text">arm-linux-gcc选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%80%BB%E4%BD%93%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.1.</span> <span class="nav-text">总体选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%AD%A6%E5%91%8A%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.2.</span> <span class="nav-text">警告选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E8%AF%95%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.3.</span> <span class="nav-text">调试选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BC%98%E5%8C%96%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.4.</span> <span class="nav-text">优化选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%93%BE%E6%8E%A5%E5%99%A8%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.5.</span> <span class="nav-text">链接器选项</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%AE%E5%BD%95%E9%80%89%E9%A1%B9"><span class="nav-number">2.1.6.</span> <span class="nav-text">目录选项</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arm-linux-ld%E9%80%89%E9%A1%B9"><span class="nav-number">2.2.</span> <span class="nav-text">arm-linux-ld选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%9B%B4%E6%8E%A5%E6%8C%87%E5%AE%9A%E4%BB%A3%E7%A0%81%E6%AE%B5%E3%80%81%E6%95%B0%E6%8D%AE%E6%AE%B5%E3%80%81bss%E6%AE%B5%E7%9A%84%E8%B5%B7%E5%A7%8B%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.1.</span> <span class="nav-text">直接指定代码段、数据段、bss段的起始地址</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BF%9E%E6%8E%A5%E8%84%9A%E6%9C%AC%E8%AE%BE%E7%BD%AE%E5%9C%B0%E5%9D%80"><span class="nav-number">2.2.2.</span> <span class="nav-text">使用连接脚本设置地址</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arm-linux-objcopy%E9%80%89%E9%A1%B9"><span class="nav-number">2.3.</span> <span class="nav-text">arm-linux-objcopy选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#arm-linux-objdump%E9%80%89%E9%A1%B9"><span class="nav-number">2.4.</span> <span class="nav-text">arm-linux-objdump选项</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B1%87%E7%BC%96%E4%BB%A3%E7%A0%81%E3%80%81%E6%9C%BA%E5%99%A8%E7%A0%81%E5%92%8C%E5%AD%98%E5%82%A8%E5%99%A8%E7%9A%84%E5%85%B3%E7%B3%BB%E4%BB%A5%E5%8F%8A%E6%95%B0%E6%8D%AE%E7%9A%84%E8%A1%A8%E7%A4%BA"><span class="nav-number">2.5.</span> <span class="nav-text">汇编代码、机器码和存储器的关系以及数据的表示</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Makefile%E4%BB%8B%E7%BB%8D"><span class="nav-number">3.</span> <span class="nav-text">Makefile介绍</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Makefile%E8%A7%84%E5%88%99"><span class="nav-number">3.1.</span> <span class="nav-text">Makefile规则</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Makefile%E6%96%87%E4%BB%B6%E9%87%8C%E7%9A%84%E8%B5%8B%E5%80%BC%E6%96%B9%E6%B3%95"><span class="nav-number">3.2.</span> <span class="nav-text">Makefile文件里的赋值方法</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Makefile%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.</span> <span class="nav-text">Makefile常用函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9B%BF%E6%8D%A2%E5%92%8C%E5%88%86%E6%9E%90%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.1.</span> <span class="nav-text">字符串替换和分析函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%96%87%E4%BB%B6%E5%90%8D%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.2.</span> <span class="nav-text">文件名函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%85%B6%E4%BB%96%E5%87%BD%E6%95%B0"><span class="nav-number">3.3.3.</span> <span class="nav-text">其他函数</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B8%B8%E7%94%A8ARM%E6%B1%87%E7%BC%96%E6%8C%87%E4%BB%A4%E5%8F%8AATPCS%E8%A7%84%E5%88%99"><span class="nav-number">4.</span> <span class="nav-text">常用ARM汇编指令及ATPCS规则</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#ARM-THUMB%E5%AD%90%E7%A8%8B%E5%BA%8F%E8%B0%83%E7%94%A8%E8%A7%84%E5%88%99ATPCS"><span class="nav-number">4.1.</span> <span class="nav-text">ARM-THUMB子程序调用规则ATPCS</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%AF%84%E5%AD%98%E5%99%A8%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">4.1.1.</span> <span class="nav-text">寄存器使用规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%95%B0%E6%8D%AE%E6%A0%88%E4%BD%BF%E7%94%A8%E8%A7%84%E5%88%99"><span class="nav-number">4.1.2.</span> <span class="nav-text">数据栈使用规则</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%82%E6%95%B0%E4%BC%A0%E9%80%92%E8%A7%84%E5%88%99"><span class="nav-number">4.1.3.</span> <span class="nav-text">参数传递规则</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Nibil</p>
  <div class="site-description" itemprop="description">A Nibil's Sharing Blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">36</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">44</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NibilCN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NibilCN" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
    <div class="sidebar-inner">
      <!-- require APlayer -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
      <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
      <!-- require MetingJS -->
      <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
      <!--网易云-->   
      <meting-js
        server="netease"
        id="7593069088"
        type="playlist" 
        mini="false"
        fixed="false"
        list-folded="true"
        autoplay="true"
        volume="0.4"
        theme="#FADFA3"
        order="random"
        loop="all"
        preload="auto"
        mutex="true">
      </meting-js>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/NibilCN" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nibil">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laugh Tale">
      <meta itemprop="description" content="A Nibil's Sharing Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="嵌入式编程基础知识 | Laugh Tale">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          嵌入式编程基础知识
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-08-05 15:06:39" itemprop="dateCreated datePublished" datetime="2022-08-05T15:06:39+08:00">2022-08-05</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/" itemprop="url" rel="index"><span itemprop="name">书籍</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" itemprop="url" rel="index"><span itemprop="name">嵌入式Linux应用完全开发手册</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/%E7%AC%AC1%E7%AF%87%E7%AC%AC3%E7%AB%A0-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/" itemprop="url" rel="index"><span itemprop="name">第1篇第3章 嵌入式编程基础知识</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>23k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>20 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>《嵌入式Linux应用完全开发手册》第1篇第3章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解交叉编译工具链的各种选项</li>
<li>掌握连接脚本的编译方法</li>
<li>了解Makefile文件中常用的函数</li>
<li>了解几个常用的ARM汇编指令</li>
<li>了解汇编程序调用C函数所遵循的ATPCS规则</li>
</ol>
<h1 id="交叉编译工具选项说明"><a href="#交叉编译工具选项说明" class="headerlink" title="交叉编译工具选项说明"></a>交叉编译工具选项说明</h1><p>源文件需要经过编译才能生成可执行文件。在Windows上进行开发时，只需要单击几个按钮即可编译，集成开发环境已经将各种编译工具的使用封装好了。Linux下也有很多优秀的集成开发工具，但是更多的是时候是直接使用编译工具；即使使用集成开发工具，也需要掌握一些编译选项。<br>PC上的编译工具链为gcc、ld、objcopy、objdump等，它们编译出来的程序在x86平台上运行。要编译出在ARM平台上运行的程序，必须要使用交叉编译工具arm-linux-gcc、arm-linux-ld。</p>
<h2 id="arm-linux-gcc选项"><a href="#arm-linux-gcc选项" class="headerlink" title="arm-linux-gcc选项"></a>arm-linux-gcc选项</h2><p>一个c&#x2F;c++文件需要经过预处理，编译，汇编，链接等4步才能变成可执行文件。</p>
<ol>
<li>预处理<br>c&#x2F;c++源文件中，以”#“开头的命令被称为预处理命令。如包含命令”#include“，宏定义命令”#define“，条件编译命令”#if“，”#ifdef“等。预处理就是将要包含的文件插入原文件中、将宏定义展开、根据条件编译命令选择要使用的代码，最后将这些代码输入到一个”.i“文件中等待进一步处理。预处理将要用到arm-linux-cpp工具。</li>
<li>编译<br>编译就是把c&#x2F;c++代码”翻译“汇编代码，所用到的工具为ccl（它的名字就是ccl，而不是arm-linux-ccl）。</li>
<li>汇编<br>汇编就是将第二步输出的汇编代码翻译成一定格式的机器代码，在Linux系统上一般表现为ELF（OBJ文件），用到的工具为arm-linux-as。”反汇编“是指将机器代码转换为汇编代码，这在调试程序时常常用到。</li>
<li>连接<br>连接就是将上步生成的OBJ文件和系统库的OBJ文件、库文件连接起来，最终生成可以在特定平台运行的可执行文件，用到的工具是arm-linux-ld。<br>编译器利用这4个步骤中的一个或者多个来处理输入文件，源文件的后缀名表示源文件所用的语言，后缀名控制着编译器的默认动作。</li>
</ol>
<table>
<thead>
<tr>
<th>后缀名</th>
<th>语言种类</th>
<th>后期操作</th>
</tr>
</thead>
<tbody><tr>
<td>.c</td>
<td>c源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.C</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cc</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.cxx</td>
<td>c++源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.m</td>
<td>Object-C 源程序</td>
<td>预处理、编译、汇编</td>
</tr>
<tr>
<td>.i</td>
<td>预处理后的c文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.ii</td>
<td>预处理后的c++文件</td>
<td>编译、汇编</td>
</tr>
<tr>
<td>.s</td>
<td>汇编语言源程序</td>
<td>汇编</td>
</tr>
<tr>
<td>.S</td>
<td>汇编语言源程序</td>
<td>预处理、汇编</td>
</tr>
<tr>
<td>.h</td>
<td>预处理器文件</td>
<td>通常不出现在命令行上</td>
</tr>
</tbody></table>
<p>其他后缀名的文件被传递给连接器（linker），通常包括一下两种：<br>.o：目标文件（Object file，OBJ文件）。<br>.a：归档库文件（Archive file）。<br>在编译过程中，除非使用了”-c“，”-S“,或者”-E“选项，或者编译错误组织了完整的编译过程，否则最后的步骤总是连接。在连接阶段中，所有对应于源程序的.o文件、”-l“选项指定的库文件、无法识别的文件名（包括指定的”.o“目标文件和”.a“库文件）按命令行中的顺序传递给连接器。<br>以一个简单的”Hello World“C程序为例：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*File : hello.c*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;hello,world\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用arm-linux-gcc，只需要一个命令就可以生成可执行文件hello，它包含了4个步骤：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-gcc -o hello hello.c</span><br></pre></td></tr></table></figure>
<p>加上”-v“选项，可以查看编译的细节：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ccl hello.c -o /tmp/cctETob7.s</span><br><span class="line">as -o /tmp/ccvv2KbL.o /tmp/cctETob7.s</span><br><span class="line">collect2 -o hello   crtl.o  crti.o  crtbegin.o /tmp/ccvv2KbL.o crtend.o crtn.o</span><br></pre></td></tr></table></figure>
<p>以上三个命令分别对应于编译步骤中的预处理+编译、汇编和连接，ld被collect2调用来连接程序。预处理和编译被放在了一个命令中（ccl）进行，可以把它再次拆分为一下两步：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cpp -o hello.i hello.c</span><br><span class="line">ccl hello.i -o /tmp/cctETob7.s</span><br></pre></td></tr></table></figure>
<p>可以通过各种选项来控制arm-linux-gcc的动作，下面介绍一些常用的选项。</p>
<h3 id="总体选项"><a href="#总体选项" class="headerlink" title="总体选项"></a>总体选项</h3><ol>
<li>-c<br>预处理、编译和汇编源文件，但是不作连接，编译器根据源文件生成OBJ文件。默认情况下，GCC通过用”.o“替换文件名的后缀”.c“，”.i“，”.s“等，产生OBJ文件名。可以使用”-o“选项选择其他名字。GCC忽略”-c“选项后面任何无法识别的输入文件。</li>
<li>-S<br>编译后即停止，不进行汇编。对于每个输入的非汇编语言文件，输出结果是汇编语言文件。默认情况下，GCC通过用”.s“替换源文件名后缀”.c“，”.i“等，产生汇编文件名。可以使用”-o“选项选择其他名字。GCC忽略任何不需要汇编的输入文件。</li>
<li>-E<br>预处理后即停止，不进行编译。预处理后的代码送往标准输出。GCC忽略任何不需要预处理的输入文件。</li>
<li>-o file<br>指定输出文件为file。无论下是预处理、编译、汇编还是连接，这个选项都可以使用，</li>
<li>-v<br>显示制作GCC工具自身时的配置命令；同时显示编译器驱动程序、预处理器、编译器的版本号。<br>以一个程序为例，它包含三个文件：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">File:main.c</span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;sub.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Main fun\n&quot;</span>);</span><br><span class="line">    sub_fun();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">File:sub.h</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"></span><br><span class="line">File:sub.c</span><br><span class="line"><span class="type">void</span> <span class="title function_">sub_fun</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">    pintf(<span class="string">&quot;Sub fun\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
使用上述命令进行编译：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
其中，main.o、sub.o是经过了预处理、编译、汇编后生成的OBJ文件，它们还没有被连接成可执行文件；最后一步将它们连接成可执行文件test，可以直接运行以下命令：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">Main fun</span><br><span class="line">Sub fun</span><br></pre></td></tr></table></figure>
现在试试其他选项，以下命令生成的main.s是main.c的汇编语言文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -S -o main.s  main.c</span><br></pre></td></tr></table></figure>
以下命令对main.c进行预处理，并将得到的结果打印出来，里面包含了所有包含的文件、所有定义的宏。在编写程序时，有时候查找某个宏定义是非常繁琐的事情，可以使用”-dM-E“选项来查看。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -E main.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="警告选项"><a href="#警告选项" class="headerlink" title="警告选项"></a>警告选项</h3><p>”-Wall“选项基本打开了所有需要注意的警告信息，比如没有指定类型的声明、在声明前就使用的函数、局部变量除了声明就没有再使用等。<br>编译上面的main.c文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -Wall -c main.c</span><br></pre></td></tr></table></figure>
<p>得到的警告信息如下</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.c:In function &quot;main&quot;</span><br><span class="line">main.c:6 warning: unused variable &quot;i&quot;</span><br></pre></td></tr></table></figure>
<p>这个警告虽然对程序没有坏的影响，但是有些警告需要加以关注，比如匹配类型的警告等。</p>
<h3 id="调试选项"><a href="#调试选项" class="headerlink" title="调试选项"></a>调试选项</h3><p>-g: 加入只有GDB才使用的额外调试信息。</p>
<h3 id="优化选项"><a href="#优化选项" class="headerlink" title="优化选项"></a>优化选项</h3><ol>
<li>-O或者-O1<br>优化：对于大多数函数，优化编译的过程将占用较长的时间和相当大的内存。不使用”-O“选项的目的是减少编译的开销，使编译结果能够调试、语句是独立的。如果在两条语句之间用断点中止程序，可以对任何变量进行赋值，或者在函数体内把程序计数器指到其他语句，以及从源程序中精确获取所期待的结果。<br>不使用”-O“或者”-O1“选项时，只有声明了register的变量才分配使用寄存器。<br>使用了”-O“或者”-O1“选项时，编译器会试图减少目标码的大小和执行时间。如果指定了”-O“或者”-O1“选项，”-fthread-jumps“和”-fdefer-pop“选项被打开。在有delay slot的机器上，”-fdelayed-branch“选项将被打开。在既没有帧指针又支持调试的机器上，”-fomit-frame-pointer“选项将被打开。某些机器上还可能打开其他选项。</li>
<li>-O2<br>多优化一些。除了涉及空间和速度的优化选项，执行几乎所有的优化工作。例如不进行循环展开和函数内嵌。和”-O“选项相比，这个选项既增加了编译时间，也提高了生成代码的运行效果。</li>
<li>-O3<br>优化的更多，除了打开”-O2“所做的一切，它还打开了”-finline-functions“选项。</li>
<li>-O0<br>不优化。<br>如果指定了多个”-O0“选项，不管带不带数字，生效的是最后一个选项。</li>
</ol>
<h3 id="链接器选项"><a href="#链接器选项" class="headerlink" title="链接器选项"></a>链接器选项</h3><p>下面的选项用于连接OBJ文件，输出可执行文件或者库文件。</p>
<ol>
<li>object-file-name<br>如果某些文件没有特别明确的后缀。GCC就认为它是OBJ文件或者库文件。如果GCC执行连接操作，这些OBJ文件就会成为连接器的输入文件。例如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o sub.o</span><br></pre></td></tr></table></figure>
main.o和sub.o就是输入的文件。</li>
<li>-llibrary<br>连接名为library的库文件。<br>连接器在搜索标准目录中寻找这个库文件，库文件的真正名字”liblibrary.a“。搜索目录除了一些系统标准目录外，还包括用户以”-L“选项指定的路径。一般来说用这个方法找到的文件就是<code>库文件---即由OBJ文件组成的归档文件</code>。连接器处理归档文件的方法是：扫面归档文件，寻找某些成员，这些成员的符号目前已被引用，不过还没有被定义。但是，如果连接器普通的OBJ文件，而不是库文件，就把这个OBJ文件按照平常方式连接进来。指定”-l“选项和指定文件名的唯一区别是，”-l“选项用”lib“和”.a“把library包裹起来，而且搜索一些目录。<br>即使不明显的使用”-llibrary“选项，一些默认的库也被连接进去，可以使用”-v“选项看到这点。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker /lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtl.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../ctri.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtbegin.o</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o</span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/crtend.o</span><br><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../../crtn.o</span><br></pre></td></tr></table></figure>
可以看见，除了main.o、sub.o两个文件外，还连接了启动文件crtl.o、crti.o、crtend.o、crtn.o，还有一些库文件（-lgcc、-lgcc_eh、-lc、-lgcc、-lgcc_eh）。</li>
<li>-nostartfiles<br>不连接系统标准启动文件，而标准库文件依然正常使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v -nostartfiles -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">-lgcc -lgcc_eh -lc -lgcc -lgcc_eh</span><br><span class="line">/usr/lib/ld:warning:cannot find entry symbol _start;defaulting to 08048184</span><br></pre></td></tr></table></figure>
可以看见启动文件ctll.o、ctri.o、crtend.o、crtn.o没有被连接进去。需要说明的是，对于一般应用程序，这些启动文件是必须的，这里仅是作为例子（这样编译出来的test文件无法执行）。在编译bootloader、内核时，将用到这个选项。</li>
<li>-nostdlib<br>不连接系统标准启动文件和标准库文件，只把指定的文件传递给连接器，这个选项常用于编译内核，bootloader等程序，它们不需要启动文件，标准库文件。仍以options程序作为例子：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -v -nostdlib -o test main.o sub.o</span><br></pre></td></tr></table></figure>
输出的信息如下:<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/collect2 --eh-frame-hdr -m elf-i386-dynamic-linker </span><br><span class="line">/lib/ld-linux.so.2</span><br><span class="line">-o test </span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2</span><br><span class="line">-L/usr/lib/gcc-lib/i386-redhat-linux/3.2.2/../../..</span><br><span class="line">main.o </span><br><span class="line">sub.o</span><br><span class="line">/usr/bin/ld:warning:cannot find entry symbol _start;defaulting to 08048074</span><br><span class="line">main.o(.text + 0x19):In function &quot;main&quot;:</span><br><span class="line">:undefined referendce to &quot;printf&quot;</span><br><span class="line">sub.o(.text + 0xf):In function &quot;sub_fun&quot;:</span><br><span class="line">:undefined reference to &quot;printf&quot;</span><br><span class="line">collect2:ld returned 1 exit status</span><br></pre></td></tr></table></figure>
出现了一大堆错误，因为printf等函数是在库文件中实现的。在编译bootloader、内核时，用到这个选项，它们用的很多函数都是自包含的。</li>
<li>-static<br>在支持动态连接的的系统上阻止连接共享库。<br>仍以options程序作为例子,使用和不使用”-static“选项编译出来的可执行程序大小相差巨大：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o main.c</span><br><span class="line">$ gcc -c -o sub.c</span><br><span class="line">$ gcc -o test main.o sub.o</span><br><span class="line">$ gcc -o test_static mian.o sub.o -static </span><br><span class="line">$ ls -l test test_static</span><br><span class="line">6591 test</span><br><span class="line">546479 test_static</span><br></pre></td></tr></table></figure>
其中test文件为6591字节，test_static为546479字节。当不使用”-static“编译文件时，程序执行前要连接共享库文件，所以还需要将共享库文件放入文件系统中。</li>
<li>-shared<br>生成一个共享OBJ文件，它可以和其他OBJ文件连接产生可执行文件。只有部分系统支持该选项。<br>当不想以源代码发布程序时，可以使用”-shared“选项生成库文件，比如对于options程序，可以如下制作库文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o sub.a sub.o</span><br></pre></td></tr></table></figure>
以后要使用sub.c中的sub_fun时，在连接程序时，将sub.a加入即可。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o ./sub.a</span><br></pre></td></tr></table></figure>
可以将多个文件制作为一个库文件，比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -shared -o sub.a sub.o sub2.o sub3.o</span><br></pre></td></tr></table></figure></li>
<li>-Xlinker option<br>把选项option传递给连接器。可以用来传递系统特定的连接选项，GCC无法识别这些选项。如果需要传递携带参数的选项，必须使用两次”-Xlinker“，一次传递选项，另一次传递其参数。例如，如果传递”-arsset-definitions“，要写成”-Xlinker -assert -Xlinker definitions“，而不能写成”-Xlinker -assert definitions“。因为这样会把整个字符串当作一个参数传递，显然不是连接器期待的。</li>
<li>-Wl，option<br>把选项option传递给连接器 。如果option中含有逗号，就在逗号处分割成多个选项。连接器通常都是通过gcc，arm-linux-gcc等命令间接启动的，要向他传入参数时，参数前面加上”-Wl,“。</li>
<li>-u symbol<br>使连接器认为取消了symbol的符号定义，从而连接库模块以取得定义。可以使用多个”-u“选项，各自跟上不同的符号，使得连接器调入附加的模块。</li>
</ol>
<h3 id="目录选项"><a href="#目录选项" class="headerlink" title="目录选项"></a>目录选项</h3><p>下列选项指定搜索路径，用于查找头文件，库文件或者编译器的某些成员。</p>
<ol>
<li>-Idir<br>在头文件的搜索路径列表添加dir目录。头文件的搜索方法为：如果以”#include &lt;&gt;“包含文件，则只会在标准库目录开始搜索（包括使用-Idir选项定义的目录）；如果以”#include “包含文件，则先从用户的工作目录开始搜索，再搜索标准库目录。</li>
<li>-I-<br>任何在”-I-“前面用”-I“选项指定的搜索路径只适用于”#include ’file‘“这种情况；它们不能用来搜索”#include&lt;&gt;“包含的头文件。如果用”-I“选项指定的搜索路径位于”-I-“选项后面，就可以在这些路径中搜索所有的”#include“指令。”-I-“选项能够阻止当前目录成为搜索”#include ’file‘“的第一选择。</li>
<li>-Ldir<br>在”-L“选项的搜索路径中添加dir目录，仍然使用options程序进行说明，先制作库文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o sub.o sub.c</span><br><span class="line">$ gcc -shared -o libsub.a sub.o</span><br></pre></td></tr></table></figure>
编译main.c：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -c -o main.o main.c</span><br></pre></td></tr></table></figure>
连接程序，下面的指令将会出错，提示找不到库文件：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -o test main.o -lsub</span><br><span class="line">/usr/bin/ld: cannot find lsub</span><br><span class="line">collect2: ld returned 1 exit status</span><br></pre></td></tr></table></figure>
可以使用”-Ldir“选项将当前目录加入搜索路径，如下则连接成功：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -L. -o test main.o -lsub</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-ld选项"><a href="#arm-linux-ld选项" class="headerlink" title="arm-linux-ld选项"></a>arm-linux-ld选项</h2><p>arm-linux-ld将用于多个目标文件、库文件连接成可执行文件。</p>
<h3 id="直接指定代码段、数据段、bss段的起始地址"><a href="#直接指定代码段、数据段、bss段的起始地址" class="headerlink" title="直接指定代码段、数据段、bss段的起始地址"></a>直接指定代码段、数据段、bss段的起始地址</h3><p>格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-Ttext startaddr</span><br><span class="line">-Tdata startaddr</span><br><span class="line">-Tbss startaddr</span><br></pre></td></tr></table></figure>
<p>其中的”startaddr“分别代表代码段、数据段和bss段的起始地址，它是一个十六进制数。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-ld -Ttext 0x00000000 -g led_on.o -o led_on_elf</span><br></pre></td></tr></table></figure>
<p>它代表的代码段的运行地址为0x00000000，<code>由于没有定义数据段、bss段的起始地址，它们被依次放在代码段的后面</code>。<br>以一个例子来说明”-Ttext“选项的作用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.text </span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br><span class="line">  b step1</span><br><span class="line">step1:</span><br><span class="line">  ldr pc, =step2</span><br><span class="line">step2:</span><br><span class="line">  b step2 </span><br></pre></td></tr></table></figure>
<p>使用下面的命令编译、连接、反汇编：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-gcc -c -o link.o link.s</span><br><span class="line">arm-linux-ld -Ttext 0x00000000 link.o -o  link_elf_0x00000000</span><br><span class="line">arm-linux-ld -Ttext 0x30000000 link.o -o  link_elf_0x30000000</span><br><span class="line">arm-lihux-objdump -D link_elf_0x00000000 &gt; link_0x00000000.dis</span><br><span class="line">arm-lihux-objdump -D link_elf_0x30000000 &gt; link_0x30000000.dis</span><br></pre></td></tr></table></figure>
<p>例子中用到了两种跳转方法：b跳转指令、直接向pc寄存器赋值。先列出不同“-Ttext”选项下生成的反汇编文件，在详细分析由于不同运行地址带来的差异及影响。两个反汇编文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">link_0x00000000.dis                       link_0x30000000.dis</span><br><span class="line">0: eaffffff b 0x4                         0: eaffffff b 0x4</span><br><span class="line">4: e59ff000 ldr pc, [pc, #0]              4: e59ff000 ldr pc, [pc, #0]</span><br><span class="line">8: eafffffe b 0x8                         8: eafffffe b 0x8</span><br><span class="line">c: 00000008 andeq r0, r0, r8              c: 30000008 tsteq r0, #8 ; 0x8</span><br></pre></td></tr></table></figure>
<p>“b step1”是个相对跳转指令，其机器码的格式如下：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/1.jpeg" alt="img not found"></p>
<ol>
<li>[31:28]位是条件码。</li>
<li>[27:24]位为“1010”时，表示b跳转指令；为“1011”时，表示b1跳转指令。</li>
<li>[23::0]表示偏移地址。<br>使用“b”或者“b1”跳转时，下一条指令的地址是这样计算的：将指令中24位带符号的补码扩展为32位（扩展其符号位），将此32位数左移两位，将得到的值加到pc寄存器中，将得到跳转的目标地址。</li>
</ol>
<p>“b step1”的机器码为eaffffff。</p>
<ol>
<li>24位带符号的补码为0xffffff，将它扩展为32位得到0xffffffff。</li>
<li>将此32位数左移两位得到0xfffffffc，其值就是-4.</li>
<li>pc的值是当前指令下的下两条指令的地址，加上步骤2得到的-4，这恰好是第二条指令step1的地址。<br>请不要被反汇编代码的“b 0x4”迷惑。它不是指跳转到0x4处执行，绝对地址需要按照上述3个步骤计算。可以发现，b跳转指令依赖于当前PC寄存器的值，这个特性使得使用b指令的程序不依赖于代码存储的位置—即不管这条代码放在什么位置，b指令都可以跳到正确的位置。这类指令称为位置无关码。使用不同的“-Ttext”选项，生成的代码仍旧是一样的。<br>“ldr pc, &#x3D;step2”，从汇编码“ldr pc, [pc, #0]”可以看出，这条指令从内存中的某个位置读出数据，并赋值给PC寄存器。这个位置的地址是当前pc寄存器的值加上偏移量0。其中存放的值依赖于连接命令的“-Ttext”选项。执行这条指令之后，对于link_0x00000000.dis，pc &#x3D; 0x0000000；对于link_0x30000000.dis，pc &#x3D; 0x30000008。执行第三条指令“b step2”后，程序的运行地址就不同了：分别是0x00000008、0x30000008。<br>Bootloader、内核程序刚开始执行时，它们所处的地址通常不等于运行地址。在程序的开头，先使用b、bl、mov等“位置无关”的指令将代码从Flash等设备复制到内存的“运行地址”处，然后再跳转到“运行地址”去执行。</li>
</ol>
<h3 id="使用连接脚本设置地址"><a href="#使用连接脚本设置地址" class="headerlink" title="使用连接脚本设置地址"></a>使用连接脚本设置地址</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arm-linux-ld -Ttimer.lds -o timer_elf head.o init.o interrupt.o main.o</span><br></pre></td></tr></table></figure>
<p>它使用连接脚本timer.lds来设置可执行文件timer_elf的地址信息，timer.lds文件内容如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS &#123;</span><br><span class="line">  . = 0x30000000;</span><br><span class="line">  .text             : &#123;   *(.text)    &#125;</span><br><span class="line">  .rodata ALIGN(4)  : &#123;   *(rodata)   &#125;</span><br><span class="line">  .data   ALIGN(4)  : &#123;   *(data)     &#125;</span><br><span class="line">  .bss    ALIGN(4)  : &#123;   *(bss)  *(COMMON) &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>解析timer.lds文件之前，先讲解连接脚本的格式。连接脚本的基本命令是SECTIONS命令，它描述了输出文件的映射图：输出文件中各段、各文件怎么怎么放置。一个SECTIONS命令内部包含一个或者多个段。段（Section）是连接脚本的基本单元，它表示输入文件中的某部分怎么放置。<br>完整的连接脚本格式如下，它的核心部分是段（Section）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">···</span><br><span class="line">secname start ALIGN(align)  (NOLOAD)  : AT(ldadr)</span><br><span class="line">  &#123; contents  &#125; &gt; region :phdr =fill</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>secname 和 contents是必需的，前者用来命名这个段。后者用来确定代码中的什么部分放在这个段中。<br>start是这个段重定位地址，也称为运行地址。如果代码中有位置无关的指令，程序在运行时，这个段必须放在这个地址上。<br>ALIGN(align)：虽然start指定了运行地址，但是仍然可以使用BLOCK（align）来指定对齐的要求—这个对齐的地址才是真正的运行地址。<br>（NOLOAD）：用来告诉加载器，在运行时不用加载这个段。显然，这个选项只有在操作系统的情况下才有意义。<br>AT（ldadr）：指定这个段在编译出来的映像文件中的地址—加载地址。如果不使用这个选项，则加载地址等于运行地址。通过这个选项，可以控制各段分别保存输出文件中不同的位置，便于把文件保存到单板上：A段放在A处，B段放在B处，运行前再把A、B段分别读出来组装成一个完整的执行程序。<br>现在开始分析下timer.lds文件：</p>
<ol>
<li>第2行表示设置“当前运行地址”为0x30000000。</li>
<li>第3行定义了一个名为“.text”的段，它的内容为“* （.text）”，表示所有输入文件的代码段。这些代码段被集合在一起，起始运行地址为0x30000000。</li>
<li>第4行定义了一个名为“.rodata”的段，在输出文件timer_elf中，它紧挨着“.text”段存放。其中“ALIGN（4）”表示起始运行地址为4字节对齐。假设前面“.text”段的地址范围是0x30000000-0x300003f1，则“.rodata”段的地址为4字节对齐后的0x300003f4。</li>
<li>第5、6行的含义与第4行类似。</li>
</ol>
<h2 id="arm-linux-objcopy选项"><a href="#arm-linux-objcopy选项" class="headerlink" title="arm-linux-objcopy选项"></a>arm-linux-objcopy选项</h2><p>arm-linux-objcopy被用来复制一个目标文件的内容到另一个文件中，可以使用不同于源文件的格式来输出目的文件，即可以进行格式转换。<br>这本书中，常用arm-linux-objcopy来将ELF格式的可执行文件转换为二进制文件。下面讲解常用的选项：</p>
<ol>
<li>input-file、outfile<br>参数input-file和outfile分别表示输入目标文件和输出目标文件。</li>
<li>-I bfdname 或 –input-target&#x3D;bfdname<br>用来指明源文件的格式，bfdname是BFD库中描述的标准格式名。如果不指明源文件格式，arm-linux-objcopy会自己去分析源文件的格式，然后去和BFD中描述的各种格式比较，从而得知源文件的目标格式名。</li>
<li>-O bfdname 或 –output-target&#x3D;bfdname<br>使用指定的格式来输出文件，bfdname是BFD库中描述的的标准格式名。</li>
<li>-F bfdname 或 –target&#x3D;bfdname<br>同时指明源文件和目的文件的格式。将源文件的内容复制到目的文件的过程中，只进行复制而不做格式转换，源文件是什么格式，目的目标文件就是什么格式。</li>
<li>-R sectionname 或 –remove-section&#x3D;sectionname<br>从输出文件中删除掉所有名为sectionname的段。这个选项可以多次使用。</li>
<li>-S 或 –strip-all<br>不从源文件复制重定位信息和符号信息到目标文件中去。</li>
<li>-g 或 –strip-debug<br>不从源文件中复制调试符号到目标文件中去。<br>在编译bootloader、内核时，常用arm-linux-objcopy命令将ELF格式的生成结果转换为二进制文件，比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ arm-linux-objcopy -O binary -S elf_file bin_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="arm-linux-objdump选项"><a href="#arm-linux-objdump选项" class="headerlink" title="arm-linux-objdump选项"></a>arm-linux-objdump选项</h2><p>arm-linux-objdump用于显示二进制文件信息，本书中常用来查看反汇编代码。下面讲解常用的选项：</p>
<ol>
<li>-b bfdname 或 –target&#x3D;bfdname<br>指定目标码格式。这不是必须的，arm-linux-objdump能自动识别许多格式。可以使用“arm-linux-objdump -i”命令查看支持的目标码格式。</li>
<li>–disassemble 或 -d<br>反汇编可执行段。</li>
<li>–disassemble 或 -D<br>反汇编所有段。</li>
<li>-EB或-EL或–endian&#x3D;{big|little}<br>指定字节序。</li>
<li>–file-headers或-f<br>显示文件的整体头部摘要信息。</li>
<li>–section-headers、–header或-h<br>显示目标文件各个段的头部摘要信息。</li>
<li>–info或-i<br>显示支持的目标文件格式和CPU架构，它们在“-b”、“-m”选项中用到。</li>
<li>–section&#x3D;name或-j name<br>仅显示指定section的信息。</li>
<li>–architecture&#x3D;machine或-m machine<br>指定反汇编目标文件时使用的架构，当待反汇编文件本身没有描述架构信息的时候，这个选项很有用。可以用“-i”选项列出这里能够指定的架构。<br>在调试程序时，常用arm-linux-objdump命令来得到汇编代码。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/*将ELF格式的文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D elf_file &gt; dis_file</span><br><span class="line">/*将二进制文件转换为反汇编文件*/</span><br><span class="line">$ arm-linux-objdump -D -b binary -m arm bin_file &gt; dis_file</span><br></pre></td></tr></table></figure></li>
</ol>
<h2 id="汇编代码、机器码和存储器的关系以及数据的表示"><a href="#汇编代码、机器码和存储器的关系以及数据的表示" class="headerlink" title="汇编代码、机器码和存储器的关系以及数据的表示"></a>汇编代码、机器码和存储器的关系以及数据的表示</h2><p>即使使用C&#x2F;C++或者其他高级语言编程，最后也会被编译工具转换为汇编代码，并最终作为机器码存储在内存、硬盘或者其他存储器上。在调试程序时，经常需要阅读它的汇编代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">4bc:        e3a0244e: mov r2, #1308622848;</span><br><span class="line">4c0:        e3a0344e: mov r3, #1308622848;</span><br><span class="line">4c4:        e5933000: ldr r3, [r3];</span><br></pre></td></tr></table></figure>
<p>4bc、4c0、4c4是这些代码的运行地址，就是说运行前，这些指令必须位于内存中的这些地址上；e3a0244e、e3a0344e、e5933000是机器码。运行地址、机器码都是十六进制表示。CPU用到的、内存中保存的都是机器码示意如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*内存中的示意图*/</span><br><span class="line">/*地址:机器码*/</span><br><span class="line">···</span><br><span class="line">0x4bc:0xe3a0244e</span><br><span class="line">0x4c0:0xe3a0344e</span><br><span class="line">0x4c4:0xe5933000</span><br><span class="line">···</span><br></pre></td></tr></table></figure>
<p>“mov r2, #1308622848”、“mov r3, #1308622848”、“ldr r3, [r3]”是上述几个机器码的汇编代码。所谓汇编代码仅仅是为了方便读写而引入的，机器码和汇编代码之间也仅仅是简单的转换关系。参考CPU的数据手册，ARM的数据处指令格式为：<br><img src="/2022/08/05/%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%BC%96%E7%A8%8B%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/2.jpeg" alt="img not found"><br>以机器码0xe3a0244e为例：</p>
<ol>
<li>[31:28] &#x3D; 0b1110，表示这条指令无条件执行。</li>
<li>[25] &#x3D; 0b1，表示Operand2是一个立即数。</li>
<li>[24:21] &#x3D; 0b1101，表示这是MOV指令。</li>
<li>[20] &#x3D; 0b0，表示这条指令执行时不影响状态位。</li>
<li>[15:12] &#x3D; 0b0010，表示Rd就是r2寄存器。</li>
<li>[11:0] &#x3D; 0x44e，这是一个立即数。<br>立即数占据机器码的低12位表示：最低8位的值称为immed_8，高4位称为rotate_imm。立即数的数值计算方法为：<value> &#x3D; immed_8 循环右移 （2 * rotate_imm）。对于”[11:0] &#x3D; 0x44e“，其中immed_8 &#x3D; 0x4e、rotate_imm&#x3D;0x4，所以此立即数为0x4e000000。</value></li>
</ol>
<h1 id="Makefile介绍"><a href="#Makefile介绍" class="headerlink" title="Makefile介绍"></a>Makefile介绍</h1><p>在Linux中使用Make命令来编译程序，特别是大程序；而make命令所执行的动作依赖与Makefile文件。最简单的Makefile文件如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">hello：hello.c</span><br><span class="line">  gcc -o hello hello.c</span><br><span class="line">clean:</span><br><span class="line">  rm -rf hello</span><br></pre></td></tr></table></figure>
<p>将上述4行存为Makefile文件（注意必须以Tab键来进行缩进第2、4行，不能以空格来进行缩进），执行make即可编译程序，执行make clean即可清除编译出来的结果。<br>make命令根据文件更新的时间戳来决定哪些文件需要重新编译，这使得可以避免编译已经编译过的、没有变化的程序，大大提高编译效率。</p>
<h2 id="Makefile规则"><a href="#Makefile规则" class="headerlink" title="Makefile规则"></a>Makefile规则</h2><p>一个简单的Makefile文件包含一系列”规则“，其样式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">目标（target）...：依赖（prerequiries）...</span><br><span class="line">&lt;Tab&gt;命令（command）</span><br></pre></td></tr></table></figure>
<p>目标（target）通常是要生成的文件的名称，可以是可执行文件或者OBJ文件，也可以是一个执行的动作名称，诸如”clean“。<br>依赖是用来产生目标的材料（比如源文件），一个目标通常有几个依赖。<br>命令是生成目标时的动作，一个规则可以含有几个命令，每个命令占一行。<br>通常，如果一个依赖发生了变化，就需要规则调整命令以更新或者创建目标。但是并非所有的目标都有依赖，例如，目标”clean“的作用就是清除文件，它没有依赖。<br>规则一般是用于解释怎样和何时重建目标。make首先调用命令处理依赖，进而才能创建或者更新目标。当然，一个规则也可以是用于解释怎样和何时执行一个动作，即打印提示信息。<br>一个Makefile文件可以包含规则以外的其他文本，但一个简单的Makefile文件仅仅需要包含规则。虽然真正的规则比这里展示的例子复杂，但是格式是完全一样的。<br>对于上述Makefile，执行”make“命令时，仅当hello.c文件比hello文件新，才会执行命令”arm-linux-gcc -o hello hello.c“生成可执行文件hello；如果还没有hello文件，这个命令也会执行。<br>运行”make clean“，由于目标没有依赖项，它的命令“rm -f hello”将被强制执行。</p>
<h2 id="Makefile文件里的赋值方法"><a href="#Makefile文件里的赋值方法" class="headerlink" title="Makefile文件里的赋值方法"></a>Makefile文件里的赋值方法</h2><p>变量的定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">immediate = deferred</span><br><span class="line">immediate ?= deferred</span><br><span class="line">immediate := immediate</span><br><span class="line">immediate += deferred or immediate</span><br><span class="line">define immediate</span><br><span class="line">deferred</span><br><span class="line">endef</span><br></pre></td></tr></table></figure>
<p>在GNU make中对变量的赋值有两种方式：延时变量、立即变量。区别在于它们的定义方式和扩展时的方式不同，前者在这个变量使用时才会扩展开，意思就是当真正使用这个变量时才会确定；后者在定义时它的值就已经确定了。使用“&#x3D;”、“?&#x3D;”定义或者使用define指定定义的变量是延时变量；使用“：&#x3D;”定义的变量是立即变量。需要注意一点的的是“?&#x3D;”仅仅在变量没有定义的情况下有效，即“?&#x3D;”用来定义第一次出现的延时变量。对于附加操作符“+&#x3D;”，右边变量如果在前面使用（：&#x3D;）定义为立即变量则它也是立即变量，否则均为延时变量。</p>
<h2 id="Makefile常用函数"><a href="#Makefile常用函数" class="headerlink" title="Makefile常用函数"></a>Makefile常用函数</h2><p>函数调用的格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(function arguments)</span><br></pre></td></tr></table></figure>
<p>这里“function”是函数名，“arguments”是该函数的参数。参数与函数名之间用空格或者Tab隔开，如果有多个参数，它们之间用逗号隔开。这些空格和逗号不是参数值的一部分。下面介绍一些常用的Makefile函数。</p>
<h3 id="字符串替换和分析函数"><a href="#字符串替换和分析函数" class="headerlink" title="字符串替换和分析函数"></a>字符串替换和分析函数</h3><ol>
<li>$ (subst from,to,text)<br>在文本“text”中使用“to”替换每一处“from”。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ (subst ee,EE,feet on the street)</span><br><span class="line">==&gt;fEEt on the strEEt</span><br></pre></td></tr></table></figure></li>
<li>$ (patsubst pattern,replacement,text)<br>寻找“text”中符合格式“pattern”的字，用“replacement”替换它们。“pattern”和“replacement”中可以使用通配符。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ (patsubst %.c,%.o,x.c.c bar.c)</span><br><span class="line">==&gt;x.c.o bar.o</span><br></pre></td></tr></table></figure></li>
<li>$ (strip string)<br>去掉前导和结尾空格，并将中间的多个空格压缩为单个空格。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ (strip a   b c )</span><br><span class="line">==&gt;a b c</span><br></pre></td></tr></table></figure></li>
<li>$ (findstring find,in)<br>在字符串“in”中查找“find”，如果找到，则返回值是“find“，否则返回值为空。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$(findstring a,a b c)</span><br><span class="line">==&gt;a</span><br><span class="line">$(findstring a,b c)</span><br><span class="line">==&gt;</span><br></pre></td></tr></table></figure></li>
<li>$(filter pattern…,text)<br>返回在”text“中由空格隔开且匹配格式”pattern…“的字，去除不符合格式”pattern…“的字。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;foo.c bar.c baz.s</span><br></pre></td></tr></table></figure></li>
<li>$(filter-out pattern…,text)<br>返回在”text“中由空格隔开并且不匹配格式”pattern…“的字，去除符合格式”pattern…“的字。它是函数filter的反函数。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(filter %.c %.s,foo.c bar.c baz.s ugh.h)</span><br><span class="line">==&gt;ugh.h</span><br></pre></td></tr></table></figure></li>
<li>$(sort list)<br>将”list“中的字按照字母顺序排列，并去掉重复的字。输出由单个空格隔开的字的列表。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(sort foo bar lose)</span><br><span class="line">==&gt;bar foo lose</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="文件名函数"><a href="#文件名函数" class="headerlink" title="文件名函数"></a>文件名函数</h3><ol>
<li>$(dir names…)<br>抽取”names…“中每一个文件名的路径部分，文件名的路径部分包括从文件名的首字符到最后一个斜杠之前的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/ ./</span><br></pre></td></tr></table></figure></li>
<li>$(notdir names…)<br>抽取”names…“中每一个文件名的除路径之外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;foo.c hacks</span><br></pre></td></tr></table></figure></li>
<li>$(suffix names…)<br>抽取”names…“中每一个文件名的后缀。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;.c</span><br></pre></td></tr></table></figure></li>
<li>$(basename names…)<br>抽取”names…“中每一个文件名除后缀以外的一切字符。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(dir src/foo.c hacks)</span><br><span class="line">==&gt;src/foo hacks</span><br></pre></td></tr></table></figure></li>
<li>$(addsuffix suffix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；suffix是一个后缀名。将suffix（后缀）的值附加在每一个独立文件的后面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(addsuffix .c,foo bar)</span><br><span class="line">==&gt;foo.c bar.c</span><br></pre></td></tr></table></figure></li>
<li>$(addprefix prefix,names…)<br>参数”names…“是一系列的文件名，文件名之间用空格隔开；prefix是一个前缀名。将prefix（前缀）的值附加在每一个独立文件的前面，完成后将文件名串联起来，它们之间用单个空格隔开。比如：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(addprefix src/,foo bar)</span><br><span class="line">==&gt;src/foo  src/bar</span><br></pre></td></tr></table></figure></li>
<li>$(wildcard pattern)<br>参数”pattern“是一个文件名格式，包含有通配符（通配符和shell的用法一样）。函数wildcard的结果是一列和格式匹配且真实存在的文件的名称，文件名之间用一个空格隔开。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c_src := $(wildcard *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="其他函数"><a href="#其他函数" class="headerlink" title="其他函数"></a>其他函数</h3><ol>
<li>$(foreach var,list,text)<br>前两个参数，”var“和”list“将首先扩展，最后一个参数”text“此时不扩展；接着，”list“扩展得到的每个字都赋值给”var“变量；然后，”text“引用该变量进行扩展，因此”text“每次扩展都不相同。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dirs := a b c d</span><br><span class="line">files := $(foreach dir,$(dir),$(wildcard $(dir)/*))</span><br><span class="line">==&gt;</span><br><span class="line">$(wildcard a/*)</span><br><span class="line">$(wildcard b/*)</span><br><span class="line">$(wildcard c/*)</span><br><span class="line">$(wildcard d/*)</span><br></pre></td></tr></table></figure></li>
<li>$(if condition,then-part[,else-part])<br>首先把第一个参数”condition“的前导空格、结尾空格去掉，然后扩展。如果扩展为非空字符产，则条件”condition“为真，那么计算第二个参数”then-part“的值，并将之作为函数的返回值。如果condition为假，并且第三个参数存在，则计算第三个参数”else-part“的值，并将该值作为函数得返回值。如果第三个参数不存在，则返回空。</li>
<li>$(origin variable)<br>变量”variable“是一个查询变量的名称，不是对改变量的引用。所以不能采用”$“和圆括号的格式书写该变量，当然，如果需要使用非常量的文件名，可以在文件名中使用变量引用。函数的返回值如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">undefined                     :变量”variable“从未被定义；</span><br><span class="line">default                       :变量”variable“是默认定义；</span><br><span class="line">environment                   :变量”variable“作为环境变量定义，选项”-e“没有打开；</span><br><span class="line">environment override          :变量”variable“作为环境变量定义，选项”-e“已打开；</span><br><span class="line">file                          :变量”variable“在Makefile中定义；</span><br><span class="line">command line                  :变量”variable“在命令行中定义；</span><br><span class="line">override                      :变量”variable“在Makefile中用override指令定义；</span><br><span class="line">automatic                     :变量”variable“是自动变量。</span><br></pre></td></tr></table></figure></li>
<li>$(shell command arguments)<br>函数shell是Makefile与外部环境通信的工具。函数shell的执行结果和在控制台上执行”command arguments“的结果相似。不过如果”command arguments“的结果含有换行符，则在函数shell的返回结果中将它们处理为单个空格，若返回结果最后是换行符或者回车符则被去掉。<br>比如当前目录下有1.c、2.c、1.h、2.h。则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c_src := $(shell ls *.c)</span><br><span class="line">==&gt;1.c 2.c</span><br></pre></td></tr></table></figure>
下面以一个Makefile为例进行演示：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">File:Makefiel</span><br><span class="line">src :=  $(shell ls *.c)</span><br><span class="line">objs := $(patsubst  %.c,%.o,$(src))</span><br><span class="line"></span><br><span class="line">test: $(objs)</span><br><span class="line">  gcc -o  $@  $^</span><br><span class="line"></span><br><span class="line">%.o:%.c</span><br><span class="line">  gcc -c -o $@  $&lt;</span><br><span class="line"></span><br><span class="line">clean:</span><br><span class="line">  rm -rf test *.o</span><br></pre></td></tr></table></figure>
上述Makefile中”$@“、”$^“、”$&lt;“称为自动变量。”$@“表示规则的目标文件名；”$^“表示所有依赖的名字，名字中间用空格隔开；”$&lt;“表示第一个依赖的文件名。<br>已知当前目录下的所有文件为Makefile、main.c、sub.c、sub.h。<br>第一行src变量的值为”main.c sub.c“。<br>第二行objs变量的值为”main.o sub.o“。<br>第四行实际上就是：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">test  : main.o sub.o</span><br></pre></td></tr></table></figure>
目标test的依赖项是main.o sub.o。开始时这两个文件还没有生成，在执行文件生成test的命令前先将main.o、sub.o作为目标查找合适的规则，以生成main.o、sub.o。<br>第七八行就是用来生成main.o、sub.o的规则：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">main.o : main.c</span><br><span class="line">  gcc -c -o main.o main.c</span><br><span class="line"></span><br><span class="line">sub.o : sub.c</span><br><span class="line">  gcc -c -o sub.o sub.c</span><br></pre></td></tr></table></figure>
这样，test的依赖main.o和sub.o就生成了。</li>
</ol>
<h1 id="常用ARM汇编指令及ATPCS规则"><a href="#常用ARM汇编指令及ATPCS规则" class="headerlink" title="常用ARM汇编指令及ATPCS规则"></a>常用ARM汇编指令及ATPCS规则</h1><p>在嵌入式开发中，汇编程序常常用于非常关键的地方，比如系统启动时的初始化，进出中断时的环境保存、恢复，对性能要求非常苛刻的函数等。</p>
<ol>
<li>相对跳转指令b、bl<br>这两条指令的不同之处在于bl指令除了跳转之外，还将返回地址（bl的下一条指令的地址）保存在lr寄存器中。<br>这两条指令的可跳转范围是当前指令的前后32M。<br>它们是位置无关的指令。<br>使用示例：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  b fun1</span><br><span class="line">  ...</span><br><span class="line">fun1:</span><br><span class="line">  bl fun2</span><br><span class="line">  ...</span><br><span class="line">fun2:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>数据传送指令mov，地址读取伪指令ldr<br>mov指令可以把一个寄存器的值赋值给另一个寄存器赋给另一个寄存器，或者把一个常数赋值给寄存器。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">/*r1 = r2*/</span><br><span class="line">mov r1,r2</span><br><span class="line"></span><br><span class="line">/*r1 = 4096*/</span><br><span class="line">mov r1,#4096</span><br></pre></td></tr></table></figure>
mov传送的常数必须能用立即数来表示。<br>当不知道一个数能否用”立即数“来表示时，可以使用ldr命令来赋值。ldr是伪指令，它不是真实存在的指令，编译器会把它扩展成真正的指令：如果该常数能用”立即数“来表示，则使用mov指令；否则编译时将该常数保存在某个位置，使用内存读取指令把它读出来。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/*r1 = 4097*/</span><br><span class="line">ldr r1, =4097</span><br><span class="line"></span><br><span class="line">/*r1 = label的绝对地址*/</span><br><span class="line">ldr r1, =label</span><br><span class="line">label:</span><br><span class="line">  ...</span><br></pre></td></tr></table></figure></li>
<li>内存访问指令:ldr,str,ldm,stm<br>ldr指令从内存中读取数据到寄存器，str指令把寄存器的值存储到内存，它们操作的数据都是32位的。示例如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">/*将地址为r2+4的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2,#4]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1*/</span><br><span class="line">ldr r1,[r2]</span><br><span class="line">/*将地址为r2的内存单元数据读取到r1,然后r2 = r2 + 4*/</span><br><span class="line">ldr r1,[r2],#4</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">/*将r1的数据保存到地址为r2 + 4的内存单元*/</span><br><span class="line">str r1,[r2,#4]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元*/</span><br><span class="line">str r1,[r2]</span><br><span class="line">/*将r1的数据保存到地址为r2的内存单元，然后r2 = r2 + 4*/</span><br><span class="line">str r1,[r2],#4</span><br><span class="line"></span><br></pre></td></tr></table></figure>
ldm和stm属于批量内存访问指令，只用一条指令就可以读写多个数据。它们的格式如下：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ldm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br><span class="line">stm&#123;cond&#125;&lt;addressing_mode&gt; &lt;rn&gt;&#123;!&#125; &lt;register list&gt; &#123;^&#125;</span><br></pre></td></tr></table></figure>
其中{cond}表示地址变化模式，有以下4种模式：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ia (Increment After):事后递增模式</span><br><span class="line">ib (Increment Before):事先递增模式</span><br><span class="line">da (Decrement After):事后递减模式</span><br><span class="line">db (Decrement Before):事先递减模式</span><br></pre></td></tr></table></figure>
<rn>中保存内存的地址，如果在后面加上了感叹号，指令执行后，rn的值会更新，等于下一个内存单元的地址。<br><register list>表示寄存器列表，对于ldm指令，从<rn>所对应的内存块取出数据。写入这些寄存器；对于stm指令，把这些寄存器的值写入<rn>所对应的内存块中。<br>{^}有两种含义：如果<register list>中有PC寄存器，它表示指令执行后，spsr寄存器的值将自动复制到cpsr寄存器中—这常用于从中断处理函数返回；如果<register list>中没有pc寄存器，它表示操作的是用户模式下的寄存器，而不是当前特权模式的寄存器。<br>指令中寄存器列表和内存单元的对应关系为：编号低的寄存器对应内存中的低地址单元，编号高的寄存器对应内存中的高地址单元。</register></register></rn></rn></register></rn></li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">HandleIRQ:                @中断入口函数</span><br><span class="line">  sub lr,lr,#4            @计算返回地址</span><br><span class="line">  stmdb sp!,&#123;r0-r12,lr&#125;   @保存使用到的寄存器，r0-r12,lr被保存在sp表示的内存中，”!“使得指令执行后sp=sp-14*4</span><br><span class="line">  ldr lr, =int_return     @设置调用Handle_IRQ函数后的返回地址</span><br><span class="line">  ldr pc, =IRQ_Handle     @调用中断返回函数</span><br><span class="line"></span><br><span class="line">int_return:</span><br><span class="line">  ldmia sp!,&#123;r0-r12,pc&#125;^  @中断返回，”^“表示将spsr的值复制到cpsr，于是从irq模式返回被中断的工作模式。”!“使得指令执行后sp = sp + 14*4</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>加减指令：add、sub<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">add r1,r2,#1 /*表示r1 = r2 + 1,即寄存器r1的值等于r2的值加上1*/</span><br><span class="line">sub r1,r2,#1 /*表示r1 = r2 - 1*/</span><br></pre></td></tr></table></figure></li>
<li>程序状态字寄存器的访问指令：msr、mrs<br>ARM处理器有一个程序状态字寄存器cpsr，它用来控制处理器的工作模式、设置中断的总开关。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">msr cpsr,r0 /*复制r0到cpsr中*/</span><br><span class="line">mrs r0,cpsr /*复制cpsr到r0中*/</span><br></pre></td></tr></table></figure></li>
<li>其他伪指令<br>在本书的汇编程序中，常常见到如下语句：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">.extern main</span><br><span class="line">.text</span><br><span class="line">.global _start</span><br><span class="line">_start:</span><br></pre></td></tr></table></figure>
”.extern“定义一个外部符号（可以是变量也可以是函数），上面的代码表示本文件中引用的main是一个外部函数。<br>”.text“表示下面的语句都属于代码段。<br>”.global“将本文件的某个程序标号定义为全局的，比如下面的代码表示_start是个全局函数。</li>
<li>汇编指令的执行条件<br>大多数ARM指令都可以条件执行，即根据cpsr寄存器中的条件标志决定执行该指令：如果条件不满足，该指令相当于一条nop指令。<br>每条ARM指令包含4位的条件域码，这表明可以定义16个执行条件。可以将这些执行条件的助记符附加在汇编指令后，如moveq，movgt等。</li>
</ol>
<table>
<thead>
<tr>
<th>条件码</th>
<th>助记符</th>
<th>含义</th>
<th>cpsr中条件标志位</th>
</tr>
</thead>
<tbody><tr>
<td>0000</td>
<td>eq</td>
<td>相等</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>0001</td>
<td>ne</td>
<td>不相等</td>
<td>Z&#x3D;0</td>
</tr>
<tr>
<td>0010</td>
<td>cs&#x2F;hs</td>
<td>无符号数大于&#x2F;等于</td>
<td>C&#x3D;1</td>
</tr>
<tr>
<td>0100</td>
<td>mi</td>
<td>负数</td>
<td>N&#x3D;1</td>
</tr>
<tr>
<td>0101</td>
<td>pl</td>
<td>非负数</td>
<td>N&#x3D;0</td>
</tr>
<tr>
<td>0110</td>
<td>vs</td>
<td>上溢出</td>
<td>V&#x3D;1</td>
</tr>
<tr>
<td>0111</td>
<td>vc</td>
<td>没有上溢出</td>
<td>V&#x3D;0</td>
</tr>
<tr>
<td>1000</td>
<td>hi</td>
<td>无符号数大于</td>
<td>C&#x3D;1 &amp;&amp; Z&#x3D;0</td>
</tr>
<tr>
<td>1001</td>
<td>ls</td>
<td>无符号数小于等于</td>
<td>C&#x3D;0</td>
</tr>
<tr>
<td>1010</td>
<td>ge</td>
<td>带符号数大于等于</td>
<td>N&#x3D;1,V&#x3D;1</td>
</tr>
<tr>
<td>1011</td>
<td>lt</td>
<td>带符号数小于</td>
<td>N&#x3D;1,V&#x3D;0</td>
</tr>
<tr>
<td>1100</td>
<td>gt</td>
<td>带符号数大于</td>
<td>Z&#x3D;0 &amp;&amp; N&#x3D;V</td>
</tr>
<tr>
<td>1101</td>
<td>le</td>
<td>带符号数小于&#x2F;等于</td>
<td>Z&#x3D;1</td>
</tr>
<tr>
<td>1110</td>
<td>al</td>
<td>无条件执行</td>
<td>-</td>
</tr>
<tr>
<td>1111</td>
<td>nv</td>
<td>从不执行</td>
<td>-</td>
</tr>
</tbody></table>
<p>表中的cpsr条件标志位N、Z、C、V分别表示Negative、Zero、Cary、Overflow。影响条件标志位的因素比较多，比如比较指令cmp、cnm、teq及tst等。</p>
<h2 id="ARM-THUMB子程序调用规则ATPCS"><a href="#ARM-THUMB子程序调用规则ATPCS" class="headerlink" title="ARM-THUMB子程序调用规则ATPCS"></a>ARM-THUMB子程序调用规则ATPCS</h2><p>为了使C语言程序和汇编程序之间能够相互调用，必须为子程序之间的调用制定规则，在ARM处理器中，这个规则被称为ATPCS：ARM程序和Thumb程序中子程序的调用的规则。<br>基本的ATPCS规则包括寄存器使用规则、数据栈使用规则、参数传递规则等。</p>
<h3 id="寄存器使用规则"><a href="#寄存器使用规则" class="headerlink" title="寄存器使用规则"></a>寄存器使用规则</h3><p>ARM处理器中有r0-r15共16个寄存器，它们的用途有一些约定的习惯，并依据这些这些用途定义了别名。</p>
<table>
<thead>
<tr>
<th>寄存器</th>
<th>别名</th>
<th>使用规则</th>
</tr>
</thead>
<tbody><tr>
<td>r15</td>
<td>pc</td>
<td>程序计数器</td>
</tr>
<tr>
<td>r14</td>
<td>lr</td>
<td>连接寄存器</td>
</tr>
<tr>
<td>r13</td>
<td>sp</td>
<td>数据栈指针</td>
</tr>
<tr>
<td>r12</td>
<td>ip</td>
<td>子程序内部调用的scratch寄存器</td>
</tr>
<tr>
<td>r11</td>
<td>v8</td>
<td>ARM状态局部变量寄存器8</td>
</tr>
<tr>
<td>r10</td>
<td>v7、sl</td>
<td>ARM状态局部变量寄存器7、在支持数据栈检查的ATPCS中为数据栈限定指针</td>
</tr>
<tr>
<td>r9</td>
<td>v6、sb</td>
<td>ARM状态局部变量寄存器6、在支持RWPI的ATPCS中为静态基址寄存器</td>
</tr>
<tr>
<td>r8</td>
<td>v5</td>
<td>ARM状态局部变量寄存器5</td>
</tr>
<tr>
<td>r7</td>
<td>v4、wr</td>
<td>ARM状态局部变量寄存器4、Thumb状态工作寄存器</td>
</tr>
<tr>
<td>r6</td>
<td>v3</td>
<td>ARM状态局部变量寄存器3</td>
</tr>
<tr>
<td>r5</td>
<td>v2</td>
<td>ARM状态局部变量寄存器2</td>
</tr>
<tr>
<td>r4</td>
<td>v1</td>
<td>ARM状态局部变量寄存器1</td>
</tr>
<tr>
<td>r3</td>
<td>a4</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器4</td>
</tr>
<tr>
<td>r2</td>
<td>a3</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器3</td>
</tr>
<tr>
<td>r1</td>
<td>a2</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器2</td>
</tr>
<tr>
<td>r0</td>
<td>a1</td>
<td>参数&#x2F;结果&#x2F;scratch寄存器1</td>
</tr>
</tbody></table>
<p>寄存器的使用规则总结如下：</p>
<ol>
<li>子程序间通过寄存器r0-r3来传递参数，这时可以使用它们的别名a0-a3。被调用的子程序返回前无须恢复r0-r3的内容。</li>
<li>在子程序中，使用r4-r11来保存局部变量，这时可以使用它们的别名v1-v8。如果在子程序中使用了它们的某些寄存器，子程序进入时需要保存这些寄存器的值，在返回时需要恢复它们；对于子程序没有使用到的寄存器，则不必进行这些操作。在Thumb程序中，通常只能使用寄存器r4-r7来保存局部变量。</li>
<li>寄存器r12用作子程序间scratch寄存器，别名ip。</li>
<li>寄存器r13用作数据栈指针，别名sp。在子程序中寄存器r13不能用作其他用途。它的值在进入、退出子程序时必须相等。</li>
<li>寄存器r14称为连接寄存器，别名lr。它用于保存子程序的返回地址。如果在子程序中保存了返回地址（比如将lr的值保存到数据栈中），r14可以用作其他用途。</li>
<li>寄存器r15是程序计数器，别名pc。它不能用作其他用途。</li>
</ol>
<h3 id="数据栈使用规则"><a href="#数据栈使用规则" class="headerlink" title="数据栈使用规则"></a>数据栈使用规则</h3><p>数据栈有两个增长方向：向内存地址减小的方向增长时，称为DESCENDING栈；向内存增加的方向增长时，称为ASCENDING栈。<br>所谓数据栈的增长就是移动栈指针。当栈指针指向栈顶元素时，称为FULL栈；当栈指针指向栈顶元素相邻的一个空的数据单元时，称为EMPTY栈。<br>使用stmdb命令往数据栈保存内容时，先递减sp指针，再保存数据，使用ldmia命令从数据栈恢复数据时，先获得数据，再递增sp指针，sp指针总是指向栈顶元素。</p>
<h3 id="参数传递规则"><a href="#参数传递规则" class="headerlink" title="参数传递规则"></a>参数传递规则</h3><p>一般来说，当参数个数不超过4个时，使用r0-r3这4个寄存器来传递参数；如果参数超过4个，剩余的参数通过数据栈来传递。<br>对于一般的返回结果，通常使用a0-a3来传递。示例：<br>假设CopyCode2SDRAM函数是用C语言实现的，它的数据原型如下：<br>int CopyCode2SDRAM(unsigned char *buf,unsigned long start_addr,int size);<br>在汇编代码中，使用下面的代码调用它，并判断返回值。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ldr r0,=0x30000000</span><br><span class="line">mov r1,#0</span><br><span class="line">mov r2,#16*1024</span><br><span class="line">bl CopyCode2SDRAM</span><br><span class="line">cmp a0,#0</span><br></pre></td></tr></table></figure>
<p>第一行将r0设为0x30000000，则CopyCode2SDRAM函数执行时，它的第一个参数buf的指向的内存地址是0x30000000。<br>第二行将r1设为0，CopyCode2SDRAM函数的第二个参数start_addr等于0。<br>第三行将r2设为16x1024，CopyCode2SDRAM函数的第三个参数size等于16x1024。<br>第五行判断返回值。</p>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/" rel="tag"># 嵌入式Linux</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/05/%E4%BD%95%E8%B0%93%E7%A1%AC%E8%A7%A3%E7%A0%81%E5%92%8C%E8%BD%AF%E8%A7%A3%E7%A0%81/" rel="prev" title="何谓硬解码和软解码">
                  <i class="fa fa-chevron-left"></i> 何谓硬解码和软解码
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/08/10/GPIO%E6%8E%A5%E5%8F%A3/" rel="next" title="GPIO接口">
                  GPIO接口 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nibil</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">505k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">7:39</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
