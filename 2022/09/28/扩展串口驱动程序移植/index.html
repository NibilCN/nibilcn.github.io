<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="嵌入式Linux设备驱动开发之扩展串口驱动程序移植 《嵌入式Linux应用完全开发手册》第4篇第21章总结归纳">
<meta property="og:type" content="article">
<meta property="og:title" content="扩展串口驱动程序移植">
<meta property="og:url" content="http://example.com/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/index.html">
<meta property="og:site_name" content="Laugh Tale">
<meta property="og:description" content="嵌入式Linux设备驱动开发之扩展串口驱动程序移植 《嵌入式Linux应用完全开发手册》第4篇第21章总结归纳">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/1.jpeg">
<meta property="og:image" content="http://example.com/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/2.jpeg">
<meta property="article:published_time" content="2022-09-28T01:23:21.000Z">
<meta property="article:modified_time" content="2022-09-28T01:23:21.000Z">
<meta property="article:author" content="Nibil">
<meta property="article:tag" content="嵌入式Linux">
<meta property="article:tag" content="Linux Driver">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/1.jpeg">


<link rel="canonical" href="http://example.com/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"http://example.com/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/","path":"2022/09/28/扩展串口驱动程序移植/","title":"扩展串口驱动程序移植"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>扩展串口驱动程序移植 | Laugh Tale</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <!--pjax：防止跳转页面音乐暂停-->
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Laugh Tale</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A Nibil's Sharing Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E7%9B%AE%E6%A0%87"><span class="nav-number">1.</span> <span class="nav-text">本章目标</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%A1%86%E6%9E%B6%E6%A6%82%E8%BF%B0"><span class="nav-number">2.</span> <span class="nav-text">串口驱动程序框架概述</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E6%9C%AF%E8%AF%AD%E4%BB%8B%E7%BB%8D"><span class="nav-number">2.1.</span> <span class="nav-text">串口驱动程序术语介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%9A%844%E7%A7%8D%E7%BB%93%E6%9E%84"><span class="nav-number">2.2.</span> <span class="nav-text">串口驱动程序的4种结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E5%88%B0-%E2%80%9CCtrl-C%E2%80%9D%E6%97%B6"><span class="nav-number">2.2.1.</span> <span class="nav-text">串口接收到 “Ctrl + C”时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E6%8E%A5%E6%94%B6%E6%99%AE%E9%80%9A%E6%95%B0%E6%8D%AE%E6%97%B6"><span class="nav-number">2.2.2.</span> <span class="nav-text">串口接收普通数据时</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E5%8F%91%E9%80%81%E6%95%B0%E6%8D%AE%E6%97%B6"><span class="nav-number">2.2.3.</span> <span class="nav-text">串口发送数据时</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D"><span class="nav-number">3.</span> <span class="nav-text">扩展串口驱动移植</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E5%BA%95%E5%B1%82%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">3.1.</span> <span class="nav-text">串口驱动程序底层代码分析</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E4%BB%A3%E7%A0%81%E4%BB%A5%E6%94%AF%E6%8C%81%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3"><span class="nav-number">3.2.</span> <span class="nav-text">修改代码以支持扩展串口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%9E%84%E5%BB%BA%E4%B8%B2%E5%8F%A3%E5%B9%B3%E5%8F%B0%E8%AE%BE%E5%A4%87%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">构建串口平台设备的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E5%BC%80%E5%8F%91%E6%9D%BF%E7%9B%B8%E5%85%B3%E7%9A%84%E4%BB%A3%E7%A0%81%E4%BD%BF%E5%BE%97%E4%B8%B2%E5%8F%A3%E5%8F%AF%E7%94%A8"><span class="nav-number">3.2.2.</span> <span class="nav-text">增加开发板相关的代码使得串口可用</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A2%9E%E5%8A%A0%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE%E9%A1%B9-CONFIG-SERIAL-EXTEND-S3C24XX"><span class="nav-number">3.2.3.</span> <span class="nav-text">增加内核配置项 CONFIG_SERIAL_EXTEND_S3C24XX</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3"><span class="nav-number">3.3.</span> <span class="nav-text">测试扩展串口</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%87%86%E5%A4%87%E5%B7%A5%E4%BD%9C"><span class="nav-number">3.3.1.</span> <span class="nav-text">准备工作</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B5%8B%E8%AF%95%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3-1"><span class="nav-number">3.3.2.</span> <span class="nav-text">测试扩展串口</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Nibil</p>
  <div class="site-description" itemprop="description">A Nibil's Sharing Blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">43</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">51</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NibilCN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NibilCN" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
    <div class="sidebar-inner">
      <!-- require APlayer -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
      <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
      <!-- require MetingJS -->
      <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
      <!--网易云-->   
      <meting-js
        server="netease"
        id="7593069088"
        type="playlist" 
        mini="false"
        fixed="false"
        list-folded="true"
        autoplay="true"
        volume="0.4"
        theme="#FADFA3"
        order="random"
        loop="all"
        preload="auto"
        mutex="true">
      </meting-js>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/NibilCN" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nibil">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laugh Tale">
      <meta itemprop="description" content="A Nibil's Sharing Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="扩展串口驱动程序移植 | Laugh Tale">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          扩展串口驱动程序移植
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-28 09:23:21" itemprop="dateCreated datePublished" datetime="2022-09-28T09:23:21+08:00">2022-09-28</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/" itemprop="url" rel="index"><span itemprop="name">书籍</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" itemprop="url" rel="index"><span itemprop="name">嵌入式Linux应用完全开发手册</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/%E7%AC%AC4%E7%AF%87%E7%AC%AC21%E7%AB%A0-%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/" itemprop="url" rel="index"><span itemprop="name">第4篇第21章 扩展串口驱动程序移植</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>11k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>10 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>嵌入式Linux设备驱动开发之扩展串口驱动程序移植</p>
<p>《嵌入式Linux应用完全开发手册》第4篇第21章总结归纳</p>
<span id="more"></span>

<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解串口终端设备驱动程序的层次结构</li>
<li>掌握移植标准串口驱动程序的方法</li>
</ol>
<h1 id="串口驱动程序框架概述"><a href="#串口驱动程序框架概述" class="headerlink" title="串口驱动程序框架概述"></a>串口驱动程序框架概述</h1><h2 id="串口驱动程序术语介绍"><a href="#串口驱动程序术语介绍" class="headerlink" title="串口驱动程序术语介绍"></a>串口驱动程序术语介绍</h2><p>在Linux中经常碰到“控制台”、“终端”、“console”、“tty”、“terminal”等术语，也经常使用到这些设备文件：<code>/dev/ttySAC0</code>、<code>/dev/tty0</code>、<code>/dev/console</code>等。要理解这些术语，需要从以前的计算机说起。<br>最初的计算机价格昂贵，一台计算机通常连接多套键盘和显示器供人使用。在以前专门有这种可以连上一台电脑的设备，他只有显示器和键盘，外加简单的处理电路，本身不具备处理信息的能力。用户通过它连接到计算机上（通常是通过串口），然后登录系统，对计算机进行操作。这样一台只有输入、显示部件，并能够连接到计算机的设备就叫做终端。tty是Teletype的缩写，Teletype是最早出现的一种终端设备，很像电传打字机。在Linux中，就用“tty”来表示终端设备，比如内核文件“tty_io.c”、“tty_ioctl.c”等都是与“终端相关的驱动程序”。设备文件<code>/dev/ttySAC0</code>、<code>/dev/tty0</code>等也表示某类终端设备。<br>“console”的意思即为控制台，顾名思义，控制台就是用户与系统进行交互的设备，这和终端的作用类似。实际上控制台和终端相比，也只是多了一项功能：它可以显示系统信息，比如内核消息、后台服务消息。从硬件上看，控制台和终端都是具备输入和显示功能的设备。<br>控制台和终端的区别体现在软件上，Linux内核从很早之前发展而来，代码中仍保留了“控制台”、“终端”的概念。启动Linux内核前传入的命令行参数“console&#x3D;…”就是用来指定“控制台”的。控制台在tty驱动初始化之前就可以使用了，它最开始的时候被用来显示内核消息（比如printk函数输出的消息）。<br>当tty驱动初始化完毕之后。用户程序就可以通过tty驱动的接口来操作各类终端设备，包括控制台。从这个意义上来说，控制台也是一种终端，只不过它还能显示内核信息。<br>从命令行参数“console&#x3D;ttySAC0”、“console&#x3D;tty0”可以了解到：系统中有很多终端设备，可以选取其中一个或多个来作为控制台。<code>设备文件/dev/console对应的设备就是命令行参数“console=...”指定的、用作控制台的终端设备</code>。</p>
<h2 id="串口驱动程序的4种结构"><a href="#串口驱动程序的4种结构" class="headerlink" title="串口驱动程序的4种结构"></a>串口驱动程序的4种结构</h2><p>终端设备有很多种类，比如串行终端、键盘和显示器、通过网络实现的终端等。串口也属于一种终端设备，它的驱动程序不仅仅是初始化硬件、发送&#x2F;接收数据。在基本硬件操作的基础上，还增加了很多软件的功能，这是一个多层次的驱动程序。<br>串口驱动程序从上到下分为4层：终端设备层、行规程、串口抽象层、串口芯片层。这种分法不是绝对的，只是为了更方便理解程序，如下图所示：<br><img src="/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/1.jpeg" alt="img not found"><br>终端设备层和行规程的下面还有其他类型的层次和串口的层次并列，比如键盘、显示器等，接下来只关注串口。<br>终端设备层向上提供统一的访问接口，使得用户不必关注具体终端的类型。<br>行规程的作用是指定数据交互的“规矩”，比如流量控制、对输入的数据进行变换处理等。常见的用途有：将TAB字符转换为8个空格，当接收到删除键时删除前面输入的字符，当接收到“CTRL + C”时，发送SIGINT信号。<br>串口抽象层和串口芯片层都属于底层的驱动程序，它们用来操作硬件。串口抽象层将各类串口的共性概括出来，他也是底层串口驱动的核心部分，比如根据串口芯片层提供的地址识别串口类型，设置波特率等。<br>串口芯片层与芯片无关，主要是向串口抽象层提供串口芯片所用的资源（访问地址、中断号等），还进行一些与芯片相关的设置。对于标准串口，移植的工作主要在这一层。</p>
<h3 id="串口接收到-“Ctrl-C”时"><a href="#串口接收到-“Ctrl-C”时" class="headerlink" title="串口接收到 “Ctrl + C”时"></a>串口接收到 “Ctrl + C”时</h3><p>在串口控制台的前台运行一个程序时，如果要手动结束它，可以输入“Ctrl + C”，处理流程如下：</p>
<ol>
<li>串口接受到字符“Ctrl + C”（ASCII码为0x03）后触发中断。假设中断处理函数是<code>drivers/serial/8250.c</code>中的<code>serial8250_interrupt</code>，它属于最底层的函数。</li>
<li>中断处理函数会将这个字符放入tty层的缓冲区中，每个终端设备都有一个接收缓冲区，里面保存的是原始数据。这一步的函数调用顺序如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">serial8250_interrupt(串口芯片层)---&gt;</span><br><span class="line">    serial8250_handle_port(串口芯片层)---&gt;</span><br><span class="line">        receive_chars(串口芯片层)---&gt;</span><br><span class="line">            usrt_insert_char(串口抽象层)---&gt;</span><br><span class="line">                tty_insert_flip_char(终端设备层)---&gt;</span><br></pre></td></tr></table></figure></li>
<li>中断处理函数还要调用其他函数进一步处理原始数据，他最终会向当前进程发送SIGINT信号，让它退出。函数调用顺序如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serial8250_interrupt(串口芯片层)---&gt;</span><br><span class="line">    serial8250_handle_port(串口芯片层)---&gt;</span><br><span class="line">        receive_chars(串口芯片层)---&gt;</span><br><span class="line">            usrt_insert_char(串口抽象层)---&gt;</span><br><span class="line">                tty_insert_flip_char(终端设备层)<span class="comment">//保存接收到的数据及它的标志（是否有错误）</span></span><br><span class="line">                tty_flip_buffer_push(终端设备层)---&gt;</span><br><span class="line">                    flush_to_ldisc(终端设备层)---&gt;</span><br><span class="line">                        disc-&gt;receive_buf，即n_tty_receive_buf(行规程)---&gt;</span><br><span class="line">                            n_tty_receive_char(行规程)---&gt;</span><br><span class="line">                                n_tty_receice_char(终端设备层)---&gt;<span class="comment">//根据字符进行不同的处理</span></span><br><span class="line">                                发送SIGINT信号，isig(行规程)<span class="comment">//对于“Ctrl + C”，发信号</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="串口接收普通数据时"><a href="#串口接收普通数据时" class="headerlink" title="串口接收普通数据时"></a>串口接收普通数据时</h3><p>串口的接口简单，它的驱动程序相对于USB、IDE等接口的驱动程序而言比较容易掌握。但是串口驱动程序中的分层思想、通过中断处理函数或者定时器处理函数来完成硬件的操作以释放CPU资源的技巧等，这些技术在内核中比较普遍。<br>以串口接收到字符为例，在控制台上输入“ls”并按回车键时，发生如下事情：</p>
<ol>
<li>shell程序一直在休眠，等待接收到“足够”或者“合适”的字符。</li>
<li>串口接受到字符“l”，将它保存起来。</li>
<li>串口输出字符“l”，这样控制台就能看到“l”的字样了。</li>
<li>同理，字符“s”也是如此。</li>
<li>串口接收到回车符，唤醒shell进程。</li>
<li>shell进程就会读取这些字符做什么事情，本例中，它会打印出当前目录下的内容。</li>
</ol>
<p>这些过程涉及的函数与上面对“Ctrl + C”的处理过程类似，只是在<code>n_tty_sereive_char</code>函数中，对于普通字符将调用<code>echo_char</code>函数将它回显；对于回车符，回显之后还要调用<code>waitqueue_active</code>唤醒等待数据的进程。</p>
<h3 id="串口发送数据时"><a href="#串口发送数据时" class="headerlink" title="串口发送数据时"></a>串口发送数据时</h3><p>在往串口上发送数据时，在U-Boot中是发送一个字符之后，循环查询串口状态，当串口再次就绪时，发送下一个字符。如此循环，知道发送完所有字符。在查询状态的过程中，耗费了CPU资源，效率低下。<br>在Linux中，串口字符的发送也是通过中断来驱动的。比如在串口控制台上运行一个程序，里面有<code>printf(&quot;hello,world\n&quot;)</code>字样的语句，它的函数调用关系如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">tty_write(终端设备层)---&gt;</span><br><span class="line">    do_tty_write(终端设备层)---&gt;</span><br><span class="line">        write_chan(行规程)---&gt;</span><br><span class="line">            add_wait_queue(&amp;tty_write_wait, &amp;wait);     <span class="comment">//加入等待队列</span></span><br><span class="line">            tty-&gt;driver-&gt;write, 即uart_write(串口抽象层)---&gt;</span><br><span class="line">                <span class="comment">//数据先被保存在串口端口(port)的缓冲区，然后启动发送</span></span><br><span class="line">                uart_start(串口抽象层)---&gt;</span><br><span class="line">                    __uart_start(串口抽象层)---&gt;</span><br><span class="line">                        port-&gt;ops-&gt;start_tx,即serial8250_start_tx(串口芯片层)---&gt;</span><br><span class="line">                            up-&gt;ier |= UART_IER_THRI;   <span class="comment">//这两行使能串口发送中断</span></span><br><span class="line">                            serial_out(up, UART_IER,up-&gt;ier);   <span class="comment">//字符的发送在中断函数中进行</span></span><br><span class="line">            schedule()  <span class="comment">//假如uart_write没立刻发送完数据，进程休眠</span></span><br></pre></td></tr></table></figure>
<p>可见，即使是发送数据，也没有使用循环查询的方法，他只是把数据保存起来，然后开启发送中断。当串口芯片内部的发送缓冲区可以再次存入数据时，这个中断被触发；在中断处理函数中将数据一点点地发送给串口芯片。<br>仍以<code>serial8250_interrupt</code>函数为例，发送数据时的调用关系如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">serial8250_interrupt(串口芯片层)---&gt;</span><br><span class="line">    serial8250_handle_port(串口芯片层)---&gt;</span><br><span class="line">        transmit_chars(串口芯片层)---&gt;</span><br><span class="line">            serial_out(串口芯片层)---&gt; <span class="comment">//将数据写入串口芯片</span></span><br><span class="line">            <span class="comment">//如果已经发送完毕，唤醒进程</span></span><br><span class="line">            uart_write_wakeup,将调用uart_tasklet_action(串口抽象层)---&gt;</span><br><span class="line">                tty_wakeup(终端设备层)---&gt;</span><br><span class="line">                    <span class="comment">//与上面的write_chan中的“add_wait_queue(&amp;tty-&gt;write_wait,&amp;wait)”对应</span></span><br><span class="line">                    wake_up_interruptible(&amp;tty-&gt;write_wait); <span class="comment">//唤醒“等待发送完毕”的进程</span></span><br><span class="line">            <span class="comment">//如果已经发送完毕，则禁止发送中断</span></span><br><span class="line">            __stop_tx(串口芯片层)</span><br></pre></td></tr></table></figure>

<h1 id="扩展串口驱动移植"><a href="#扩展串口驱动移植" class="headerlink" title="扩展串口驱动移植"></a>扩展串口驱动移植</h1><h2 id="串口驱动程序底层代码分析"><a href="#串口驱动程序底层代码分析" class="headerlink" title="串口驱动程序底层代码分析"></a>串口驱动程序底层代码分析</h2><p>扩展串口在开发板上的连线如下图所示，中间的缓冲器用来提高电路的驱动能力。<br><img src="/2022/09/28/%E6%89%A9%E5%B1%95%E4%B8%B2%E5%8F%A3%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F%E7%A7%BB%E6%A4%8D/2.jpeg" alt="img not found"><br>扩展串口芯片16C2550属于标准串口，内核的串口驱动程序对它支持良好。可以大胆假设，移植的工作只有一点：告诉这些驱动程序这个扩展芯片所使用的资源，即访问地址和中断号。<br>与具体芯片相关的驱动代码在“串口芯片层”。对于16C2550，它就是<code>drivers/serial/8250.c</code>。入口函数为<code>serial8250_init</code>，它被用来向上层驱动程序注册串口的物理信息。只要弄清楚了这个函数就知道怎么增加对扩展串口的支持了。<br><code>serial8250_init</code>函数代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">serial8250_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	ret = uart_register_driver(&amp;serial8250_reg); <span class="comment">//注册串口终端设备，未和具体串口挂钩</span></span><br><span class="line">...</span><br><span class="line">	serial8250_isa_devs = platform_device_alloc(<span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">						    PLAT8250_DEV_LEGACY);<span class="comment">//分配platform_device 结构</span></span><br><span class="line">...</span><br><span class="line">	ret = platform_device_add(serial8250_isa_devs);<span class="comment">//加入内核设备层</span></span><br><span class="line">...</span><br><span class="line">	serial8250_register_ports(&amp;serial8250_reg, &amp;serial8250_isa_devs-&gt;dev);<span class="comment">//枚举old_serial_port中定义的串口</span></span><br><span class="line"></span><br><span class="line">	ret = platform_driver_register(&amp;serial8250_isa_driver);<span class="comment">//枚举内核设备层中的接口</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述5个函数是关键，其中<code>platform_driver_register</code>是重点。<br><code>uart_register_driver</code>函数向“终端设备层”注册驱动<code>serial8250_reg</code>，它指定了终端设备的名称、主次设备号等。<code>serial8250_reg</code>内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">uart_driver</span> <span class="title">serial8250_reg</span> =</span> &#123;</span><br><span class="line">	.owner			= THIS_MODULE,</span><br><span class="line">	.driver_name		= <span class="string">&quot;serial&quot;</span>, <span class="comment">//驱动名称，可以使用“cat /proc/tty/driver/serial”来查看</span></span><br><span class="line">	.dev_name		= <span class="string">&quot;ttyS&quot;</span>,<span class="comment">//设备名称，可以使用“cat /proc/devices”来查看</span></span><br><span class="line">	.major			= TTY_MAJOR,<span class="comment">//主设备号为4</span></span><br><span class="line">	.minor			= <span class="number">64</span>,<span class="comment">//次设备号</span></span><br><span class="line">	.nr			= UART_NR,<span class="comment">//支持的最大串口数，默认为8</span></span><br><span class="line">	.cons			= SERIAL8250_CONSOLE,<span class="comment">//控制台，如果非空，可以用作控制台</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>uart_register_driver</code>只是注册了主次设备号分别为4和64的终端设备，它还没和具体的硬件挂钩。<br><code>platform_device_alloc</code>、<code>platform_device_add</code>、<code>serial8250_register_ports</code>三个函数被用来枚举“老方法定义的”串口设备。所谓“老方法定义的”串口设备就是使用old_serial_port结构指定物理信息的串口，这是为了与以前的串口驱动兼容而遗留下的数据结构。在<code>drivers/serial/8250.c</code>中有如下几行，其中的SERIAL_PORT_DFNS宏在本书所用的内核中被定义为NULL:</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">old_serial_port</span> <span class="title">old_serial_port</span>[] =</span> &#123;</span><br><span class="line">	SERIAL_PORT_DFNS <span class="comment">/* defined in asm/serial.h */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>platform_driver_register</code>函数向内核注册了一个平台驱动serial8250_isa_driver，它用来枚举名称为“serial8250”的平台设备。<br>内核根据其他发生确定了很多设备的信息，这些设备被称为平台设备；加载平台驱动程序时将驱动程序与平台设备逐个比较，如果两者匹配，就是用这个驱动来进一步处理。是否匹配的判断方法是：设备名称和驱动名称是否一样。<code>serial8250_isa_driver</code>结构定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">serial8250_isa_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= serial8250_probe,</span><br><span class="line">	.remove		= __devexit_p(serial8250_remove),</span><br><span class="line">	.suspend	= serial8250_suspend,</span><br><span class="line">	.resume		= serial8250_resume,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可见，serial8250_isa_driver中驱动名称为“serial8250”，只要内核中有相同名称的平台设备，<code>platform_driver_register</code>函数最终会调用<code>serial8250_probe</code>函数来枚举它。<br>只要内核中名为“serial8250”的平台设备定义了正确的串口物理信息，<code>serial8250_probe</code>函数就能自动的检测串口，并将它和前面注册的终端设备联系起来。<br>总而言之，移植扩展串口的主要工作是构建一个平台设备的数据结构，在里面指定串口的物理信息。</p>
<h2 id="修改代码以支持扩展串口"><a href="#修改代码以支持扩展串口" class="headerlink" title="修改代码以支持扩展串口"></a>修改代码以支持扩展串口</h2><p>串口的物理信息主要有两类，访问地址、中断号。只要指明了这两点，并使它们可用，就可以驱动串口了。“使它们可用”的意思是：设置相关的存储控制器以适当的位宽访问这些地址，注册中断时指明合适的触发方式。</p>
<h3 id="构建串口平台设备的数据结构"><a href="#构建串口平台设备的数据结构" class="headerlink" title="构建串口平台设备的数据结构"></a>构建串口平台设备的数据结构</h3><p>在内核代码中查找字符“serial8250”，可以在<code>arch/arm/mach-s3c2410/mach-bast.c</code>中看到如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_serial8250_port</span> <span class="title">bast_sio_data</span>[] =</span> &#123;</span><br><span class="line">...</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">bast_sio</span> =</span> &#123;</span><br><span class="line">    .name   = <span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">    .id     = PLAT8250_DEV_PLATFORM,</span><br><span class="line">    .dev    = &#123;</span><br><span class="line">        .platform_data  =   &amp;bast_sio_data,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line">...</span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">bast_devices</span>[] _<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">...</span><br><span class="line">    &amp;bast_sio,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在<code>arch/arm/plat-s3c24xx/common-smdk.c</code>中仿照mach-bast.c文件增加如下3段代码。增加的代码如下，它们都使用宏CONFIG_SERIAL_EXTEND_S3C24XX包含起来：</p>
<ol>
<li><p>增加要包含的头文件</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;linux/serial_8250.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li><p>增加平台设备数据结构</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for extend serial chip</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">plat_serial8250_port</span> <span class="title">s3c_device_8250_data</span>[] =</span> &#123;</span><br><span class="line">    [<span class="number">0</span>] = &#123;</span><br><span class="line">        .mapbase    = <span class="number">0x28000000</span>,</span><br><span class="line">        .irq        = IRQ_EINT18,</span><br><span class="line">        .flag       = (UPF_BOOT_AUTOCONF | UPF_IOREMAP | UPF_SHARE_IRQ),</span><br><span class="line">        .iotype     = UPIO_MEM,</span><br><span class="line">        .regshift   = <span class="number">0</span>,</span><br><span class="line">        .uartclk    = <span class="number">115200</span> * <span class="number">16</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="number">1</span>] = &#123;</span><br><span class="line">        .mapbase    = <span class="number">0x29000000</span>,</span><br><span class="line">        .irq        = IRQ_EINT17,</span><br><span class="line">        .flag       = (UPF_BOOT_AUTOCONF | UPF_IOREMAP | UPF_SHARE_IRQ),</span><br><span class="line">        .iotype     = UPIO_MEM,</span><br><span class="line">        .regshift   = <span class="number">0</span>,</span><br><span class="line">        .uartclk    = <span class="number">115200</span> * <span class="number">16</span>,</span><br><span class="line">    &#125;,</span><br><span class="line">    &#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">s3c_device_8250</span> =</span> &#123;</span><br><span class="line">    .name   = <span class="string">&quot;serial8250&quot;</span>,</span><br><span class="line">    .id     = <span class="number">0</span>,</span><br><span class="line">    .dev    = &#123;</span><br><span class="line">        .platform_data  =   &amp;s3c_device_8250_data,</span><br><span class="line">    &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure>
<p><code>s3c_device_8250_data</code>结构定义了两个数组项，表示16C2550芯片中的两个串口。数组项0表示扩展串口A，数组项1表示扩展串口B。<br><code>.mapbase = 0x28000000</code>表示串口A的访问基址，这是物理地址。<br><code>.irq = IRQ_EINT18</code>指定串口A使用的中断号为IRQ_EINT18，由电路连接图可知道。<br><code>UPF_BOOT_AUTOCONF</code>表示自动配置串口，即自动检测它的类型、FIFO大小等；<code>UPF_IOREMAP</code>表示需要将前面使用的<code>.mapbase = 0x28000000</code>指定的物理地址映射为虚拟地址，然后才能使用这个虚拟地址来访问串口A；<code>UPF_SHARE_IRQ</code>表示IRQ_EINT18是个共享中断。<br><code>.iotype = UPIO_MEM</code>表示使用“内存地址”（就是mapbase映射后的地址）来访问串口A，与之对应的有UPIO_HUB6、UPIO_RM9000等，它们读写串口芯片的方式有所不同。<br><code>.regshift = 0</code>用来计算串口的寄存器地址。串口的寄存器都有特定的序号，比如发送&#x2F;接收寄存器（TX&#x2F;RX）序号为0，中断使能寄存器（IER）序号为1。假设mapbase映射后的地址为membase，寄存器序号为index，则它的访问地址为：membase + (index &lt;&lt; regshift)。由电路连接图可知，S3C2410&#x2F;S3C2440与16C2550的连接的总线宽度为8，所以regshift为0；如果总线宽度为16，则regshift为1；如果总线宽度为32，则regshift为2。<br><code>.uartclk = 115200 * 16</code>表示串口A的时钟。此值计算方法为：假设为了设置串口波特率为baud，需要往串口的商数寄存器写入数值quot&#x3D;uart&#x2F;(baudx16)。从16C2550的芯片手册可知quot的计算公式为</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">divisor(decimal) = (XTAL1 clock frequency) / (serial data rate x 16)</span><br></pre></td></tr></table></figure>
<p>由电路连接图可知，晶振频率为1.8432MHz，所以：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">uartclk = (XTAL1 clock frequency) = 1.8432M = 115200 * 16</span><br></pre></td></tr></table></figure>
<p>串口B与串口A类似，不再赘述。<br><code>s3c_device_8250(platform_device类型的数据结构)</code>，它的名字为“serial8250”，这与<code>drivers/serial/8250.c</code>中的平台驱动程序serial8250_isa_driver相对应。</p>
</li>
<li><p>加入内核设备列表<br>把平台设备s3c_device_8250加入smdk_devs数组后，系统启动时会把这个数组中的设备注册进内核中。增加的代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> __<span class="title">initdata</span> *<span class="title">smdk_devs</span>[] =</span> &#123;</span><br><span class="line">    &amp;s3c_device_nand,</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line">    &amp;s3c_device_8250,</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在，平台设备的数据结构已经设置好。</p>
</li>
</ol>
<h3 id="增加开发板相关的代码使得串口可用"><a href="#增加开发板相关的代码使得串口可用" class="headerlink" title="增加开发板相关的代码使得串口可用"></a>增加开发板相关的代码使得串口可用</h3><p>这一步需要实现两点：设置相关的存储控制器以适当的位宽访问串口芯片，注册中断时指明合适的触发方式。这需要在<code>drivers/serial/8250.c</code>中增加代码。</p>
<ol>
<li>增加头文件<br>设置存储控制器的BANK5时需要用到这个头文件，代码如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//for extend serial chip,</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24xx</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;asm/arch-s3c2410/regs-mem.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li>
<li>设置存储控制器的BANK5的位宽<br>由电路原理图可知，16C2550扩展串口芯片需要以8位的总线宽度进行访问，我们在<code>drivers/serial/8250.c</code>的初始化函数前面进行设置，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">serial8250_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> ret, i;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (nr_uarts &gt; UART_NR)</span><br><span class="line">		nr_uarts = UART_NR;</span><br><span class="line"></span><br><span class="line">	printk(KERN_INFO <span class="string">&quot;Serial: 8250/16550 driver $Revision: 1.90 $ &quot;</span></span><br><span class="line">		<span class="string">&quot;%d ports, IRQ sharing %sabled\n&quot;</span>, nr_uarts,</span><br><span class="line">		share_irqs ? <span class="string">&quot;en&quot;</span> : <span class="string">&quot;dis&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line">    <span class="comment">//设置BANK5的位宽为8</span></span><br><span class="line">    *((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON) =    \</span><br><span class="line">    ((*((<span class="keyword">volatile</span> <span class="type">unsigned</span> <span class="type">int</span> *)S3C2410_BWSCON)) &amp; ~(<span class="number">3</span> &lt;&lt; <span class="number">20</span>)) | S3C2410_BWSCON_DW5_8;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li>注册中断处理程序时，指定触发方式<br>由电路原理图可知，16C2550扩展串口芯片的INTA、INTB中断信号为高电平有效。<code>低电平有效的信号在电路原理图中一般都在前面加上字母“n”，或者加上上划线</code>，比如图中的nIOR、nIOW等信号表示低电平有效。<br>所以需要将INTA、INTB指定为上升沿触发（指定为高电平触发也可以），在<code>drivers/serial/8250.c</code>文件中调用<code>request_irq</code>函数之前增加如下代码<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">serial_link_irq_chain</span><span class="params">(<span class="keyword">struct</span> uart_8250_port *up)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SERIAL_EXTEND_S3C24XX</span></span><br><span class="line">    irq_flags |= IRQF_TRIGGER_RISING;   <span class="comment">//中断触发方式为上升沿触发</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    ret = request_irq(up-&gt;port.irq, serial8250_interrupt, </span><br><span class="line">    irq_flags, <span class="string">&quot;serial&quot;</span>, i);</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="增加内核配置项-CONFIG-SERIAL-EXTEND-S3C24XX"><a href="#增加内核配置项-CONFIG-SERIAL-EXTEND-S3C24XX" class="headerlink" title="增加内核配置项 CONFIG_SERIAL_EXTEND_S3C24XX"></a>增加内核配置项 CONFIG_SERIAL_EXTEND_S3C24XX</h3><p>在内核文件<code>drivers/serial/Kconfig</code>中增加如下几行：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">config CONFIG_SERIAL_EXTEND_S3C24XX</span><br><span class="line">    bool &quot;Extend UART for S3C24XX DEMO Board&quot;</span><br><span class="line">    depends on SERIAL_8250=y</span><br><span class="line">    --help--</span><br><span class="line">        Say Y here to use the extend UART</span><br></pre></td></tr></table></figure>

<h2 id="测试扩展串口"><a href="#测试扩展串口" class="headerlink" title="测试扩展串口"></a>测试扩展串口</h2><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>首先配置内核，选中配置项CONFIG_SERIAL_EXTEND_S3C24XX。执行“make menuconfig”后，如下选择：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Device Drivers ---&gt;</span><br><span class="line">    Character devices ---&gt;</span><br><span class="line">        Serial drivers ---&gt;</span><br><span class="line">            &lt;*&gt; 8250/16550 and compatible serial support</span><br><span class="line">            ...</span><br><span class="line">            [*] Extend UART for S3C24XX DEMO board</span><br></pre></td></tr></table></figure>
<p>然后执行“make uImage”编译内核，这将在内核<code>arch/arm/boot</code>目录下生成内核映像文件uImage。<br>最后修改开发板根文件系统，步骤如下。</p>
<ol>
<li>如果不使用mdev，如下增加ttyS0，ttyS1设备文件；如果使用mdev，这步可以省略。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mknod  /dev/ttyS0 c 4 64</span><br><span class="line">mknod  /dev/ttyS1 c 4 64</span><br></pre></td></tr></table></figure></li>
<li>修改&#x2F;etc&#x2F;inittab文件，增加如下代码。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ttyS0::askfirst:-/bin/sh</span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="测试扩展串口-1"><a href="#测试扩展串口-1" class="headerlink" title="测试扩展串口"></a>测试扩展串口</h3><p>使用新内核、新的根文件系统启动系统，然后原来的控制台下执行如下命令，可以看到检测到了两个串口。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">cat /proc/tty/driver/serial</span><br><span class="line">serinfo:1.0 driver revision:</span><br><span class="line">0: uart:16550A mmio:0x28000000 irq:62 mmbase 0xC486A000 tx:0 rx:0</span><br><span class="line">1: uart:16550A mmio:0x29000000 irq:61 mmbase 0xC486C000 tx:0 rx:0</span><br></pre></td></tr></table></figure>
<p>将第一个扩展串口连接到主机上、将主机的串口设为（9600，8N1）后，就可以通过这个扩展串口来控制系统了。<br>如果想设置串口的默认波特率为115200，可以参加如下修改内核文件<code>drivers/serial/serial_core.c</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">uart_register_driver</span><span class="params">(<span class="keyword">struct</span> uart_driver *drv)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">    normal-&gt;init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">改为：</span><br><span class="line">    normal-&gt;init_termios.c_cflag = B115200 | CS8 | CREAD | HUPCL | CLOCAL;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux/" rel="tag"># 嵌入式Linux</a>
              <a href="/tags/Linux-Driver/" rel="tag"># Linux Driver</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/09/24/Linux%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84/" rel="prev" title="Linux异常处理体系结构">
                  <i class="fa fa-chevron-left"></i> Linux异常处理体系结构
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/09/29/%E7%BD%91%E5%8D%A1%E9%A9%B1%E5%8A%A8%E7%A7%BB%E6%A4%8D/" rel="next" title="网卡驱动移植">
                  网卡驱动移植 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nibil</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">652k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">9:53</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
