<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="嵌入式Linux系统移植之移植Linux内核 《嵌入式Linux应用完全开发手册》第1篇第16章总结归纳">
<meta property="og:type" content="article">
<meta property="og:title" content="移植Linux内核">
<meta property="og:url" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/index.html">
<meta property="og:site_name" content="Laugh Tale">
<meta property="og:description" content="嵌入式Linux系统移植之移植Linux内核 《嵌入式Linux应用完全开发手册》第1篇第16章总结归纳">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/1.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/2.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/3.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/4.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/5.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/6.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/7.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/8.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/9.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/10.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/11.jpeg">
<meta property="og:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/12.jpeg">
<meta property="article:published_time" content="2022-09-07T08:36:37.000Z">
<meta property="article:modified_time" content="2022-09-07T08:36:37.000Z">
<meta property="article:author" content="Nibil">
<meta property="article:tag" content="Linux 应用开发">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/1.jpeg">


<link rel="canonical" href="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/","path":"2022/09/07/移植Linux内核/","title":"移植Linux内核"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>移植Linux内核 | Laugh Tale</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <!--pjax：防止跳转页面音乐暂停-->
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Laugh Tale</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A Nibil's Sharing Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E6%9C%AC%E7%AB%A0%E7%9B%AE%E6%A0%87"><span class="nav-number">1.</span> <span class="nav-text">本章目标</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E7%89%88%E6%9C%AC%E5%8F%8A%E7%89%B9%E7%82%B9"><span class="nav-number">2.</span> <span class="nav-text">Linux 版本及特点</span></a></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux%E7%A7%BB%E6%A4%8D%E5%87%86%E5%A4%87"><span class="nav-number">3.</span> <span class="nav-text">Linux移植准备</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%8E%B7%E5%8F%96Linux%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81"><span class="nav-number">3.1.</span> <span class="nav-text">获取Linux内核源码</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84%E5%8F%8AMakefile%E5%88%86%E6%9E%90"><span class="nav-number">3.2.</span> <span class="nav-text">内核源码结构及Makefile分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E6%BA%90%E7%A0%81%E7%BB%93%E6%9E%84"><span class="nav-number">3.2.1.</span> <span class="nav-text">内核源码结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Linux-Makefile-%E5%88%86%E6%9E%90"><span class="nav-number">3.2.2.</span> <span class="nav-text">Linux Makefile 分析</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E6%A0%B8%E7%9A%84Kconfig%E5%88%86%E6%9E%90"><span class="nav-number">3.3.</span> <span class="nav-text">内核的Kconfig分析</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#Kconfig-%E6%96%87%E4%BB%B6%E7%9A%84%E5%9F%BA%E6%9C%AC%E8%A6%81%E7%B4%A0%EF%BC%9Aconfig%E6%9D%A1%E7%9B%AE%EF%BC%88entry%EF%BC%89"><span class="nav-number">3.3.1.</span> <span class="nav-text">Kconfig 文件的基本要素：config条目（entry）</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#menu-%E6%9D%A1%E7%9B%AE"><span class="nav-number">3.3.2.</span> <span class="nav-text">menu 条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#choice-%E6%9D%A1%E7%9B%AE"><span class="nav-number">3.3.3.</span> <span class="nav-text">choice 条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#comment-%E6%9D%A1%E7%9B%AE"><span class="nav-number">3.3.4.</span> <span class="nav-text">comment 条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#source-%E6%9D%A1%E7%9B%AE"><span class="nav-number">3.3.5.</span> <span class="nav-text">source 条目</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%8F%9C%E5%8D%95%E5%BD%A2%E5%BC%8F%E7%9A%84%E9%85%8D%E7%BD%AE%E7%95%8C%E9%9D%A2%E6%93%8D%E4%BD%9C%E6%96%B9%E6%B3%95"><span class="nav-number">3.3.6.</span> <span class="nav-text">菜单形式的配置界面操作方法</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E9%85%8D%E7%BD%AE%E9%80%89%E9%A1%B9"><span class="nav-number">3.4.</span> <span class="nav-text">Linux 内核配置选项</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E7%95%8C%E9%9D%A2%E4%B8%BB%E8%8F%9C%E5%8D%95%E7%9A%84%E7%B1%BB%E5%88%AB"><span class="nav-number">3.4.1.</span> <span class="nav-text">配置界面主菜单的类别</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9CSystem-Type%E2%80%9D-%E8%8F%9C%E5%8D%95%EF%BC%9A%E7%B3%BB%E7%BB%9F%E7%B1%BB%E5%9E%8B"><span class="nav-number">3.4.2.</span> <span class="nav-text">“System Type” 菜单：系统类型</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E2%80%9CDevice-Drivers%E2%80%9D-%E8%8F%9C%E5%8D%95%EF%BC%9A%E8%AE%BE%E5%A4%87%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.4.3.</span> <span class="nav-text">“Device Drivers” 菜单：设备驱动程序</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E7%A7%BB%E6%A4%8D"><span class="nav-number">4.</span> <span class="nav-text">Linux 内核移植</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Linux-%E5%86%85%E6%A0%B8%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%A6%82%E8%BF%B0"><span class="nav-number">4.1.</span> <span class="nav-text">Linux 内核启动过程概述</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9Linux%E5%86%85%E6%A0%B8%E4%BB%A5%E6%94%AF%E6%8C%81S3C2410-x2F-S3C2440%E5%BC%80%E5%8F%91%E6%9D%BF"><span class="nav-number">4.2.</span> <span class="nav-text">修改Linux内核以支持S3C2410&#x2F;S3C2440开发板</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%BC%95%E5%AF%BC%E9%98%B6%E6%AE%B5%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.2.1.</span> <span class="nav-text">引导阶段代码分析</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#start-kernel-%E5%87%BD%E6%95%B0%E9%83%A8%E5%88%86%E4%BB%A3%E7%A0%81%E5%88%86%E6%9E%90"><span class="nav-number">4.2.2.</span> <span class="nav-text">start_kernel 函数部分代码分析</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#setup-arch-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">4.2.2.1.</span> <span class="nav-text">setup_arch 函数分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#paging-init%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">4.2.2.2.</span> <span class="nav-text">paging_init函数分析</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#console-init-%E5%87%BD%E6%95%B0%E5%88%86%E6%9E%90"><span class="nav-number">4.2.2.3.</span> <span class="nav-text">console_init 函数分析</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9%E5%86%85%E6%A0%B8"><span class="nav-number">4.2.3.</span> <span class="nav-text">修改内核</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-MTD-%E5%88%86%E5%8C%BA"><span class="nav-number">4.3.</span> <span class="nav-text">修改 MTD 分区</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%A9%B1%E5%8A%A8%E5%AF%B9%E8%AE%BE%E5%A4%87%E7%9A%84%E8%AF%86%E5%88%AB%E8%BF%87%E7%A8%8B"><span class="nav-number">4.3.1.</span> <span class="nav-text">驱动对设备的识别过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E6%94%B9-MTD-%E5%88%86%E5%8C%BA-1"><span class="nav-number">4.3.2.</span> <span class="nav-text">修改 MTD 分区</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%A7%BB%E6%A4%8D-YAFFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="nav-number">4.4.</span> <span class="nav-text">移植 YAFFS 文件系统</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#YAFFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E4%BB%8B%E7%BB%8D"><span class="nav-number">4.4.1.</span> <span class="nav-text">YAFFS 文件系统介绍</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#YAFFS-%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A7%BB%E6%A4%8D"><span class="nav-number">4.4.2.</span> <span class="nav-text">YAFFS 文件系统移植</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B0%86yaffs2%E4%BB%A3%E7%A0%81%E5%8A%A0%E5%85%A5%E5%86%85%E6%A0%B8"><span class="nav-number">4.4.2.1.</span> <span class="nav-text">将yaffs2代码加入内核</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E9%85%8D%E7%BD%AE%E3%80%81%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8"><span class="nav-number">4.4.2.2.</span> <span class="nav-text">配置、编译内核</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E3%80%81%E7%83%A7%E5%86%99%E3%80%81%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8"><span class="nav-number">4.5.</span> <span class="nav-text">编译、烧写、启动内核</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E8%AF%91%E5%86%85%E6%A0%B8"><span class="nav-number">4.5.1.</span> <span class="nav-text">编译内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%83%A7%E5%86%99%E5%86%85%E6%A0%B8"><span class="nav-number">4.5.2.</span> <span class="nav-text">烧写内核</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%90%AF%E5%8A%A8%E5%86%85%E6%A0%B8"><span class="nav-number">4.5.3.</span> <span class="nav-text">启动内核</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Nibil</p>
  <div class="site-description" itemprop="description">A Nibil's Sharing Blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">22</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">28</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">7</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NibilCN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NibilCN" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
    <div class="sidebar-inner">
      <!-- require APlayer -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
      <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
      <!-- require MetingJS -->
      <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
      <!--网易云-->   
      <meting-js
        server="netease"
        id="7593069088"
        type="playlist" 
        mini="false"
        fixed="false"
        list-folded="true"
        autoplay="true"
        volume="0.4"
        theme="#FADFA3"
        order="random"
        loop="all"
        preload="auto"
        mutex="true">
      </meting-js>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/NibilCN" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nibil">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laugh Tale">
      <meta itemprop="description" content="A Nibil's Sharing Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="移植Linux内核 | Laugh Tale">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          移植Linux内核
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-09-07 16:36:37" itemprop="dateCreated datePublished" datetime="2022-09-07T16:36:37+08:00">2022-09-07</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/" itemprop="url" rel="index"><span itemprop="name">书籍</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/" itemprop="url" rel="index"><span itemprop="name">嵌入式Linux应用完全开发手册</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/%E5%B5%8C%E5%85%A5%E5%BC%8FLinux%E5%BA%94%E7%94%A8%E5%AE%8C%E5%85%A8%E5%BC%80%E5%8F%91%E6%89%8B%E5%86%8C/%E7%AC%AC1%E7%AF%87%E7%AC%AC16%E7%AB%A0-%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/" itemprop="url" rel="index"><span itemprop="name">第1篇第16章 移植Linux内核</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>44k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>40 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>嵌入式Linux系统移植之移植Linux内核</p>
<p>《嵌入式Linux应用完全开发手册》第1篇第16章总结归纳</p>
<span id="more"></span>
<h1 id="本章目标"><a href="#本章目标" class="headerlink" title="本章目标"></a>本章目标</h1><ol>
<li>了解内核源码结构，了解内核启动过程</li>
<li>掌握内核配置方法</li>
<li>移植内核同时支持S3C2410、S3C2440</li>
<li>掌握MTD设备的分区方法</li>
<li>掌握YAFFS文件系统的移植方法</li>
</ol>
<h1 id="Linux-版本及特点"><a href="#Linux-版本及特点" class="headerlink" title="Linux 版本及特点"></a>Linux 版本及特点</h1><p>Linux内核的版本号可以从源代码的顶层目录下的Makefile中看到，比如下面几行它们构成了Linux的版本号：2.6.22.6。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">VERSION = <span class="number">2</span></span><br><span class="line">PATCHLEVEL = <span class="number">6</span></span><br><span class="line">SUBLEVEL = <span class="number">22</span></span><br><span class="line">EXTRAVERSION = <span class="number">.6</span></span><br></pre></td></tr></table></figure>
<p>其中的“VERSION”和“PATCHLEVEL”组成主版本号，比如2.4、2.5、2.6等，稳定版本的主版本号用偶数表示（比如2.4、2.6），每隔2-3年出现一个稳定版本。开发中的版本用技术表示（2.3、2.5），它是下一个稳定版本的前身。<br>“SUBLEVEL”称为此版本号，它不分奇偶顺序递增。每隔1-2个月发布一个稳定版本。<br>“EXTRAVERSION”称为扩展版本号，它不分奇偶，顺序递增。每周发布几次扩展版本号，修正最新的稳定版本的问题。<br>Linux内核的最初版本在1991年发布，这是Linus Torvalds为他开发的386开发的一个类Minix的操作系统。<br>Linux 1.0的官方版发行于1994年3月，包含了386的官方支持，仅支持单CPU系统。<br>Linux 1.2发行于1995年3月，它是第一个包含多平台（Alpha、Sparc、Mips等）支持的官方版本。<br>Linux 2.0发行于1996年6月，包含很多新的平台支持，但是最重要的是，它是第一个支持SMP（对称多处理器）体系的版本。<br>Linux 2.2发行于1999年1月，它带来了SMP系统性能的极大提升，同时支持更多的硬件。<br>Linux 2.2发行于2001年1月，它进一步提升了SMP系统的扩展性，同时它集成了很多用于支持桌面系统的特性：USB、PC卡（PCMCIA）的支持，内置的即插即用等。<br>Linux 2.6发行于2003年12月，在Linux 2.4的基础上作了极大的改进。2.6内核支持更多的平台，从小规模的嵌入式系统到服务器级的64位的系统；使用新的调度器，进程的切换更高效；内核可被抢占，使得用户的操作可以得到更快速的响应；I&#x2F;O子系统也经历很大的修改，使得它在各种工作负荷下都更具响应性；模块子系统、文件系统都做了大量的改进。另外，以前使用Linux的变种μClinux来支持没有MMU的处理器，现在2.6版本的Linux中已经合入了μClinux的功能，也可以支持没有MMU的处理器。</p>
<h1 id="Linux移植准备"><a href="#Linux移植准备" class="headerlink" title="Linux移植准备"></a>Linux移植准备</h1><h2 id="获取Linux内核源码"><a href="#获取Linux内核源码" class="headerlink" title="获取Linux内核源码"></a>获取Linux内核源码</h2><p>登录Linux内核的官方网站<code>http://www.kernel.org/</code>，可以看到下图所示的内容：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/1.jpeg" alt="img not found"><br>上面标明了Linux内核的最新稳定版本、正在开发的测试版本，图中间的版本号就是各种补丁的链接地址。各种标记符的意义如下表所示：</p>
<table>
<thead>
<tr>
<th>标记</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>F</td>
<td>全部代码，单击“F”即可下载全部内核代码</td>
</tr>
<tr>
<td>B</td>
<td>当前补丁基于哪个版本的内核，单击“B”可以下载这个内核</td>
</tr>
<tr>
<td>V</td>
<td>查看补丁文件的信息，修改了哪些文件</td>
</tr>
<tr>
<td>VI</td>
<td>查看与上一个扩展版本相比，修改了哪些文件</td>
</tr>
<tr>
<td>C</td>
<td>当前的修改记录</td>
</tr>
<tr>
<td>ChangeLog</td>
<td>正式的修改记录，由开发者提供</td>
</tr>
</tbody></table>
<p>一般而言，各种补丁文件都是基于内核的某个正式版本生成的，除非使用标记符“B”指明了它所基于的版本。比如有补丁文件patch-2.6.xx.1、patch-2.6.xx.2、patch-2.6.xx.3，它们都是基于内核2.6.xx生成的补丁文件。使用时可以在内核2.6.xx上直接打补丁patch-2.6.xx.3，并不需要先打上补丁文件patch-2.6.xx.1、patch-2.6.xx.2；相应的，如果已经打上了补丁文件patch-2.6.xx.2，在打补丁之前，要先去除补丁文件patch-2.6.xx.2。<br>本书在Linux2.6.22.6上进行移植开发。下载linux-2.6.22.6.tar.bz2后如下解压即可得到目录linux-2.6.22.6，里面存放了内核源码，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar xjf linux<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>.tar.bz2</span><br></pre></td></tr></table></figure>
<p>也可以先下载内核源文件linux-2.6.22.tar.bz2、补丁文件patch-2.6.22.6.bz2，然后解压、打补丁：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tar xjf linux<span class="number">-2.6</span><span class="number">.22</span>.tar.bz2</span><br><span class="line">tar xjf patch<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span>.bz2</span><br><span class="line">cd linux<span class="number">-2.6</span><span class="number">.22</span></span><br><span class="line">patch -p1 &lt; ../patch<span class="number">-2.6</span><span class="number">.22</span><span class="number">.6</span></span><br></pre></td></tr></table></figure>

<h2 id="内核源码结构及Makefile分析"><a href="#内核源码结构及Makefile分析" class="headerlink" title="内核源码结构及Makefile分析"></a>内核源码结构及Makefile分析</h2><h3 id="内核源码结构"><a href="#内核源码结构" class="headerlink" title="内核源码结构"></a>内核源码结构</h3><p>Linux内核文件有近2万，出去其他架构CPU的相关文件，支持S3C2410、S3C2440这两款芯片的完整内核文件有1万多个。这些文件的组织结构并不复杂，它们分别位于顶层目录下的17个子目录，各个目录功能独立。下表描述各目录的功能，最后两个目录不包含代码。</p>
<table>
<thead>
<tr>
<th>目录名</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>arch</td>
<td>体系结构相关的代码，对于每个架构的CPU，arch下有一个对应的子目录，比如<code>arch/arm</code>、<code>arch/i386</code>。</td>
</tr>
<tr>
<td>block</td>
<td>块设备的通用函数</td>
</tr>
<tr>
<td>crypto</td>
<td>常用的加密和散列算法（AES、SHA），还有一些压缩和CRC校验算法</td>
</tr>
<tr>
<td>drivers</td>
<td>所有的设备驱动程序，里面的每一个子目录对应一类驱动程序，比如<code>drivers/block</code>为块设备驱动程序，<code>drivers/char</code>为字符设备驱动程序，<code>drivers/mtd</code>为NOR Flash、NAND Flash等存储设备的驱动程序</td>
</tr>
<tr>
<td>fs</td>
<td>Linux支持的文件系统的代码，每一个子目录对应一种文件系统，比如<code>fs/jffs2</code>、<code>fs/ext2</code>、<code>fs/ext3</code></td>
</tr>
<tr>
<td>include</td>
<td>内核头文件，有基本头文件（存放在<code>include/linux</code>目录下）、各种驱动或功能部件的头文件（比如<code>include/media</code>、<code>include/mtd</code>、<code>include/net</code>）、各种体系相关的头文件（比如<code>include/asm-arm</code>、<code>include/asm-i386</code>）。当配置内核之后，<code>include/asm</code>是某个<code>include/asm-xxx</code>的链接</td>
</tr>
<tr>
<td>init</td>
<td>内核的初始化代码（不是系统的引导代码），其中的<code>main.c</code>文件中的<code>start_kernel</code>函数是内核引导后运行的第一个函数</td>
</tr>
<tr>
<td>ipc</td>
<td>进程间的通信代码</td>
</tr>
<tr>
<td>Kernel</td>
<td>内核管理的核心代码，与处理器相关的代码位于<code>arch/*/kernel</code></td>
</tr>
<tr>
<td>lib</td>
<td>内核用到的一些库函数的代码，比如<code>crc32.c</code>、<code>string.c</code>，与处理器相关的库函数代码位于<code>arch/*/lib</code>目录下</td>
</tr>
<tr>
<td>mm</td>
<td>内存管理代码，与处理器相关的内存管理代码位于<code>arch/*/mm</code>目录下</td>
</tr>
<tr>
<td>net</td>
<td>网络支持代码，每个子目录对应与网络的一个方面</td>
</tr>
<tr>
<td>security</td>
<td>安全、密钥相关的代码</td>
</tr>
<tr>
<td>sound</td>
<td>音频设备的驱动代码</td>
</tr>
<tr>
<td>usr</td>
<td>用来制作一个压缩的cpio归档文件：initrd的镜像，它可以作为内核启动后挂接的第一个文件系统</td>
</tr>
<tr>
<td>Documentation</td>
<td>内核文档</td>
</tr>
<tr>
<td>scripts</td>
<td>用于配置、编译内核的脚本文件</td>
</tr>
</tbody></table>
<p>对于ARM架构的S3C2410、S3C2440，其体系相关的代码在<code>arch/arm</code>目录下，在后面进行Linux移植时，开始的工作正是修改这个目录下的文件。内核代码的层次结构如下图：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/2.jpeg" alt="img not found"></p>
<h3 id="Linux-Makefile-分析"><a href="#Linux-Makefile-分析" class="headerlink" title="Linux Makefile 分析"></a>Linux Makefile 分析</h3><p>内核中的哪些文件将被编译，怎样被编译，连接顺序如何确定，哪个文件在最前面，哪些文件或函数先执行。这些都是通过Makefile来管理的。</p>
<ol>
<li>决定编译哪些文件</li>
<li>怎样编译这些文件</li>
<li>怎样连接这些文件</li>
</ol>
<p>Linux内核源码中含有很多个Makefile文件，这些Makefile文件又要包含其他一些文件（比如配置信息、通用的规则等 ）。这些文件构成了Linux的Makefile体系：</p>
<table>
<thead>
<tr>
<th>名称</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>顶层Makefile</td>
<td>它是所有Makefile文件的核心，从总体上控制着内核的编译、连接</td>
</tr>
<tr>
<td>.config</td>
<td>配置文件，在配置内核时生成，所有的Makefile文件（包括顶层目录及各级子目录）都是根据.config文件来决定使用哪些文件</td>
</tr>
<tr>
<td>arch&#x2F;$(ARCH)&#x2F;Makefile</td>
<td>对应体系结构的Makefile，它用来决定哪些体系结构相关的文件参与内核的生成，并提供一些规则来生成特定格式的内核映像</td>
</tr>
<tr>
<td>scipts&#x2F;Makefile.*</td>
<td>Makefile共用的通用规则、脚本等</td>
</tr>
<tr>
<td>kbuild Makefiles</td>
<td>各级子目录下的Makefile，它们相对简单，被上一层Makefile调用来编译当前子目录下的文件</td>
</tr>
</tbody></table>
<p>内核文档<code>Documentation/kbuild/makefiles.txt</code>对内核中的Makefile作用、用法讲解的非常透彻，以下根据前面总结的Makefile的3大作用分析这5类文件。</p>
<ol>
<li>决定编译哪些文件<br>Linux 内核的编译过程从顶层Makefile开始，然后递归进入各级子目录调用它们的Makefile，分为3个步骤。<br>①顶层Makefile决定内核根目录下哪些子目录将被编进内核。<br>②<code>arch/$(ARCH)/Makefile</code>决定<code>arch/$(ARCH)</code>目录下哪些文件、哪些目录将被编进内核。<br>③各级子目录下的Makefile决定所在目录下哪些文件将被编进内核，哪些文件将被编成模块（即驱动程序），进入哪些子目录继续调用它们的Makefile。</li>
</ol>
<p>先看步骤①，在顶层Makefile中可以看到如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init-y          :   init/</span><br><span class="line">drivers-y       :   drivers/    sound/</span><br><span class="line">net-y           :   net/</span><br><span class="line">libs-y          :   lib/</span><br><span class="line">core-y          :   usr/</span><br><span class="line">...</span><br><span class="line">core-y          +=  kernerl/    mm/ fs/ ipc/    security/   crypto/ block/</span><br></pre></td></tr></table></figure>
<p>可见，顶层Makefile将这13个子目录分为5类：init-y、drivers-y、net-y、libs-y和core-y。之前上表中的17个子目录，出去<code>include</code>目录和后面两个不包含内核代码的目录外，还有一个<code>arch</code>目录没有出现在内核中。它在<code>arch/$(ARCH)/Makefile</code>中被包含进内核，在顶层Makefile中直接包含了这个Makefile，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include $(srctree)/arch/$(ARCH)/Makefile</span><br></pre></td></tr></table></figure>
<p>对于ARCH变量，可以在执行make命令时传入，比如“make ARCH&#x3D;arm …”。另外，对于非x86平台，还需要指定交叉编译工具，这也可以在执行make命令时传入，比如“make CROSS_COMPILE&#x3D;arm-linux- …”。为了方便，常在顶层Makefile中进行修改。<br>修改前：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH    ?= $(SUBARCH)</span><br><span class="line">CROSS_COMPILE   ?= </span><br></pre></td></tr></table></figure>
<p>修改后：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ARCH    ?= arm</span><br><span class="line">CROSS_COMPILE   ?= arm-linux-</span><br></pre></td></tr></table></figure>
<p>对于步骤②的<code>arch/$(ARCH)/Makefile</code>，以ARM体系为例，在<code>arch/arm/Makefile</code>中可以看到如下内容：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">head-y  := arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o </span><br><span class="line">...</span><br><span class="line">core-y  += arch/arm/kernel/ arch/arm/mm/ arch/arm/common/</span><br><span class="line">core-y  += $(MACHINE)</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2400/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2412/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) += arch/arm/mach-s3c2440/</span><br><span class="line">...</span><br><span class="line">libs-y  := arch/arm/lib/    $(libs-y)</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>由第1行可知，除前面的5类子目录外，又出现了另一类：<code>head-y</code>，不过它是直接以文件名出现。MMUEXT在<code>arch/arm/Makefile</code>前面定义，对于没有MMU的处理器，MMUEXT的值为-nommu，使用文件head-nommu.S；对于有MMU的处理器，MMUEXT的值为空，使用文件head.S。<br><code>arch/arm/Makefile</code>中类似第3、4、5行的代码进一步扩展了<code>core-y</code>的内容，第9行扩展了<code>libs-y</code>的内容，这些都是体系结构相关的目录。第5-7行中的CONFIG_ARCH_S3C2410在配置内核时定义，它的值有3种：y、m、空。y表示编进内核，m表示编为模块，空表示不使用。<br>编译内核时，将依次进入init-y、core-y、libs-y、drivers-y和net-y所列出的目录执行它们的Makefile，每个子目录都会生成一个build-in.o（libs-y所列目录下，有可能lib.a文件）。最后，<code>head-y</code>所表示的文件将和这些build-in.o、lib.a一起被连接成内核映像文件vmlinux。<br>最后，步骤③是如何进行的。<br>在配置内核时，生成配置文件<code>.config</code>。内核顶层Makefile使用如下语句间接包含<code>.config</code>文件，以后就根据<code>.config</code>中定义的各个变量来决定编译哪些文件。之所以说是“间接”包含，是因为包含的是<code>include/config/auto.conf</code>文件，而它只是将<code>.config</code>文件中的注释去掉，并根据顶层Makefile中定义的变量增加一些变量而已。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#Read in config</span><br><span class="line">-include include/config/<span class="keyword">auto</span>.conf</span><br></pre></td></tr></table></figure>
<p><code>include/config/auto.conf</code>文件的生成过程不再描述，它与<code>.config</code>的格式相同，摘选部分内容如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_ARCH_SMDK2410=y</span><br><span class="line">CONFIG_ARCH_S3C2440=y</span><br><span class="line"># .config中没有下面这行，它是根据顶层Makefile中定义的内核的版本号增加的</span><br><span class="line">CONFIG_KERNELVERSION=<span class="string">&quot;2.6.22.6&quot;</span></span><br><span class="line"># .config中没有下面这行，它是根据顶层Makefile中定义的ARCH变量增加的</span><br><span class="line">CONFIG_ARCH=<span class="string">&quot;arm&quot;</span></span><br><span class="line">CONFIG_JFFS2_FS=y</span><br><span class="line">CONFIG_LEDS_S3C24XX=m</span><br></pre></td></tr></table></figure>

<p>在<code>include/config/auto.conf</code>文件中，变量的值主要有两类：“y”和“m”。各级子目录的Makefile使用这些变量来决定哪些文件被编译进内核中，哪些文件被编成模块（即驱动程序），要进入哪些下一级子目录继续编译，这通过以下4种方法来确定（obj-y、obj-m、lib-y是Makefile中的变量）。</p>
<p>①obj-y用来定义哪些文件被编进（build-in）内核。<br>obj-y中定义的.o文件由当前目录下的.c或.S文件编译生成，它们连同下级子目录的build-in.o文件一起被组合成（使用“$(LD) -r”命令）当前目录下的build-in.o文件。这个build-in.o文件将被它的上一层Makefile使用。<br>obj-y中各个.o文件的顺序是有意义的，因为内核中用<code>moudule_init</code>或<code>__initcall</code>定义的函数将按照它们的连接顺序被调用。<br><strong>例子1</strong>，当下面的CONFIG_ISDN、CONFIG_ISDN_PPP_BSDCOMP在<code>.config</code>中被定义为y时，isdn.c或isdn.S、isdn_bsdcomp.c或isdn_bsdcomp.S被编译成isdn.o、isdn_bssdcomp.o。这两个.o文件被组合进buidl-in.o文件中，最后被链接进入内核。假如isdn.o、isdn_bsdcomp.o中分别用<code>moudule_init(A)</code>、<code>moudule_init(B)</code>定义了函数A、B，则内核启动时A先被调用，然后是B。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_ISDN)      += isdn.o</span><br><span class="line">obj-$(CONFIG_ISDN_PPP_BSDCOMP)      += isdn_bsdcomp.o</span><br></pre></td></tr></table></figure>

<p>②obj-m用来定义哪些文件被编译成可加载模块（Loadable module）。<br>obj-m中定义的.o文件有当前目录下的.c或.S文件编译生成，它们不会被编进build-in.o中，而是被编成可加载模块。<br>一个模块可以由一个或多个.o文件组成。对于只有一个源文件的模块，在obj-m中直接增加它的.o文件即可。对于有多个源文件的模块，除在obj-m中增加一个.o文件外，还要定义一个<module_name>-objs变量来告诉Makefile这个.o文件由哪些文件组成。<br><strong>例子2</strong>，当下面的CONFIG_ISDN_PPP_BSDCOMP在.config文件中被定义为m时，isdn_bsdcomp.c或isdn_bsdcomp.S将被编译成isdn_bsdcomp.o文件，它最后被制作成isdn_bsdcomp.ko模块。</module_name></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#drivers/isdn/i4l/Makefile</span></span><br><span class="line">obj-$(CONFIG_ISDN_PPP_BSDCOMP)  += isdn_bsdcomp.o</span><br></pre></td></tr></table></figure>
<p><strong>例子3</strong>，当下面的CONFIG_ISDN在.config文件中被定义为m时，将会生成一个isdn.o文件，它由isdn-objs中定义的isdn-net-lib.o、isdn_v110.o、isdn_common.o等3个文件组合而成。isdn.o最后被制作成isdn.ko模块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#drivers/isdn/i4l/Makefile</span></span><br><span class="line">obj-$(CONFIG_ISDN)  += isdn.o</span><br><span class="line">isdn-objs   :=  isdn_net_lib.o isdn_v110.o isdn_common.o</span><br></pre></td></tr></table></figure>

<p>③lib-y用来定义哪些文件被编成库文件<br>lib-y中定义的.o文件由当前目录下的.c或.S文件编译生成，它们被打包成当前目录下的一个库文件：lib.a。<br>同时出现在obj-y、lib-y中的.o文件，不会被包含进lib.a中。<br>要把这个lib.a编译进入内核中，需要在顶层Makefile中libs-y变量中列出当前目录。要编成库文件的内核代码一般都在这两个目录下：<code>lib/</code>、<code>arch/$(ARCH)/lib</code>。</p>
<p>④obj-y、obj-m还可以用来指定要进入的下一级子目录。<br>Linux中一个Makefile文件只负责生成当前目录下的目标文件，子目录下的目标文件由子目录的Makefile生成。Linux的编译系统会自动进入这些子目录调用他们的Makefile，只是需要在进入之前指定这些子目录。<br>这要用到obj-y、obj-m，只要在其中增加这些子目录名即可。<br><strong>例子4</strong>，<code>fs/Makefile</code>中有如下一行，当CONFIG_JFFS2_FS被定义为y或m时，在编译时将会进入<code>jffs2</code>目录进行编译。Linu的编译系统只会根据这些信息决定是否进入下一级目录，而下一级目录的文件如何编译成build-in.o或模块由它的Makefile决定。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_JFFS2_FS)      += jffs2</span><br></pre></td></tr></table></figure>

<ol start="2">
<li><p>怎么编译这些文件<br>即编译选项、连接选项是什么。这些选项分为3类：全局的，适用于整个内核代码树；局部的，仅适用于某个Makefile中的所有文件；个体的，仅适用于某个文件。<br>全局选项在顶层Makefile和<code>arch/$(ARCH)/Makefile</code>中定义，这些选项的名称为：CFLAGS、AFLAGS、LDFLAGS、ARFLAGS，它们分别是编译C文件的选项、编译汇编文件的选项、连接文件的选项、制作库文件的选项。<br>需要使用局部选项时，它们在各个子目录中定义，名称为：EXTRA_FLAGS、EXTRA_ALAGS、EXTRA_LDFLAGS、EXTRA_ARFLAGS，它们的用途与前述选项相同，只是适用范围比较小，它们针对当前的Makefile中的所有文件。<br>另外，如果想针对某个文件定义它的编译选项，可以使用CFLAGS_$@,AFLAGS_$@。前者用于编译某个C文件，后者用于编译某个汇编文件。$@表示某个目标文件名，比如以下代码表示编译aha152x.c时，选项中要额外加上“-DAHA152X_STAT -DAUTOCONF”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># drivers/scsi/Makefile</span></span><br><span class="line">CFLAGS_aha152x.o = -DAHA152X_STAT -DAUTOCONF</span><br></pre></td></tr></table></figure>
<p>需要注意的是，这3类选项是一起用的，在<code>scropts/Makefile.lib</code>中可以看到。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">_c_flags  = $(CFLAGS) $(EXTRA_CFLAGS) $(CFLAGS_$(basetarget).o)</span><br></pre></td></tr></table></figure>
</li>
<li><p>怎样连接这些文件，它们的顺序如何<br>前面分析有哪些文件需要编译进入内核时，顶层Makefile和<code>arch/$(ARCH)/Makefile</code>定义了6类目录（或文件）：head-y、init-y、drivers-y、net-y、libs-y和core-y。它们的初始值如下（以ARM体系为例）：<br><code>arch/arm/Makefile</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">head-y    := arch/arm/kernel/head$(MMUEXT).o arch/arm/kernel/init_task.o</span><br><span class="line">...</span><br><span class="line">core-y    := arch/arm/kernel/ arch/arm/mm/ arch/arm/common/</span><br><span class="line">core-y    := $(MACHINE)</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2400/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2412/</span><br><span class="line">core-$(CONFIG_ARCH_S3C2410) +=  arch/arm/mach-s3c2440/</span><br><span class="line">...</span><br><span class="line">libs-y				:= arch/arm/lib/ $(libs-y)</span><br></pre></td></tr></table></figure>
<p>顶层Makefile中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init-y  :=  init/</span><br><span class="line">drivers :=  drivers/  sound/</span><br><span class="line">net-y   :=  net/</span><br><span class="line">libs-y  :=  lib/</span><br><span class="line">core-y  :=  usr/</span><br><span class="line">...</span><br><span class="line">core-y  +=  kernel/ mm/ fs/ ipc/  security/ crypto/ block/</span><br></pre></td></tr></table></figure>
<p>可见，除head-y之外，其余的init-y、drivers-y等都是目录名。在顶层Makefile中，这些目录名的后面直接加上build-in.o或lib.a，表示要连接进内核的文件，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">init-y  :=  $(patsubst %/, %/build-in.o, $(init-y))</span><br><span class="line">core-y  :=  $(patsubst %/, %/build-in.o, $(core-y))</span><br><span class="line">drivers-y  :=  $(patsubst %/, %/build-in.o, $(drivers-y))</span><br><span class="line">net-y  :=  $(patsubst %/, %/lib.a, $(net-y))</span><br><span class="line">libs-y1  :=  $(patsubst %/, %/build-in.o, $(libs-y))</span><br><span class="line">libs-y2  :=  $(patsubst %/, %/build-in.o, $(libs-y))</span><br><span class="line">libs-y  :=  $(libs-y1 $(libs-y2))</span><br></pre></td></tr></table></figure>
<p>上面的patsubst是个字符串处理函数，它的用法如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$(patsubst pattern,replacement,text)</span><br></pre></td></tr></table></figure>
<p>表示寻找“text”中符合格式“pattern”的字，用“replacement”替换它们。比如上面的init-y初值为“init&#x2F;”，经过交换之后，“init-y”变为“init&#x2F;build-in.o”。<br>顶层Makefile中，继续往下看：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vmlinux-init  :=  $(head-y) $(init-y)</span><br><span class="line">vmlinux-main  :=  $(core-y) $(libs-y) $(drivers-y)  $(net-y)</span><br><span class="line">vmlinux-all   :=  $(vmlinux-linux)  $(vmlinux-main)</span><br><span class="line">vmlinux-lds   :=  arch/$(ARCH)/kernel/vmlinux.lds</span><br></pre></td></tr></table></figure>
<p>第3行的<code>vmlinux-all</code>表示所有构成内核映像文件vmlinux的目标文件，从第1-3行可知这些目标文件的顺序为：head-y、init-y、core-y、libs-y、drivers-y、net-y，即<code>arch/arm/kernel/head.o</code>（假设有MMU，否则为head-nommu.o）、<code>arch/arm/kernel/init_task.o</code>、<code>init/build-in.o</code>、<code>usr/build-in.o</code>等。<br>第4行表示连接脚本为<code>arch/$(ARCH)/kernel/vmlinux.lds</code>。对于ARM体系，连接脚本就是<code>arch/arm/kernel/vmlinux.lds</code>，它由<code>arch/arm/kernel/vmlinux.lds.S</code>文件生成。规则在<code>scripts/Makefile.build</code>中，如下所示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$(obj)/%.lds: $(src)/%.lds.S  FORCE</span><br><span class="line">      $(call if_changed_dep,cpp_lds_S)</span><br></pre></td></tr></table></figure>
<p>现将生成的<code>arch/arm/kernel/vmlinux.lds</code>摘录如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">SECTIONS</span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	. = 0xc0000000 + 0x00008000;                  /* 代码段起始地址，这是个虚拟地址 */</span><br><span class="line"></span><br><span class="line">	.text.head : &#123;</span><br><span class="line">		_stext = .;</span><br><span class="line">		_sinittext = .;</span><br><span class="line">		*(.text.head)</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.init : &#123;			                                /* 内核初始化的代码和数据 */</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	.text : &#123;			                                /* 真正的代码段 */</span><br><span class="line">		_text = .;		                              /* 代码段和只读数据段的开始地址	*/</span><br><span class="line">...</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	/* 只读数据 */</span><br><span class="line">  . = ALIGN((4096)); .rodata:AT(ADDR(.rodata) - 0) &#123;......&#125; . = ALIGN((4096));</span><br><span class="line"></span><br><span class="line">	_etext = .;			                              /* 代码段和只读数据段的结束地址 */</span><br><span class="line">... ...</span><br><span class="line">	.data : AT(__data_loc) &#123;                      /* 数据段 */</span><br><span class="line">		__data_start = .;	                          /* 数据段起始地址 */</span><br><span class="line">... ...</span><br><span class="line">		_edata = .;                                 /* 数据段结束地址 */</span><br><span class="line">	&#125;</span><br><span class="line">	_edata_loc = __data_loc + SIZEOF(.data);      /* 数据段结束地址 */</span><br><span class="line"></span><br><span class="line">	.bss : &#123;                                      /* BSS段，没有初始化或初值为0的全局、静态变量 */</span><br><span class="line">		__bss_start = .;	                          /* BSS段起始地址 */</span><br><span class="line">		*(.bss)</span><br><span class="line">		*(COMMON)</span><br><span class="line">		_end = .;                                   /* BSS段结束地址 */</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	.stab 0 : &#123; *(.stab) &#125;                        /* 调试信息段	*/</span><br><span class="line">... ...</span><br></pre></td></tr></table></figure>
<p>下面对本节分析Makefile的结果作一下总结。</p>
</li>
<li><p>配置文件.config中定义了一系列的变量，Makefile将结合它们来决定哪些文件被编进内核、哪些文件被编成模块、涉及哪些子目录。</p>
</li>
<li><p>顶层Makefile和<code>arch/$(ARCH)/Makefile</code>决定根目录下哪些子目录、<code>arch/$(ARCH)</code>目录下哪些文件和目录将被编进内核。</p>
</li>
<li><p>最后，各级子目录下的Makefile决定所在目录下哪些文件将被编进内核，哪些文件将被编成模块（驱动程序），进入哪些子目录继续调用它们的Makefile。</p>
</li>
<li><p>顶层Makefile和<code>arch/$(ARCH)/Makefile</code>设置了可以影响所有文件的编译、连接选项：CFLAGS、AFLAGS、LDFLAGS、ARFLAGS。</p>
</li>
<li><p>各级子目录下的Makefile中可以设置能够影响当前目录下所有文件的编译、连接选项：EXTRA_CFLAGS、EXTRA_AFLAGS、EXTRA_LDFLAGS、EXTRA_ARFLAGS；还可以设置可以影响某个文件的编译选项：CFLAGS_$@，AFLAGS_$@。</p>
</li>
<li><p>顶层Makefile按照一定的顺序组织文件，根据连接脚本<code>arch/$(ARCH)/kernel/vmlinux.lds</code>生成内核映像文件vmlinux。</p>
</li>
</ol>
<h2 id="内核的Kconfig分析"><a href="#内核的Kconfig分析" class="headerlink" title="内核的Kconfig分析"></a>内核的Kconfig分析</h2><p>在内核目录下执行“make menuconfig ARCH&#x3D;arm CROSS_COMPILE&#x3D;arm-linux-”时，就会看到一个如下图所示的菜单：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/3.jpeg" alt="img not found"><br>这就是内核的配置界面。通过配置界面，可以选择芯片类型、选择需要支持的文件系统，去除不需要的选项等，这就称为“配置内核”。注意，也有其他形式的配置界面，比如“make config”命令启动字符配置界面，对于每个选项都会依次出现一行提示信息，逐个回答；“make xconfig”命令启动X-windows图形配置界面。<br>所有配置工具都是通过读取<code>arch/$(ARCH)/Kconfig</code>文件来生成配置界面，这个文件是所有配置文件的总入口，它会包含其他目录的Kconfig文件。配置界面如上图所示。<br>内核源码的每个子目录中，都有一个Makefile文件和Kconfig文件。Makefile的作用前面已经讲述，Kconfig用于配置内核，它就是各种配置界面的源文件。内核的配置工具读取各个Kconfig文件，生成配置界面供开发人员配置内核，最后生成配置文件.config。<br>内核的配置界面以树状的菜单形式组织，主菜单下有若干子菜单，子菜单下又有子菜单或配置选项。每个子菜单或选项可以有依赖关系，这些依赖关系用来确定它们上是否显示。只有被依赖项的父项已经被选中，子项才会显示。<br>Kconfig文件的语法可以参考<code>Documentation/kbuild/kconfig-language.txt</code>文件，下面讲述几个常用的语法，并在最后介绍菜单形式的配置界面操作方法。</p>
<h3 id="Kconfig-文件的基本要素：config条目（entry）"><a href="#Kconfig-文件的基本要素：config条目（entry）" class="headerlink" title="Kconfig 文件的基本要素：config条目（entry）"></a>Kconfig 文件的基本要素：config条目（entry）</h3><p>config条目常被其他条目包含，用来生成菜单、进行多项选择等。<br>config条目用来配置一个选项，或者这么说，它用于生成一个变量，这个变量会连同它的值一起被写入配置文件.config中。比如有一个config条目用来配置CONFIG_LEDS_S3C24XX，根据用户的选择，.config文件中可能出现下面3种配置结果中的一个。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">CONFIG_LEDS_S3C24XX=y         # 对应的文件被编进内核</span><br><span class="line">CONFIG_LEDS_S3C24XX=m         # 对应的文件被编成模块</span><br><span class="line">#CONFIG_LEDS_S3C24XX          # 对应的文件没有被使用</span><br></pre></td></tr></table></figure>
<p>以一个例子说明config条目格式，下面代码选自<code>fs/Kconfig</code>文件，它用于配置CONFIG_JFFS2_FS_POSIX_ACL选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">config JFFS2_FS_POSIX_ACL</span><br><span class="line">	bool &quot;JFFS2 POSIX Access Control Lists&quot;</span><br><span class="line">	depends on JFFS2_FS_XATTR</span><br><span class="line">	default y</span><br><span class="line">	select FS_POSIX_ACL</span><br><span class="line">	help</span><br><span class="line">	  Posix Access Control Lists (ACLs) support permissions for users and</span><br><span class="line">	  groups beyond the owner/group/world scheme.</span><br><span class="line">	  </span><br><span class="line">	  To learn more about Access Control Lists, visit the Posix ACLs for</span><br><span class="line">	  Linux website &lt;http://acl.bestbits.at/&gt;.</span><br><span class="line">	  </span><br><span class="line">	  If you don&#x27;t know what Access Control Lists are, say N</span><br></pre></td></tr></table></figure>
<p>代码中包含了几乎所有的元素，下面一一说明：<br>第1行中，config是关键字，表示一个配置选项的开始；紧跟着的JFFS2_FS_POSIX_ACL是配置选项的名称，省略了前缀“CONFIG_”。<br>第2行中，boot表示变量类型，即CONFIG_JFFS2_FS_POSIX_ACL的类型。有5种类型：bool、tristate、string、hex和int，其中的tristate和string是基本的类型，其他类型是它们的变种。boot变量取值有两种：y和n；tristate变量取值有3种：y、n和m；string变量取值为字符串；hex变量取值为十六进制的数据；int变量取值为十进制的数据。<br>“boot”之后的字符串是提示信息，在配置界面中上下移动光标选中它时，就可以通过按空格或回车来设置CONFIG_JFFS2_FS_POSIX_ACL的值。提示信息的完整格式如下，如果使用“if<expr>”，则当expr为真时才显示提示信息。在实际使用时，prompt关键字可以省略。</expr></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;prompt&quot;</span> &lt;prompt&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第3行表示依赖关系，格式如下。只有JFFS2_FS_XATTR配置选项被选中时，当前配置选项中的提示信息才会出现，才能设置当前配置选项。注意，如果依赖条件不满足，则它取默认值。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;depend on &quot;</span>/<span class="string">&quot;requires&quot;</span> &lt;expr&gt;</span><br></pre></td></tr></table></figure>
<p>第4行的表示默认值为y，格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;default&quot;</span> &lt;expr&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第5行表示当前配置选项JFFS2_FS_POSIX_ACL被选中时，配置选项FS_POSIX_ACL也会被自动选中，格式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;select&quot;</span> &lt;symbol&gt; [<span class="string">&quot;if&quot;</span> &lt;expr&gt;]</span><br></pre></td></tr></table></figure>
<p>第6行表示下面几行是帮助信息，帮助信息的关键字有如下两种，它们完全一样。当遇到一行的缩进距离比第一行帮助信息的缩进距离小时，表示帮助信息已经结束。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&quot;help&quot;</span> or <span class="string">&quot;---help---&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="menu-条目"><a href="#menu-条目" class="headerlink" title="menu 条目"></a>menu 条目</h3><p>menu条目用于生成菜单，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;menu&quot; &lt;prompt&gt;</span><br><span class="line">&lt;menu options&gt;</span><br><span class="line">&lt;menu block&gt;</span><br><span class="line">&quot;endmenu&quot;</span><br></pre></td></tr></table></figure>
<p>它的实际使用并不如它的标准格式那样复杂，下面是一个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;Floating point emulation&quot;</span><br><span class="line"></span><br><span class="line">config FPE_NWFPE</span><br><span class="line">      ... ...</span><br><span class="line">config FPE_NWFPE_XP</span><br><span class="line">      ... ... </span><br><span class="line">... ...</span><br><span class="line">endmenu</span><br></pre></td></tr></table></figure>
<p>menu之后的字符串是菜单名，“menu”和“endmenu”之间有很多config条目。在配置界面会出现如下字样的菜单，移动光标选中它后按回车键进入，就会看到这些config条目定义的配置选项。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Floating point emulation  ---&gt;</span><br></pre></td></tr></table></figure>
<h3 id="choice-条目"><a href="#choice-条目" class="headerlink" title="choice 条目"></a>choice 条目</h3><p>choice条目将多个类似的配置选项组合在一起，供用户单选或多选，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;choice&quot;</span><br><span class="line">&lt;choice options&gt;</span><br><span class="line">&lt;choice block&gt;</span><br><span class="line">&quot;endchioce&quot;</span><br></pre></td></tr></table></figure>
<p>实际使用中，也是在“choice”和“endchoice”之间定义多个config条目，比如<code>arch/arm/Kconfig</code>中有如下代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">choice </span><br><span class="line">      prompt &quot;ARM system type&quot;</span><br><span class="line">      default ARCH_VERSATILE</span><br><span class="line"></span><br><span class="line">config ARCH_AAEC2000</span><br><span class="line">      ...</span><br><span class="line">config ARCH_INTEGRATOR</span><br><span class="line">      ...</span><br><span class="line">endchoice</span><br></pre></td></tr></table></figure>
<p>prompt“ARM system type”给出提示信息“ARM system type”，光标选中它之后按回车键进入，就可以看到多个config条目定义的配置选项。<br>choice条目中定义的变量类型只能有两种：bool和tristate，不能同时有这两种类型的变量。对于bool类型的choice条目，只能在多个选项中选择一个；对于tristate类型的choice条目，要么就把一个或多个选项色设为m；要么就像bool类型的choice条目一样，只能选择一个。这是可以理解的，比如对于同一个硬件，它有多个驱动程序，可以选择将其中之一编译进内核（配置选项设置为y），也可以都将它们编译成模块（配置选项设置为m）。</p>
<h3 id="comment-条目"><a href="#comment-条目" class="headerlink" title="comment 条目"></a>comment 条目</h3><p>comment条目用于定义一些帮助信息，它在配置过程中出现界面的第一行；并且这些帮助信息会出现在配置文件中，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&quot;comment&quot; &lt;prompt&gt;</span><br><span class="line">&lt;comment options&gt;</span><br></pre></td></tr></table></figure>
<p>实际使用也很简单，比如<code>arch/arm/Kconfig</code></p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">menu &quot;Floating point emulation&quot;</span><br><span class="line"></span><br><span class="line">comment &quot;At least one emulation must be selected&quot;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>进入菜单“Floating point emulation —&gt;”之后，在第一行会看到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">--- At least one emulation must be selected</span><br></pre></td></tr></table></figure>
<p>而在.config文件中也会看到如下内容：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">#</span><br><span class="line"># At least one emulation must be selected</span><br><span class="line"># </span><br></pre></td></tr></table></figure>
<h3 id="source-条目"><a href="#source-条目" class="headerlink" title="source 条目"></a>source 条目</h3><p>source 条目用于读入另一个Kconfig文件，格式如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;source&quot; &lt;prompt&gt;</span><br></pre></td></tr></table></figure>
<p>下面是一个例子，取自<code>arch/arm/Kconfig</code>，它读入<code>net/Kconfig</code>文件。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source &quot;net/Kconfig&quot;</span><br></pre></td></tr></table></figure>

<h3 id="菜单形式的配置界面操作方法"><a href="#菜单形式的配置界面操作方法" class="headerlink" title="菜单形式的配置界面操作方法"></a>菜单形式的配置界面操作方法</h3><p>配置界面的开始几行就是它的操作方法，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/4.jpeg" alt="img not found"><br>内核<code>scripts/kconfig/mconf.c</code>文件的注释给出了更详细的操作方法，讲解如下：<br>一些特定功能的文件可以直接编译进内核中，或者编译成一个可加载模块，或者根本不使用它们。还有一些内核参数，必须给它们赋一个值：十进制数、十六进制数，或者一个字符串。<br>配置界面中，以<code>[*]</code>、<code>&lt;M&gt;</code>或<code>[]</code>开头的选项表示相应的功能被编译进内核中、被编译成一个模块，或者没有使用。尖括号<code>&lt;&gt;</code>表示相应功能的文件可以被编译成模块。<br><code>↑</code>、<code>↓</code>方向键用来高亮选中某个配置选项，如果要进入某个子菜单，先选中它，然后按回车键进入。配置选项的名字后有<code>---&gt;</code>表示它是一个子菜单。配置选项的名称中有一个高亮的字母，它被称为<code>热键(hotkey)</code>,直接输入热键就可以选中该配置选项，或者循环选中具有相同热键的配置选项。<br>可以使用翻页键<code>&lt;Page Up&gt;</code>、<code>&lt;Page Down&gt;</code>来移动配置界面中的内容。<br>要退出配置界面，使用<code>←</code>、<code>→</code>方向键选中<code>&lt;Exit&gt;</code>按钮，然后按回车键。如果没有配置选项使用后面这些按键作为热键的话，也可以按两次<code>&lt;ESC&gt;</code>或<code>&lt;E&gt;&lt;X&gt;</code>键退出。<br>按<code>&lt;TAB&gt;</code>键可以在<code>&lt;Select&gt;</code>、<code>Exit</code>、<code>Help</code>这3个按钮中循环选中它们。<br>要想阅读某个配置选项的帮助信息，选中它之后，再选中<code>&lt;Help&gt;</code>按钮，按回车键；也可以选中配置选项后，直接按<code>&lt;H&gt;</code>或<code>&lt;?&gt;</code>键。<br>对于choice条目中的多个配置选项，使用方向键高亮选中某个配置选项，按<code>&lt;S&gt;</code>或空格键选中它；也可以通过输入配置选项的首字母，按<code>&lt;S&gt;</code>或空格键选中它。<br>对于int、hex或string类型的配置选项，要输入它们的值时，先高亮选中选中它，按回车键，输入数据，再按回车键。对于十六进制数据，前缀0x可以省略掉。<br>配置界面的最下面，如下图红框所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/5.jpeg" alt="img not found"><br>前者用于加载某个配置文件，后者用于将当前的配置保存到某个配置文件中去。需要注意的是，如果不使用这两个选项，配置的加载文件、输出文件都默认为.config文件；如果加载了其他的文件（假设文件名为A），然后在它的基础上进行修改，最后退出保存时，这些变化会保存到A中去，而不是.config。<br>当然，可以先加载文件A，然后修改，最后保存到.config中去。</p>
<h2 id="Linux-内核配置选项"><a href="#Linux-内核配置选项" class="headerlink" title="Linux 内核配置选项"></a>Linux 内核配置选项</h2><p>Linux内核配置选项多达上千个，一个个的进行选择既耗费时间，对开发人员的要求也比较高（需要了解每个配置选项的作用）。一般的做法是在某个默认配置文件的基础上进行修改，比如我们可以先加载配置文件<code>arch/arm/configs/s3c2410_defconfig</code>，再增加、去除某些配置选项。</p>
<h3 id="配置界面主菜单的类别"><a href="#配置界面主菜单的类别" class="headerlink" title="配置界面主菜单的类别"></a>配置界面主菜单的类别</h3><p>下表讲解了主菜单的类别，以后读者配置内核时，可以根据自己所要设置的功能进入某个菜单，然后根据其中的各个配置选项的帮助信息进行配置。</p>
<table>
<thead>
<tr>
<th>配置界面主菜单</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Code maturity level options</td>
<td>代码成熟度选项：用于包含一些正在开发的或者不成熟的代码、驱动程序。一般不设置</td>
</tr>
<tr>
<td>Genaral setup</td>
<td>常规设置：比如增加附加的内核版本号、支持	内存交换功能、System V进程间通信等。除非很熟悉其中的内容，否则一般使用默认配置</td>
</tr>
<tr>
<td>Loadable module support</td>
<td>可加载模块支持：一般都会打开可加载模块支持（Enable loadable module support）、允许卸载已经加载到模块（Module unloading）、让内核通过运行modprobe来自动加载所需要的模块（Automatic kernel module loading）</td>
</tr>
<tr>
<td>Block layer</td>
<td>块设备层：用于设置块设备的一些总体参数，比如是否支持大于2TB的块设备、是否支持大于2TB的文件、设置I&#x2F;O调度器等。一般使用默认值即可</td>
</tr>
<tr>
<td>System Type</td>
<td>系统类型：选择CPU的架构、开发板类型等与开发板相关的配置选项</td>
</tr>
<tr>
<td>Bus support</td>
<td>PCMCIA&#x2F;CardBus总线的支持</td>
</tr>
<tr>
<td>Kernel Features</td>
<td>用于设置内核的一些参数，比如是否支持内核抢占、是否支持动态修改系统时钟等</td>
</tr>
<tr>
<td>Boot options</td>
<td>启动参数：比如设置默认的命令行参数等</td>
</tr>
<tr>
<td>Floating point emulation</td>
<td>浮点运算仿真功能：目前Linux 还不支持硬件浮点运算，所以要选择一个浮点仿真器，一般选择“NWFPE math emulation”</td>
</tr>
<tr>
<td>Userspace binary formats</td>
<td>可执行文件格式：一般都支持ELF、a.out格式</td>
</tr>
<tr>
<td>Power management options</td>
<td>电源管理选项</td>
</tr>
<tr>
<td>Networking</td>
<td>网络协议选项：一般选择“Networking support”以支持网络功能，选择“Packet socket”以支持socket接口功能，选择“TCP&#x2F;IP networking”以支持TCP&#x2F;IP网络协议。通常可以在选择“Networking support”后使用默认配置</td>
</tr>
<tr>
<td>Device Drivers</td>
<td>设备驱动程序：几乎包含了Linux的所有驱动程序</td>
</tr>
<tr>
<td>File systems</td>
<td>文件系统：可以在里面选择要支持的文件系统，比如EXT2、JFFS2等</td>
</tr>
<tr>
<td>Profiling support</td>
<td>对系统的活动进行分析，仅供内核开发者使用</td>
</tr>
<tr>
<td>Kernel hacking</td>
<td>调试内核时的各种选项</td>
</tr>
<tr>
<td>Security options</td>
<td>安全选项，一般使用默认配置</td>
</tr>
<tr>
<td>Cryptographic options</td>
<td>加密选项</td>
</tr>
<tr>
<td>Library routines</td>
<td>库子程序：比如CRC32检验函数、zlib压缩函数等。不包含在内核源码中的第三方内核模块可能需要这些库，可以全不选，内核中若有其他部分依赖它，会自动选上</td>
</tr>
</tbody></table>
<h3 id="“System-Type”-菜单：系统类型"><a href="#“System-Type”-菜单：系统类型" class="headerlink" title="“System Type” 菜单：系统类型"></a>“System Type” 菜单：系统类型</h3><p>对于arm平台（在顶层Makefile中修改“ARCH ?&#x3D; arm”）,执行“make menuconfig”后，在配置界面可以看到“System Type”字样，进入它得到另一个界面，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/6.jpeg" alt="img not found"><br>第一行“ARM system type”用来选择体系结构，进入它之后选中“Samsung S3C2410，S3C2412，S3C2413，S3C2440，S3C2442，S3C2443”，查看帮助信息可以知道它对应CONFIG_ARCH_S3C2410配置项。<br>下面几行用来设置S3C2410（包括S3C2412等）系统的特性，比如选中“S3C2410 UART to use for low-level message”后按回车键，可以输入数字，表示使用哪个串口来输入内核打印信息：选中“S3C2410 DMA support”表示支持DMA功能。<br>再往下的“S3C2410 Machine —&gt;”、“S3C2440 Machine —&gt;”表示这又是一个菜单，它们用来选择开发板类型。比如进入“S3C2410 Machine”菜单后，可以看到如下内容：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/7.jpeg" alt="img not found"><br>它们表示目前内核中支持S3C2410的8种开发板。选中某个开发板之后，它相应的文件就会被编译进内核中。比如对于开发板<code>SMDK2410/A9M2410</code>，它的配置项为CONFIG_ARCH_SMDK2410，在<code>arch/arm/mach-s3c2410/Makefile</code>中可以看到如下一行，表示如果选择支持该开发板，则<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code>文件被编进内核中。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_ARCH_SMDK2410) 	+= mach-smdk2410.o</span><br></pre></td></tr></table></figure>
<p>在移植内核时，可以选中某个配置相似的开发板，然后在上面进行修改。</p>
<h3 id="“Device-Drivers”-菜单：设备驱动程序"><a href="#“Device-Drivers”-菜单：设备驱动程序" class="headerlink" title="“Device Drivers” 菜单：设备驱动程序"></a>“Device Drivers” 菜单：设备驱动程序</h3><p>执行“make menuconfig”后，在配置界面可以看到“Device Drivers”字样，进入它得到另一个界面，如下图所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/8.jpeg" alt="img not found"><br>图中的各个子菜单与内核源码<code>drivres/</code>目录下各个子目录一一对应，如下表所示，在配置过程中可以参考这个表格找到对应的配置选项，在添加新驱动时，也可以参考它来决定代码放在哪个目录下。</p>
<table>
<thead>
<tr>
<th>Device Drivers 子菜单</th>
<th>描述</th>
</tr>
</thead>
<tbody><tr>
<td>Generic Driver Options</td>
<td>对应<code>divers/base</code>目录，这是设备驱动程序中一些基本和通用的配置选项</td>
</tr>
<tr>
<td>Connector - undefined userspace &lt;-&gt; kernelspace linker</td>
<td>对应<code>divers/connector</code>目录</td>
</tr>
<tr>
<td>Memory Technology Device （MTD）support</td>
<td>对应<code>divers/mtd</code>目录，用于支持各种新型的存储设备，比如NOR Flash、NAND Flash等</td>
</tr>
<tr>
<td>Parallel port support</td>
<td>对应<code>divers/parport</code>目录，用于支持各种并口设备</td>
</tr>
<tr>
<td>Plug and Play support</td>
<td>对应<code>divers/pnp</code>目录，支持各种“即插即用”设备</td>
</tr>
<tr>
<td>Block devices</td>
<td>对应<code>divers/block</code>目录，包括回环设备、RAMDISK等的驱动</td>
</tr>
<tr>
<td>ATA&#x2F;ATAPI&#x2F;MFM&#x2F;RLL support</td>
<td>对应<code>divers/ide</code>目录，它用来支持ATA&#x2F;ATAPI&#x2F;MFM&#x2F;RLL 接口的硬盘、软盘、光盘等</td>
</tr>
<tr>
<td>SCSI device support</td>
<td>对应<code>divers/scsi</code>目录，支持各种scsi接口的设备</td>
</tr>
<tr>
<td>Serial ATA（prod）and parallel ATA （experiment）drivers</td>
<td>对应<code>divers/ata</code>目录，支持SATA与PATA设备</td>
</tr>
<tr>
<td>Multi-device support （RAID and LVM）</td>
<td>对应<code>divers/md</code>目录，表示多设备支持（RAID和LVM），RAID和LVM的作用是使多个物理设备组建成一个单独的逻辑磁盘</td>
</tr>
<tr>
<td>Network device support</td>
<td>对应<code>divers/net</code>目录，用来支持各种网络设备，比如CS8900、DM9000等</td>
</tr>
<tr>
<td>ISDN subsystem</td>
<td>对应<code>divers/isdn</code>目录，用来提供综合业务数字网（Integrate Service Digital Network）的驱动程序</td>
</tr>
<tr>
<td>Input device support</td>
<td>对应<code>divers/input</code>目录，支持各类输入设备，比如键盘、鼠标等</td>
</tr>
<tr>
<td>Character devices</td>
<td>对应<code>divers/char</code>目录，它包含各种字符设备驱动程序。串口的配置也是从这个菜单调用的，但是串口的代码在<code>drivers/serial</code>下</td>
</tr>
<tr>
<td>I2C support</td>
<td>对应<code>divers/i2c</code>目录，支持各类I2C设备</td>
</tr>
<tr>
<td>SPI support</td>
<td>对应<code>divers/spi</code>目录，支持各类SPI设备</td>
</tr>
<tr>
<td>Dallas’s 1-wire bus</td>
<td>对应<code>divers/w1</code>目录，支持一线总线</td>
</tr>
<tr>
<td>Hardware Monitoring support</td>
<td>对应<code>divers/hwmon</code>目录</td>
</tr>
<tr>
<td>Misc devices</td>
<td>对应<code>divers/misc</code>目录，用来支持一些不好分类的设备，称为杂项设备</td>
</tr>
<tr>
<td>Multifuction device drivers</td>
<td>对应<code>divers/mfd</code>目录，用来支持多功能的设备，比如SM501，它既可以用于显示图像，也可以用作串口</td>
</tr>
<tr>
<td>LED devices</td>
<td>对应<code>divers/leds</code>目录，包含各种LED驱动程序</td>
</tr>
<tr>
<td>Multimedia devices</td>
<td>对应<code>divers/media</code>目录，包含多媒体驱动，比如V4L（Video for Linux），它用于向上提供统一的图像、声音接口</td>
</tr>
<tr>
<td>Graphics support</td>
<td>对应<code>divers/video</code>目录，提供图形设备&#x2F;显卡的支持</td>
</tr>
<tr>
<td>Sound</td>
<td>对应<code>sound/</code>目录（它不在drivers下），用来支持各种声卡</td>
</tr>
<tr>
<td>HID Devices</td>
<td>对应<code>divers/hid</code>目录，用来支持各种USB-HID设备，或者符合USB-HID规范的设备（蓝牙）。HID（Human Interface Device），比如各种USB接口的鼠标&#x2F;键盘&#x2F;游戏杆&#x2F;手写板等输入设备</td>
</tr>
<tr>
<td>USB support</td>
<td>对应<code>divers/usb</code>目录，包括各种USB Host和USB Device 设备</td>
</tr>
<tr>
<td>MMC&#x2F;SD card support</td>
<td>对应<code>divers/mmc</code>目录，用来支持各种MMC&#x2F;SD卡</td>
</tr>
<tr>
<td>Real Time Clock</td>
<td>对应<code>divers/rtc</code>目录，用来支持各种实时时钟设备。比如S3C24x0上就集成了RTC芯片</td>
</tr>
</tbody></table>
<h1 id="Linux-内核移植"><a href="#Linux-内核移植" class="headerlink" title="Linux 内核移植"></a>Linux 内核移植</h1><p>本节将修改Linux-2.6.22.6内核，使得它可以同时在本书使用的S3C2410、S3C2440开发板上运行，并修改相关驱动使它支持网络功能、支持JFFS2、YAFFS文件系统，同时修改MTD设备分区，使得内核可以挂接NAND Flash上的文件系统。</p>
<h2 id="Linux-内核启动过程概述"><a href="#Linux-内核启动过程概述" class="headerlink" title="Linux 内核启动过程概述"></a>Linux 内核启动过程概述</h2><p>与移植U-Boot的过程相似，在移植Linux之前，先了解它的启动过程。Linux的启动过程可以分为两部分：架构&#x2F;开发板相关的引导过程、后续的通用启动过程。下图所示是ARM架构处理器上Linux内核vmlinux的启动过程。之所以强调是vmlinux，是因为其他格式的内核在进行与vmlinux相同的流程之前会有一些独特的操作。比如对于压缩格式的内核zImage，它首先进行自解压得到vmlinux，然后执行vmlinux开始正常的启动流程。<br>引导阶段通常使用汇编语言编写，它首先检查内核是否支持当前架构的处理器，然后检查是否支持当前开发板。通过检查后，就为调用下一阶段的<code>start_kernel</code>函数准备了。主要分为如下两个步骤。</p>
<ol>
<li>连接内核时使用的虚拟地址，所以要设置页表、使能MMU。</li>
<li>调用C函数<code>start_kernel</code>之前的常规工作，包括复制数据段、清除BSS段、调用<code>start_kernel</code>函数。</li>
</ol>
<p>第二阶段的关键代码主要使用C语言编写。它进行内核初始化的全部工作，最后调用<code>rest_init</code>函数启动init过程，创建系统第一个进程：init进程。在第二阶段，仍有部分架构&#x2F;开发板相关的代码，比如下图中的<code>setup_arch</code>函数用于进行架构&#x2F;开发板相关的设置（重新设置页表、设置系统时钟、初始化串口等）。<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/9.jpeg" alt="img not found"></p>
<h2 id="修改Linux内核以支持S3C2410-x2F-S3C2440开发板"><a href="#修改Linux内核以支持S3C2410-x2F-S3C2440开发板" class="headerlink" title="修改Linux内核以支持S3C2410&#x2F;S3C2440开发板"></a>修改Linux内核以支持S3C2410&#x2F;S3C2440开发板</h2><p>首先配置、编译内核，确保内核可以正确编译。得到内核源码后，先修改顶层Makefile，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ARCH 	?= $(SUBARCH)</span><br><span class="line">CROSS_COMPILR	?= </span><br><span class="line">改为</span><br><span class="line">ARCH 	?= arm</span><br><span class="line">CROSS_COMPILR	?= arm-linux- </span><br></pre></td></tr></table></figure>
<p>然后执行如下命令，使用<code>arch/arm/configs/smdk2410_defconfig</code>文件来配置内核，它生成.config配置文件，后面就可以直接使用“make menuconfig”修改配置了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make smdk2410_defconfig</span><br></pre></td></tr></table></figure>
<p>最后是编译生成内核，执行“make”命令将在顶层目录下生成内核映像文件vmlinux；执行“make uImage”除生成vmlinux外，还在<code>arch/arm/boot</code>目录下生成U-Boot格式的内核映像文件uImage。<br>对于S3C2410开发板，上面生成的uImage是可以使用的。在U-Boot控制界面中使用如下命令下载uImage并启动它：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tftp <span class="number">0x32000000</span> uImage 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/uImage/</span><br><span class="line">bootm <span class="number">0x32000000</span></span><br></pre></td></tr></table></figure>
<p>在串口可以看到内核的启动信息，只是在最后看到如下的panic信息，这是因为没有修改MTD分区，没有增加对yaffs文件系统的支持。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">VFS: Uable to mount root fs via NFS, trying flopping</span><br><span class="line">VFS: Cannot open root device <span class="string">&quot;mtdblock/2&quot;</span> or unknown-block(<span class="number">2</span>,<span class="number">0</span>)</span><br><span class="line">Please append a correct <span class="string">&quot;root=&quot;</span> boot option;here are the availaable partitions:</span><br><span class="line"><span class="number">1f</span>00			<span class="number">16</span> 		mtdblock0	(driver?)</span><br><span class="line"><span class="number">1f</span>01			<span class="number">2048</span> 	mtdblock1	(driver?)</span><br><span class="line"><span class="number">1f</span>02			<span class="number">4096</span> 	mtdblock2	(driver?)</span><br><span class="line"><span class="number">1f</span>03			<span class="number">2048</span> 	mtdblock3	(driver?)</span><br><span class="line"><span class="number">1f</span>04			<span class="number">4096</span> 	mtdblock4	(driver?)</span><br><span class="line"><span class="number">1f</span>05			<span class="number">10240</span> 	mtdblock5	(driver?)</span><br><span class="line"><span class="number">1f</span>06			<span class="number">24576</span> 	mtdblock6	(driver?)</span><br><span class="line"><span class="number">1f</span>07			<span class="number">16384</span> 	mtdblock7	(driver?)</span><br><span class="line">Kernel panic - not syncing: VFS: Uable to mount root fs on unkown-block(<span class="number">2</span>,<span class="number">0</span>)</span><br></pre></td></tr></table></figure>
<p>对于S3C2440开发板，使用同样的命令启动uImage，在打印如下信息之后（U-Boot打印），就会出现一大堆乱码：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/10.jpeg" alt="img not found"><br>所以，Linux 2.6.22.6还不支持本书所用的S3C2440开发板，这个开发板的配置与内核所支持的开发板不一致。<br>要让内核支持当前的S3C2410开发板，需要进行一些修改。</p>
<h3 id="引导阶段代码分析"><a href="#引导阶段代码分析" class="headerlink" title="引导阶段代码分析"></a>引导阶段代码分析</h3><p>由前面对内核Makefile的分析，可知<code>arch/arm/kernel/head.S</code>是内核执行的第一个文件。另外。U-Boot调用内核时，r1寄存器中存储“机器类型ID”，内核会用到它。<br>移植Linux内核时，对于<code>arch/arm/kernel/head.S</code>，只需要关注开头几条命令，如下所示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">ENTRY(stext)</span><br><span class="line">msr cpsr_c, PSR_F_BIT | PSR_I_BIT | SVC_MODE	@确保进入管理（SVC）模式，并禁止中断</span><br><span class="line">mrc p15, 0, r9, c0, c0							@读取CPU ID，存入r9寄存器</span><br><span class="line">bl __lookup_processor_type						@调用函数，输入参数r9=cpuid，返回值r5=procinfo</span><br><span class="line">movs r10,r5										@如果不支持当前CPU，则返回值r5=0</span><br><span class="line">beq __error_p									@如果r5=0，则打印错误</span><br><span class="line">bl __lookup_machine_type						@调用函数，返回值r5=machinfo</span><br><span class="line">movs r8, r5										@如果不支持当前机器，则返回值r5=0</span><br><span class="line">beq __error_a									@如果r5=0，则打印错误</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>第2行通过设置CPSR寄存器来确保处理器进入管理（SVC）模式，并且禁止中断。<br>第3行读取协处理器CP15的寄存器C0获得CPU ID，CPU ID格式如下所示：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/11.jpeg" alt="img not found"></p>
<table>
<thead>
<tr>
<th>位</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>[31:24]</td>
<td>厂商编号有如下值。<br>0x41 &#x3D; A，表示ARM公司 <br>0x44 &#x3D; D，表示Digital Equipment公司 <br> 0x69 &#x3D; 1，表示Intel公司</td>
</tr>
<tr>
<td>[23:20]</td>
<td>由厂商定义，当产品编号相同时，使用子编号来区分不同的产品子类，如产品中不同的高速缓存大小等</td>
</tr>
<tr>
<td>[19:16]</td>
<td>ARM体系版本号，目前取值如下。<br>0x01，表示ARM体系版本4 <br>0x02，表示ARM体系版本4T <br>0x03，表示ARM体系版本5 <br>0x04，表示ARM体系版本5 <br>0x05，表示ARM体系版本5T <br>0x06，表示ARM体系版本5TE</td>
</tr>
<tr>
<td>[15:4]</td>
<td>产品主编号</td>
</tr>
<tr>
<td>[3:0]</td>
<td>处理器版本号</td>
</tr>
</tbody></table>
<p>比如S3C2410的CPU ID为0x41129200，S3C2440的CPU ID也是0x41129200。注意，S3C2410和S3C2440称为片山系统（SOC），除CPU外，还集成了UART、USB控制器、NAND Flash控制器等设备。从它们的CPU ID可知，它们的CPU是相同的，只是片上外设不一样。<br>第4行调用<code>__lookup_processor_type</code>函数，确定内核是否支持当前CPU。如果支持，r5寄存器将会返回一个用来描述处理器的结构体的地址，否则r5的值为0。<br>第7行调用<code>__lookup_machine_type</code>函数，确定内核是否支持当前开发板。如果支持，r5寄存器将会返回一个用来描述这个开发板的结构体的地址，否则r5的值为0。<br>如果<code>__lookup_processor_type</code>、<code>__lookup_machine_type</code>这两个函数中有一个返回值为0，则内核不能启动，如果配置内核时选择了CONFIG_DEBUG_ALL，还会打印一些提示信息。<br><code>__lookup_processor_type</code>、<code>__lookup_machine_type</code>函数都是在<code>arch/arm/kernel/head-common.S</code>中定义的。<br>内核映像中，定义了若干个<code>proc_info_list</code>结构（结构体原型在include&#x2F;asm-arm&#x2F;procinfo.h中定义），表示它支持的CPU。对于ARM架构的CPU，这些结构体的源码在<code>arch/arm/mm/</code>目录下，比如<code>proc-arm920.S</code>中的如下代码，它表示arm920 CPU的proc_info_list结构。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">.section &quot;.proc.info.init&quot;, #alloc, #execinstr</span><br><span class="line"></span><br><span class="line">.type __arm920_proc_info, #object</span><br><span class="line">__arm920_proc_info:</span><br><span class="line">.long 0x41009200</span><br><span class="line">.long 0xff00fff0</span><br><span class="line">...</span><br></pre></td></tr></table></figure>
<p>不同的<code>proc_info_list</code>结构被用来支持不同的CPU，它们都是定义在“.proc.info.init”段中。在连接内核时，这些结构体被组织在一起，开始地址为<code>__proc_info_begin</code>，结束地址为<code>__proc_info_end</code>。这可以从连接脚本<code>arch/arm/kernel/vmlinux.lds</code>中看出来。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__proc_info_begin = .;		//proc_info_init结构的开始地址</span><br><span class="line">*(.proc.info.init)</span><br><span class="line">__proc_info_end = .;		//proc_info_init结构的结束地址</span><br></pre></td></tr></table></figure>
<p><code>__lookup_processor_type</code>函数就是根据前面读出的CPU ID （存在r9 寄存器中），从这些<code>proc_info_init</code>结构中找出匹配的，它的代码如下（<code>arch/arm/kernel/head-common.S</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">	.type	__lookup_processor_type, %function</span><br><span class="line">__lookup_processor_type:</span><br><span class="line">	adr	r3, 3f							@ r3 = 最后一行代码的物理地址（3）</span><br><span class="line">	ldmda	r3, &#123;r5 - r7&#125;				@ r5 = __proc_info_begin,r6 = __proc_info_end,它们是虚拟地址。r7 = 最后一行代码的虚拟地址</span><br><span class="line">	sub	r3, r3, r7						@ r3 = r3 - r7，即物理地址和虚拟地址的差值</span><br><span class="line">	add	r5, r5, r3						@ r5 = __proc_info_begin 对应的物理地址</span><br><span class="line">	add	r6, r6, r3						@ r6 = __proc_info_end 对应的物理地址</span><br><span class="line">1:	ldmia	r5, &#123;r3, r4&#125;				@ r3、r4 = proc_info_list结构中的cpu_val、cpu_mask</span><br><span class="line">	and	r4, r4, r9						@ r4 = (r4 &amp; r9) = (cpu_mask &amp; 传入的CPU ID)</span><br><span class="line">	teq	r3, r4							@ 比较</span><br><span class="line">	beq	2f								@ 如果相等，表示找到匹配的proc_info_list结构，跳到（2）</span><br><span class="line">	add	r5, r5, #PROC_INFO_SZ			@ r5指向下一个proc_info_list结构 PROC_INFO_SZ = sizeof（proc_info_list）</span><br><span class="line">	cmp	r5, r6							@ 是否已经比较完所有的proc_info_list结构</span><br><span class="line">	blo	1b								@ 没有则继续比较</span><br><span class="line">	mov	r5, #0							@ 比较完毕，但是没有匹配的proc_info_list结构，r5 = 0</span><br><span class="line">2:	mov	pc, lr							@ 返回</span><br><span class="line"></span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * Look in include/asm-arm/procinfo.h and arch/arm/kernel/arch.[ch] for</span><br><span class="line"> * more information about the __proc_info and __arch_info structures.</span><br><span class="line"> */</span><br><span class="line">	.long	__proc_info_begin			@ proc_info_list结构的开始地址，这是连接地址，也是虚拟地址</span><br><span class="line">	.long	__proc_info_end				@ proc_info_list结构的结束地址，这是链接地址，也是虚拟地址</span><br><span class="line">3:	.long	.							@ “.”表示当前这行代码编译连接后的虚拟地址</span><br></pre></td></tr></table></figure>
<p>在调用<code>__enable_mmu</code>函数之前使用的都是物理地址，而内核却是以虚拟地址连接的。所以在访问<code>proc_info_list</code>结构前，先将它的虚拟地址转换为物理地址，第3-7行就是用来转换地址的。<br>第3行用来获得第26行代码的物理地址。adr指令基于pc寄存器计算地址值，由于这时候还没使能MMU，pc寄存器中使用的还是物理地址，所以执行“adr,r3,3f”后，r3寄存器中存放的就是第26行代码的物理地址。<br>第4行用来获得第24-26行定义的数据：__proc_info_begin、__proc_info_end和“.”。这3个数据都是在连接内核时确定，它们是虚拟地址，前两个表示<code>proc_info_list</code>结构的开始地址和结束地址，“.”表示当前行的代码在编译连接后的虚拟地址。<br>第5行计算物理地址和虚拟地址的差值，第6-7行根据这个差值计算<code>__proc_info_begin</code>、<code>__proc_info_end</code>的物理地址。<br>下面的代码依次读取每个<code>proc_info_list</code>结构前面的两个成员（cpu_val和cpu_mask），判断cpu_val是否等于(r9 &amp; cpu_mask)，r9是<code>arch/arm/kernel/head.S</code>中调用<code>__lookup_processor_type</code>时传入的CPU ID。如果比较相等，则表示当前<code>proc_info_list</code>结构适用于这个CPU，直接返回这个结构的地址（存在r5中）。如果<code>__proc_info_begin</code>、<code>__proc_info_end</code>之间的所有<code>proc_info_list</code>结构都不支持这个CPU，则返回0(r5)。<br>对于S3C2410、S3C2440开发板，它们的CPU ID都是0x41129200，而在<code>arch/arm/mm/proc-arm920.S</code>中定义的<code>__arm920_proc_info</code>结构中，cpu_val、cpu_mask等于0x41009200、0xff00fff0，刚好匹配。内核中要包含这个文件，在<code>arch/arm/mm/Makefile</code>中可以看到下面这行，它表示需要配置CONFIG_CPU_ARM920T（配置菜单中System Type-&gt;Support ARM920T procrssor）。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj-$(CONFIG_CPU_ARM920T)      += proc_arm920.o</span><br></pre></td></tr></table></figure>
<p>下面讲解<code>__	lookup_machine_type</code>,它和<code>__lookup_processor_type</code>函数代码相似。<br>内核中对于每种支持的开发板都会使用宏MACHINE_START、MACHINE_END来定义一个<code>machine_desc</code>结构，它定义了开发板相关的一些属性和函数。比如机器类型ID、起始I&#x2F;O物理地址，Bootloader传入的参数的地址、中断初始化函数、I&#x2F;O映射函数等。比如对于SDMK2440开发板，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中定义如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MACHINE_START(S3C2440, &quot;SMDK2440&quot;)</span><br><span class="line">	/* Maintainer: Ben Dooks &lt;ben@fluff.org&gt; */</span><br><span class="line">	.phys_io	= S3C2410_PA_UART,</span><br><span class="line">	.io_pg_offst	= (((u32)S3C24XX_VA_UART) &gt;&gt; 18) &amp; 0xfffc,</span><br><span class="line">	.boot_params	= S3C2410_SDRAM_PA + 0x100,</span><br><span class="line"></span><br><span class="line">	.init_irq	= s3c24xx_init_irq,</span><br><span class="line">	.map_io		= smdk2440_map_io,</span><br><span class="line">	.init_machine	= smdk2440_machine_init,</span><br><span class="line">	.timer		= &amp;s3c24xx_timer,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure>
<p>宏<code>MACHINE_START</code>、<code>MACHINE_END</code>在<code>include/asm-arm/mach/arch.h</code>文件中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Set of macros to define architecture features.  This is built into</span></span><br><span class="line"><span class="comment"> * a table by the linker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACHINE_START(_type,_name)			\</span></span><br><span class="line"><span class="meta">static const struct machine_desc __mach_desc_##_type	\</span></span><br><span class="line"><span class="meta"> __used							\</span></span><br><span class="line"><span class="meta"> __attribute__((__section__(<span class="string">&quot;.arch.info.init&quot;</span>))) = &#123;	\</span></span><br><span class="line"><span class="meta">	.nr		= MACH_TYPE_##_type,		\</span></span><br><span class="line"><span class="meta">	.name		= _name,</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MACHINE_END				\</span></span><br><span class="line"><span class="meta">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>所以上一段代码扩展开来就是：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">machine_desc</span> __<span class="title">mach_desc_S3C2440</span>	\</span></span><br><span class="line"><span class="class"> __<span class="title">used</span>							\</span></span><br><span class="line"><span class="class"> __<span class="title">attribute__</span>((__<span class="title">section__</span>(&quot;.<span class="title">arch</span>.<span class="title">info</span>.<span class="title">init</span>&quot;))) =</span> &#123;	\</span><br><span class="line">	.nr		= MACH_TYPE_S3C2440,		\</span><br><span class="line">	.name		= _name,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的MACH_TYPE_S3C2440在<code>arch/arm/tools/mach-types</code>中定义，它最后会被换成一个头文件<code>include/asm-arm/mach-types.h</code>供其他文件包含。machine_desc在<code>include/asm-arm/mach/arch.h</code>文件中定义。所有的machine_desc结构都处于“.arch.info.init”段中，在连接内核时，它们被组织在一起，开始地址为<code>__arch_info_begin</code>，结束地址为<code>__arch_info_end</code>。这可以从连接脚本文件<code>arch/arm/kernel/vmlinux.lds</code>中看出来：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">__arch_info_begin = .;				<span class="comment">//machine_desc结构的开始地址</span></span><br><span class="line">	*(.arch.info.init)</span><br><span class="line">__arch_info_end = .;				<span class="comment">//machine_desc结构的结束地址</span></span><br></pre></td></tr></table></figure>
<p>不同的machine_desc结构用于不同的开发板，U-Boot调用内核时，会在r1寄存器中给出开发板的标记（机器类型ID）。<code>__loockup_machine_type</code>函数将这个值与machine_desc中的nr成员比较，如果两者相等则表示找到匹配的machine_desc结构，于是返回它的地址（存在r5中）。如果<code>__arch_info_begin</code>和<code>__arch_info_end</code>之间所有的machine_desc结构的nr成员都不等于r1寄存器的值，则返回0（r5）。<br>对于本书所用的S3C2410、S3C2440开发板，U-Boot传入的机器类型ID为MACH_TYPE_SMDK2410、MACH_TYPE_SMDK2440。它们对应的machine_desc结构分别在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>和<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code>中定义，所以两个文件要编进内核。在配置菜单中，选中下面两个开发板即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">System Type --&gt; S3C2410 Machines --&gt; SMDK2410/A9M2410</span><br><span class="line">System Type --&gt; S3C2440 Machines --&gt; SMDK2440</span><br></pre></td></tr></table></figure>
<p><code>__lookup_machine_type</code>函数的代码如下（<code>/arch/arm/kernel/head-common.S</code>）：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">3:	.long	.</span><br><span class="line">	.long	__arch_info_begin</span><br><span class="line">	.long	__arch_info_end</span><br><span class="line">...</span><br><span class="line">	.type	__lookup_machine_type, %function</span><br><span class="line">__lookup_machine_type:</span><br><span class="line">	adr	r3, 3b								@ r3 = 第1行的物理地址</span><br><span class="line">	ldmia	r3, &#123;r4, r5, r6&#125;				@ r4 = 第1行的虚拟地址	r5 = __arch_info_begin r6 = __arch_info_end 它们是虚拟地址</span><br><span class="line">	sub	r3, r3, r4							@ r3 = r3 - r4 即物理地址和虚拟地址的差值</span><br><span class="line">	add	r5, r5, r3							@ r5 = __arch_info_begin 对应的物理地址</span><br><span class="line">	add	r6, r6, r3							@ r6 = __arch_info_end 对应的物理地址</span><br><span class="line">1:	ldr	r3, [r5, #MACHINFO_TYPE]			@ r5是machine_desc 结构的地址 r3 = machine_desc 结构中定义的nr成员，即机器类型ID</span><br><span class="line">	teq	r3, r1								@ r1是Bootloader调用内核时传入的机器类型ID，测试是否相等</span><br><span class="line">	beq	2f									@ 若相等，跳到（2）</span><br><span class="line">	add	r5, r5, #SIZEOF_MACHINE_DESC		@ 否则，r5指向下一个machine_desc结构，SIZEOF_MACHINE_DESC = sizeof(machine_desc)</span><br><span class="line">	cmp	r5, r6								@ 是否比较完所有的machine_desc结构</span><br><span class="line">	blo	1b									@ 没有则继续比较</span><br><span class="line">	mov	r5, #0								@ 比较完毕，但是没有匹配的machine_desc结构，r5 = 0</span><br><span class="line">2:	mov	pc, lr								@ 返回</span><br></pre></td></tr></table></figure>
<p>如果<code>__lookup_processor_tyep</code>、<code>__lookup_machine_type</code>函数都返回成功，则后续引导程序将继续执行下去。其中的<code>__create_page_tables</code>函数用来创建一级页表以建立虚拟地址到物理地址的映射关系，它用到<code>__lookup_processor_type</code>函数返回的proc_info_list结构。在引导的最后，调用<code>start_kernel</code>函数进入内核启动的第二阶段。<code>__lookup_machine_type</code>函数确定的machine_desc结构将在第二阶段多次使用。</p>
<h3 id="start-kernel-函数部分代码分析"><a href="#start-kernel-函数部分代码分析" class="headerlink" title="start_kernel 函数部分代码分析"></a>start_kernel 函数部分代码分析</h3><p>进入<code>start_kernel</code>函数（<code>init/main.c</code>）之后，如果串口上没有看到内核的启动信息，一般而言有两个原因：Bootloader传入的命令行参数不对，或者<code>setup_arch</code>函数（<code>arch/arm/kernel/setup.c</code>）针对开发板的设置不正确。<br>在调用<code>setup_arch</code>函数之前就已经调用<code>“printk(linux_banner)”</code>了，但是这个时候printk函数只是将打印信息放在缓存区中，并没有打印到控制台上（串口、LCD屏等），因为这个时候控制台还未初始化。printk打印的内容在<code>console_init</code>函数注册、初始化控制台之后才真正输出。<br>移植U-Boot时，U-Boot传给内核的参数有两类：预先存在某个地址的tag列表和调用内核时在r1寄存器中指定的机器类型ID。后者在引导阶段的<code>__lookup_machine_type</code>函数已经用到。而tag列表将在<code>setup_arch</code>函数中进行初步处理。本节将重点介绍<code>setup_arch</code>函数、<code>console_init</code>函数、以tag列表的处理（内存tag、命令行tag）、串口控制台的初始化为主线。</p>
<h4 id="setup-arch-函数分析"><a href="#setup-arch-函数分析" class="headerlink" title="setup_arch 函数分析"></a>setup_arch 函数分析</h4><p><code>setup_arch</code>函数在<code>arch/arm/kernel/setup.c</code>中定义，其部分代码及流程图如下：<br><img src="/2022/09/07/%E7%A7%BB%E6%A4%8DLinux%E5%86%85%E6%A0%B8/12.jpeg" alt="img not found"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">setup_arch</span><span class="params">(<span class="type">char</span> **cmdline_p)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	setup_processor();											<span class="comment">//进行处理器相关的一些设置</span></span><br><span class="line">	mdesc = setup_machine(machine_arch_type);					<span class="comment">//获得开发板的machine_desc结构</span></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (mdesc-&gt;boot_params)										<span class="comment">//定义了Bootloader传入参数的地址</span></span><br><span class="line">		tags = phys_to_virt(mdesc-&gt;boot_params);				<span class="comment">//这个地址就是tag列表的首地址</span></span><br><span class="line">...</span><br><span class="line">	<span class="keyword">if</span> (tags-&gt;hdr.tag == ATAG_CORE) &#123;</span><br><span class="line">		<span class="keyword">if</span> (meminfo.nr_banks != <span class="number">0</span>)								<span class="comment">//如果已经在内核中定义了meminfo结构</span></span><br><span class="line">			squash_mem_tags(tags);								<span class="comment">//则忽略内存tag</span></span><br><span class="line">		parse_tags(tags);										<span class="comment">//解释每一个tag</span></span><br><span class="line">	&#125;</span><br><span class="line">...</span><br><span class="line">	<span class="built_in">memcpy</span>(boot_command_line, from, COMMAND_LINE_SIZE);</span><br><span class="line">	boot_command_line[COMMAND_LINE_SIZE<span class="number">-1</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">	parse_cmdline(cmdline_p, from);								<span class="comment">//对命令行进行一些先期的处理</span></span><br><span class="line">	paging_init(&amp;meminfo, mdesc);								<span class="comment">//重新初始化页表</span></span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>首先，第[4]行的<code>setup_processor</code>函数被用来进行处理器相关的一些设置，它会调用引导阶段的<code>lookup_processor_type</code>函数以获得该处理器的proc_info_list结构。<br>接下来，第[5]行的<code>setup_machine</code>函数被用来获得开发板的machine_desc结构，这通过调用引导阶段<code>lookup_machine_type</code>函数来实现。以后就会根据开发板的machine_desc结构来进行一些开发板的相关操作，<br>第[7]-[8]行用来确定Bootloader传入的启动参数的地址，它在开发板的machine_desc结构中指定，第[8]行将它转换为虚拟地址。比如对于S3C2440开发板，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中有如下定义。启动参数的地址就是（S3C2410_SDRAM_PA + 0x100），即0x30000100。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">MACHINE_START(S3C2440,<span class="string">&quot;SMDK2440&quot;</span>)</span><br><span class="line">...</span><br><span class="line">	.bootm_params = S3C2440_SDRAM_PA + <span class="number">0x100</span>,</span><br></pre></td></tr></table></figure>
<p>第[13]行处理每个tag。文件<code>arch/arm/kernel/setup.c</code>对每种tag都定义了相应的处理函数，比如对于内存tag、命令行tag，使用如下两行代码指定了它们的处理函数为<code>parse_tag_mem32、parse_tag_cmdline</code>。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">__tagtable(ATAG_MEM,parse_tag_mem32);</span><br><span class="line">__tagtable(ATAG_CMDLINE,parse_tag_cmdline);</span><br></pre></td></tr></table></figure>
<p><code>parse_tag_mem32</code>函数根据内存tag定义的内存起始地址、长度，在全局结构变量meminfo中增加内存的描述信息。以后内核就可以通过meminfo结构了解开发板的的内存信息。<br><code>parse_tag_cmdline</code>只是简单的将命令行tag的内容复制到字符串default_command_line中保存下来，后面才进一步处理。<br>第[18]行扫描命令行参数，对其中的一些参数进行先期的处理。这些参数使用“__early_param”来定义，比如<code>arch/arm/kernel/setup.c</code>中下面的一行代码，它表示如果命令行中有“mem&#x3D;…”的字样，就调用<code>early_mem</code>（在<code>include/asm-arm/setup.h</code>中定义）对它进行处理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__early_param(<span class="string">&quot;mem=&quot;</span>,early_mem);</span><br></pre></td></tr></table></figure>
<p>“mem&#x3D;…”用来强制限制Linux系统所能使用的内存总量，比如“mem&#x3D;60M”使得系统只能使用60MB的内存，即使内存tag中指明了共有64MB内存。类似的参数还有“initrd&#x3D;”等。<br>此时命令行的处理还没有结束，在setup_arch函数之外还会进行一系列后续处理，比如<code>start_kernel</code>函数中调用如下代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">setup_command_line(command_line);</span><br><span class="line">...</span><br><span class="line">parse_early_param();</span><br><span class="line">parse_args(<span class="string">&quot;Booting kernel&quot;</span>, static_command_line, __start___param,</span><br><span class="line">		   __stop___param - __start___param,</span><br><span class="line">		   &amp;unknown_bootoption);</span><br></pre></td></tr></table></figure>
<p>比如对于命令行中的“console&#x3D;ttySAC0”，它的处理过程就是第[4]行的<code>parse_args</code>函数调用第[6]行传入的<code>unknown_bootoption</code>函数，最后调用下面代码指定的处理函数<code>console_setup</code>（在<code>kernel/printk.c</code>中定义）。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">__setup(<span class="string">&quot;console=&quot;</span>,console_setup);</span><br></pre></td></tr></table></figure>
<p>命令行参数“console&#x3D;…”用来指定要使用的控制台的名称、序号、参数。比如对于“console&#x3D;ttySAC0,115200”，表示要使用的控制台名称为ttySAC，序号为0（第一个串口），波特率为115200。经过<code>console_setup</code>处理后，会在全局结构变量console_cmdline中保存这些信息，在后面<code>console_init</code>函数初始化控制台时会根据这些信息选择要使用的控制台。<br><code>setup_arch</code>函数后面会调用<code>paging_init</code>函数，这也是一个开发板相关的函数。</p>
<h4 id="paging-init函数分析"><a href="#paging-init函数分析" class="headerlink" title="paging_init函数分析"></a>paging_init函数分析</h4><p>这个函数在<code>setup_arch</code>函数中的调用形式如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paging_init(&amp;meminfo,mdesc);</span><br></pre></td></tr></table></figure>
<p>meminfo中存放内存的信息，前面解释内存tag时确定了构建这个全局结构。<br>mdesc就是前面<code>lookup_machine_type</code>函数返回的machine_desc结构。对于S3C2440开发板，这个结构在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中有如下定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">MACHINE_START(S3C2440, <span class="string">&quot;SMDK2440&quot;</span>)</span><br><span class="line">	<span class="comment">/* Maintainer: Ben Dooks &lt;ben@fluff.org&gt; */</span></span><br><span class="line">	.phys_io	= S3C2410_PA_UART,</span><br><span class="line">	.io_pg_offst	= (((u32)S3C24XX_VA_UART) &gt;&gt; <span class="number">18</span>) &amp; <span class="number">0xfffc</span>,</span><br><span class="line">	.boot_params	= S3C2410_SDRAM_PA + <span class="number">0x100</span>,</span><br><span class="line"></span><br><span class="line">	.init_irq	= s3c24xx_init_irq,</span><br><span class="line">	.map_io		= smdk2440_map_io,</span><br><span class="line">	.init_machine	= smdk2440_machine_init,</span><br><span class="line">	.timer		= &amp;s3c24xx_timer,</span><br><span class="line">MACHINE_END</span><br></pre></td></tr></table></figure>
<p>上面几行代码是移植Linux必须关注的数据结构。对于S3C2410开发板，它在<code>arch/arm/mach-s3c2410/mach-smdk2410.c</code><br><code>paging_init</code>函数在<code>arch/arm/mm/mmu.c</code>中定义，根据我们的移植目的–让内核可以在S3C2440上运行。关注如下流程：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">paging_init -&gt; devicemaps_init -&gt; mdesc -&gt; map_io()</span><br></pre></td></tr></table></figure>
<p>对于S3C2440开发板，就是调用<code>smdk2410_map_io</code>函数，它也是<code>arch/arm/mach-s3c2440/mach-s3c2440.c</code>中定义。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">void</span> __init <span class="title function_">smdk2440_map_io</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	s3c24xx_init_io(smdk2440_iodesc, ARRAY_SIZE(smdk2440_iodesc));</span><br><span class="line">	s3c24xx_init_clocks(<span class="number">16934400</span>);</span><br><span class="line">	s3c24xx_init_uarts(smdk2440_uartcfgs, ARRAY_SIZE(smdk2440_uartcfgs));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上述三个函数所实现的功能，从名字就可以看出，第四行中参数值表示开发板晶振的频率。当前开发板所使用的晶振频率是12MHz，不是16934400，这就是S3C2440开发板上启动uImage时串口输出乱码的原因，将它改为12000000即可。</p>
<h4 id="console-init-函数分析"><a href="#console-init-函数分析" class="headerlink" title="console_init 函数分析"></a>console_init 函数分析</h4><p>虽然上面已经找到内核无法正常输出信息的原因，但我们不该止步于此。在2.4的内核中，命令行参数常用“console&#x3D;ttyS0”来指定控制台为串口0，在2.6版本的内核中改为“console&#x3D;ssySAC0”。分析<code>console_init</code>函数的功能就可以了解这点。<br><code>console_init</code>函数被<code>start_kernel</code>函数调用，它在<code>drivers/char/tty_io.c</code>文件中定义</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">console_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">initcall_t</span> *call;</span><br><span class="line">...</span><br><span class="line">	call = __con_initcall_start;</span><br><span class="line">	<span class="keyword">while</span> (call &lt; __con_initcall_end) &#123;</span><br><span class="line">		(*call)();</span><br><span class="line">		call++;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>它调用地址范围<code>__con_initcall_start</code>至<code>__con_initcall_end</code>之间的定义的每个函数，这些函数使用<code>console_initcall</code>宏来指定。比如<code>drivers/serial/s3c2410.c</code>中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">console_initcall(s3c24xx_serial_initconsole);</span><br></pre></td></tr></table></figure>
<p><code>s3c24xx_serial_initconsole</code>函数也是在<code>drivers/serial/s3c2410.c</code>中定义，它初始化S3C24xx类SoC的串口控制台，部分代码如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">s3c24xx_serial_initconsole</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	register_console(&amp;s3c24xx_serial_console);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>s3c24xx_serial_console结构在<code>drivers/serial/s3c2410.c</code>中定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">console</span> <span class="title">s3c24xx_serial_console</span> =</span></span><br><span class="line">&#123;</span><br><span class="line">	.name		= S3C24XX_SERIAL_NAME,				<span class="comment">//即“ttySAC”</span></span><br><span class="line">	.device		= uart_console_device,				<span class="comment">//以后使用/dev/console时，用来构造设备节点</span></span><br><span class="line">	.flags		= CON_PRINTBUFFER,					<span class="comment">//控制台可用之前，printk已经在缓冲区打印了很多信息，CON_PRINTBUFFER表示注册控制台之后</span></span><br><span class="line">													<span class="comment">//打印这些“过去”的信息</span></span><br><span class="line">	.index		= <span class="number">-1</span>,								<span class="comment">//-1可以匹配任意序号。比如ttySAC0/1/2</span></span><br><span class="line">	.write		= s3c24xx_serial_console_write,		<span class="comment">//打印函数</span></span><br><span class="line">	.setup		= s3c24xx_serial_console_setup		<span class="comment">//设置函数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>register_console(&amp;s3c24xx_serial_console);</code>在内核中注册控制台，就是把s3c24xx_serial_console结构链入一个全局链表console_drivers中（它在<code>kernel/printf.c</code>中定义）。并且使用其中的name和index与前面的“console&#x3D;…”指定的控制台相比较，如果相符，则以后的printk信息从这个控制台输出。<br>对于本书的情况，“console&#x3D;ttySAC0”，而s3c24xx_serial_console结构中名字为“ttySAC”，序号为-1（可取任意值），所以两者匹配，printk信息将从串口0输出。<br>现在总结一下上面分析的<code>内核启动第二阶段的函数调用过程</code>，相同的缩进表示它们是在同一个函数中被调用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">start_kernel -&gt;</span><br><span class="line">	setup_arch -&gt;</span><br><span class="line">		setup_processor</span><br><span class="line">		setup_machine</span><br><span class="line">		...</span><br><span class="line">		parse_tags</span><br><span class="line">		...</span><br><span class="line">		parse_cmdline</span><br><span class="line">		paging_init -&gt;</span><br><span class="line">			devicemaps_init -&gt;</span><br><span class="line">				mdesc_map_io() -&gt;</span><br><span class="line">					s3c24xx_init_io</span><br><span class="line">					s3c24xx_init_clocks</span><br><span class="line">					s3c24xx_init_uarts</span><br><span class="line">		...</span><br><span class="line">		console_init -&gt;</span><br><span class="line">			s3c24xx_serial_initconsole -&gt;</span><br><span class="line">				register_console(&amp;s3c24xx_serial_initconsole)</span><br><span class="line">		...</span><br></pre></td></tr></table></figure>

<h3 id="修改内核"><a href="#修改内核" class="headerlink" title="修改内核"></a>修改内核</h3><p>在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中做如下修改：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">s3c24xx_init_clocks(<span class="number">16934400</span>);</span><br><span class="line">改为</span><br><span class="line">s3c24xx_init_clocks(<span class="number">12000000</span>);</span><br></pre></td></tr></table></figure>
<p>然后执行“make uImage”生成uImage。<br>对于S3C2410、S3C2440开发板，上面生成的uImage都可以使用了。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tftp <span class="number">0x32000000</span> uImage 或 nfs <span class="number">0x30000000</span> <span class="number">192.168</span><span class="number">.1</span><span class="number">.57</span>:/work/nfs_root/uImage</span><br><span class="line">bootm <span class="number">0x32000000</span></span><br></pre></td></tr></table></figure>
<p>可以看到内核的启动信息，最后出现panic信息（这需要修改mtd分区、增加对yaffs文件系统的支持）。</p>
<h2 id="修改-MTD-分区"><a href="#修改-MTD-分区" class="headerlink" title="修改 MTD 分区"></a>修改 MTD 分区</h2><p>MTD（Memory Technology Device），即内存技术设备，是Linux中对ROM、NOR Flash、NAND Flash等存储设备抽象出来的设备层。它向上提供统一的访问接口：读、写、擦除等；屏蔽了底层硬件的操作、各类存储设备的差别。得益于MTD设备的作用，重新划分NAND Flash的分区很简单。</p>
<h3 id="驱动对设备的识别过程"><a href="#驱动对设备的识别过程" class="headerlink" title="驱动对设备的识别过程"></a>驱动对设备的识别过程</h3><p>驱动程序识别设备时，有以下两种方法。</p>
<ol>
<li>驱动程序本身带有设备的信息，比如开始地址、中断号等；加载驱动程序时，就可以根据这些信息来识别设备。</li>
<li>驱动程序本身没有设备的信息，但是内核中已经根据其他方式确定了很多设备的信息；加载驱动程序时，将驱动程序与这些设备逐个比较，确定两者是否匹配，如果成功匹配，那么就可以通过驱动程序操作这个设备了。<br>内核常使用第二种方法来识别设备，这可以将各种设备集中在一个文件中管理，当开发板的配置改变时，便于修改代码。在内核文件<code>include/linux/paltform/device.h</code>中，定义了两个数据结构来表示这些设备和驱动程序：paltform_device结构用来描述设备的名称、ID、所占用的资源（内存地址&#x2F;大小、中断号）等；platform_driver结构用来描述各种操作函数，比如枚举函数、移除设备函数、驱动的名称等。<br>内核启动后，首先构造链表将描述设备的platform_device结构组织起来，得到一个设备的列表；当加载某个驱动程序的platform_driver结构时，使用一些匹配函数来检查驱动程序能否支持这些设备，常用的检察方式很简单：比较驱动程序和设备的名称。<br>以S3C2440开发板为例，在<code>arch/arm/mach-s3c2440/mach-smdk2440.c</code>中定义了如下设备：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> *<span class="title">smdk2440_devices</span>[] __<span class="title">initdata</span> =</span> &#123;</span><br><span class="line">	&amp;s3c_device_usb,</span><br><span class="line">	&amp;s3c_device_lcd,</span><br><span class="line">	&amp;s3c_device_wdt,</span><br><span class="line">	&amp;s3c_device_i2c,</span><br><span class="line">	&amp;s3c_device_iis,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
在<code>arch/arm/plat-s3c24xx/common-smdk.c</code>中定义了如下设备：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> __<span class="title">initdata</span> *<span class="title">smdk_devs</span>[] =</span> &#123;</span><br><span class="line">	&amp;s3c_device_nand,</span><br><span class="line">	&amp;smdk_led4,</span><br><span class="line">	&amp;smdk_led5,</span><br><span class="line">	&amp;smdk_led6,</span><br><span class="line">	&amp;smdk_led7,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
这些设备在<code>smdk2410_init</code>函数或<code>smdk2440_init</code>函数中，通过<code>platform_add_devices</code>函数注册进内核中。<br>NAND Flash设备s3c_device_nand在<code>arch/arm/plat-s3c24xx/devs.c</code>中的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">platform_device</span> <span class="title">s3c_device_nand</span> =</span> &#123;</span><br><span class="line">	.name		  = <span class="string">&quot;s3c2410-nand&quot;</span>,</span><br><span class="line">	.id		  = <span class="number">-1</span>,</span><br><span class="line">	.num_resources	  = ARRAY_SIZE(s3c_nand_resource),</span><br><span class="line">	.resource	  = s3c_nand_resource,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
对于S3C2440开发板，s3c_device_nand结构的名字会在s3c24xx_map_io函数中修改为“s3c2440-nand”，这个函数在<code>arch/arm/plat-s3c24xx/s3c244x.c</code>中的定义如下：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> __init <span class="title function_">s3c244x_map_io</span><span class="params">(<span class="keyword">struct</span> map_desc *mach_desc, <span class="type">int</span> size)</span></span><br><span class="line">&#123;</span><br><span class="line">...</span><br><span class="line">	s3c_device_i2c.name  = <span class="string">&quot;s3c2440-i2c&quot;</span>;</span><br><span class="line">	s3c_device_nand.name = <span class="string">&quot;s3c2440-nand&quot;</span>;</span><br><span class="line">	s3c_device_usbgadget.name = <span class="string">&quot;s3c2440-usbgadget&quot;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
有了NAND Flash设备，还要有NAND Flash驱动程序，内核针对S3C2410、S3C2412、S3C2440定义了3个驱动。它们在<code>drivers/mtd/s3c2410.c</code>中的<code>s3c2410_nand_init</code>函数中注册进内核，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">int</span> __init <span class="title function_">s3c2410_nand_init</span><span class="params">(<span class="type">void</span>)</span></span><br><span class="line">&#123;</span><br><span class="line">	printk(<span class="string">&quot;S3C24XX NAND Driver, (c) 2004 Simtec Electronics\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">	platform_driver_register(&amp;s3c2412_nand_driver);</span><br><span class="line">	platform_driver_register(&amp;s3c2440_nand_driver);</span><br><span class="line">	<span class="keyword">return</span> platform_driver_register(&amp;s3c2410_nand_driver);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
其中的s3c2440_nand_driver结构也是在相同的文件中定义，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">platform_driver</span> <span class="title">s3c2440_nand_driver</span> =</span> &#123;</span><br><span class="line">	.probe		= s3c2440_nand_probe,</span><br><span class="line">	.remove		= s3c2410_nand_remove,</span><br><span class="line">	.suspend	= s3c24xx_nand_suspend,</span><br><span class="line">	.resume		= s3c24xx_nand_resume,</span><br><span class="line">	.driver		= &#123;</span><br><span class="line">		.name	= <span class="string">&quot;s3c2440-nand&quot;</span>,</span><br><span class="line">		.owner	= THIS_MODULE,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
可见，s3c_device_nand结构和s3c2440_nand_driver结构中的name成员相同，都是“s3c2440-nand”。<code>platform_driver_register</code>函数就是根据这点确定它们是匹配的，所以调用<code>s3c2440_nand_probe</code>函数来枚举NAND Flash设备s3c_device_nand。<br>从<code>s3c2440_nand_probe</code>函数开始，可以一直找到对NAND Flash分区的识别，如下所示：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">s3c2440_nand_probe(&amp;s3c_device_nand) -&gt;								<span class="comment">//这个参数是为了便于理解加上的</span></span><br><span class="line">	s3c24xx_nand_probe(&amp;s3c_device_nand, TYPE_S3C2440) -&gt;			<span class="comment">//</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">s3c2410_platform_nand</span> *<span class="title">plat</span> =</span> to_nand_plat(pdev) -&gt;	<span class="comment">//plat = &amp;smdk_nand_info</span></span><br><span class="line">		s3c2410_nand_add_partition(info, nmtd, sets); -&gt;			<span class="comment">//sets就是smdk_nand_info</span></span><br><span class="line">		add_mtd_partitions											<span class="comment">//实际的参数为smdk_default_nand_part</span></span><br></pre></td></tr></table></figure>
这些函数都在<code>drivers/mtd/nand/s3c2410.c</code>中定义，最后的<code>add_mtd_partitions</code>函数根据smdk_default_nand_part结构来确定分区。这个结构在<code>arch/arm/plat-s3c24xx/common-smdk.c</code>中定义，要改变分区时修改它即可。</li>
</ol>
<h3 id="修改-MTD-分区-1"><a href="#修改-MTD-分区-1" class="headerlink" title="修改 MTD 分区"></a>修改 MTD 分区</h3><p>如上所述，要改变分区时，修改<code>arch/arm/plat-s3c24xx/common-smdk.c</code>文件中的smdk_default_nand_part结构即可。本章节将NAND Flash划分为3个分区，前2MB用于存放内核，接下来的8MB用于存放JFFS2文件系统，剩下的用来存放YAFFS文件系统。<br>smdk_default_nand_part结构修改如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">mtd_partition</span> <span class="title">smdk_default_nand_part</span>[] =</span> &#123;</span><br><span class="line">	[<span class="number">0</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;Kernel&quot;</span>,</span><br><span class="line">		.size	= SZ_2M,</span><br><span class="line">		.offset	= <span class="number">0</span>,</span><br><span class="line">	&#125;,</span><br><span class="line">	[<span class="number">1</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;jffs2&quot;</span>,</span><br><span class="line">		.offset = MTDPART_OFS_APPEND,</span><br><span class="line">		.size	= SZ_8M,</span><br><span class="line">	&#125;,</span><br><span class="line">	[<span class="number">2</span>] = &#123;</span><br><span class="line">		.name	= <span class="string">&quot;yaffs&quot;</span>,</span><br><span class="line">		.offset = MTDPART_OFS_APPEND,</span><br><span class="line">		.size	= MTDPART_SIZ_FULL,</span><br><span class="line">	&#125;,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中的MTDPART_OFS_APPEND表示当前分区紧接着上一个分区，MTDPART_SIZ_FULL表示当前分区的大小为剩余的Flash空间。<br>执行“make uImage”重新生成内核映像，重新启动后可以看到内核打印出如下分区信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Creating <span class="number">3</span> MTD partitions on <span class="string">&quot;NAND 64MiB 3,3V 8-bit&quot;</span></span><br><span class="line"><span class="number">0x00000000</span><span class="number">-0x00200000</span>: <span class="string">&quot;kernel&quot;</span></span><br><span class="line"><span class="number">0x00200000</span><span class="number">-0x00a00000</span>: <span class="string">&quot;jffs2&quot;</span></span><br><span class="line"><span class="number">0x00a00000</span><span class="number">-0x04000000</span>: <span class="string">&quot;yaffs&quot;</span></span><br></pre></td></tr></table></figure>
<p>由于目标板没有写入文件系统映像，也没有设置命令行使用网络文件系统（nfs），内核启动后还是会出现panic信息。</p>
<h2 id="移植-YAFFS-文件系统"><a href="#移植-YAFFS-文件系统" class="headerlink" title="移植 YAFFS 文件系统"></a>移植 YAFFS 文件系统</h2><h3 id="YAFFS-文件系统介绍"><a href="#YAFFS-文件系统介绍" class="headerlink" title="YAFFS 文件系统介绍"></a>YAFFS 文件系统介绍</h3><p>YAFFS（yet another flash file system）是一种类似于JFFS&#x2F;JFFS2、专门为NAND Flash 设计的嵌入式文件系统，适用于大容量的存储设备。它是日志结构的文件系统，提供了损耗平衡和掉电保护，可以有效避免意外掉电对文件系统一致性和完整性的影响。与JFFS相比，它减少了一些功能，因此速度更快，占用内存更少。<br>YAFFS充分考虑了NAND Flash的特点，根据NAND Flash以页面为单位存取的特点，将文件组织成固定大小的数据段。利用NAND Flash提供的每个页面16字节的OOB空间来存储ECC（Error Correction Code）和文件系统的组织信息，不仅能实现错误检测和坏块处理，也能够提高文件系统的加载速度。YAFFS采用了一种多策略混合的垃圾回收算法，结合了贪心策略的高效性和随机选择的平均性，达到了兼顾系统开销和损耗平衡的目的。<br>YAFFS文件系统具有很好的移植性，可以在Linux、WindowsCE、pSOS、ThreadX、DSP-BIOS等多种操作系统上工作。为NAND Flash提供了一种可靠的操作系统，并且适合于对能耗要求高的嵌入式系统。<br>YAFFS文件系统目前已经发展到第二版本：YAFFS2，它向前兼容YAFFS1，主要特点是支持每页容量大于512字节的NAND Flash。</p>
<table>
<thead>
<tr>
<th></th>
<th>比较</th>
<th>YAFFS2</th>
<th>YAFFS1</th>
</tr>
</thead>
<tbody><tr>
<td>写操作</td>
<td>快1-3倍</td>
<td>1.5MB&#x2F;s-4.5MB&#x2F;s</td>
<td>1.5MB&#x2F;s</td>
</tr>
<tr>
<td>读操作</td>
<td>快1-2倍</td>
<td>7.6MB&#x2F;s-16.7MB&#x2F;s</td>
<td>7.6MB&#x2F;s</td>
</tr>
<tr>
<td>删除操作</td>
<td>快4-34倍</td>
<td>7.8MB&#x2F;s-62.5MB&#x2F;s</td>
<td>1.8MB&#x2F;s</td>
</tr>
<tr>
<td>垃圾回收</td>
<td>快2-7倍</td>
<td>2.1MB&#x2F;s-7.7MB&#x2F;s</td>
<td>1.1MB&#x2F;s</td>
</tr>
<tr>
<td>内存消耗</td>
<td>减少25%-50%</td>
<td>-</td>
<td>-</td>
</tr>
</tbody></table>
<p>一般而言，在NOR Flash上使用JFFS2文件系统，在NAND Flash上使用YAFFS文件系统。JFFS2与YAFFS的性能比较如下。<br>| 性能 | JFFS2 | YAFFS |<br>| 内存消耗 | 每个节点（node）占用16字节<br>128MB的Flash将占用4MB内存 | 每页占用2字节<br>128MB的Flash将占用512KB内存 |<br>| 第一次启动时的扫描时间 | 128MB的Flash上时间为25S | 只需要读取OOB，时间为3S |<br>| 是否压缩 | 压缩 | 不压缩 |<br>| 代码复杂度 | 复杂 | 简单 |<br>| 使用的操作系统 | Linux、eCos | 很多，容易移植 |<br>| 启动时间 | Flash容量为4MB（or 8MB）时为4S | Flash容量为30MB时为7S |</p>
<h3 id="YAFFS-文件系统移植"><a href="#YAFFS-文件系统移植" class="headerlink" title="YAFFS 文件系统移植"></a>YAFFS 文件系统移植</h3><p>从<code>http://www.aleph1.co.uk/cgi-bin/viewcvs.cgi/</code>获取源代码文件root.tar.gz。解压得到Development目录，里面有两个子目录：yaffs和yaffs2。yaffs目录不在维护，yaffs2兼容yaffs。</p>
<h4 id="将yaffs2代码加入内核"><a href="#将yaffs2代码加入内核" class="headerlink" title="将yaffs2代码加入内核"></a>将yaffs2代码加入内核</h4><p>可以通过yaffs2目录下的脚本文件patch.ker.sh来给内核打补丁，用法如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">usage: ./patch-ker.sh c/l kernelpath</span><br><span class="line">if c/l is c,then copy. if 1 then link</span><br></pre></td></tr></table></figure>
<p>这表明，如果“c&#x2F;l”为“c”，则yaffs2的代码会被复制到内核目录下；如果是“1”，则仅仅是在内核目录下创建一些连接文件。<br>假设下载解压后的yaffs2源码目录为<code>/work/system/Development/yaffs2</code>，内核源码目录为<code>/work/system/linux-2.6.22.6</code>，执行以下命令打补丁：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /work/system/Development/yaffs2</span><br><span class="line">./patch-ker.sh c /work/system/linux-2.6.22.6</span><br></pre></td></tr></table></figure>
<p>上述命令完成以下3件事情。</p>
<ol>
<li>修改内核fs&#x2F;Kconfig文件，增加以下两行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Patched by YAFFS</span><br><span class="line">source &quot;fs/yaffs/Kconfig&quot;</span><br></pre></td></tr></table></figure></li>
<li>修改内核fs&#x2F;Makefile文件，增加以下两行<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># Patched by YAFFS</span><br><span class="line">obj-$(CONFIG_YAFFS_FS)	+= yaffs2/</span><br></pre></td></tr></table></figure></li>
<li>在内核<code>fs/</code>目录下创建yaffs2子目录，然后复制如下文件。<br>将yaffs2源码目录下得Makefile.kernel文件复制为内核<code>fs/yaffs2/Makefile</code>文件。<br>将yaffs2源码目录下的Kconfig文件复制到内核<code>fs/yaffs2</code>目录下。<br>将yaffs2源码目录下的*.c、*.h（不包括子目录下的文件）复制到内核<code>fs/yaffs2</code>目录下。</li>
</ol>
<h4 id="配置、编译内核"><a href="#配置、编译内核" class="headerlink" title="配置、编译内核"></a>配置、编译内核</h4><p>阅读<code>fs/yaffs2/Kconfig</code>文件可以了解各个配置选项的作用。</p>
<ol>
<li>CONFIG_YAFFS_FS：支持YAFFS文件系统</li>
<li>CONFIG_YAFFS_YAFFS1：支持YAFFS1文件系统<br>对于每页大小为512字节的NAND Flash，要选上这个配置项</li>
<li>CONFIG_YAFFS_YAFFS1：支持YAFFS2文件系统<br>对于每页大小为2048字节的NAND Flash，要选上这个配置项。本书所用的NAND Flash每页为512字节，这个配置项可以不选。</li>
<li>CONFIG_YAFFS_AUTO_YAFFS2：自动选择YAFFS2格式。<br>如果不设置这个配置项，必须使用“yaffs2”字样来表示YAFFS2文件系统格式；如果设置了这个配置项，则可以使用“yaffs”字样来统一表示YAFFS、YAFFS2文件系统格式，驱动程序会根据NAND Flash页的大小自动分辨是YAFFS还是YAFFS2。</li>
<li>CONFIG_YAFFS_9BYTE_TAGS<br>老的YAFFS1文件系统中，使用oob区中9个字节作为文件系统的标记（tag），比新的YAFFS1多了1个字节—“pageStatus”，它用来表示页的状态。<br>如果要使用老的YAFFS1，这个配置项要选上，另外要修改MTD设备层以使用老的oob layout结构。oob layout就是内核文件<code>drivers/mtd/nand/nand_base.c</code>中的nand_oob_16结构。<br>Linux-2.6.22.6内核使用新的oob layout，格式如下。它表示ECC码存放的位置是oob区中0、1、…、7这8个字节；剩下的空间就称为可用空间，供文件系统使用，代码中将这些数据称为标记（tag）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_ecclayout</span> <span class="title">nand_oob_16</span> =</span> &#123;</span><br><span class="line">	.eccbytes = <span class="number">6</span>,</span><br><span class="line">	.eccpos	= &#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">7</span>&#125;,</span><br><span class="line">	.oobfree = &#123;</span><br><span class="line">		&#123;</span><br><span class="line">			.offset = <span class="number">8</span>,</span><br><span class="line">			.length = <span class="number">8</span></span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
以前的内核使用老的oob layout，格式如下，ECC码的位置不一样，标记的位置也不一样。<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">nand_ecclayout</span> <span class="title">nand_oob_16</span> =</span> &#123;</span><br><span class="line">	.eccbytes = <span class="number">6</span>,</span><br><span class="line">	.eccpos	= &#123;<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">13</span>,<span class="number">14</span>,<span class="number">15</span>&#125;,</span><br><span class="line">	.oobavail = <span class="number">9</span>,</span><br><span class="line">	.oobfree = &#123;&#123;<span class="number">0</span>,<span class="number">4</span>&#125;,&#123;<span class="number">6</span>,<span class="number">2</span>&#125;,&#123;<span class="number">11</span>,<span class="number">2</span>&#125;,&#123;<span class="number">4</span>,<span class="number">1</span>&#125;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
如果要使用老格式的YAFFS1映像文件，定义CONFIG_YAFFS_9BYTE_TAGS配置项，并且修改nand_oob_16结构为老的格式。</li>
<li>CONFIG_YAFFS_DOES_ECC：使用YAFFS本身的ECC校验参数。<br>一般使用MTD设备层的ECC校验函数，这个配置项不用设置。<br>了解各配置项的意义后，就可以配置内核，选上对YAFFS的支持了。在内核配置界面选中“YAFFS2 file system support”即可，其他配置选项使用默认值。<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">File systems	---&gt;</span><br><span class="line">	Miscellaneous filesystems	---&gt;</span><br><span class="line">		&lt;*&gt;	YAFFS2 file system support </span><br></pre></td></tr></table></figure>
最后执行“make uImage”编译内核。</li>
</ol>
<h2 id="编译、烧写、启动内核"><a href="#编译、烧写、启动内核" class="headerlink" title="编译、烧写、启动内核"></a>编译、烧写、启动内核</h2><p>到目前为止，内核已经同时支持了S3C2410和S3C2440，修改了NAND Flash的分区，增加了对YAFFS文件系统的支持。另外，内核原来已经支持JFFS2文件系统。现在的内核。已经基本可用，可以将它烧入NAND Flash中。</p>
<h3 id="编译内核"><a href="#编译内核" class="headerlink" title="编译内核"></a>编译内核</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make uImage</span><br></pre></td></tr></table></figure>
<h3 id="烧写内核"><a href="#烧写内核" class="headerlink" title="烧写内核"></a>烧写内核</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tftp 0x32000000 uImage 或 nfs 0x30000000 192.168.1.57:/work/nfs_root/uImage</span><br><span class="line">nand erase 0 0x200000							//擦除NAND Flash 前2MB</span><br><span class="line">nand write.jffs2 0x32000000 0 $(filesize)		//烧写uImage</span><br></pre></td></tr></table></figure>

<h3 id="启动内核"><a href="#启动内核" class="headerlink" title="启动内核"></a>启动内核</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">nboot 0x32000000 0 0</span><br><span class="line">bootm 0x32000000</span><br></pre></td></tr></table></figure>
<p>要想开发板上电自动启动内核，可以设置bootcmd环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set bootcmd &#x27;nboot 0x32000000 0 0; bootm 0x32000000&#x27;</span><br><span class="line">setenv</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux-%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/" rel="tag"># Linux 应用开发</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/08/31/%E7%A7%BB%E6%A4%8DUBoot/" rel="prev" title="移植UBoot">
                  <i class="fa fa-chevron-left"></i> 移植UBoot
                </a>
            </div>
            <div class="post-nav-item">
                <a href="/2022/09/16/%E6%9E%84%E5%BB%BALinux%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F/" rel="next" title="构建Linux根文件系统">
                  构建Linux根文件系统 <i class="fa fa-chevron-right"></i>
                </a>
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nibil</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">301k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">4:34</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
