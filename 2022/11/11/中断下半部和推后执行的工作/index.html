<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width">
<meta name="theme-color" content="#222"><meta name="generator" content="Hexo 6.2.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">



<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.1.1/css/all.min.css" integrity="sha256-DfWjNxDkM94fVBWx1H5BMMp0Zq7luBlV8QRcSES7s+0=" crossorigin="anonymous">
  <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/animate.css/3.1.1/animate.min.css" integrity="sha256-PR7ttpcvz8qrF57fur/yAx1qXMFJeJFiA6pSzWi0OIE=" crossorigin="anonymous">

<script class="next-config" data-name="main" type="application/json">{"hostname":"example.com","root":"/","images":"/images","scheme":"Muse","darkmode":false,"version":"8.12.2","exturl":false,"sidebar":{"position":"left","display":"always","padding":18,"offset":12},"copycode":{"enable":true,"style":"mac"},"bookmark":{"enable":true,"color":"#222","save":"auto"},"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"stickytabs":false,"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"fadeInDown","post_body":"fadeInDown","coll_header":"fadeInLeft","sidebar":"fadeInUp"}},"prism":false,"i18n":{"placeholder":"搜索...","empty":"没有找到任何搜索结果：${query}","hits_time":"找到 ${hits} 个搜索结果（用时 ${time} 毫秒）","hits":"找到 ${hits} 个搜索结果"},"path":"/search.xml","localsearch":{"enable":true,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false}}</script><script src="/js/config.js"></script>

    <meta name="description" content="在第7章中，我们讨论了内核为处理中断而提供的中断处理程序机制。中断处理程序是内核中很有用的部分。但是，由于本身存在一些局限，所以它只能完成整个中断处理流程的上半部分。这些局限包括：  中断处理程序以异步方式执行，并且它有可能打断其他重要代码（甚至包括其他中断处理程序）的执行。因此，为了避免被打断的代码停止时间过长，中断执行程序应该执行得越快越好。 如果当前有一个中断处理程序正在执行，在最好的情况下">
<meta property="og:type" content="article">
<meta property="og:title" content="中断下半部和推后执行的工作">
<meta property="og:url" content="http://example.com/2022/11/11/%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C/index.html">
<meta property="og:site_name" content="Laugh Tale">
<meta property="og:description" content="在第7章中，我们讨论了内核为处理中断而提供的中断处理程序机制。中断处理程序是内核中很有用的部分。但是，由于本身存在一些局限，所以它只能完成整个中断处理流程的上半部分。这些局限包括：  中断处理程序以异步方式执行，并且它有可能打断其他重要代码（甚至包括其他中断处理程序）的执行。因此，为了避免被打断的代码停止时间过长，中断执行程序应该执行得越快越好。 如果当前有一个中断处理程序正在执行，在最好的情况下">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-11-11T06:52:57.000Z">
<meta property="article:modified_time" content="2022-11-11T06:52:57.000Z">
<meta property="article:author" content="Nibil">
<meta property="article:tag" content="Linux Kernel">
<meta property="article:tag" content="操作系统">
<meta name="twitter:card" content="summary">


<link rel="canonical" href="http://example.com/2022/11/11/%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C/">



<script class="next-config" data-name="page" type="application/json">{"sidebar":"","isHome":false,"isPost":true,"lang":"zh-CN","comments":"","permalink":"http://example.com/2022/11/11/%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C/","path":"2022/11/11/中断下半部和推后执行的工作/","title":"中断下半部和推后执行的工作"}</script>

<script class="next-config" data-name="calendar" type="application/json">""</script>
<title>中断下半部和推后执行的工作 | Laugh Tale</title>
  





  <noscript>
    <link rel="stylesheet" href="/css/noscript.css">
  </noscript>
  <!--pjax：防止跳转页面音乐暂停-->
  <script src="https://cdn.jsdelivr.net/npm/pjax@0.2.8/pjax.js"></script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" class="use-motion">
  <div class="headband"></div>

  <main class="main">
    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏" role="button">
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
        <span class="toggle-line"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <i class="logo-line"></i>
      <p class="site-title">Laugh Tale</p>
      <i class="logo-line"></i>
    </a>
      <p class="site-subtitle" itemprop="description">A Nibil's Sharing Blog</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
        <i class="fa fa-search fa-fw fa-lg"></i>
    </div>
  </div>
</div>



<nav class="site-nav">
  <ul class="main-menu menu"><li class="menu-item menu-item-home"><a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a></li><li class="menu-item menu-item-about"><a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a></li><li class="menu-item menu-item-tags"><a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a></li><li class="menu-item menu-item-categories"><a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a></li><li class="menu-item menu-item-archives"><a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a></li>
      <li class="menu-item menu-item-search">
        <a role="button" class="popup-trigger"><i class="fa fa-search fa-fw"></i>搜索
        </a>
      </li>
  </ul>
</nav>



  <div class="search-pop-overlay">
    <div class="popup search-popup"><div class="search-header">
  <span class="search-icon">
    <i class="fa fa-search"></i>
  </span>
  <div class="search-input-container">
    <input autocomplete="off" autocapitalize="off" maxlength="80"
           placeholder="搜索..." spellcheck="false"
           type="search" class="search-input">
  </div>
  <span class="popup-btn-close" role="button">
    <i class="fa fa-times-circle"></i>
  </span>
</div>
<div class="search-result-container no-result">
  <div class="search-result-icon">
    <i class="fa fa-spinner fa-pulse fa-5x"></i>
  </div>
</div>

    </div>
  </div>

</div>
        
  
  <div class="toggle sidebar-toggle" role="button">
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
    <span class="toggle-line"></span>
  </div>

  <aside class="sidebar">

    <div class="sidebar-inner sidebar-nav-active sidebar-toc-active">
      <ul class="sidebar-nav">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <div class="sidebar-panel-container">
        <!--noindex-->
        <div class="post-toc-wrap sidebar-panel">
            <div class="post-toc animated"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="nav-number">1.</span> <span class="nav-text">下半部</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E7%94%A8%E4%B8%8B%E5%8D%8A%E9%83%A8"><span class="nav-number">1.1.</span> <span class="nav-text">为什么要用下半部</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E7%8E%AF%E5%A2%83"><span class="nav-number">1.2.</span> <span class="nav-text">下半部的环境</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%B8%8B%E5%8D%8A%E9%83%A8%E7%9A%84%E8%B5%B7%E6%BA%90"><span class="nav-number">1.2.1.</span> <span class="nav-text">下半部的起源</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BB%BB%E5%8A%A1%E9%98%9F%E5%88%97"><span class="nav-number">1.3.</span> <span class="nav-text">任务队列</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8Ctasklet"><span class="nav-number">1.4.</span> <span class="nav-text">软中断和tasklet</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%B7%B7%E4%B9%B1%E7%9A%84%E4%B8%8B%E5%8D%8A%E9%83%A8%E6%A6%82%E5%BF%B5"><span class="nav-number">1.5.</span> <span class="nav-text">混乱的下半部概念</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">2.</span> <span class="nav-text">软中断</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.</span> <span class="nav-text">软中断的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.1.1.</span> <span class="nav-text">软中断处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%89%A7%E8%A1%8C%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">2.1.2.</span> <span class="nav-text">执行软中断</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">2.2.</span> <span class="nav-text">使用软中断</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%86%E9%85%8D%E7%B4%A2%E5%BC%95"><span class="nav-number">2.2.1.</span> <span class="nav-text">分配索引</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E5%86%8C%E4%BD%A0%E7%9A%84%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">注册你的处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A7%A6%E5%8F%91%E4%BD%A0%E7%9A%84%E8%BD%AF%E4%B8%AD%E6%96%AD"><span class="nav-number">2.2.3.</span> <span class="nav-text">触发你的软中断</span></a></li></ol></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#tasklet"><span class="nav-number">3.</span> <span class="nav-text">tasklet</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#tasklet%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.</span> <span class="nav-text">tasklet的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#tasklet%E7%BB%93%E6%9E%84%E4%BD%93"><span class="nav-number">3.1.1.</span> <span class="nav-text">tasklet结构体</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6tasklet"><span class="nav-number">3.1.2.</span> <span class="nav-text">调度tasklet</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%BF%E7%94%A8tasklet"><span class="nav-number">3.2.</span> <span class="nav-text">使用tasklet</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84tasklet"><span class="nav-number">3.2.1.</span> <span class="nav-text">声明你自己的tasklet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BC%96%E5%86%99%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84tasklet%E5%A4%84%E7%90%86%E7%A8%8B%E5%BA%8F"><span class="nav-number">3.2.2.</span> <span class="nav-text">编写你自己的tasklet处理程序</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%B0%83%E5%BA%A6%E4%BD%A0%E8%87%AA%E5%B7%B1%E7%9A%84tasklet"><span class="nav-number">3.2.3.</span> <span class="nav-text">调度你自己的tasklet</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#ksoftirq"><span class="nav-number">3.2.4.</span> <span class="nav-text">ksoftirq</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%80%81%E7%9A%84BH%E6%9C%BA%E5%88%B6"><span class="nav-number">3.3.</span> <span class="nav-text">老的BH机制</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97"><span class="nav-number">4.</span> <span class="nav-text">工作队列</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B7%A5%E4%BD%9C%E9%98%9F%E5%88%97%E7%9A%84%E5%AE%9E%E7%8E%B0"><span class="nav-number">4.1.</span> <span class="nav-text">工作队列的实现</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.1.</span> <span class="nav-text">表示线程的数据结构</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A1%A8%E7%A4%BA%E5%B7%A5%E4%BD%9C%E7%9A%84%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="nav-number">4.1.2.</span> <span class="nav-text">表示工作的数据结构</span></a></li></ol></li></ol></li></ol></div>
        </div>
        <!--/noindex-->

        <div class="site-overview-wrap sidebar-panel">
          <div class="site-author site-overview-item animated" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Nibil</p>
  <div class="site-description" itemprop="description">A Nibil's Sharing Blog</div>
</div>
<div class="site-state-wrap site-overview-item animated">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
        <a href="/archives/">
          <span class="site-state-item-count">38</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
          <a href="/categories/">
        <span class="site-state-item-count">46</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
          <a href="/tags/">
        <span class="site-state-item-count">29</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>
  <div class="links-of-author site-overview-item animated">
      <span class="links-of-author-item">
        <a href="https://github.com/NibilCN" title="GitHub → https:&#x2F;&#x2F;github.com&#x2F;NibilCN" rel="noopener" target="_blank"><i class="fab fa-github fa-fw"></i>GitHub</a>
      </span>
  </div>



        </div>
      </div>
    </div>
    <div class="sidebar-inner">
      <!-- require APlayer -->
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.css">
      <script src="https://cdn.jsdelivr.net/npm/aplayer/dist/APlayer.min.js"></script>
      <!-- require MetingJS -->
      <script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>
      <!--网易云-->   
      <meting-js
        server="netease"
        id="7593069088"
        type="playlist" 
        mini="false"
        fixed="false"
        list-folded="true"
        autoplay="true"
        volume="0.4"
        theme="#FADFA3"
        order="random"
        loop="all"
        preload="auto"
        mutex="true">
      </meting-js>
    </div>
  </aside>
  <div class="sidebar-dimmer"></div>


    </header>

    
  <div class="back-to-top" role="button" aria-label="返回顶部">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>
  <div class="reading-progress-bar"></div>
  <a role="button" class="book-mark-link book-mark-link-fixed"></a>

  <a href="https://github.com/NibilCN" class="github-corner" title="Follow me on GitHub" aria-label="Follow me on GitHub" rel="noopener" target="_blank"><svg width="80" height="80" viewBox="0 0 250 250" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg></a>

<noscript>
  <div class="noscript-warning">Theme NexT works best with JavaScript enabled</div>
</noscript>


    <div class="main-inner post posts-expand">


  


<div class="post-block">
  
  

  <article itemscope itemtype="http://schema.org/Article" class="post-content" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2022/11/11/%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Nibil">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Laugh Tale">
      <meta itemprop="description" content="A Nibil's Sharing Blog">
    </span>

    <span hidden itemprop="post" itemscope itemtype="http://schema.org/CreativeWork">
      <meta itemprop="name" content="中断下半部和推后执行的工作 | Laugh Tale">
      <meta itemprop="description" content="">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          中断下半部和推后执行的工作
        </h1>

        <div class="post-meta-container">
          <div class="post-meta">
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-calendar"></i>
      </span>
      <span class="post-meta-item-text">发表于</span>

      <time title="创建时间：2022-11-11 14:52:57" itemprop="dateCreated datePublished" datetime="2022-11-11T14:52:57+08:00">2022-11-11</time>
    </span>
    <span class="post-meta-item">
      <span class="post-meta-item-icon">
        <i class="far fa-folder"></i>
      </span>
      <span class="post-meta-item-text">分类于</span>
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/" itemprop="url" rel="index"><span itemprop="name">学习</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/" itemprop="url" rel="index"><span itemprop="name">书籍</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/" itemprop="url" rel="index"><span itemprop="name">Linux内核设计与实现</span></a>
        </span>
          ，
        <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
          <a href="/categories/%E5%AD%A6%E4%B9%A0/%E4%B9%A6%E7%B1%8D/Linux%E5%86%85%E6%A0%B8%E8%AE%BE%E8%AE%A1%E4%B8%8E%E5%AE%9E%E7%8E%B0/%E7%AC%AC8%E7%AB%A0-%E4%B8%AD%E6%96%AD%E4%B8%8B%E5%8D%8A%E9%83%A8%E5%92%8C%E6%8E%A8%E5%90%8E%E6%89%A7%E8%A1%8C%E7%9A%84%E5%B7%A5%E4%BD%9C/" itemprop="url" rel="index"><span itemprop="name">第8章 中断下半部和推后执行的工作</span></a>
        </span>
    </span>

  
    <span class="post-meta-item" title="阅读次数" id="busuanzi_container_page_pv">
      <span class="post-meta-item-icon">
        <i class="far fa-eye"></i>
      </span>
      <span class="post-meta-item-text">阅读次数：</span>
      <span id="busuanzi_value_page_pv"></span>
    </span>
    <span class="post-meta-break"></span>
    <span class="post-meta-item" title="本文字数">
      <span class="post-meta-item-icon">
        <i class="far fa-file-word"></i>
      </span>
      <span class="post-meta-item-text">本文字数：</span>
      <span>18k</span>
    </span>
    <span class="post-meta-item" title="阅读时长">
      <span class="post-meta-item-icon">
        <i class="far fa-clock"></i>
      </span>
      <span class="post-meta-item-text">阅读时长 &asymp;</span>
      <span>16 分钟</span>
    </span>
</div>

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">
        <p>在第7章中，我们讨论了内核为处理中断而提供的中断处理程序机制。中断处理程序是内核中很有用的部分。但是，由于本身存在一些局限，所以它只能完成整个中断处理流程的上半部分。这些局限包括：</p>
<ol>
<li>中断处理程序以异步方式执行，并且它有可能打断其他重要代码（甚至包括其他中断处理程序）的执行。因此，为了避免被打断的代码停止时间过长，中断执行程序应该执行得越快越好。</li>
<li>如果当前有一个中断处理程序正在执行，在最好的情况下（如果IRQF_DISABLED没有被设置），与该中断同级的其他中断会被屏蔽，在最坏的情况下（如果IRQF_DISABLED有被设置），当前处理器上所有其他中断都会被屏蔽。因为禁止中断后硬件与操作系统无法通信，因此，中断处理程序执行得越快越好。</li>
<li>由于中断处理函数往往需要对硬件进行操作，所以它们通常有很高的时限要求。</li>
<li>中断处理程序不在进程上下文中运行，所以它们不能阻塞。这限制了它们所做得事情。</li>
</ol>
<p>现在，为什么中断处理程序只能作为整个硬件中断处理流程一部分的原因就很明显了。操作系统必须有一个快速、异步、简单的机制负责对硬件做出迅速响应并完成那些时间要求很严格的操作。中断处理程序很适合于实现这些功能，可是，对于那些其他的、对时间要求相对宽松的任务，就应该推后到中断被激活以后再去运行。<br>这样，整个中断处理流程就被分为了两个部分，或叫两半。第一个部分是中断处理程序（上半部），就像我们在第7章讨论的那样，内核通过对它的异步执行完成对硬件中断的即时响应。在本章中，我们要研究的是中断处理流程中的另外那一部分，下半部（bottom halves）。</p>
<span id="more"></span>

<h1 id="下半部"><a href="#下半部" class="headerlink" title="下半部"></a>下半部</h1><p>下半部的工作就是执行与中断处理密切相关但中断处理程序本身不执行的工作。在理想情况下，最好是中断处理程序将所有工作都交给下半部分执行，因为我们希望在中断处理程序中完成的工作越少越好（也就是越快越好）。我们期望中断处理程序能够尽可能快的返回。<br>但是，中断处理程序注定要完成一部分工作。例如，中断处理程序几乎都需要通过操作硬件对中断的到达进行确认，有时它还会从硬件拷贝数据。因为这些工作对时间非常敏感，所以只能靠中断处理程序自己去完成。<br>剩下的几乎所有其他工作都是下半部执行的目标。例如，如果你在上半部中把数据从硬件拷贝到内存，那么当然应该在下半部中处理它们。遗憾的是，并不存在严格明确的规定来说明到底什么任务应该在哪个部分中完成–如何做决定完全取决于驱动程序开发者自己的判断。尽管在理论上不存在什么错误，但是轻率的实现效果往往不很理想。记住，中断处理程序会异步执行，并且在最好的情况下它也会锁定当前的中断线。因此将中断处理程序持续执行的时间缩短到最小程度显得非常重要。对于在上半部和下半部之间划分工作，尽管不存在某种严格的规则，但还是有一些提示可供借鉴：</p>
<ol>
<li>如果一个任务对时间非常敏感，将其放在中断处理程序中执行。</li>
<li>如果一个任务和硬件相关，将其放在中断处理程序中执行。</li>
<li>如果一个任务要保证不被其他中断（特别是相同的中断）打断，将其放在中断处理程序中执行。</li>
<li>其他所有任务，考虑放置在下半部执行。</li>
</ol>
<p>当你开始尝试写自己的驱动程序的时候，读一下别人的中断处理程序和相应的下半部可能会让你受益匪浅。在决定怎样把你的中断处理流程中的工作划分到上半部和下半部中去的时候，问问自己什么必须放进上半部而什么可以放进下半部。通常，中断处理程序要执行得越快越好。</p>
<h2 id="为什么要用下半部"><a href="#为什么要用下半部" class="headerlink" title="为什么要用下半部"></a>为什么要用下半部</h2><p>理解为什么要让工作推后执行以及在什么时候推后执行非常关键。你希望尽量减少中断处理程序中需要完成的工作量，因为它在运行的时候，当前的中断线在所有处理器上都会被屏蔽。更糟糕的是，如果一个处理程序是IRQF_DISABLED类型，它执行的时候会禁止所有本地中断（而且把本地中断线全局的屏蔽掉）。而缩短中断被屏蔽的时间对系统的响应能力和性能都至关重要。再加上中断处理程序要与其他程序（甚至是其他的中断处理程序）异步执行，所以很明显，我们必须尽力缩短中断处理程序的执行。解决的办法就是把一些工作放到以后去做。<br>但具体放到以后什么时候去做呢？在这里，以后仅仅用来强调不是马上而已，理解这一点相当重要，下半部并不需要指明一个确切时间，只要把这些任务推迟一点，让它们在系统不太繁忙的并且中断恢复后执行就可以了。通常下半部在中断处理程序一返回就会马上运行。下半部执行的关键在于当它们运行的时候，允许响应所有的中断。<br>不仅仅是Linux，许多操作系统也把处理硬件中断的过程分为两部分。上半部分简单快速，执行的时候禁止一些或全部中断。下半部分稍后执行，而且执行期间可以响应所有的中断。这种设计可使系统处于中断屏蔽状态的时间尽可能的短，以此来提高系统的响应能力。</p>
<h2 id="下半部的环境"><a href="#下半部的环境" class="headerlink" title="下半部的环境"></a>下半部的环境</h2><p>和上半部只能通过中断处理程序实现不同，下半部可以通过多种机制实现。这些用来实现下半部的机制分别由不同的接口和子系统组成。在第7章中，我们了解到实现中断处理程序的方法只有一种，但在本章中你会发现，实现一个下半部会有许多不同的方法。实际上，在Linux发展的过程中曾经出现过多种下半部机制。让人备受困扰的是，其中不少机制名字起得很相像，甚至还有一些机制名字词不达意。这就需要专门的程序员来给下半部命名。<br>在本章中，我们将要讨论2.6版本的内核中的下半部机制是如何设计和实现的。同时我们也会讨论怎么在自己编写的内核代码中使用它们。而那些过去使用的、已经废除了有一段时间的机制，由于曾经闻名遐迩，所以在相关的时候我们还会有所提及。</p>
<h3 id="下半部的起源"><a href="#下半部的起源" class="headerlink" title="下半部的起源"></a>下半部的起源</h3><p>最早的Linux只提供“bottom half”这种机制用于实现下半部。这个名字在那时毫无异义，因为当时它是将工作推后的唯一方法。这种机制也被称为“BH”，我们现在也这么叫它，以避免和“下半部”这个通用词汇混淆。像过往的那段美好岁月中的许多东西一样，BH接口也非常简单。它提供了一个静态创建、由32个bottom havles组成的链表。上半部通过一个32位整数中的一位来标识出哪个bottom half可以执行。每个BH都在全局范围内进行同步。即使分属于不同的处理器，也不允许任何两个bottom half同时执行。这种机制使用方便却不够灵活，简单却有性能瓶颈。</p>
<h2 id="任务队列"><a href="#任务队列" class="headerlink" title="任务队列"></a>任务队列</h2><p>不久，内核开发者们就引入了任务队列（task queue）机制来实现工作的推后执行，并用它来代替BH机制。内核为此定义了一组队列，其中每个队列都包含一个由等待调用的函数组成链表。根据其所处队列的位置，这些函数会在某个时刻执行。驱动程序可以把它们自己的下半部注册到合适的队列上去。这种机制表现得还不错，但仍不够灵活，没法代替整个BH接口。对于一些性能要求较高的子系统，像网络部分，它也不能胜任。</p>
<h2 id="软中断和tasklet"><a href="#软中断和tasklet" class="headerlink" title="软中断和tasklet"></a>软中断和tasklet</h2><p>在2.3这个开发版本中，内核开发者引入了软中断和tasklet。如果无需考虑和过去开发的驱动程序兼容的话，软中断和tasklet可以完全代替BH接口。软中断是一组静态定义的下半部接口，有32个，可以在任何处理器上同时执行–即使两个类型相同也可以。tasklet这一名称起得很糟糕，让人费解，它们是一种基于软中断实现的灵活性强、动态创建的下半部实现机制。两个不同类型的tasklet可以在不同的处理器上同时执行，但类型相同的tasklet不能同时执行。tasklet其实是一种在性能和易用性之间寻求平衡的产物。对于大多数下半部处理来说，用tasklet就足够了，像网络这样对性能要求非常高的情况下才需要使用软中断。可是，使用软中断需要特别小心，因为两个相同的软中断有可能同时被执行。此外，软中断还必须在编译期间就进行静态注册。与此相反，tasklet可以通过代码进行动态注册。<br>有些人别被这些概念彻底搞糊涂了，他们把所有的下半部都当成是软件产生的中断或软中断。换句话说，就是他们把软中断机制和下半部统统都叫软中断。软中断和BH与tasklet并驾齐名。<br>在开发2.5版本的内核时，BH接口最终被弃置了，所有的BH使用者必须转而使用其他下半部接口。此外，任务队列接口也被工作队列接口取代了。工作队列是一种简单但很有用的方法，它们先对要推后执行的工作排队，稍后在进程上下文中执行它们。<br>综上所述，在2.6这个当前版本中，内核提供了三种不同形式的下半部实现机制：软中断、tasklets和工作队列。内核过去曾经用过的BH和任务队列接口，现在已经湮没在记忆中了。</p>
<p><strong>内核定时器</strong><br>另外一个可以用于将工作推后执行的机制是内核定时器。不像本章到目前为止介绍到的所有这些机制，内核定时器把操作推迟到某个确定的时间段之后执行。也就是说，尽管本章讨论的其他机制可以把操作推后到除了现在以外的任何时间进行，但是当你必须保证在一个确定的时间段过去之后再运行时，你应该使用内核定时器。</p>
<h2 id="混乱的下半部概念"><a href="#混乱的下半部概念" class="headerlink" title="混乱的下半部概念"></a>混乱的下半部概念</h2><p>这些东西确实把人搅得很混乱，但它们其实只不过是一些起名的问题，让我们再来梳理一遍。<br>“下半部（bottom half）”是一个操作系统通用词汇，用于指代中断处理流程中推后执行的那一部分，之所以这样命名，是因为它表示中断处理方案一半的第二部分或者下半部。在Linux中，这个词目前确实就是这个含义。所有用于实现将工作推后执行的内核机制都被称为“下半部机制”。一些人错误地把所有的下半部机制都叫做“软中断”，真是自寻烦恼。<br>“下半部”这个词也指代Linux最早提供的那种将工作推后执行的实现机制。由于该机制也被叫做“BH”，所以，我们就使用它的这个名称，而让“下半部”这个词仍然保持它通常的含义。BH机制很早之前就被反对使用了，在2.5版本的内核中，它就被完全去除了。<br>当前，<code>有三种机制可以用来实现将工作推后执行：软中断、tasklet、工作队列</code>。tasklet通过软中断实现，而工作队列与它们完全不同。下表揭示了下半部机制的演化历程。</p>
<table>
<thead>
<tr>
<th>下半部机制</th>
<th>状态</th>
</tr>
</thead>
<tbody><tr>
<td>BH</td>
<td>在2.5中去除</td>
</tr>
<tr>
<td>任务队列（Task queues）</td>
<td>在2.5中去除</td>
</tr>
<tr>
<td>软中断（Softirq）</td>
<td>在2.3中开始引入</td>
</tr>
<tr>
<td>tasklet</td>
<td>在2.3中开始引入</td>
</tr>
<tr>
<td>工作队列（Work queues）</td>
<td>在2.5中开始引入</td>
</tr>
</tbody></table>
<p>在搞清楚这些混乱的命名之后，让我们开始具体研究各个机制。</p>
<h1 id="软中断"><a href="#软中断" class="headerlink" title="软中断"></a>软中断</h1><p>我们的讨论从实际的下半部实现–软中断方法开始。软中断使用得比较少；而tasklet是下半部更常用的一种形式。但是，由于tasklet是通过软中断实现的，所以我们先来研究软中断。软中断的代码位于<code>kernel/softirq.c</code>文件中。</p>
<h2 id="软中断的实现"><a href="#软中断的实现" class="headerlink" title="软中断的实现"></a>软中断的实现</h2><p>软中断是在编译期间静态分配的。它不像tasklet那样能被动态地注册或注销。软中断由softirq_action结构表示，它定义在&lt;linux&#x2F;interrupt.h&gt;中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> &#123;</span></span><br><span class="line">    <span class="type">void</span> (*action)(<span class="keyword">struct</span> softirq_action *);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><code>kernel/softirq.c</code>中定义了一个包含有32个该结构体的数组。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> <span class="title">softirq_vec</span>[<span class="title">NR_SOFTIRQS</span>];</span></span><br></pre></td></tr></table></figure>
<p>每个被注册的软中断都占据该数组的一项，因此最多有可能有32个软中断。注意，这是一个定值–注册的软中断数目的最大值没法动态改变。在当前的内核版本中，这32个项中只用到9个。</p>
<h3 id="软中断处理程序"><a href="#软中断处理程序" class="headerlink" title="软中断处理程序"></a>软中断处理程序</h3><p>软中断处理程序action的函数原型如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">softirq_handler</span><span class="params">(<span class="keyword">struct</span> softirq_action *)</span>;</span><br></pre></td></tr></table></figure>
<p>当内核运行一个软中断处理程序的时候，它就会执行这个action函数，其唯一的参数为指向相应的softirq_action结构体的指针。例如，如果my_softirq指向softirq_vec数组的某项，那么内核会用如下的方式调用软中断处理程序中的函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">my_softirq-&gt;action(my_softirq);</span><br></pre></td></tr></table></figure>
<p>当你看到内核把整个结构体都传递给软中断处理程序而不是仅仅传递数据值的时候，你可能会很吃惊。这个小技巧可以保证将来在结构体中加入新的域时，无须对所有的软中断处理程序都进行变动。如果需要，软中断处理程序可以方便地解析它的参数，从数据成员中提取数值。<br>一个软中断不会抢占另一个软中断。实际上，唯一可以抢占软中断的是中断处理程序。不过，其他的软中断（甚至是相同类型的软中断）可以在其他处理器上同时执行。</p>
<h3 id="执行软中断"><a href="#执行软中断" class="headerlink" title="执行软中断"></a>执行软中断</h3><p>一个注册的软中断必须在被标记后才会执行。这被称为触发软中断（raising the softirq）。通常，中断处理程序会在返回前标记它的软中断，使其在稍后被执行。于是，在合适的时刻，该软中断就会运行。在下列地方，待处理的软中断会被检查和执行：</p>
<ol>
<li>从一个硬件中断代码出返回。</li>
<li>在ksoftirqd内核线程中。</li>
<li>在那些显式检查和执行待处理的软中断的代码中，如网络子系统中</li>
</ol>
<p>不管是用什么方法唤起，软中断都要在do_softirq()中执行。该函数很简单。如果有待处理的软中断，do_softirq()会循环遍历每一个，调用它们的处理程序。让我观察一下do_softirq()经过简化后的核心部分：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">u32 pending;</span><br><span class="line"></span><br><span class="line">pending = local_softirq_pending();</span><br><span class="line"><span class="keyword">if</span>(pending) &#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">softirq_action</span> *<span class="title">h</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重设待处理的位图</span></span><br><span class="line">    set_softirq_pending(<span class="number">0</span>);</span><br><span class="line"></span><br><span class="line">    h = softirq_vec;</span><br><span class="line">    <span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="keyword">if</span>(pending &amp; l)</span><br><span class="line">            h-&gt;action(h);</span><br><span class="line">        h++;</span><br><span class="line">        pending &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;<span class="keyword">while</span>(pending);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>以上摘录的是软中断处理的核心部分。它检查并执行所有待处理的软中断，具体要做的包括：</p>
<ol>
<li>用局部变量pending保存local_softirq_pending()宏的返回值。它是待处理的软中断的32位位图–如果第n位被设置为1，那么第n位对应类型的软中断等待处理。</li>
<li>现在待处理的软中断位图已经被保存，可以将实际的软中断位图清零了。</li>
<li>将指针n指向softirq_vec的第一项。</li>
<li>如果pending第一位被置为1，则h-&gt;action(h)被调用。</li>
<li>指针加1，所以现在它指向softirq_vec数组的第二项。</li>
<li>位掩码pending右移一位。这样会丢弃第一位，然后让其他各位依次向后移动一个位置。于是，原来的第二位现在就在第一位的位置上了。</li>
<li>现在指针h指向数组的第二项，pending位掩码的第二位现在也到了第一位上。重复执行上面的步骤。</li>
<li>一直重复下去，直到pengding变为0，这表明已经没有待处理的软中断了，我们的任务也就完成了。注意，这种检查足以保证h总指向softirq_vec的有效项，因为pending最多只可能设置32位，循环最多也只执行32次。</li>
</ol>
<h2 id="使用软中断"><a href="#使用软中断" class="headerlink" title="使用软中断"></a>使用软中断</h2><p><code>软中断保留给系统中对时间要求最严格以及最重要的下半部使用</code>。目前，只有两个子系统（网络和SCSI）直接使用软中断。此外，内核定时器和tasklet都是建立在软中断上的。如果你想加入一个新的软中断，首先应该问问自己为什么用tasklet实现不了。tasklet可以动态生成，由于它们对加锁的要求不高，所以使用起来也很方便，而且它们的性能也非常不错。当然，对于时间要求严格并能自己高效地完成加锁工作的应用，软中断会是正确的选择。</p>
<h3 id="分配索引"><a href="#分配索引" class="headerlink" title="分配索引"></a>分配索引</h3><p>在编译期间，通过在&lt;linux&#x2F;interrupts.h&gt;中定义的一个枚举类型来静态地声明软中断。内核用这些从0开始的索引表示一种相对优先级。索引号小的软中断在索引号大的软中断之前执行。<br>建立一个新的软中断必须在此枚举类型中加入新的项。而加入时，你不能像在其他地方一样，简单地把新项加到列表的末尾。相反，你必须根据希望赋予它地优先级来决定加入的位置。习惯上，HI_SOFTIRQ通常作为第一项，而RCU_SOFTIRQ作为最后一项。新项可能插在BLOCK_SOFTIRQ和TASKLET_SOFTIRQ之间。下表列出了已有的tasklet类型。<br><strong>tasklet类型列表</strong></p>
<table>
<thead>
<tr>
<th>tasklet</th>
<th>优先级</th>
<th>软中断描述</th>
</tr>
</thead>
<tbody><tr>
<td>HI_SOFTIRQ</td>
<td>0</td>
<td>优先级高的tasklet</td>
</tr>
<tr>
<td>TIMER_SOFTIRQ</td>
<td>1</td>
<td>定时器的下半部</td>
</tr>
<tr>
<td>NET_TX_SOFTIRQ</td>
<td>2</td>
<td>发送网络数据包</td>
</tr>
<tr>
<td>NET_RX_SOFTIRQ</td>
<td>3</td>
<td>接收网络数据包</td>
</tr>
<tr>
<td>BLOCK_SOFTIRQ</td>
<td>4</td>
<td>BLOCK装置</td>
</tr>
<tr>
<td>TASKLET_SOFTIRQ</td>
<td>5</td>
<td>正常优先级的tasklets</td>
</tr>
<tr>
<td>SCHED_SOFTIRQ</td>
<td>6</td>
<td>调度程度</td>
</tr>
<tr>
<td>HRTIMER_SOFTIRQ</td>
<td>7</td>
<td>高分辨率定时器</td>
</tr>
<tr>
<td>RCU_SOFTIRQ</td>
<td>8</td>
<td>RCU锁定</td>
</tr>
</tbody></table>
<h3 id="注册你的处理程序"><a href="#注册你的处理程序" class="headerlink" title="注册你的处理程序"></a>注册你的处理程序</h3><p>接着，在运行时通过调用open_softirq()注册软中断处理程序，该函数有两个参数：软中断的索引号和处理函数。如网络子系统，在net&#x2F;coreldev.c通过以下方式注册自己的软中断：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">open_softirq(NET_TX_SOFTIRQ,net_tx_action);</span><br><span class="line">open_softirq(NET_RX_SOFTIRQ,net_rx_action);</span><br></pre></td></tr></table></figure>
<p>软中断处理程序执行的时候，允许响应中断，但它自己不能休眠。在一个处理程序运行的时候，当前处理器上的软中断被禁止。但其他的处理器仍可以执行别的软中断。实际上，如果同一个软中断在它被执行的同时再次被触发了，那么另外一个处理器可以同时运行其处理程序。这意味着任何共享数据（甚至是仅在软中断处理程序内部使用的全局变量）都需要严格的锁保护。这点很重要，它也是tasklet更受青睐的原因。单纯地禁止你的软中断处理程序同时执行不是很理想。如果仅仅通过互斥的加锁方式来防止它自身的并发执行，那么使用软中断就没有任何意义了。因此，大部分中断处理程序，都通过采取单处理器数据（仅属于某一个处理器的数据，因此根本不需要加锁）或其他的一些技巧来避免显式的加锁，从而提供更出色的性能。<br>引入软中断的主要原因是其可扩展性。如果不需要扩展到多个处理器，那么，就使用tasklet吧。tasklet本质上也是软中断，只不过同一个处理程序的多个实例不能在多个处理器上同时运行。</p>
<h3 id="触发你的软中断"><a href="#触发你的软中断" class="headerlink" title="触发你的软中断"></a>触发你的软中断</h3><p>通过在枚举类型的列表中添加新项以及调用open_softirq()进行注册之后，新的软中断处理程序就能够运行。raise_softirq()函数可以将一个软中断设置为挂起状态，让它在下次调用do_softirq()函数时投入运行。举个例子，网络子系统可能会调用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">raise_softirq(NET_TX_SOFTIRQ);</span><br></pre></td></tr></table></figure>
<p>这会触发NET_TX_SOFTIRQ软中断。它的处理程序net_tx_action()就会在内核下一次执行软中断时投入运行。该函数在触发一个软中断之前先要禁止中断，触发后再恢复原来的状态。如果中断本来就已经被禁止了，那么可以调用另一函数raise_softirq_irqoff()，这会带来一些优化效果。如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//中断已经被禁止</span></span><br><span class="line">raise_softirq_irqoff(NET_TX_SOFTIRQ);</span><br></pre></td></tr></table></figure>
<p>在中断处理程序中触发软中断是最常见的形式。在这种情况下，中断处理程序执行硬件设备的相关操作，然后触发相应的软中断，最后退出。内核在执行完中断处理程序之后，马上就会调用do_softirq()函数。于是软中断开始执行中断处理程序留给它去完成的剩余任务。在这个例子中，“上半部”和“下半部”名字的含义一目了然。</p>
<h1 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h1><p>tasklet是利用软中断实现的一种下半部机制。我们之前提到过，它和进程没有任何关系。tasklet和软中断在本质上很相似，行为表现也相近，但是，它的接口更简单，锁保护也比较低。<br>选择到底是用软中断还是tasklet其实很简单：通常你应该用tasklet。就像我们在前面看到的，软中断的使用者屈指可数。它只在那些执行频率很高和连续性要求很高的情况下才需要使用。而tasklet却有更广泛的用途。大多数情况下用tasklet效果都还不错，而且它们还非常容易使用。</p>
<h2 id="tasklet的实现"><a href="#tasklet的实现" class="headerlink" title="tasklet的实现"></a>tasklet的实现</h2><p>因为tasklet是通过软中断实现的，所以它们本身也是软中断。前面讨论过了，tasklet由两类软中断代表：HI_SOFTIRQ和TASKLET_SOFTIRQ。这两者之间唯一的实际区别在于，HI_SOFTIRQ类型的软中断先于TASKLET_SOFTIRQ类型的软中断执行。</p>
<h3 id="tasklet结构体"><a href="#tasklet结构体" class="headerlink" title="tasklet结构体"></a>tasklet结构体</h3><p>tasklet由tasklet_struct结构表示。每个结构体单独代表一个tasklet，它在&lt;linux&#x2F;interrupt.h&gt;中定义为：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span>        <span class="comment">//链表中的下一个tasklet</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> state;                <span class="comment">//tasklet的状态</span></span><br><span class="line">    <span class="type">atomic_t</span> count;                     <span class="comment">//引用计数器</span></span><br><span class="line">    <span class="type">void</span> (*func)(<span class="type">unsigned</span> <span class="type">long</span>);        <span class="comment">//tasklet处理函数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> data;                 <span class="comment">//给tasklet处理函数的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>结构体中的func成员是tasklet的处理程序（像软中断中的action一样），data是它唯一的参数。<br>state成员只能在0、TASKLET_STATE_SCHED和TASKLET_STATE_RUN之间取值。TASKLET_STATE_SCHED表明tasklet已被调度，正准备投入运行，TASKLET_STATE_RUN表示该tasklet正在运行。TASKLET_STATE_RUN只有在多处理器的系统上才会作为一种优化来使用，单处理器系统任何时候都清楚单个tasklet是不是正在运行（它要么就是当前正在执行的代码，要么不是）。<br>count成员是tasklet的引用计数器。如果它不为0，则tasklet被禁止，不允许执行；只有当它为0时，tasklet才被激活，并且被设置为挂起状态时，该tasklet才能够被执行。</p>
<h3 id="调度tasklet"><a href="#调度tasklet" class="headerlink" title="调度tasklet"></a>调度tasklet</h3><p>已调度的tasklet（等同于被触发的软中断）存放在两个单处理器数据结构：tasklet_vec（普通tasklet）和tasklet_hi_vec（高优先级的tasklet）。这两个数据结构都是由tasklet_struct结构体组成的链表。链表中的每个tasklet_struct代表一个不同的tasklet。<br>tasklet_struct结构体构成的链表。链表中的每个tasklet_struct代表一个不同的tasklet。<br>tasklet由tasklet_schedule()和tasklet_hi_schedule()函数进行调度，它们接受一个指向tasklet_struct结构的指针作为参数。两个函数非常相似（区别在于一个使用TASKLET_SOFTIRQ，而另一个用HI_SOFTIRQ）。在接下来的内容中我们将仔细研究怎么编写和使用tasklet。现在，让我们先考察一下task_schedule()的细节：<br>tasklet_schedule()的执行步骤：</p>
<ol>
<li>检查tasklet的状态是否为TASKLET_STATE_SCHED。如果是，说明tasklet已经被调度过了，函数立即返回。</li>
<li>调用_tasklet_schedule()。</li>
<li>保存中断状态，然后禁止本地中断。在我们执行tasklet代码时，这么做能够保证当tasklet_struct()处理这些tasklet时，处理器上的数据不会弄乱。</li>
<li>把需要调度的tasklet加到每个处理器一个的tasklet_vec链表或tasklet_hi_vec链表的表头上去。</li>
<li>唤起TASKLET_SOFTIRQ或HI_SOFTIRQ软中断，这样在下一次调用do_softirq()时就会执行该tasklet。</li>
<li>恢复中断到原状态并返回。</li>
</ol>
<p>在前面的内容中我们曾经提起过挂起，do_softirq()会尽可能早地在下一个合适地时机运行。由于大部分tasklet和软中断都是在中断处理程序中被设置成待处理状态，所以最近一个中断返回的时候看起来就是执行do_softirq()的最佳时机。因为TASKLET_SOFTIRQ和HI_SOFTIRQ已经被触发了，所以do_softirq()会执行相应的软中断处理程序。而这两个处理程序，taklet_action()和tasklet_hi_action()，就是tasklet处理的核心。让我们观察它们做了什么：</p>
<ol>
<li>禁止中断（没有必要首先保存其状态，这是因为这里的代码总是作为软中断被调用，而且中断总是被激活的），并为当前处理器检索tasklet_vec或tasklet_hi_vec链表。</li>
<li>将当前处理器上的该链表设置为NULL，达到清空的效果。</li>
<li>允许响应中断。没有必要再恢复它们回原始状态，这是因为这段程序本身就是作为软中断处理程序被调用的，所以中断是应该被允许的。</li>
<li>循环遍历获得链表上的每一个待处理的tasklet。</li>
<li>如果是多处理器系统，通过检查TASKLET_STATE_RUN来判断这个tasklet是否正在其他处理器上运行。如果它正在运行，那么现在就不要执行，跳到下一个待处理的tasklet去（回忆一下，同一时间里，相同类型的tasklet只能有一个执行）。</li>
<li>如果当前这个tasklet没有执行，将其状态设置为TASKLET_STATE_RUN，这样别的处理器就不会再去执行它了。</li>
<li>检查count值是否为0，确保tasklet没有被禁止。如果tasklet被禁止了，则跳到下一个挂起的tasklet去。</li>
<li>我们已经清楚地知道这个tasklet没有在其他地方执行，并且被我们设置成执行状态，这样它在其他部分就不会被执行，并且引用计数为0，现在可以执行tasklet的处理程序了。</li>
<li>tasklet运行完毕，清除tasklet的state域的TASKLET_STATE_RUN状态标志。</li>
<li>重复执行下一个tasklet，直至没有剩余的等待处理的tasklet。</li>
</ol>
<p>taslet的实现很简单，但非常巧妙。我们可以看到，所有的tasklet都通过重复运用HI_SOFTRIRQ和TASKLET_SOFTIRQ这两个软中断实现。当一个tasklet被调度时，内核就会唤起这两个软中断中的一个。随后，该软中断会被特定的函数处理，执行所有已调度的tasklet。这个函数保证同一时间里只有一个给定类别的tasklet会被执行（但其他不同的tasklet可以同时执行）。所有的这些复杂性都被一个简洁的接口隐藏起来了。</p>
<h2 id="使用tasklet"><a href="#使用tasklet" class="headerlink" title="使用tasklet"></a>使用tasklet</h2><p>大多数情况下，为了控制一个寻常的硬件设备，tasklet机制都是实现自己的下半部的最佳选择。tasklet可以动态创建，使用方便，执行起来还算快。此外，尽管它们的名字使人混淆，但能加深你的印象。</p>
<h3 id="声明你自己的tasklet"><a href="#声明你自己的tasklet" class="headerlink" title="声明你自己的tasklet"></a>声明你自己的tasklet</h3><p>你既可以静态地创建tasklet，也可以动态地创建它。选择哪种方式取决于你到底是有（或者想要）一个对tasklet的直接引用还是间接引用。如果你准备静态地创建一个tasklet（也就是有一个它的直接引用），使用下面&lt;linux&#x2F;interrupt.h&gt;中定义的两个宏中的一个：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(name,func,data)</span><br><span class="line">DECLARE_TASKLET_DISABLE(name,func,data);</span><br></pre></td></tr></table></figure>
<p>这两个宏都能根据给定的名称静态的创建一个tasklet_struct结构。当该tasklet被调度之后，给定的函数func就会被执行，它的参数由data给出。这两个宏之间的区别在于引用计数器的初始值设置不同。前面一个宏把创建的tasklet引用计数器设置为0，该tasklet处于激活状态。另一个把引用计数器设置为1，所以该tasklet处于禁止状态。下面是一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DECLARE_TASKLET(my_tasklet,my_tasklet_handler,dev);</span><br></pre></td></tr></table></figure>
<p>这行代码其实等价于</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> <span class="title">my_tasklet</span> =</span> &#123;</span><br><span class="line">    <span class="literal">NULL</span>,<span class="number">0</span>,ATOMIC_INIT(<span class="number">0</span>),</span><br><span class="line">    my_tasklet_handler,dev</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样就创建了一个名为my_tasklet，处理程序为tasklet_handler并且是已被激活的tasklet。当处理程序被调用的时候，dev就会被传递给它。<br>还可以通过将一个间接引用（一个指针）赋给一个动态创建的tasklet_struct结构的方式来初始化一个tasklet_init()：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_init(t,tasklet_handler,dev);<span class="comment">//动态而不是静态创建</span></span><br></pre></td></tr></table></figure>

<h3 id="编写你自己的tasklet处理程序"><a href="#编写你自己的tasklet处理程序" class="headerlink" title="编写你自己的tasklet处理程序"></a>编写你自己的tasklet处理程序</h3><p>tasklet处理程序必须符合规定的函数类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">tasklet_handler</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> data)</span></span><br></pre></td></tr></table></figure>
<p>因为是靠软中断实现，所以tasklet不能睡眠。这意味着你不能在tasklet中使用信号量或者其他什么阻塞式的函数。由于tasklet运行时允许响应中断，所以你必须做好预防工作（如屏蔽中断然后获取一个锁），如果你的tasklet和中断处理程序之间共享了某些数据的话。两个相同的tasklet绝不会同时执行，这点和软中断不同–尽管两个不同的tasklet可以在两个处理器上同时执行。如果你的tasklet和其他的tasklet或者软中断共享了数据，你必须进行适当地锁保护。</p>
<h3 id="调度你自己的tasklet"><a href="#调度你自己的tasklet" class="headerlink" title="调度你自己的tasklet"></a>调度你自己的tasklet</h3><p>通过调用tasklet_schedule()函数并传递给它相应的tasklet_struct的指针，该tasklet就会被调度以便执行：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tasklet_schedule(&amp;my_tasklet);<span class="comment">//把my_tasklet标记为挂起</span></span><br></pre></td></tr></table></figure>
<p>在tasklet被调度之后，只要有机会它就会尽可能早地运行。在它还没得到运行机会之前，如果有一个相同的tasklet又被调度了，那么它仍然只会运行一次。而如果这时它已经开始运行了，比如说在另外一个处理器上，那么这个新的tasklet会被重新调度并再次被运行。作为一种优化措施，一个tasklet总在调度它的处理器上执行–这是希望能更好地利用处理器的高速缓存。<br>你可以调用tasklet_disable()函数来禁止某个指定的tasklet。如果该tasklet当前正在执行，这个函数会等到它执行完毕再返回。你也可以调用tasklet_disable_nosync()函数，它也用来禁止指定的tasklet，不过它无须在返回前等待tasklet执行完毕。这么做往往不太安全，因为你无法估计该tasklet是否仍在执行。调用tasklet_enable()函数可以激活一个tasklet，如果希望激活DECLARE_TASKLET_DISABLE()创建的tasklet，你也得调用这个函数，如：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">tasklet_diasble(&amp;my_tasklet);   <span class="comment">//tasklet现在被禁止</span></span><br><span class="line"><span class="comment">//我们毫无疑问地知道tasklet不能运行</span></span><br><span class="line">tasklet_enable(&amp;my_tasklet);    <span class="comment">//tasklet现在被激活</span></span><br></pre></td></tr></table></figure>
<p>你可以通过调用tasklet_kill()函数从挂起的队列中去掉一个tasklet。该函数的参数是一个指向某个tasklet的tasklet_struct的长指针。在处理一个经常调度它自身的tasklet的时候，从挂起的队列中移去已调度的tasklet会很有用。这个函数首先等待该tasklet执行完毕，然后再将它移去。当然，没有什么可以阻止其它地方的代码重新调度该tasklet。由于该函数可能会引起休眠，所以禁止在中断上下文中使用它。</p>
<h3 id="ksoftirq"><a href="#ksoftirq" class="headerlink" title="ksoftirq"></a>ksoftirq</h3><p>每个处理器都有一组辅助处理软中断（或tasklet）的内核线程。当内核中出现大量软中断的时候，这些内核线程就会辅助处理它们。因为tasklet通过用软中断实施，下面的讨论同样适用于软中断和tasklet。简洁起见，我们将主要参考软中断。<br>我们前面阐述过，对于软中断，内核会选择在几个特殊时机进行处理。而在中断处理程序返回时是最常见的。软中断被触发的频率有时可能很高（像在进行大流量的网络通信期间）。更不利的是，处理函数有时还会自行重复触发。也就是说，当一个软中断执行的时候，它可以重新触发自己以便再次得到执行（事实上，网络子系统就会这么做）。如果软中断本身出现的频率就高，再加上它们又将自己重新设置为可执行状态的能力，那么就会导致用户空间进程无法获得足够的处理器时间，因而处于饥饿状态。而且，单纯的对重新触发的软中断采取不立即处理的策略，也无法让人接受。当软中断最初提出时，就是一个让人进退维谷的问题，亟待解决，而直观的解决方案又都不理想。首先，就让我们看看两种最容易想到的直观的方案。<br>第一种方案是，只要还有被触发并等待处理的软中断，本次执行就要负责处理，重新触发的软中断也在本次执行返回前被处理。这样做可以保证对内核的软中断采取即时处理的方式，关键在于，对重新触发的软中断也会立即处理。当负载很高的时候这样做就会出问题，此时会有大量被触发的软中断，而它们本身又被重复触发。系统可能会一直处理软中断，根本不能完成其他任务，用户空间的任务被忽略了–实际上，只有软中断和中断处理程序轮流执行，而系统的用户只能等待。只有在系统永远处于低负载的情况下，这种方案才会有理想的运行效果；只要系统有哪怕是中等程度的负载量，这种方案就无法让人满意。用户空间根本不能容忍有明显的停顿出现。<br>第二种方案选择不处理重新触发的软中断。在从中断返回的时候，内核和平常一样，也会检查所有挂起的软中断并处理它们。但是，任何自行重新触发的软中断都不会马上处理。它们会被放到下一个软中断执行时去处理。而这个时机通常也就是下一次中断返回的时候，这等于就是说，一定得等一段时间，新的（或者重新触发的）软中断才能被执行。可是，在比较空闲的系统中，立即处理软中断才是比较好的做法。很不幸，这个方案显然又是一个时好时坏的选择。尽管它能保证用户空间不处于饥饿状态，但它却让软中断忍受饥饿的痛苦，而根本没有好好利用闲置的系统资源。<br>在设计软中断时，开发者就意识到需要一些折中。最终在内核实现的方案是不会立即处理重新触发的软中断。而作为改进，当大量软中断出现的时候，内核会唤醒一组内核线程来处理这些负载。这些线程在最低的优先级上运行（nice值为19），这能避免它们跟其他重要的任务抢夺资源。但是它们最终肯定会被执行，所以，这个这种方案能够保证软中断负担很重的时候，用户程序不会因为得不到处理时间而处于饥饿状态。相应的，也能保证“过量”的软中断终究会得到处理。最后，在空闲系统上，这个方案同样表现良好，软中断处理的非常迅速（因为仅存的内核线程肯定会马上调度）。<br>每个处理器都有一个这样的线程。所有的线程名字都叫做ksoftirqd&#x2F;n，区别在于n，它对应的是处理器的编号。在一个双CPU的机器上就有两个这样的线程，分别叫做ksoftirqd&#x2F;0和ksoftirqd&#x2F;1。为了保证只要有空闲的处理器，它们就会处理软中断，所以给每个处理器都分配一个这样的线程。一旦该线程被初始化，它就会执行类似下面这样的死循环：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    <span class="keyword">if</span>(!softirq_pending(cpu))</span><br><span class="line">        schedule();</span><br><span class="line">    </span><br><span class="line">    set_current_state(TASK_RUNNING);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(softirq_pending(cpu)) &#123;</span><br><span class="line">        do_softirq();</span><br><span class="line">        <span class="keyword">if</span>(need_resched())</span><br><span class="line">            schedule();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    set_current_state(TASK_INTERRUPTIBLE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>只要有待处理的软中断（由softirq_pending()函数负责发现），ksoftirq就会调用do_softirq()去处理它们。通过重复执行这样的操作，重复触发的软中断也会被执行。如果有必要的话，每次迭代后都会调用schedule()以便让更重要的进程得到处理机会。当所有需要执行的操作都完成以后，该内核进程将自己设置为TASK_INTERRUPT状态，唤起调度程序选择其他可执行进程投入运行。<br>只要do_softirq()函数发现已经执行过的内核线程重新触发了它自己，软中断内核线程就会被唤醒。</p>
<h2 id="老的BH机制"><a href="#老的BH机制" class="headerlink" title="老的BH机制"></a>老的BH机制</h2><p>尽管BH机制令人欣慰的退出了历史舞台，在2.6版内核中已经难觅踪迹。可是，它毕竟曾经经历了漫长的时光–从最早版本的内核就开始了。由于其余威尚存，所以仅仅不经意地提起它是不够的，尽管在2.6版本中已经不再使用它了，但历史就是历史，应该被了解。<br>BH很古老，但它能揭示一些东西。所有BH都是静态定义的，最多可以有32个。由于处理函数必须在编译时就被定义好，所以实现模块时不能直接使用BH接口。不过业已存在的BH倒是可以利用。随着时间的推移，这种静态要求和最大为32个的数目限制最终妨碍了它们的应用。<br>每个BH处理程序都严格的按顺序执行–不允许任何两个BH处理程序同时执行，即使它们的类型不同。这样做倒是使同步变得简单了，可是却不利于多处理的可扩展性，也不利于大型SMP的性能。使用BH的驱动程序很难从多个处理器上收益，特别是网络层，可以说为此饱受困扰。<br>除了这些特点，BH机制和tasklet就很像了。实际上，在2.4内核中，BH就是基于tasklet实现的。所有可能的32个BH都通过在&lt;linux&#x2F;interrupt.h&gt;中定义的常量表示。如果需要将一个BH标志为挂起状态，可以把相应的BH号传给mark_bh()函数。在2.4内核中，这将导致随后调度BH tasklet，具体工作是由函数bh_action()完成的。而在2.4内核之前，BH机制独立实现，不依赖任何低级BH机制，这和现在的软中断很像。<br>由于这种形式的下半部机制存在缺点，内核开发者们希望引入任务队列机制来代替它。尽管任务队列得到了不少使用者的认可，但它实际上并没有达成这个目的。在2.3版本的内核中，引入了新的软中断和tasklet机制也就结束了对BH的使用。BH机制基于tasklet重新实现。不幸的是，因为新接口本身降低了对执行的序列化保障，所以从BH接口移植到tasklet或软中断接口上操作起来非常复杂。在2.5版中，这种移植最终在定时器和SCSI（最后的BH使用者）转换到软中断机制后完成了。于是内核开发者们立即除去了BH接口。</p>
<h1 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h1><p>工作队列（work queue）是另外一种将工作推后执行的形式，它和我们前面讨论的所有其他形式都不相同。工作队列可以把工作推后，交给一个内核线程去执行–这个下半部总是会在进程上下文中执行。这样，通过工作队列执行的代码能占尽进程上下文的所有优势。最重要的就是工作队列允许重新调度甚至是睡眠。<br><code>通常，在工作队列和软中断tasklet中做出选择非常容易。如果推后执行的任务需要睡眠，那么就选择工作队列。如果推后执行的任务不需要睡眠，那么就选择软中断或tasklet。</code>实际上，工作队列通常可以用内核线程去替换。但是由于内核开发者们非常反对创建新的内核线程（在有些场合，使用这种冒失的办法可能会吃到苦头），所以我们也推荐使用工作队列。当然，这种接口也的确很容易使用。<br><code>如果你需要用一个可以重新调度的实体来执行你的下半部处理，你应该使用工作队列。</code>它是唯一能在进程上下文中运行的下半部实现机制，也只有它才可以睡眠。这意味着在你需要获得大量的内存时，在你需要获取信号量时，在你需要执行阻塞式的I&#x2F;O操作时，它都会非常有用，如果你不需要用一个内核线程来推后执行工作，那么就考虑使用tasklet吧。</p>
<h2 id="工作队列的实现"><a href="#工作队列的实现" class="headerlink" title="工作队列的实现"></a>工作队列的实现</h2><p>工作队列子系统是一个用于创建内核线程的接口，通过它创建的进程负责执行由内核其他部分排到队列里的任务。它创建的这些内核线程称作工作者线程（worker thread）。工作队列可以让你的驱动程序创建一个专门的工作者线程来处理需要退后的工作。不过，工作队列子系统提供了一个缺省的工作者线程来处理这些工作。因此，工作队列最基本的表现形式，就转变成了一个把需要推后执行的任务交给特定的通用线程的这样一种接口。<br>缺省的工作者线程叫做events&#x2F;n，这里n是处理器的编号；每个处理器对应一个线程。例如，单处理器的系统只有events&#x2F;0这样一个线程。而双处理器的系统就会多一个events&#x2F;1线程。缺省的工作者线程会从多个地方得到被推后的工作。许多内核驱动程序都把它们的下半部交给缺省的工作者线程去做。除非一个驱动程序或者子系统必须建立一个属于它自己的内核线程，否则最好使用缺省线程。<br>不过并不存在什么东西能够阻止代码创建属于自己的工作者线程。如果你需要在工作者线程中执行大量的处理操作，这样做或许会带来好处。处理器密集型和性能要求严格的任务会因为拥有自己的工作者线程而获得好处。此时这么做也有助于减轻缺省线程的负担，避免工作队列中其他需要完成的工作处于饥饿状态。</p>
<h3 id="表示线程的数据结构"><a href="#表示线程的数据结构" class="headerlink" title="表示线程的数据结构"></a>表示线程的数据结构</h3><p>工作者线程用workqueue_struct结构表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    外部可见的工作队列抽象是</span></span><br><span class="line"><span class="comment">    由每个CPU的工作队列组成的数据</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> <span class="title">cpu_wq</span>[<span class="title">NR_CPUS</span>];</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *name;</span><br><span class="line">    <span class="type">int</span> singlethread;</span><br><span class="line">    <span class="type">int</span> freezeable;</span><br><span class="line">    <span class="type">int</span> rt;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>该结构内是一个由cpu_workqueue_struct结构组成的数组，它定义在<code>kernel/workqueue.c</code>中，数组的每一项对应系统中的一个处理器。由于系统中每个处理器对应一个工作者线程，所以对于给定的某台计算机来说，就是每个处理器，每个工作者线程对应一个这样的cpu_workqueue_struct结构体。cpu_workqueue_struct是<code>kernel/workqueue.c</code>中的核心数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">cpu_workqueue_struct</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span> lock;                    <span class="comment">//锁保护这种结构</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">worklist</span>;</span>          <span class="comment">//工作列表</span></span><br><span class="line">    <span class="type">wait_queue_head_t</span> more_work;        </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">current_struct</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>        <span class="comment">//关联工作队列结构</span></span><br><span class="line">    <span class="type">task_t</span> *thread;                     <span class="comment">//关联线程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，每个工作者线程类型关联一个自己的workqueue_struct。在结构体里面，给每个线程分配一个cpu_workqueue_struct，因而也就是给每个处理器分配一个，因为每个处理器都有一个该类型的工作者线程。</p>
<h3 id="表示工作的数据结构"><a href="#表示工作的数据结构" class="headerlink" title="表示工作的数据结构"></a>表示工作的数据结构</h3><p>所有的工作者线程都是普通的内核线程实现的，它们都要执行worker_thread()函数。在它初始化完之后，这个函数执行一个死循环并开始休眠。当有操作被插入到队列里的时候，线程就会被唤醒，以便执行这些操作。当没有剩余的操作时，它又会继续休眠。<br>工作用&lt;linux&#x2F;workqueue.h&gt;中定义的work_struct结构体表示：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">    <span class="type">atomic_long_t</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span></span><br><span class="line">    <span class="type">work_func_t</span> func;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这些结构体被连接成链表，在每个服务器上的每种类型的队列都对应这样一个链表。比如，每个处理器上用于执行被推后的工作的那个通用线程都有一个这样的链表。当一个工作者线程被唤醒时，它会执行它的链表上的所有工作。工作被执行完毕，它就将相应的work_struct对象从链表上移去，当链表上不再有对象时，它就会继续休眠。<br>我们可以看一下worker_thread()函数的核心流程，简化如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;) &#123;</span><br><span class="line">    prepare_to_wait(&amp;cwq-&gt;more_work,&amp;wait,TASK_INTERRUPTIBLE);</span><br><span class="line">    <span class="keyword">if</span>(list_empty(&amp;cwq-&gt;worklist))</span><br><span class="line">        schedule();</span><br><span class="line">    finish_wait(&amp;cwq-&gt;more_work,&amp;wait);</span><br><span class="line">    run_workqueue(cwq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

    </div>

    
    
    

    <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/Linux-Kernel/" rel="tag"># Linux Kernel</a>
              <a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" rel="tag"># 操作系统</a>
          </div>

        

          <div class="post-nav">
            <div class="post-nav-item">
                <a href="/2022/11/09/%E4%B8%AD%E6%96%AD%E5%92%8C%E4%B8%AD%E6%96%AD%E5%A4%84%E7%90%86/" rel="prev" title="中断和中断处理">
                  <i class="fa fa-chevron-left"></i> 中断和中断处理
                </a>
            </div>
            <div class="post-nav-item">
            </div>
          </div>
    </footer>
  </article>
</div>






</div>
  </main>

  <footer class="footer">
    <div class="footer-inner">


<div class="copyright">
  &copy; 
  <span itemprop="copyrightYear">2022</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Nibil</span>
</div>
<div class="wordcount">
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-chart-line"></i>
    </span>
    <span title="站点总字数">550k</span>
  </span>
  <span class="post-meta-item">
    <span class="post-meta-item-icon">
      <i class="fa fa-coffee"></i>
    </span>
    <span title="站点阅读时长">8:20</span>
  </span>
</div>
<div class="busuanzi-count">
    <span class="post-meta-item" id="busuanzi_container_site_uv">
      <span class="post-meta-item-icon">
        <i class="fa fa-user"></i>
      </span>
      <span class="site-uv" title="总访客量">
        <span id="busuanzi_value_site_uv"></span>
      </span>
    </span>
    <span class="post-meta-item" id="busuanzi_container_site_pv">
      <span class="post-meta-item-icon">
        <i class="fa fa-eye"></i>
      </span>
      <span class="site-pv" title="总访问量">
        <span id="busuanzi_value_site_pv"></span>
      </span>
    </span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" rel="noopener" target="_blank">Hexo</a> & <a href="https://theme-next.js.org/muse/" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

    </div>
  </footer>

  
  <script src="https://cdnjs.cloudflare.com/ajax/libs/animejs/3.2.1/anime.min.js" integrity="sha256-XL2inqUJaslATFnHdJOi9GfQ60on8Wx1C2H8DYiN1xY=" crossorigin="anonymous"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/next-theme-pjax/0.5.0/pjax.min.js" integrity="sha256-3NkoLDrmHLTYj7csHIZSr0MHAFTXth7Ua/DDt4MRUAg=" crossorigin="anonymous"></script>
<script src="/js/comments.js"></script><script src="/js/utils.js"></script><script src="/js/motion.js"></script><script src="/js/schemes/muse.js"></script><script src="/js/next-boot.js"></script><script src="/js/bookmark.js"></script><script src="/js/pjax.js"></script>

  
<script src="https://cdnjs.cloudflare.com/ajax/libs/hexo-generator-searchdb/1.4.0/search.js" integrity="sha256-vXZMYLEqsROAXkEw93GGIvaB2ab+QW6w3+1ahD9nXXA=" crossorigin="anonymous"></script>
<script src="/js/third-party/search/local-search.js"></script>





  
  <script data-pjax async src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>





</body>
</html>
